<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【置顶】[闲话] Something to Say</title>
      <link href="/archives/something_to_say/"/>
      <url>/archives/something_to_say/</url>
      
        <content type="html"><![CDATA[<p>这里是我的博客的移植版。</p><p>我的早期内容糟粕很多，甚至可能有错误内容&#x2F;xk 远古文章当个乐子看吧。</p>]]></content>
      
      
      <categories>
          
          <category> Essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 梦熊 2025 省选集训营 做题笔记</title>
      <link href="/archives/MXWC2025/"/>
      <url>/archives/MXWC2025/</url>
      
        <content type="html"><![CDATA[<h1 id="20250204-模拟-T1"><a href="#20250204-模拟-T1" class="headerlink" title="20250204 模拟 T1"></a>20250204 模拟 T1</h1><p>删点 MST，$3\leq n,m\leq 5\times 10^5$。</p><h2 id="Sub-1"><a href="#Sub-1" class="headerlink" title="Sub 1"></a>Sub 1</h2><p>$n,m\leq 1000$。</p><p>暴力模拟。或者写正解没上数据结构优化。</p><h2 id="Sub-2"><a href="#Sub-2" class="headerlink" title="Sub 2"></a>Sub 2</h2><p>数据随机。哈哈我也不会。</p><p>赛时没几个人会的档。由于随机所以造出来的树每个点度数都不多，暴力维护连通块。没写，大概就这个意思。</p><h2 id="Sub-3"><a href="#Sub-3" class="headerlink" title="Sub 3"></a>Sub 3</h2><p>一条链 $(i,i+1,1)$ 然后后面随便连点边。</p><p>MST 一定是这条链。</p><p>一次只会分成两个连通块。就是求 $u\lt i\lt v$ 的最小边权。</p><p>扫描线一下。</p><h2 id="赛时提交记录"><a href="#赛时提交记录" class="headerlink" title="赛时提交记录"></a>赛时提交记录</h2><p><a href="https://mna.wang/contest/submission/765776">https://mna.wang/contest/submission/765776</a></p><h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>前言：删边 MST 版本。</p><p><a href="https://atcoder.jp/contests/JAG2013Spring/tasks/icpc2013spring_e">https://atcoder.jp/contests/JAG2013Spring/tasks/icpc2013spring_e</a></p><p><a href="https://codeforces.com/problemset/problem/827/D">https://codeforces.com/problemset/problem/827/D</a></p><p><a href="https://codeforces.com/problemset/problem/1184/E3">https://codeforces.com/problemset/problem/1184/E3</a></p><p>我因为做过然后一时半会儿没转过弯来调了一个多小时倒闭了。GGG。</p><p>场上的时候我先是注意到了增量是 $\mathcal O(n)$ 的，一直在想处理每条边对应的可替代边，然后去重，掐头掐尾。</p><p>写了一下这个的暴力版本过不去拍但是过了大样例的第一个。我想先把这个改对了再套树剖，没测别的大样例。一直挂，寄寄寄。这个看起来可能有点对但是不太靠谱。</p><p>这个做法的主要思路和 std 都差不多。唯一问题好像是，我不能很方便的判断出子树之间的连边？</p><p>不管了，反正随便和我重写的 std 做法很像，代码复制黏贴一点改几句话就过了。糖糖的。</p><p>考虑类似删边 MST 的做法。删边 MST 要把贡献放到边上，我这里还是放到边上，删点就是删掉相邻边，然后就寄了。</p><p>把贡献放到点上，然后就全对了。子树可以连到一个祖先，或者连到其他子树。连到祖先的部分是链上 checkmin 然后单点求值。这个大力树剖，或者一个很简单的写法是对权值从小到大排序，覆盖一个点就删一个点，这里可以并查集维护删点，删点就是合并到父亲。</p><p>发现 $(u,v)$ 只可能是删掉 $\operatorname{lca}(u,v)$ 的时候才会用这条边合并两个子树。这样的话一条边只会在一个点贡献。均摊是对的。然后再做一个 $\mathcal O(deg)$ 个点的 MST。</p><p>代码非常好写！！1</p><p>但是不妨碍我模拟赛的时候和弱智一样！！1</p><p><a href="https://mna.wang/contest/submission/766572">https://mna.wang/contest/submission/766572</a></p><h1 id="20250205-模拟-T1"><a href="#20250205-模拟-T1" class="headerlink" title="20250205 模拟 T1"></a>20250205 模拟 T1</h1><p>有 $n$ 个点 $x_i$，每次从 $x_i$ 出发必须跳到 $[x_i+L,x_i+R]$ 之间的一个点 $x_j$。</p><p>每个点 $x_i$ 有元素 $a_i$。找到一个跳跃方式，使得经过的 $a_i$ 降序排序之后字典序最大。</p><p>无法到达输出 $-1$。</p><p>$1\leq n\leq 5\times 10^5$，$1\leq x_i,L,R\leq 10^9$，$1\leq a_i\leq n$，$x_i\lt x_{i+1}$。</p><h2 id="特殊性质"><a href="#特殊性质" class="headerlink" title="特殊性质"></a>特殊性质</h2><p>$a_i$ 是排列。</p><p>zzk 说是因为不知道怎么放部分分放了个这个。他不知道怎么做。</p><p>我也不知道哈哈。</p><p>好像是说按位贪心可以做。但是想到这个就死翘翘了。和正解一点关系没有，大概是没法优化到正解复杂度的。</p><h2 id="Sub-1-1"><a href="#Sub-1-1" class="headerlink" title="Sub 1"></a>Sub 1</h2><p>$n\leq 500$。</p><p>发个考场时的笔记。</p><blockquote><p>枚举点 $i$，枚举前驱点 $j$。</p><p>每个点维护一个序列表示目前的答案方式</p><p>点 $i$ 的最优序列是点 $j$ 在某个位置插入 $a_i$ 得到的</p><p>比较大小二分 lcp。序列只要维护一个前缀 hash 然后可以单点求值即可。</p></blockquote><p>哈哈这个是正解。三方是实现这个暴力用 vector 然后暴力枚举 $j$ 比较。</p><p>代码不想交梦熊，这里贴一下主函数。</p><pre><code class="highlight cpp"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(n, L, R);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">read</span>(p[i]);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">read</span>(a[i]);    vec[<span class="number">1</span>] = &#123;a[<span class="number">1</span>]&#125;;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)    &#123;        <span class="type">int</span> l = <span class="built_in">lower_bound</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, p[i] - R) - p;        <span class="type">int</span> r = <span class="built_in">upper_bound</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, p[i] - L) - p - <span class="number">1</span>;        <span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt;= r; j++)        &#123;            <span class="keyword">if</span> (vec[j].<span class="built_in">empty</span>())                <span class="keyword">continue</span>;            <span class="keyword">auto</span> v = vec[j];            <span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();            <span class="keyword">for</span> (; it != v.<span class="built_in">end</span>(); it++)            &#123;                <span class="keyword">if</span> (*it &lt; a[i])                &#123;                    v.<span class="built_in">insert</span>(it, a[i]);                    <span class="keyword">break</span>;                &#125;            &#125;            <span class="keyword">if</span> (it == v.<span class="built_in">end</span>())                v.<span class="built_in">insert</span>(it, a[i]);            <span class="built_in">checkmax</span>(vec[i], v);        &#125;    &#125;    <span class="built_in">write</span>(vec[n].<span class="built_in">size</span>(), <span class="string">&#x27;\n&#x27;</span>);    <span class="keyword">for</span> (<span class="type">int</span> i : vec[n])        <span class="built_in">write</span>(i, <span class="string">&#x27; &#x27;</span>);    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p>缺失部分在梦熊交了 $\mathcal O(n^2\log n)$ 的。不影响理解。</p><p>但是这个是错的，我没判 -1。</p><h2 id="Sub-2-1"><a href="#Sub-2-1" class="headerlink" title="Sub 2"></a>Sub 2</h2><p>$n\leq 5000$。</p><p>$n\leq 500$ 的做法转移是一个提取区间 max。套个单调队列或者线段树就好。我写了个线段树，复杂度 $\mathcal O(n^2\log n)$。</p><p><a href="https://mna.wang/contest/submission/767064">https://mna.wang/contest/submission/767064</a></p><h2 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h2><p>首先这个转移形式是一段区间的 max 并且区间端点单调，所以可以单调队列维护。</p><p>开一个主席树，支持单点插入即可。</p><p>找 lcp 可以用 sum hash。看左子树的 hash 是不是一样，如果左子树一样就找右子树。为了避免冲突提前把每个 $[1,n]$ 映射到 $[0,p)$。</p><p>然后似乎没什么难写的，注意一下这题从大到小主席树值域要倒过来。</p><p><a href="https://mna.wang/contest/submission/776878">https://mna.wang/contest/submission/776878</a></p><h1 id="20250205-模拟-T2"><a href="#20250205-模拟-T2" class="headerlink" title="20250205 模拟 T2"></a>20250205 模拟 T2</h1><p>省流：Monster 的 DAG 版本。</p><p>给定 DAG，每个点有一个怪兽两条属性，花费 $a_i$ 血量击杀他然后回复 $b_i$ 滴血。求最小初始血量。</p><p>原题：<a href="https://qoj.ac/contest/1221/problem/6406">https://qoj.ac/contest/1221/problem/6406</a>。</p><p>$2\leq n+m\leq 72$，$1\leq a_i,b_i\leq 10^{15}$。</p><p>这个题有点乱，晚点好好补一下各档分的做法。</p><p>先写一下我的赛场做法。最高目前过了 96pts 的分。</p><p>数据很小，模拟退火，甚至还是阉割版，我不会完整的模拟退火。先随便拉一条 DFS 序下来，然后直接随机交换，更优就替换答案。然后次数开大点用 bitset 存一些目前可达的点集就差不多了。随便来一发就 84 了。随便调调参可以 96。</p><p><a href="https://mna.wang/contest/submission/767450">https://mna.wang/contest/submission/767450</a></p><p>然后为了获得 100 分，我们缝合一下 Cfz 的，数据分治一下。</p><blockquote><p>显然有一个状压 DP。</p><p>但是状态数不满。</p><p>直接 map 存状态然后 BFS。</p></blockquote><p>就过了。</p><p>Cfz 这个可以加点神秘的东西不是我这个做法给数据分治成 100。</p><p><strong>后续补。</strong></p><h1 id="20250205-模拟-T3"><a href="#20250205-模拟-T3" class="headerlink" title="20250205 模拟 T3"></a>20250205 模拟 T3</h1><p>求 $n$ 个盒子放 $m$ 个左括号，每个盒子都是合法括号序列，并且不存在一个盒子有 $k$ 个左括号的方案数。</p><p>$1\leq n,m\leq 10^7$，$1\leq k\leq m$，$10^8\leq p\leq 10^9+7$。</p><p>反射容斥和拉格朗日反演啥的都太难了，来点我学得会的做法。</p><p>首先显然套一个容斥，把不能有 $k$ 个左括号的限制消掉。然后 DP。$f_{i,j}$ 表示 $i$ 个盒子装 $j$ 个左括号的方案数。</p><p>这个有个显然的 $\mathcal O(n^3)$ 的，枚举这个盒子放多少左括号，转移显然。</p><p>这样就三方了。</p><h2 id="特殊性质-1"><a href="#特殊性质-1" class="headerlink" title="特殊性质 1"></a>特殊性质 1</h2><p>$k&#x3D;m$。</p><p>我也不知道是什么，会这个就会整个题了吧。</p><h2 id="特殊性质-2"><a href="#特殊性质-2" class="headerlink" title="特殊性质 2"></a>特殊性质 2</h2><p>$p&#x3D;998244353$。</p><p>一眼 NTT。但是有人说被卡常了，反正我不会 NTT 不关我事 &gt;_&lt;</p><h2 id="正解-2"><a href="#正解-2" class="headerlink" title="正解"></a>正解</h2><p>先随便说个东西。这个 $f_{i,j}$ 打表出来形如</p><pre><code class="highlight plain">1          0          0          0          0          0          0          0          0          0          0 1          1          2          5         14         42        132        429       1430       4862      16796 1          2          5         14         42        132        429       1430       4862      16796      58786 1          3          9         28         90        297       1001       3432      11934      41990     149226 1          4         14         48        165        572       2002       7072      25194      90440     326876 1          5         20         75        275       1001       3640      13260      48450     177650     653752 1          6         27        110        429       1638       6188      23256      87210     326876    1225785 1          7         35        154        637       2548       9996      38760     149226     572033    2187185 1          8         44        208        910       3808      15504      62016     245157     961400    3749460 1          9         54        273       1260       5508      23256      95931     389367    1562275    6216210 1         10         65        350       1700       7752      33915     144210     600875    2466750   10015005</code></pre><p>然后观察一下，第 $1$ 行和第 $2$ 行只差一位，而第 $1$ 行是卡特兰数，说明第 $2$ 行是一个类似卡特兰数的转移，多个 $\pm 1$。然后撞几个式子就出来了。令人汗颜。</p><p><a href="https://mna.wang/contest/submission/768314">https://mna.wang/contest/submission/768314</a></p><p>这个正经做法我还不会，晚点写。</p><p><strong>后续补。</strong></p><h1 id="20250206-模拟-T1"><a href="#20250206-模拟-T1" class="headerlink" title="20250206 模拟 T1"></a>20250206 模拟 T1</h1><p>给定长度为 $n$ 的序列 $x_i$。定义 $f(x_i)&#x3D;(a\oplus x_i)-b$，其中 $\oplus$ 是异或。</p><p>有 $q$ 次操作每次形如：</p><ol><li><code>1 k v</code> 表示 $x_k\gets v$</li><li><code>2 a b</code> 表示求出一个 $i$ 满足 $f(x_i)f(x_{i+1})\leq 0$。无解输出 <code>-1</code>。</li></ol><p>$1\leq n,q\leq 10^6$，$0\leq x_i,v,a,b\lt 2^{30}$，$1\leq k\leq n$。</p><h2 id="特殊性质-1"><a href="#特殊性质-1" class="headerlink" title="特殊性质"></a>特殊性质</h2><p>不带修。</p><p><a href="https://qoj.ac/problem/9669">https://qoj.ac/problem/9669</a></p><p>和正解一起讲，事实上会了这个就会正解了。</p><h2 id="正解-3"><a href="#正解-3" class="headerlink" title="正解"></a>正解</h2><p>我很不理解这个题出出来有什么意义，如果只是为了科普这个题很牛逼的这个做法完全可以开成强制在线。$10^6$ 卡掉了 $\log^2$ 也卡掉了正解的 $\log$。</p><p>不带修的版本求出最小的 $f(x)$ 和最大的 $f(y)$，那么如果有 $f(x)f(y)\leq 0$ 那么一定有解。</p><p>我们可以考虑如果此时还有一个 $z$ 那么 $f(x)f(z)$ 和 $f(y)f(z)$ 一定有一个 $\leq 0$。原因显然。</p><p>那么我们直接分治就对了。每次取 $mid&#x3D;\frac{x+y}{2}$，然后递归跑下去。直到区间长度为 $2$。</p><p>带修的话在字典树的叶子结点加一个可删堆就好了，小心一些空间什么的。</p><p>糖题。线下评测还把我空间卡了。麻麻思乐。</p><p><a href="https://mna.wang/contest/submission/768709">https://mna.wang/contest/submission/768709</a></p><h1 id="20250207-模拟-T1"><a href="#20250207-模拟-T1" class="headerlink" title="20250207 模拟 T1"></a>20250207 模拟 T1</h1><p>每次操作选择当前位置抬高一格或者下个位置降低一格。操作永久保留。走到 $n$ 就回到 $1$。高度相同才可以通行。问走 $k$ 轮的最小操作次数。</p><h2 id="正解-4"><a href="#正解-4" class="headerlink" title="正解"></a>正解</h2><p>太简单了不写部分分做法了。</p><p>不难发现一个位置如果下降了就不会上升。而且下降的一定是后缀。所以需要先把后缀拍平。</p><p>然后 $k&#x3D;1$ 答案就是极差，因为可以证明我们做降低操作是不优的。这说明我们每一轮答案都是极差。</p><p>然后继续观察一下每一轮相当于是删掉了最左侧的元素。那么直接前缀和维护一下就做完了。</p><p><a href="https://mna.wang/contest/submission/770764">https://mna.wang/contest/submission/770764</a></p><h1 id="20250207-模拟-T2"><a href="#20250207-模拟-T2" class="headerlink" title="20250207 模拟 T2"></a>20250207 模拟 T2</h1><p>构造不超过 $V$ 个点 $E$ 条边的有向图使得外向基环树大小是 $k$。</p><p>$V&#x3D;80$，$E&#x3D;220$，$1\leq k\leq 10^{18}$。</p><p><strong>可以有重边和自环。</strong></p><h2 id="Sub-1-Sub-2"><a href="#Sub-1-Sub-2" class="headerlink" title="Sub 1 &amp; Sub 2"></a>Sub 1 &amp; Sub 2</h2><p>$V&#x3D;130$，$E&#x3D;400$，$1\leq k\leq 10$。</p><p>$V&#x3D;130$，$E&#x3D;400$，$1\leq k\leq 100$。</p><p>直接连 $k$ 条边就做完了。</p><h2 id="Sub-3-1"><a href="#Sub-3-1" class="headerlink" title="Sub 3"></a>Sub 3</h2><p>$V&#x3D;130$，$E&#x3D;400$，$k&#x3D;2^t(0\leq t\leq 20)$。</p><p>构造 $t+1$ 个点的链，中间每个点连 $2$ 条边。</p><h2 id="正解-5"><a href="#正解-5" class="headerlink" title="正解"></a>正解</h2><p>这是 std 做法。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/yv7k11wq.png"></p><p>然后是 Cfz 做法。</p><p>妈的我赛时做了个完全一样的做法啊？？？然后我和【数据删除】赛时开黑，我俩认为我的做法应该对着加法构造加法器。但是这个很糖，做不了，因为一条边的贡献和两条边是不一样的。他并不是局部做了一个乘法最后可以加回来。然后发现这个东西啥都过不去。</p><p>但是这个做法的式子其实是加法乘法拼起来了，所以可以改。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ow34q9qg.png"></p><p>这个方案数是 $AB+AC+CD$。同理画更多点的图出来。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/gy4o8luz.png"></p><p>我们令 $A&#x3D;B&#x3D;E&#x3D;F&#x3D;1$，那么方案数是 $1+D(1+G)$。</p><p>同理边上连 $k_i$ 条生成树个数就是 $1+k_1(1+k_2(1+\dots))$。</p><p>然后这个直接就好了。。。奇数连一条偶数连两条是 $\log$ 但是常数倍。这个问题不大，奇数找一下 $\leq 7$ 的质因子除掉，就过了。</p><h1 id="20250207-听课笔记"><a href="#20250207-听课笔记" class="headerlink" title="20250207 听课笔记"></a>20250207 听课笔记</h1><h2 id="CF1305F"><a href="#CF1305F" class="headerlink" title="CF1305F"></a>CF1305F</h2><p>答案 $\leq n$ 因为可以直接操作成 $\gcd&#x3D;2$。</p><p>说明至少 $n&#x2F;2$ 个数操作了 $\leq 1$ 次。</p><p>随机选 $t$ 个数那么只有 $\dfrac{1}{2^t}$ 的概率都操作了 $\geq 2$ 次。</p><p>把这 $t$ 个数操作 $1$ 次的方案的质因子都拎出来，一个数最多 $\omega&#x3D;11$ 个。</p><p>直接判断 $\gcd$ 为这些质因子的最小次数。复杂度 $\mathcal O(t\sqrt V+tkn)$。取 $t&#x3D;50$ 时正确率足以通过。 </p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC391 FG 一句话题解</title>
      <link href="/archives/ABC391/"/>
      <url>/archives/ABC391/</url>
      
        <content type="html"><![CDATA[<p>没脸投题解区了，给我的博客里扔点垃圾。</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>来说一下我的铸币做法。有两个很简单的是直接优先队列每次尝试加 $(i+1,j,k),(i,j+1,k),(i,j,k+1)$。做完了。还有个做法是排序然后枚举 $ijk\leq K$，做完了。</p><p>但是前两天刚写的 <a href="https://www.luogu.com.cn/article/gwgzmc70">https://www.luogu.com.cn/article/gwgzmc70</a> 我印象深刻。我直接对着这个题做的。哈哈无敌了。</p><p>考虑式子写成 $kx+b$ 的形式。然后把 $k$ 的前 $K$ 大和 $b$ 的前 $K$ 大都搞出来。二分答案，然后由于 $K$ 可以线性做直接模拟。</p><p>一共要写三个二分答案，哈哈我也是神人了。复杂度更劣，我的 $\log$ 是带在值域上的。</p><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>省流：P4590。</p><p>DP of DP 模板。发现 LCS 的 DP 数组差分是 01 序列。压成状态然后搜 DFA。做完了。外面的 DP 部分是糖题。</p><p>哦哦啊啊额额哈哈嘿嘿。</p><p>我怎么是全场最后一个过这题的。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ARC191 ABC 题解</title>
      <link href="/archives/ARC191/"/>
      <url>/archives/ARC191/</url>
      
        <content type="html"><![CDATA[<p>感觉以后 haoba 让我写的题解应该往博客也存一份，省得以后找不到&#x2F;fendou</p><p>C 题题解是洗稿了某小群聊天记录。给大家磕头了。所以这份文章不打算投题解，抄来的洗稿之后投太不要脸了。A B 题解也写的一坨，没人看最好（）</p><p>代码是榜前三。</p><hr><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>考虑逐位直接枚举 $s_i$ 然后替换成最大的严格大于 $s_i$ 的 $t_j$。没有就不替换。重复这个过程，最后能形成最大的 $s$，以及剩下了一些 $t$ 的操作没有做。</p><p>这些操作如果直接选择放到最后一个位置的话，可能会把数给改小。对于最后剩下的操作，我们再判一遍能不能恰好在 $s$ 中重新覆盖一遍。都改不了的话只能改最后一位。在保证这一次操作之后的操作都可以重新覆盖的情况下，选最大的一个修改掉最后一位。</p><hr><p>Nachia</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">ifdef</span> NACHIA</span><span class="meta">#<span class="keyword">define</span> _GLIBCXX_DEBUG</span><span class="meta">#<span class="keyword">else</span></span><span class="meta">#<span class="keyword">define</span> NDEBUG</span><span class="meta">#<span class="keyword">endif</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;<span class="keyword">using</span> u64 = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;<span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i=0; i&lt;int(n); i++)</span><span class="type">const</span> i64 INF = <span class="number">1001001001001001001</span>;<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt; <span class="type">void</span> <span class="title">chmin</span><span class="params">(A&amp; l, <span class="type">const</span> A&amp; r)</span></span>&#123; <span class="keyword">if</span>(r &lt; l) l = r; &#125;<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt; <span class="type">void</span> <span class="title">chmax</span><span class="params">(A&amp; l, <span class="type">const</span> A&amp; r)</span></span>&#123; <span class="keyword">if</span>(l &lt; r) l = r; &#125;<span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">void</span> <span class="title">testcase</span><span class="params">()</span></span>&#123;    i64 N, M; cin &gt;&gt; N &gt;&gt; M;    string S, T; cin &gt;&gt; S &gt;&gt; T;    <span class="keyword">auto</span> X = T;    <span class="built_in">sort</span>(X.<span class="built_in">begin</span>(), X.<span class="built_in">end</span>());    <span class="keyword">for</span>(<span class="type">char</span>&amp; c : S)&#123;        <span class="keyword">if</span>(c &lt; X.<span class="built_in">back</span>())&#123;            c = X.<span class="built_in">back</span>();            X.<span class="built_in">pop_back</span>();        &#125;    &#125;    <span class="type">char</span> c = T.<span class="built_in">back</span>();    <span class="type">bool</span> ok = <span class="literal">false</span>;    <span class="keyword">for</span>(<span class="type">char</span> x : S) <span class="keyword">if</span>(c == x) ok = <span class="literal">true</span>;    <span class="keyword">if</span>(!ok) S.<span class="built_in">back</span>() = c;    cout &lt;&lt; S &lt;&lt; <span class="string">&quot;\n&quot;</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);    <span class="built_in">testcase</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p>hitonanode</p><pre><code class="highlight cpp"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    <span class="type">int</span> N, M;    string S, T;    cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T;    <span class="built_in">dbg</span>(S);    <span class="built_in">dbg</span>(T);    <span class="keyword">constexpr</span> <span class="type">int</span> D = <span class="number">10</span>;    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tcnt</span><span class="params">(D)</span></span>;    <span class="keyword">for</span> (<span class="type">char</span> c : T) tcnt.<span class="built_in">at</span>(c - <span class="string">&#x27;0&#x27;</span>)++;    <span class="built_in">dbg</span>(tcnt);    string ret = S;    <span class="type">int</span> cur = <span class="number">0</span>;    <span class="type">int</span> m = D;    <span class="built_in">IREP</span>(v, D) &#123;        <span class="type">int</span> rem = tcnt.<span class="built_in">at</span>(v);        <span class="keyword">while</span> (rem) &#123;            <span class="keyword">while</span> (cur &lt; N <span class="keyword">and</span> S.<span class="built_in">at</span>(cur) &gt;= <span class="string">&#x27;0&#x27;</span> + v) ++cur;            <span class="keyword">if</span> (cur == N) <span class="keyword">break</span>;            ret.<span class="built_in">at</span>(cur) = <span class="string">&#x27;0&#x27;</span> + v;            ++cur;            <span class="built_in">chmin</span>(m, v);            --rem;        &#125;    &#125;    &#123;        <span class="type">char</span> c = T.<span class="built_in">back</span>();        <span class="keyword">if</span> (!<span class="built_in">count</span>(<span class="built_in">ALL</span>(ret), c)) ret.<span class="built_in">back</span>() = c;    &#125;    cout &lt;&lt; ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;&#125;</code></pre><p>SomethingNew</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">define</span> all(x) x.begin(), x.end()</span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;    <span class="type">int</span> n, m;    cin &gt;&gt; n &gt;&gt; m;    string s, t, t0;    cin &gt;&gt; s &gt;&gt; t0;    t = t0;    <span class="built_in">sort</span>(<span class="built_in">all</span>(t));    <span class="built_in">reverse</span>(<span class="built_in">all</span>(t));    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">used</span><span class="params">(<span class="number">1000</span>)</span></span>;    <span class="type">int</span> c = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;        <span class="keyword">while</span> (c != s.<span class="built_in">size</span>() <span class="keyword">and</span> s[c] &gt;= t[i]) &#123;            c++;        &#125;        <span class="keyword">if</span> (c != s.<span class="built_in">size</span>()) &#123;            s[c] = t[i];            used[t[i]] = <span class="number">1</span>;            c++;        &#125;    &#125;    <span class="keyword">for</span> (<span class="keyword">auto</span> i : s)        used[i] = <span class="number">1</span>;    <span class="keyword">if</span> (used[t<span class="number">0.</span><span class="built_in">back</span>()]) &#123;        cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    &#125; <span class="keyword">else</span> &#123;        s.<span class="built_in">back</span>() = t<span class="number">0.</span><span class="built_in">back</span>();        cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>一个性质是：在 $x\geq y$ 的时候，$x-y\leq x\oplus y$。</p><blockquote><p>考虑每个二进制位的贡献。<br>二进制位这一位相同的话是 $x-y$ 和 $x\oplus y$ 这一位都是 $0$。<br>否则的话 $x$ 这一位是 $1$ 而 $y$ 这一位是 $0$，$x-y$ 和 $x\oplus y$ 这一位都是 $1$。<br>如果 $x$ 这一位是 $0$ 而 $y$ 这一位是 $1$，$x-y$ 这里可以看成这个二进制位的贡献是 $-1$，$x\oplus y$ 的贡献是 $1$。<br>每个二进制位都是 $x-y$ 小，所以最后拼起来肯定是 $x-y$ 小。</p></blockquote><p>而 $x\bmod y$ 可以看做 $x-ky$。$k\geq 2$ 时显然肯定有 $x-ky\lt x\oplus y$。</p><p>那么说明只可能是 $k&#x3D;1$，也就是这里的取模转成了减法。</p><p>还是参考上面这段证明，要求 $x-y&#x3D;x\oplus y$ 只可能是 $x,y$ 这一位相同，或者 $x,y$ 这一位分别是 $0,1$。</p><p>也就是说如果 $x$ 这一位是 $0$，那么 $y$ 就有两种选择了。</p><p>然后我们就是要对于每一位有 $1$ 或 $2$ 种选择，找到第 $x$ 大的数。这里第 $1$ 个方案就是 $n$，没什么意义，先 $x\gets x-1$。</p><p>如果 $x$ 超过了总方案数答案就是 $-1$。</p><p>否则的话我们可以模拟 $x$ 的二进制的构造。$n$ 的第 $k$ 个为 $0$ 的位可以带来 $2^k$ 的方案数。直接看对应的 $x$ 有没有这一位，有的话答案里算上这一位。</p><hr><p>Nachia</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">ifdef</span> NACHIA</span><span class="meta">#<span class="keyword">define</span> _GLIBCXX_DEBUG</span><span class="meta">#<span class="keyword">else</span></span><span class="meta">#<span class="keyword">define</span> NDEBUG</span><span class="meta">#<span class="keyword">endif</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;<span class="keyword">using</span> u64 = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;<span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i=0; i&lt;int(n); i++)</span><span class="type">const</span> i64 INF = <span class="number">1001001001001001001</span>;<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt; <span class="type">void</span> <span class="title">chmin</span><span class="params">(A&amp; l, <span class="type">const</span> A&amp; r)</span></span>&#123; <span class="keyword">if</span>(r &lt; l) l = r; &#125;<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt; <span class="type">void</span> <span class="title">chmax</span><span class="params">(A&amp; l, <span class="type">const</span> A&amp; r)</span></span>&#123; <span class="keyword">if</span>(l &lt; r) l = r; &#125;<span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">void</span> <span class="title">testcase</span><span class="params">()</span></span>&#123;    i64 N, K; cin &gt;&gt; N &gt;&gt; K;    i64 n = <span class="number">1</span>; <span class="keyword">while</span>(n*<span class="number">2</span> &lt;= N) n *= <span class="number">2</span>;    i64 F = N - n;    vector&lt;i64&gt; B;    i64 Q = <span class="number">1</span>;    <span class="built_in">rep</span>(i,<span class="number">30</span>) <span class="keyword">if</span>((<span class="number">1ll</span> &lt;&lt; i) &lt; n) <span class="keyword">if</span>(!((<span class="number">1ll</span> &lt;&lt; i) &amp; F))&#123;        B.<span class="built_in">push_back</span>(<span class="number">1ll</span> &lt;&lt; i);        Q *= <span class="number">2</span>;    &#125;    i64 ans = N;    <span class="keyword">if</span>(Q &lt; K)&#123; cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>; <span class="keyword">return</span>; &#125;    K--;    <span class="built_in">rep</span>(i,B.<span class="built_in">size</span>()) <span class="keyword">if</span>(K&amp;(<span class="number">1ll</span>&lt;&lt;i)) ans |= B[i];    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);    i64 T; cin &gt;&gt; T;    <span class="built_in">rep</span>(i,T) <span class="built_in">testcase</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p>hitonanode</p><pre><code class="highlight cpp"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">expe</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;    vector&lt;<span class="type">int</span>&gt; ret;    <span class="built_in">FOR</span>(x, <span class="number">1</span>, <span class="number">1e5</span>) &#123;        <span class="keyword">if</span> ((x ^ N) == x % N) ret.<span class="built_in">push_back</span>(x);        <span class="keyword">if</span> (ret.<span class="built_in">size</span>() &gt;= <span class="number">50</span>) <span class="keyword">break</span>;    &#125;    <span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> K)</span> </span>&#123;    lint U = <span class="number">1</span>;    <span class="keyword">while</span> (U &lt; N) &#123;        U = U * <span class="number">2</span> + <span class="number">1</span>;    &#125;    <span class="built_in">dbg</span>(<span class="built_in">make_tuple</span>(N, U));    vector&lt;<span class="type">int</span>&gt; diffs;    <span class="built_in">REP</span>(d, <span class="number">30</span>) &#123;        <span class="keyword">if</span> (((U - N) &gt;&gt; d) &amp; <span class="number">1</span>) diffs.<span class="built_in">push_back</span>(d);    &#125;    lint sz = <span class="built_in">lint</span>(<span class="number">1</span>) &lt;&lt; diffs.<span class="built_in">size</span>();    <span class="keyword">if</span> (sz &lt; K) <span class="keyword">return</span> <span class="number">-1</span>;    <span class="type">const</span> <span class="type">int</span> mask = K - <span class="number">1</span>;    lint ret = U;    <span class="built_in">REP</span>(d, diffs.<span class="built_in">size</span>()) &#123;        <span class="keyword">if</span> (mask &amp; (<span class="number">1</span> &lt;&lt; d)) &#123;        &#125; <span class="keyword">else</span> &#123;            ret ^= <span class="built_in">lint</span>(<span class="number">1</span>) &lt;&lt; diffs.<span class="built_in">at</span>(d);        &#125;    &#125;    <span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    <span class="built_in">FOR</span>(v, <span class="number">1</span>, <span class="number">100</span>) &#123;        <span class="built_in">dbg</span>(<span class="built_in">make_tuple</span>(v, <span class="built_in">expe</span>(v)));    &#125;    <span class="type">int</span> T;    cin &gt;&gt; T;    <span class="keyword">while</span> (T--) &#123;        <span class="type">int</span> N, K;        cin &gt;&gt; N &gt;&gt; K;        cout &lt;&lt; <span class="built_in">solve</span>(N, K) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre><p>SomethingNew</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">define</span> all(x) x.begin(), x.end()</span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> int long long</span><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;    <span class="type">int</span> k, y;    cin &gt;&gt; y &gt;&gt; k;    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bts</span><span class="params">(<span class="number">60</span>)</span></span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; ++i) &#123;        <span class="keyword">if</span> (y &amp; (<span class="number">1</span> &lt;&lt; i))            bts[i] = <span class="number">1</span>;    &#125;    k--;    <span class="type">int</span> c = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; ++i) &#123;        <span class="keyword">if</span> (bts[i] == <span class="number">0</span> <span class="keyword">and</span> c &lt; <span class="number">30</span>) &#123;            <span class="keyword">if</span> (k &amp; (<span class="number">1</span> &lt;&lt; c)) &#123;                bts[i] = <span class="number">1</span>;            &#125;            c++;        &#125;    &#125;    <span class="type">int</span> r = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; ++i) &#123;        r += bts[i] &lt;&lt; i;    &#125;    <span class="comment">//cerr &lt;&lt; r &lt;&lt; &#x27;\n&#x27;;</span>    <span class="keyword">if</span> ((r % y) == (r ^ y))        cout &lt;&lt; r &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    <span class="keyword">else</span>        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;&#125;<span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);    <span class="type">int</span> t=<span class="number">1</span>;    cin &gt;&gt; t;    <span class="keyword">while</span> (t--) &#123;        <span class="built_in">solve</span>();    &#125;&#125;</code></pre><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote><p>『阶』定义<br>由欧拉定理可知，对 $a\in \mathbb{Z},m\in \mathbb{N^*}$，若 $(a,m) &#x3D; 1$，则 $a^{\varphi(m)} \equiv 1 \pmod{m}$。</p><p>因此满足同余式  $a^n \equiv 1 \pmod{m}$ 的最小正整数 $n$ 存在，这个 $n$ 称作 $a$ 模 $m$ 的阶，记作 $\delta_m(a)$ 或 $\operatorname{ord}_m(a)$。</p></blockquote><p>本题相当于找到阶为 $n$ 的一对 $(a,m)$。</p><p>根据定义直接可得 $\varphi(m)$ 得是 $n$ 的倍数。</p><p>考虑 $\varphi(n)$ 分解质因数时的求法，我们直接让每个 $p_i$ 的幂次多 $1$ 就好。为了避免分解质因数可以直接取 $m&#x3D;n^2$。</p><p>考虑同余的 $1$ 怎么搞。暴力尝试 $a$ 的取值，发现在 $a&#x3D;n+1$ 时均有 $a^{n}\equiv 1\pmod{n^2}$。</p><p>证明的话，展开 $(n+1)^n$，只有第一项是 $1$，其他的都是 $n^2$ 的倍数。</p><p>所以 $a&#x3D;n+1,m&#x3D;n^2$ 就是一个合法的可能。</p><hr><p>另外一种做法是枚举 $m&#x3D;kn+1$ 然后 Miller–Rabin，或者随机检查几个 $a$ 判断是否合法。之后求出原根。原根可以随机然后判断。</p><hr><p>Nachia</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">ifdef</span> NACHIA</span><span class="meta">#<span class="keyword">define</span> _GLIBCXX_DEBUG</span><span class="meta">#<span class="keyword">else</span></span><span class="meta">#<span class="keyword">define</span> NDEBUG</span><span class="meta">#<span class="keyword">endif</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;<span class="keyword">using</span> u64 = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;<span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i=0; i&lt;int(n); i++)</span><span class="type">const</span> i64 INF = <span class="number">1001001001001001001</span>;<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt; <span class="type">void</span> <span class="title">chmin</span><span class="params">(A&amp; l, <span class="type">const</span> A&amp; r)</span></span>&#123; <span class="keyword">if</span>(r &lt; l) l = r; &#125;<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt; <span class="type">void</span> <span class="title">chmax</span><span class="params">(A&amp; l, <span class="type">const</span> A&amp; r)</span></span>&#123; <span class="keyword">if</span>(l &lt; r) l = r; &#125;<span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atcoder/math&gt;</span></span><span class="function"><span class="type">void</span> <span class="title">testcase</span><span class="params">()</span></span>&#123;    i64 N; cin &gt;&gt; N;    <span class="keyword">if</span>(N == <span class="number">1</span>)&#123; cout &lt;&lt; <span class="string">&quot;1 1\n&quot;</span>; <span class="keyword">return</span>; &#125;    vector&lt;i64&gt; A, M;    vector&lt;pair&lt;i64,i64&gt;&gt; pe;    <span class="keyword">for</span>(i64 p=<span class="number">2</span>; p*p&lt;=N; p+=(p==<span class="number">2</span>?<span class="number">1</span>:<span class="number">2</span>)) <span class="keyword">if</span>(N%p == <span class="number">0</span>)&#123;        pe.<span class="built_in">push_back</span>(&#123; p,<span class="number">0</span> &#125;);        <span class="keyword">while</span>(N%p == <span class="number">0</span>)&#123; pe.<span class="built_in">back</span>().second += <span class="number">1</span>; N /= p; &#125;    &#125;    <span class="keyword">if</span>(N != <span class="number">1</span>) pe.<span class="built_in">push_back</span>(&#123; N,<span class="number">1</span> &#125;);    <span class="keyword">for</span>(<span class="keyword">auto</span> [p,e] : pe)&#123;        i64 pp = <span class="number">1</span>;        <span class="built_in">rep</span>(i,e) pp *= p;        <span class="keyword">if</span>(p != <span class="number">2</span>)&#123;            A.<span class="built_in">push_back</span>(p<span class="number">+1</span>);            M.<span class="built_in">push_back</span>(pp*p);        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pp == <span class="number">2</span>)&#123;            A.<span class="built_in">push_back</span>(<span class="number">3</span>);            M.<span class="built_in">push_back</span>(<span class="number">4</span>);        &#125; <span class="keyword">else</span> &#123;            A.<span class="built_in">push_back</span>(<span class="number">5</span>);            M.<span class="built_in">push_back</span>(pp*<span class="number">4</span>);        &#125;    &#125;    <span class="keyword">auto</span> [aa,mm] = atcoder::<span class="built_in">crt</span>(A, M);    cout &lt;&lt; aa &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mm &lt;&lt; <span class="string">&quot;\n&quot;</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);    i64 T; cin &gt;&gt; T;    <span class="built_in">rep</span>(i,T) <span class="built_in">testcase</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p>hitonanode</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span><span class="keyword">namespace</span> SPRP &#123;<span class="comment">// http://miller-rabin.appspot.com/</span><span class="type">const</span> std::vector&lt;std::vector&lt;__int128&gt;&gt; bases&#123;    &#123;<span class="number">126401071349994536</span>&#125;,                              <span class="comment">// &lt; 291831</span>    &#123;<span class="number">336781006125</span>, <span class="number">9639812373923155</span>&#125;,                  <span class="comment">// &lt; 1050535501 (1e9)</span>    &#123;<span class="number">2</span>, <span class="number">2570940</span>, <span class="number">211991001</span>, <span class="number">3749873356</span>&#125;,               <span class="comment">// &lt; 47636622961201 (4e13)</span>    &#123;<span class="number">2</span>, <span class="number">325</span>, <span class="number">9375</span>, <span class="number">28178</span>, <span class="number">450775</span>, <span class="number">9780504</span>, <span class="number">1795265022</span>&#125; <span class="comment">// &lt;= 2^64</span>&#125;;<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get_id</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;    <span class="keyword">if</span> (n &lt; <span class="number">291831</span>) &#123;        <span class="keyword">return</span> <span class="number">0</span>;    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">1050535501</span>) &#123;        <span class="keyword">return</span> <span class="number">1</span>;    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">47636622961201</span>)        <span class="keyword">return</span> <span class="number">2</span>;    <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">3</span>; &#125;&#125;&#125; <span class="comment">// namespace SPRP</span><span class="comment">// Miller-Rabin primality test</span><span class="comment">// https://ja.wikipedia.org/wiki/%E3%83%9F%E3%83%A9%E3%83%BC%E2%80%93%E3%83%A9%E3%83%93%E3%83%B3%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A%E6%B3%95</span><span class="comment">// Complexity: O(lg n) per query</span><span class="keyword">struct</span> &#123;    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">modpow</span><span class="params">(__int128 x, __int128 n, <span class="type">long</span> <span class="type">long</span> mod)</span> <span class="keyword">noexcept</span> </span>&#123;        __int128 ret = <span class="number">1</span>;        <span class="keyword">for</span> (x %= mod; n; x = x * x % mod, n &gt;&gt;= <span class="number">1</span>) ret = (n &amp; <span class="number">1</span>) ? ret * x % mod : ret;        <span class="keyword">return</span> ret;    &#125;    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span> <span class="keyword">noexcept</span> </span>&#123;        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> n == <span class="number">2</span>;        <span class="type">int</span> s = __builtin_ctzll(n - <span class="number">1</span>);        <span class="keyword">for</span> (__int128 a : SPRP::bases[SPRP::<span class="built_in">get_id</span>(n)]) &#123;            <span class="keyword">if</span> (a % n == <span class="number">0</span>) <span class="keyword">continue</span>;            a = <span class="built_in">modpow</span>(a, (n - <span class="number">1</span>) &gt;&gt; s, n);            <span class="type">bool</span> may_composite = <span class="literal">true</span>;            <span class="keyword">if</span> (a == <span class="number">1</span>) <span class="keyword">continue</span>;            <span class="keyword">for</span> (<span class="type">int</span> r = s; r--; a = a * a % n) &#123;                <span class="keyword">if</span> (a == n - <span class="number">1</span>) may_composite = <span class="literal">false</span>;            &#125;            <span class="keyword">if</span> (may_composite) <span class="keyword">return</span> <span class="literal">false</span>;        &#125;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;&#125; is_prime;<span class="keyword">struct</span> &#123;    <span class="comment">// Pollard&#x27;s rho algorithm: find factor greater than 1</span>    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">find_factor</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;        <span class="built_in">assert</span>(n &gt; <span class="number">1</span>);        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;        <span class="keyword">if</span> (<span class="built_in">is_prime</span>(n)) <span class="keyword">return</span> n;        <span class="type">long</span> <span class="type">long</span> c = <span class="number">1</span>;        <span class="keyword">auto</span> f = [&amp;](__int128 x) -&gt; <span class="type">long</span> <span class="type">long</span> &#123; <span class="built_in">return</span> (x * x + c) % n; &#125;;        <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>;; t++) &#123;            <span class="keyword">for</span> (c = <span class="number">0</span>; c == <span class="number">0</span> <span class="keyword">or</span> c + <span class="number">2</span> == n;) c = <span class="built_in">rand_int</span>() % n;            <span class="type">long</span> <span class="type">long</span> x0 = t, m = std::<span class="built_in">max</span>(n &gt;&gt; <span class="number">3</span>, <span class="number">1LL</span>), x, ys, y = x0, r = <span class="number">1</span>, g, q = <span class="number">1</span>;            <span class="keyword">do</span> &#123;                x = y;                <span class="keyword">for</span> (<span class="type">int</span> i = r; i--;) y = <span class="built_in">f</span>(y);                <span class="type">long</span> <span class="type">long</span> k = <span class="number">0</span>;                <span class="keyword">do</span> &#123;                    ys = y;                    <span class="keyword">for</span> (<span class="type">int</span> i = std::<span class="built_in">min</span>(m, r - k); i--;)                        y = <span class="built_in">f</span>(y), q = __int128(q) * std::<span class="built_in">abs</span>(x - y) % n;                    g = std::__gcd&lt;<span class="type">long</span> <span class="type">long</span>&gt;(q, n);                    k += m;                &#125; <span class="keyword">while</span> (k &lt; r <span class="keyword">and</span> g &lt;= <span class="number">1</span>);                r &lt;&lt;= <span class="number">1</span>;            &#125; <span class="keyword">while</span> (g &lt;= <span class="number">1</span>);            <span class="keyword">if</span> (g == n) &#123;                <span class="keyword">do</span> &#123;                    ys = <span class="built_in">f</span>(ys);                    g = std::__gcd(std::<span class="built_in">abs</span>(x - ys), n);                &#125; <span class="keyword">while</span> (g &lt;= <span class="number">1</span>);            &#125;            <span class="keyword">if</span> (g != n) <span class="keyword">return</span> g;        &#125;    &#125;    <span class="function">std::vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;        std::vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; ret;        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;            <span class="type">long</span> <span class="type">long</span> f = <span class="built_in">find_factor</span>(n);            <span class="keyword">if</span> (f &lt; n) &#123;                <span class="keyword">auto</span> tmp = <span class="built_in">operator</span>()(f);                ret.<span class="built_in">insert</span>(ret.<span class="built_in">end</span>(), tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());            &#125; <span class="keyword">else</span>                ret.<span class="built_in">push_back</span>(n);            n /= f;        &#125;        std::<span class="built_in">sort</span>(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>());        <span class="keyword">return</span> ret;    &#125;    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">euler_phi</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;        <span class="type">long</span> <span class="type">long</span> ret = <span class="number">1</span>, last = <span class="number">-1</span>;        <span class="keyword">for</span> (<span class="keyword">auto</span> p : <span class="keyword">this</span>-&gt;<span class="built_in">operator</span>()(n)) ret *= p - (last != p), last = p;        <span class="keyword">return</span> ret;    &#125;&#125; FactorizeLonglong;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span><span class="comment">// CUT begin</span><span class="comment">// Solve ax+by=gcd(a, b)</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Int</span>&gt; <span class="function">Int <span class="title">extgcd</span><span class="params">(Int a, Int b, Int &amp;x, Int &amp;y)</span> </span>&#123;    Int d = a;    <span class="keyword">if</span> (b != <span class="number">0</span>) &#123;        d = <span class="built_in">extgcd</span>(b, a % b, y, x), y -= (a / b) * x;    &#125; <span class="keyword">else</span> &#123;        x = <span class="number">1</span>, y = <span class="number">0</span>;    &#125;    <span class="keyword">return</span> d;&#125;<span class="comment">// Calculate a^(-1) (MOD m) s if gcd(a, m) == 1</span><span class="comment">// Calculate x s.t. ax == gcd(a, m) MOD m</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Int</span>&gt; <span class="function">Int <span class="title">mod_inverse</span><span class="params">(Int a, Int m)</span> </span>&#123;    Int x, y;    <span class="built_in">extgcd</span>&lt;Int&gt;(a, m, x, y);    x %= m;    <span class="keyword">return</span> x + (x &lt; <span class="number">0</span>) * m;&#125;<span class="comment">// Require: 1 &lt;= b</span><span class="comment">// return: (g, x) s.t. g = gcd(a, b), xa = g MOD b, 0 &lt;= x &lt; b/g</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Int</span>&gt; <span class="comment">/* constexpr */</span> <span class="function">std::pair&lt;Int, Int&gt; <span class="title">inv_gcd</span><span class="params">(Int a, Int b)</span> </span>&#123;    a %= b;    <span class="keyword">if</span> (a &lt; <span class="number">0</span>) a += b;    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> &#123;b, <span class="number">0</span>&#125;;    Int s = b, t = a, m0 = <span class="number">0</span>, m1 = <span class="number">1</span>;    <span class="keyword">while</span> (t) &#123;        Int u = s / t;        s -= t * u, m0 -= m1 * u;        <span class="keyword">auto</span> tmp = s;        s = t, t = tmp, tmp = m0, m0 = m1, m1 = tmp;    &#125;    <span class="keyword">if</span> (m0 &lt; <span class="number">0</span>) m0 += b / s;    <span class="keyword">return</span> &#123;s, m0&#125;;&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Int</span>&gt;<span class="comment">/* constexpr */</span> <span class="function">std::pair&lt;Int, Int&gt; <span class="title">crt</span><span class="params">(<span class="type">const</span> std::vector&lt;Int&gt; &amp;r, <span class="type">const</span> std::vector&lt;Int&gt; &amp;m)</span> </span>&#123;    <span class="built_in">assert</span>(r.<span class="built_in">size</span>() == m.<span class="built_in">size</span>());    <span class="type">int</span> n = <span class="built_in">int</span>(r.<span class="built_in">size</span>());    <span class="comment">// Contracts: 0 &lt;= r0 &lt; m0</span>    Int r0 = <span class="number">0</span>, m0 = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;        <span class="built_in">assert</span>(<span class="number">1</span> &lt;= m[i]);        Int r1 = r[i] % m[i], m1 = m[i];        <span class="keyword">if</span> (r1 &lt; <span class="number">0</span>) r1 += m1;        <span class="keyword">if</span> (m0 &lt; m1) &#123;            std::<span class="built_in">swap</span>(r0, r1);            std::<span class="built_in">swap</span>(m0, m1);        &#125;        <span class="keyword">if</span> (m0 % m1 == <span class="number">0</span>) &#123;            <span class="keyword">if</span> (r0 % m1 != r1) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;            <span class="keyword">continue</span>;        &#125;        Int g, im;        std::<span class="built_in">tie</span>(g, im) = <span class="built_in">inv_gcd</span>&lt;Int&gt;(m0, m1);        Int u1 = m1 / g;        <span class="keyword">if</span> ((r1 - r0) % g) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;        Int x = (r1 - r0) / g % u1 * im % u1;        r0 += x * m0;        m0 *= u1;        <span class="keyword">if</span> (r0 &lt; <span class="number">0</span>) r0 += m0;    &#125;    <span class="keyword">return</span> &#123;r0, m0&#125;;&#125;<span class="comment">// 蟻本 P.262</span><span class="comment">// 中国剰余定理を利用して，色々な素数で割った余りから元の値を復元</span><span class="comment">// 連立線形合同式 A * x = B mod M の解</span><span class="comment">// Requirement: M[i] &gt; 0</span><span class="comment">// Output: x = first MOD second (if solution exists), (0, 0) (otherwise)</span><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Int</span>&gt;<span class="function">std::pair&lt;Int, Int&gt;</span><span class="function"><span class="title">linear_congruence</span><span class="params">(<span class="type">const</span> std::vector&lt;Int&gt; &amp;A, <span class="type">const</span> std::vector&lt;Int&gt; &amp;B, <span class="type">const</span> std::vector&lt;Int&gt; &amp;M)</span> </span>&#123;    Int r = <span class="number">0</span>, m = <span class="number">1</span>;    <span class="built_in">assert</span>(A.<span class="built_in">size</span>() == M.<span class="built_in">size</span>());    <span class="built_in">assert</span>(B.<span class="built_in">size</span>() == M.<span class="built_in">size</span>());    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)A.<span class="built_in">size</span>(); i++) &#123;        <span class="built_in">assert</span>(M[i] &gt; <span class="number">0</span>);        <span class="type">const</span> Int ai = A[i] % M[i];        Int a = ai * m, b = B[i] - ai * r, d = std::__gcd(M[i], a);        <span class="keyword">if</span> (b % d != <span class="number">0</span>) &#123;            <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 解なし</span>        &#125;        Int t = b / d * <span class="built_in">mod_inverse</span>&lt;Int&gt;(a / d, M[i] / d) % (M[i] / d);        r += m * t;        m *= M[i] / d;    &#125;    <span class="keyword">return</span> std::<span class="built_in">make_pair</span>((r &lt; <span class="number">0</span> ? r + m : r), m);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Int</span> = <span class="type">int</span>, <span class="keyword">class</span> Long = <span class="type">long</span> <span class="type">long</span>&gt; Int <span class="built_in">pow_mod</span>(Int x, <span class="type">long</span> <span class="type">long</span> n, Int md) &#123;    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(Int) * <span class="number">2</span> &lt;= <span class="built_in">sizeof</span>(Long), <span class="string">&quot;Watch out for overflow&quot;</span>);    <span class="keyword">if</span> (md == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;    Int ans = <span class="number">1</span>;    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) ans = (Long)ans * x % md;        x = (Long)x * x % md;        n &gt;&gt;= <span class="number">1</span>;    &#125;    <span class="keyword">return</span> ans;&#125;<span class="comment">// Find smallest primitive root for given number n （最小の原始根探索）</span><span class="comment">// n must be 2 / 4 / p^k / 2p^k (p: odd prime, k &gt; 0)</span><span class="comment">// (https://en.wikipedia.org/wiki/Primitive_root_modulo_n)</span><span class="comment">//</span><span class="comment">// Complexity: maybe O(sqrt(n)), if n is</span><span class="comment">// prime Algorithm: http://kirika-comp.hatenablog.com/entry/2018/03/12/210446 Verified:</span><span class="comment">// - https://yukicoder.me/submissions/405938</span><span class="comment">// - https://judge.yosupo.jp/problem/primitive_root</span><span class="comment">// - SRM 840 Div.1 900 https://community.topcoder.com/stat?c=problem_statement&amp;pm=17877</span><span class="comment">// Sample:</span><span class="comment">//  - 998244353 ( = (119 &lt;&lt; 23) + 1 ) -&gt; 3</span><span class="comment">//  - 163577857 ( = (39 &lt;&lt; 22) + 1 ) -&gt; 23</span><span class="comment">//  - 2 -&gt; 1</span><span class="comment">//  - 1 -&gt; -1</span><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">find_smallest_primitive_root</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;    std::vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; fac;    <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> phi = FactorizeLonglong.<span class="built_in">euler_phi</span>(n);    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> q : <span class="built_in">FactorizeLonglong</span>(phi)) &#123;        <span class="keyword">if</span> (fac.<span class="built_in">empty</span>() <span class="keyword">or</span> fac.<span class="built_in">back</span>() != q) fac.<span class="built_in">push_back</span>(q);    &#125;    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> g = <span class="number">1</span>; g &lt; n; g++) &#123;        <span class="keyword">if</span> (std::__gcd(n, g) != <span class="number">1</span>) <span class="keyword">continue</span>;        <span class="keyword">if</span> (<span class="built_in">pow_mod</span>&lt;<span class="type">long</span> <span class="type">long</span>, __int128&gt;(g, phi, n) != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;        <span class="type">bool</span> ok = <span class="literal">true</span>;        <span class="keyword">for</span> (<span class="keyword">auto</span> pp : fac) &#123;            <span class="keyword">if</span> (<span class="built_in">pow_mod</span>&lt;<span class="type">long</span> <span class="type">long</span>, __int128&gt;(g, phi / pp, n) == <span class="number">1</span>) &#123;                ok = <span class="literal">false</span>;                <span class="keyword">break</span>;            &#125;        &#125;        <span class="keyword">if</span> (ok) <span class="keyword">return</span> g;    &#125;    <span class="keyword">return</span> <span class="number">-1</span>;&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">lint</span>&gt;<span class="function">lint <span class="title">power</span><span class="params">(lint x, lint n, lint MOD)</span></span><span class="function"></span>&#123;    lint ans = <span class="number">1</span>;    <span class="keyword">while</span> (n&gt;<span class="number">0</span>)    &#123;        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) (ans *= x) %= MOD;        (x *= x) %= MOD;       n &gt;&gt;= <span class="number">1</span>;    &#125;    <span class="keyword">return</span> ans;&#125;<span class="function">plint <span class="title">solve</span><span class="params">(lint N)</span> </span>&#123;    <span class="keyword">for</span> (lint d = <span class="number">1</span>;; ++d) &#123;        <span class="type">const</span> lint p = d * N + <span class="number">1</span>;        <span class="keyword">if</span> (!<span class="built_in">is_prime</span>(p)) <span class="keyword">continue</span>;        <span class="type">const</span> lint g = <span class="built_in">find_smallest_primitive_root</span>(p);        <span class="keyword">auto</span> r = <span class="built_in">power</span>&lt;__int128&gt;(g, d, p);        <span class="keyword">return</span> &#123;r, p&#125;;    &#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    <span class="comment">// FOR(n, 1, 1000) solve(n);</span>    <span class="type">int</span> T;    cin &gt;&gt; T;    <span class="keyword">while</span> (T--) &#123;        <span class="type">int</span> N;        cin &gt;&gt; N;        <span class="keyword">auto</span> [a, m] = <span class="built_in">solve</span>(N);        cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; m &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre><p>SomethingNew</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">define</span> all(x) x.begin(), x.end()</span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> int long long</span><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;    <span class="type">int</span> n;    cin &gt;&gt; n;    cout &lt;&lt; n + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n * n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;&#125;<span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);    <span class="type">int</span> t=<span class="number">1</span>;    cin &gt;&gt; t;    <span class="keyword">while</span> (t--) &#123;        <span class="built_in">solve</span>();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] [模拟赛 20250126] UTPC2023K Kth Sum</title>
      <link href="/archives/UTPC2023K/"/>
      <url>/archives/UTPC2023K/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/utpc2023/tasks/utpc2023_k">https://atcoder.jp/contests/utpc2023/tasks/utpc2023_k</a></p><p><a href="https://qoj.ac/problem/9123">https://qoj.ac/problem/9123</a></p><h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>求 $n^3$ 个 $a_i+b_j+c_k$ 中的第 $k$ 大值。</p><p>$1\leq n\leq 5\times 10^4$，$1\leq k\leq \min{n^3,10^9}$，$0\leq a_i,b_i,c_i\leq 10^9$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>以下内容的 $k$ 混用了，懒得改，下标的 $k$ 表示的是 $c$ 的第 $k$ 个元素，不表示下标的就是第 $k$ 大的 $k$。</p><p>注意 $\sqrt {10^9}\neq 10^3$！注意 $\sqrt {10^9}\neq 10^3$！注意 $\sqrt {10^9}\neq 10^3$！注意 $\sqrt {10^9}\neq 10^3$！注意 $\sqrt {10^9}\neq 10^3$！注意 $\sqrt {10^9}\neq 10^3$！注意 $\sqrt {10^9}\neq 10^3$！注意 $\sqrt {10^9}\neq 10^3$！注意 $\sqrt {10^9}\neq 10^3$！</p><p>套路性地二分答案。二分 $lim$ 之后判断 $\leq lim$ 的时候有 $\geq k$ 个。</p><p>二分答案发现我们钦定一个 $a_i$ 之后最优也是 $\mathcal O(n)$ 地双指针求出合法的 $(j,k)$ 的对数。</p><p>但是我们发现，如果一个很大的 $a_i$ 有很多组 $(j,k)$ 合法，说明就已经超过 $k$ 个了。</p><p>具体的，我们对 $a,b,c$ 分别排序。枚举 $a_i$，只要 $(j,k)$ 的合法对数超过了 $k&#x2F;i$ 那么可以直接判断出是可行的。</p><p>但是这样还是避免不了 $\mathcal O(n)$ 地求出合法的 $(j,k)$ 的对数。考虑根号分治。对于 $i\leq B$ 的部分，我们直接暴力数 $(j,k)$ 对数。对于 $i\gt B$ 的部分，我们只需要看是否有一个 $i$ 能有 $\geq k&#x2F;B$ 个合法对。</p><p>然后我就觉得 $\sqrt{10^9}&#x3D;10^3$ 直接暴力做然后似大样例了&#x2F;qd</p><blockquote><p>对于 $i\gt B$ 的部分，我们只需要看是否有一个 $i$ 能有 $\geq k&#x2F;B$ 个合法对。</p></blockquote><p>这句话等价于，我们只需要保留 $k&#x2F;B$ 个最小的 $d_l&#x3D;b_j+c_k$，对于每个 $i\gt b$ 我们看有多少 $a_i+d_l\leq lim$。</p><p>然而这一部分又可以 $\mathcal O(\max{n,k&#x2F;B})$ 地求出。前面一部分是 $\mathcal O(nB)$ 的。这两部分加一起复杂度是 $\mathcal O(nB+k&#x2F;B)$。取最小值应该为 $B&#x3D;\sqrt{k&#x2F;n}$，此时两个都是 $\sqrt{nk}$。</p><p>接下来我们只需要做『保留 $k&#x2F;B$ 个最小的 $d_l&#x3D;b_j+c_k$』这件事。</p><p>这一部分我们还是无脑二分答案。先找到第 $k&#x2F;B$ 小的 $d_l$，然后双指针把小于等于他的都扔一起排序。</p><p><del>然后我模拟场上做到这里大样例本地跑了 0.4s 洛谷跑了 0.6s 觉得过了（悲）</del></p><p>第 $k&#x2F;B$ 小的有 $\mathcal O(n^3)$ 数量级，全存下来就飞了&#x2F;qd</p><p>把严格小于第 $k&#x2F;B$ 小的 $d_l$ 先扔进去，剩下不够的扔第 $k&#x2F;B$ 小的 $d_l$ 填满它。</p><p>最后预处理复杂度 $\mathcal O(n\log V+m\log m)$，其中 $m&#x3D;\min{n^2,k&#x2F;B}$ 表示我们需要保留的前 $m$ 小的 $d_l&#x3D;b_j+c_k$。二分答案复杂度 $\mathcal O((nB+k&#x2F;B)\log V)$，取 $B&#x3D;\sqrt{k&#x2F;n}$ 复杂度为 $\mathcal O(\sqrt{kn}\log V)$。</p><h1 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h1><p><a href="https://atcoder.jp/contests/utpc2023/submissions/62117369">https://atcoder.jp/contests/utpc2023/submissions/62117369</a></p><p><a href="https://qoj.ac/submission/873391">https://qoj.ac/submission/873391</a></p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC248G GCD cost on the tree</title>
      <link href="/archives/ABC248G/"/>
      <url>/archives/ABC248G/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定 $n$ 个点的树，每个点有点权 $a_i$。定义 $D(u,v)$ 表示 $u\to v$ 的简单路径的长度（即经过的点的个数）。定义 $G(u,v)$ 表示 $u\to v$ 的简单路径经过的所有点的 $\gcd$。定义 $F(u,v)$ 表示 $D(u,v)G(u,v)$。</p><p>求 $\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;i+1}^n F(i,j)$。</p><p>$1\leq n\leq 10^5$，$1\leq a_i\leq 10^5$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>对于每个 $\gcd$ 直接找他的路径不是很好做。我们不妨枚举 $\gcd$ 找 $G(u,v)$ 为 $\gcd$ 倍数的路径，然后容斥一下。</p><p>设 $f_i$ 表示 $G(u,v)$ 恰好等于 $i$ 的 $\sum\limits_{u&#x3D;1}^n\sum\limits_{v&#x3D;u+1}^n D(u,v)$。</p><p>设 $g_i$ 表示 $i\mid G(u,v)$ 的 $\sum\limits_{u&#x3D;1}^n\sum\limits_{v&#x3D;u+1}^n D(u,v)$。</p><p>则有 $f_i\gets g_i-\sum\limits_{i\mid j\land j\gt i} f_j$。</p><p>设 $N&#x3D;10^5$ 即本题中的 $\max a_i$，那么显然有 $\forall 2i\gt N,f_i&#x3D;g_i$。</p><p>我们现在只要求出这个 $g_i$ 就可以倒着推出所有 $f_i$。$\sum i\times f_i$ 即为答案。</p><p>我们把所有的 $i\mid a_j$ 的点 $j$ 拎出来。他们形成一片森林。我们对其中的每棵树 $T$ 求出 $\sum\limits_{u\in T}\sum\limits_{v\in T \land u\neq v} D(u,v)$ 即可。</p><p>这是个经典问题。考虑每条边的贡献。预处理出所有点的子树大小然后再搜一遍就行。由于本题的距离定义不太一样最后加上一个 $\binom{|T|}{2}$。</p><p>这样子做完之后照着上面的容斥重推一遍就好了。</p><p>时间复杂度计算考虑一个点会被哪些 $\gcd$ 用到。显然是因子个数。找 $i\mid a_j$ 的点可以调和级数地预处理因子。</p><h1 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h1><p><a href="https://atcoder.jp/contests/abc248/submissions/61987219">AT submission 61987219</a></p><pre><code class="highlight cpp"><span class="keyword">using</span> Z = mod_int&lt;<span class="number">998244353</span>&gt;;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>;<span class="type">int</span> n;Z f[<span class="number">100020</span>];<span class="type">int</span> a[<span class="number">100020</span>];<span class="type">int</span> sz[<span class="number">100020</span>];<span class="type">bool</span> ok[<span class="number">100020</span>];vector&lt;<span class="type">int</span>&gt; g[<span class="number">100020</span>];vector&lt;<span class="type">int</span>&gt; d[<span class="number">100020</span>];vector&lt;<span class="type">int</span>&gt; vec[<span class="number">100020</span>];Z tot;Z ans;<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span><span class="function"></span>&#123;    sz[u] = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> v : g[u])    &#123;        <span class="keyword">if</span> (!ok[v] || v == fa)            <span class="keyword">continue</span>;        <span class="built_in">dfs</span>(v, u);        sz[u] += sz[v];    &#125;&#125;<span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> rt)</span></span><span class="function"></span>&#123;    ok[u] = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> v : g[u])    &#123;        <span class="keyword">if</span> (!ok[v] || v == fa)            <span class="keyword">continue</span>;        <span class="built_in">calc</span>(v, u, rt);        tot += <span class="number">1LL</span> * sz[v] * (sz[rt] - sz[v]);    &#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= N; j += i)            d[j].<span class="built_in">emplace_back</span>(i);    &#125;    cin &gt;&gt; n;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        cin &gt;&gt; a[i];        <span class="keyword">for</span> (<span class="type">int</span> j : d[a[i]])            vec[j].<span class="built_in">push_back</span>(i);    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)    &#123;        <span class="type">int</span> u, v;        cin &gt;&gt; u &gt;&gt; v;        g[u].<span class="built_in">push_back</span>(v);        g[v].<span class="built_in">push_back</span>(u);    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)    &#123;        tot = <span class="number">0</span>;        <span class="keyword">for</span> (<span class="type">int</span> j : vec[i])            ok[j] = <span class="number">1</span>;        <span class="keyword">for</span> (<span class="type">int</span> j : vec[i])        &#123;            <span class="keyword">if</span> (!ok[j])                <span class="keyword">continue</span>;            <span class="built_in">dfs</span>(j, <span class="number">0</span>);            <span class="built_in">calc</span>(j, <span class="number">0</span>, j);            tot += <span class="number">1LL</span> * sz[j] * (sz[j] - <span class="number">1</span>) / <span class="number">2</span>;        &#125;        f[i] = tot;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = N; i &gt;= <span class="number">1</span>; i--)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= N; j += i)            f[i] -= f[j];    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)        ans += i * f[i];    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF2063F2 Counting Is Not Fun (Hard Version)</title>
      <link href="/archives/CF2063F2/"/>
      <url>/archives/CF2063F2/</url>
      
        <content type="html"><![CDATA[<h1 id="F1-题解链接"><a href="#F1-题解链接" class="headerlink" title="F1 题解链接"></a>F1 题解链接</h1><p><a href="http://blog.cyx2009.top/archives/CF2063F1/">http://blog.cyx2009.top/archives/CF2063F1/</a></p><h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>我们称可以用以下操作生成的括号串为一个『合法括号串』：</p><ol><li>空串。</li><li>如果串 $A$ 是『合法括号串』，那么 $\texttt{(}A\texttt{)}$ 也是一个『合法括号串』。</li><li>如果串 $A$ 和串 $B$ 都是『合法括号串』，那么 $AB$ 也是一个『合法括号串』。</li></ol><p>现在有一个隐藏的长度恰好为 $2n$ 的『合法括号串』$s$。依次有 $n$ 条信息，每条信息给出 $l,r$ 表示 $s_l&#x3D;\texttt{(},s_r&#x3D;\texttt{)}$ 且 $s_l,s_r$ 是通过操作 2 被<strong>同时</strong>添加的一对括号。</p><p>回答 $n+1$ 个问题：</p><ul><li>第一个问题回答没有给定任何信息时 $s$ 的所有可能情况。</li><li>第 $i+1$ 个问题回答给定前 $i$ 条信息时 $s$ 的所有可能情况。</li></ul><p>答案对 $998244353$ 取模。</p><p><strong>本题为 Hard Version。</strong></p><p>多测。</p><p>$1\leq t\leq 10^4$，$2\leq n,\sum n\leq 3\times 10^5$，$1\leq l_i\lt r_i\leq 2n$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>关于前置的做法相关请先阅读 F1 题解。本文着重讲对 F1 的暴力做法的数据结构优化。</p><p>F1 的瓶颈在于我们暴力的做了后缀加法和查询父亲括号。</p><p>我们把这个事情重新描述一遍。我们需要做的是：</p><blockquote><p>维护序列 $a$ 和标记序列 $f$，支持以下操作：</p><ol><li>给定 $x$，对 $[x,n]$ 做 $+1$ 或 $-1$。</li><li>给定 $x$，求点 $x$ 的值。</li><li>给定 $x,rk$。求最大的 $y$ 满足 $y&lt;x$ 且点 $y$ 的值为 $rk-1$ 且 $f_y&#x3D;1$。</li><li>给定 $x$，$f_x\gets 0$。</li><li>给定 $x$，$f_x\gets 1$。</li></ol></blockquote><p>这个东西看上去很复杂，我们直接考虑分块。设块长为 $B$。</p><p>操作 1 和操作 2 的分块属于是大炮打蚊子了。操作 1 散块暴力操作 $a_i\gets a_i+1$ 或 $a_i\gets a_i-1$ 之后重构这一块，整块打标记。操作 2 就是查询这一个位置的值即 $a_i+tag_{bel_i}$。</p><p>操作 3 我们需要知道某一块中是否存在值恰好为 $x$ 的数。如果有的话我们直接在这一块中找答案。我们对每一块维护一个长度为 $\mathcal O(n)$ 的桶表示这一块的这个值出现了几次。但是空间 $\mathcal O(n^2&#x2F;B)$ 爆炸，不难发现这一块之间极差只有 $\mathcal O(B)$。我们记录每个元素与这一块第一个值的差的桶即可。重构一个块以及操作 3 的查找分别是 $\mathcal O(B)$ 和 $\mathcal O(n&#x2F;B)$ 的。</p><p>操作 4 和操作 5 我们直接 $\mathcal O(1)$ 的修改这个块的桶的某个位置即可。</p><p>这样子我们就得到了一份 $\mathcal O(n\sqrt n)$ 的代码。但是这里 $n$ 自带 $2$ 倍常数，删除一堆括号的时候还有约 $3$ 次的根号复杂度的查询 &#x2F; 修改，很遗憾 TLE 了。</p><p>但是我坚信分块是有前途的，于是我卡了一晚上的常。</p><p>发现一个惊人的事情：<strong>我们的 $f$ 只会修改左括号位置上的值</strong>。只有后缀加法的操作可能会从右括号开始。</p><p>但是，这一点也不影响。我们直接对左括号离散化，右括号找自己后面下一个左括号的位置，从这里开始修改。</p><p>这样子的 $\mathcal O(n\sqrt n)$ 的复杂度就是可行的了。</p><h1 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h1><p><a href="https://codeforces.com/contest/2063/submission/302499400">CF submission 302499400</a></p><p>只加了离散化左括号，没有其他卡常。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF2063F1 Counting Is Not Fun (Easy Version)</title>
      <link href="/archives/CF2063F1/"/>
      <url>/archives/CF2063F1/</url>
      
        <content type="html"><![CDATA[<h1 id="F2-题解链接"><a href="#F2-题解链接" class="headerlink" title="F2 题解链接"></a>F2 题解链接</h1><p><a href="http://blog.cyx2009.top/archives/CF2063F2/">http://blog.cyx2009.top/archives/CF2063F2/</a></p><h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>我们称可以用以下操作生成的括号串为一个『合法括号串』：</p><ol><li>空串。</li><li>如果串 $A$ 是『合法括号串』，那么 $\texttt{(}A\texttt{)}$ 也是一个『合法括号串』。</li><li>如果串 $A$ 和串 $B$ 都是『合法括号串』，那么 $AB$ 也是一个『合法括号串』。</li></ol><p>现在有一个隐藏的长度恰好为 $2n$ 的『合法括号串』$s$。依次有 $n$ 条信息，每条信息给出 $l,r$ 表示 $s_l&#x3D;\texttt{(},s_r&#x3D;\texttt{)}$ 且 $s_l,s_r$ 是通过操作 2 被<strong>同时</strong>添加的一对括号。</p><p>回答 $n+1$ 个问题：</p><ul><li>第一个问题回答没有给定任何信息时 $s$ 的所有可能情况。</li><li>第 $i+1$ 个问题回答给定前 $i$ 条信息时 $s$ 的所有可能情况。</li></ul><p>答案对 $998244353$ 取模。</p><p><strong>本题为 Easy Version。</strong></p><p>多测。</p><p>$1\leq t\leq 10^3$，$2\leq n,\sum n\leq 5000$，$1\leq l_i\lt r_i\leq 2n$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>以下约定 $\operatorname{Cat}(n)&#x3D;\binom{2n}{n}-\binom{2n}{n+1}$ 表示卡特兰数第 $n$ 项。</p><p>为了方便考虑，我们假定在 $(0,2n+1)$ 的位置初始就有一对括号。这显然不影响答案。</p><p>括号串计数优先往卡特兰数上想，恰好样例中答案只有卡特兰数。一个笨笨的猜测是，我们把那些已经确定的括号遮住不看，设剩余了 $2(n-k)$ 个位置，答案是 $\operatorname{Cat}(n-k)$。</p><p>但是这样子我们的信息的限制完全不对。例如 $\texttt{(\underline{<del>}((\underline{</del>}\underline{<del>}))\underline{</del>})}$ 这种情况。实际上由于已经确定的括号“拦”住了，导致填 $\texttt{(}<br>{\color{red}{\texttt{(}}}<br>\texttt{((}<br>{\color{red}{\texttt{)(}}}\texttt{))}{\color{red}{\texttt{)}}}\texttt{)}$ 这样子的括号串虽然是合法的，但是并不满足给定的信息，即 $(4,8)$ 这对括号是通过 2 操作添加的，因为中间的 $\texttt{)(}$ 并不是合法括号串。</p><p>之后不难想到，如果我们给括号标层：给每个括号内部区域加上 $1$。也就是对于一对括号 $(l,r)$，我们把左括号位置 $+1$，右括号的下一个位置 $-1$，然后做前缀和。最后左右括号位置的值就是这个括号的层。不难发现左括号和右括号位置的值一定是一样的。</p><p>之后我们去刻画这个限制。这个限制相当于说 $[l+1,r-1]$ 是一个『合法括号串』。递归地考虑这个问题，感性理解一下，我们设此时有一个层级为 $k$ 的括号 $(l_k,r_k)$，那么它内部可能会有很多 $(l_{k+1},r_{k+1})$。我们忽略这些 $(l_{k+1},r_{k+1})$ 的部分，设剩下的空白的没有信息的位置有 $x$ 个，这个 $(l_k,r_k)$ 内部的贡献就是 $\operatorname{Cat}(x)$。</p><p>最后我们把每层的括号的贡献给乘起来就是最后答案。</p><p>这个理解很好理解，相当于是把 $(l_{k+1},r_{k+1})$ 的部分全部扔掉然后在里面填合法括号串。然而在合法括号串的任何位置插入一个合法括号串仍然是合法的。所以这些 $(l_{k+1},r_{k+1})$ 的内部只要填了合法括号串，怎么填是无所谓的。</p><p>F1 实现的时候直接每次暴力添加括号然后扫一遍不难统计。但是为了扩展到 F2，我们这样的每次 $\mathcal O(n)$ 扫一遍看起来就没什么前途。</p><p>我们继续刻画这个添加一对括号对答案的影响。添加一个括号串相当于是把自己父亲的一点贡献拆给自己。把一个 $\operatorname{Cat}(y)$ 拆成 $\operatorname{Cat}(y-x-1)\operatorname{Cat}(x)$。我们求出这个 $x$ 就好。</p><p>但是这个也许有点困难了，至少我尝试实现发现需要维护很多东西。正难则反，我们把添加括号改成拆括号，询问逆序。</p><p>逆序之后相当于是一个 $\operatorname{Cat}(x)$ 和一个 $\operatorname{Cat}(y)$ 合并成了 $\operatorname{Cat}(x+y+1)$。这个就很轻松了，我们只需要支持一个事情：查询这对括号的上一层父亲括号。设这对括号层级是 $rk$，父亲括号指包裹他的层级为 $rk-1$ 的那一对括号。</p><p>要找父亲括号我们要首先求出这个 $rk$。刚才说括号标层是差分描述的，差分之后前缀和相当于是后缀 $+1$ 或后缀 $-1$，查询单点的值。</p><p>之后考虑查父亲括号。父亲括号相当于是某个前缀的最后一个值为 $rk-1$ 的位置并且这个位置被标记成了左括号。</p><p>在 F1 我们把这些操作模拟一遍就可以。单次复杂度 $\mathcal O(n)$，总复杂度 $\mathcal O(n^2)$。</p><h1 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h1><p>代码里有一段很长的 modint 板子。</p><p><a href="https://codeforces.com/contest/2063/submission/302480835">CF submission 302480835</a></p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[笔记] 叉人须知</title>
      <link href="/archives/hack_help/"/>
      <url>/archives/hack_help/</url>
      
        <content type="html"><![CDATA[<p>这里是 hack 时的常见注意事项。</p><ol><li><p>带了 $T$ 组 memset 的可能真能过，看一眼 test2 是不是卡满了 $T$ 组。</p></li><li><p><code>sqrt</code> 在 CF 的<strong>某个</strong> C++ 版本上精度是和 <code>sqrtll</code> 一样的。聊天记录找不到了。改天有空自己测一下补一下细节。</p></li><li><p><code>multiset.count()</code> 虽然复杂度是 $\mathcal O(\log n+ans)$ 但是写 <code>if (s.count(x))</code> 的时候会被 O2 优化成 <code>s.contains()</code> 复杂度是对的。GCC 4.9.3 已经有这个优化了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> StudyNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[笔记] 一些可能需要记录的东西</title>
      <link href="/archives/something_needs_to_record/"/>
      <url>/archives/something_needs_to_record/</url>
      
        <content type="html"><![CDATA[<p>考虑到我脑子不太好，一些简单的东西发现不了，还容易忘，遂记录。</p><hr><p>曼哈顿距离，等价于每一个 $2^k$ 种正负号的选择的最大值。</p><p>求所有点对最大值可以考虑建若干个点表示符号情况然后连边。最小值不适用。</p><p><a href="https://atcoder.jp/contests/agc034/tasks/agc034_d">AT_agc034_d</a> 没补</p><p><a href="https://codeforces.com/contest/1156/problem/G">CF1093G</a> 没补</p><p><a href="http://poj.org/problem?id=2926">POJ2926</a> 太棒了我写了这篇专栏后两天就做到了。直接用这个就过了。</p><hr><p>$a\operatorname{op} b&#x3D;\begin{cases}a&amp;a&#x3D;b\c&amp;\text{otherwise }\end{cases}$</p><p>这类形式运算可以刻画成取模意义下的运算。该例子中对应 $1,2,3$ 之后 $a\operatorname{op} b\equiv 2a+2b\pmod 3$。</p><p><a href="https://www.luogu.com.cn/problem/P7803">P7803</a></p><hr><p>处理两个量的变化但是不是区间端点仍然可以考虑莫队。</p><p><a href="https://atcoder.jp/contests/tenka1-2014-final/tasks/tenka1_2014_final_d">AT_tenka1_2014_final_d</a></p><hr><p>判断集合内是否只有一种颜色可以判方差做到 $\mathcal O(1)$。</p><p><a href="https://codeforces.com/problemset/problem/351/D">CF351D</a></p><hr><p>题目在很多询问的答案可能是连续的，例如根号分治之后答案不超过根号种。</p><p><a href="https://codeforces.com/problemset/problem/786/C">CF786C</a></p><p><a href="https://codeforces.com/problemset/problem/1968/G2">CF1968G2</a></p><hr><p>处理本质不同区间个数但是端点连续可以把区间映射到平面之后扫描线算面积。</p><p><a href="https://atcoder.jp/contests/abc346/tasks/abc346_g">AT_abc346_g</a></p><hr><p>求所有情况的答案可以看成概率，DP 他的期望，最后答案乘上总方案。</p><p><a href="https://atcoder.jp/contests/agc030/tasks/agc030_d">AT_agc030_d</a></p><hr><p>字符串要求一些部分相同可以考虑枚举 $i$ 每 $i$ 个点打一个标记，每个部分会刚好跨过一个。</p><p><a href="https://www.luogu.com.cn/problem/P1117">P1117</a></p><p><a href="https://www.luogu.com.cn/problem/UVA10829">UVA10829</a> 没补</p><hr><p>baka’s trick。不用删除的双指针。设合并信息复杂度是 $\mathcal O(C)$ 则总复杂度是 $\mathcal O(nC)$。</p><p>这是看别的题题解在同一篇文章里看到的，改天学一下。</p><p><a href="https://www.cnblogs.com/dcytrl/p/18544036">https://www.cnblogs.com/dcytrl/p/18544036</a></p><p><a href="https://qoj.ac/problem/7307">QOJ7307</a></p><hr><p>二分图博弈，起点为 $u$ 时必胜当且仅当 $u$ 在所有最大匹配上。</p><p>实现：</p><blockquote><p>注意到一个点 $i$ 一定在最大匹配中等价于所有最大流中 $S$ 到该点 $i$ 的边有流量。</p><p>这个命题等价于：在某个最大流中 $S$ 到 $i$ 的边有流量，且残量网络上不存在 $S$ 到 $i$ 的路径。</p><p>故我们只需在残量网络上从源点开始搜索能到达的点即可。这部分时间复杂度 $\mathcal O(n)$。 </p></blockquote><p>我注意不到，所以这是需要记录的。</p><p><a href="https://loj.ac/p/536">LOJ536</a></p>]]></content>
      
      
      <categories>
          
          <category> StudyNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF254D Rats</title>
      <link href="/archives/CF254D/"/>
      <url>/archives/CF254D/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>凭什么有人觉得这题难写来着，多分析一点就很好写了&#x2F;fendou</p><h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>$n\times m$ 的网格，有若干个老鼠 $\tt R$。墙是 $\tt X$。普通地面是 $\tt .$。选择两个位置投放炸弹，炸弹每个时刻往四联通扩张一次。炸弹不可以越过墙。炸弹投放时间为 $0$，$d$ 秒之后炸弹就会停止扩张。问选择哪两个位置各投放一个炸弹才能让所有老鼠都被炸到。无解输出 <code>-1</code>。</p><p>要求构造的答案炸弹初始不在墙上，不可以两个炸弹初始在同一个位置。</p><p>$1\leq n,m\leq 1000$，$1\leq d\leq 8$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>$d$ 很小，从这里考虑。发现一个炸弹有效范围大概是 $\mathcal O(d^2)$ 的，无遮挡的情况下曼哈顿距离小于等于 $d$ 的是可炸的。</p><p>枚举第一只老鼠周围曼哈顿距离不超过 $d$ 的格子，作为第一个炸弹的候选点。找到另一只老鼠，与第一只老鼠曼哈顿距离最大，再把它周围曼哈顿距离不超过 $d$ 的格子作为第二个炸弹的候选点。枚举所有候选点组合，搜索一遍记录炸掉的老鼠个数。</p><p>复杂度 $\mathcal O(d^6)$。极其好写。写一个 BFS 调用两次即可。</p><p>这个做法看起来有点不靠谱。<del>但是他过了</del>。尝试构造 hack。大概 hack 思路是有一个老鼠和第一只的距离很近，但是被封住了导致没法在规定时间炸到。曼哈顿最远的反而能被炸到。</p><p>感性理解一下，这种形式的 hack，这只老鼠本身就会成为第一个炸弹的候选点之一，肯定是会被炸到的。第一只老鼠和最远的老鼠，又可以通过枚举第二个炸弹的位置被同时炸到。不管怎样这样的做法肯定是对的。</p><p>另外我一开始用 <code>std::map</code> 存访问位置多带了 $\log$ 被卡常了。搜索的时候标记套路性地打成颜色标记即可。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://codeforces.com/contest/254/submission/301081506">CF submission 301081506</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n, m, k;<span class="type">char</span> mp[<span class="number">1020</span>][<span class="number">1020</span>];vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; vec;vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; v1;vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; v2;set&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; s;<span class="type">int</span> vis[<span class="number">1020</span>][<span class="number">1020</span>];<span class="type">int</span> cnt;<span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;<span class="type">const</span> <span class="type">int</span> dy[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;<span class="function"><span class="type">bool</span> <span class="title">in</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &lt;= x &amp;&amp; x &lt;= n &amp;&amp; <span class="number">1</span> &lt;= y &amp;&amp; y &lt;= m; &#125;<span class="type">int</span> col;<span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><span class="function"></span>&#123;    col++;    queue&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; q;    q.<span class="built_in">push</span>(&#123;x, y, <span class="number">0</span>&#125;);    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())    &#123;        <span class="keyword">auto</span> [x, y, d] = q.<span class="built_in">front</span>();        q.<span class="built_in">pop</span>();        <span class="keyword">if</span> (vis[x][y] == col)            <span class="keyword">continue</span>;        vis[x][y] = col;        <span class="keyword">if</span> (mp[x][y] == <span class="string">&#x27;R&#x27;</span>)            s.<span class="built_in">insert</span>(&#123;x, y&#125;);        <span class="keyword">if</span> (d == k)            <span class="keyword">continue</span>;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)        &#123;            <span class="type">int</span> tx = x + dx[i];            <span class="type">int</span> ty = y + dy[i];            <span class="keyword">if</span> (<span class="built_in">in</span>(tx, ty) &amp;&amp; mp[tx][ty] != <span class="string">&#x27;X&#x27;</span>)                q.<span class="built_in">push</span>(&#123;tx, ty, d + <span class="number">1</span>&#125;);        &#125;    &#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);    <span class="built_in">freopen</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)            cin &gt;&gt; mp[i][j];    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)        &#123;            <span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;R&#x27;</span>)                vec.<span class="built_in">push_back</span>(&#123;i, j&#125;);        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)        &#123;            <span class="keyword">if</span> (mp[i][j] != <span class="string">&#x27;X&#x27;</span> &amp;&amp; <span class="built_in">abs</span>(i - vec[<span class="number">0</span>][<span class="number">0</span>]) + <span class="built_in">abs</span>(j - vec[<span class="number">0</span>][<span class="number">1</span>]) &lt;= k)                v<span class="number">1.</span><span class="built_in">push_back</span>(&#123;i, j&#125;);        &#125;    &#125;    <span class="type">int</span> p = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)    &#123;        <span class="keyword">if</span> (<span class="built_in">abs</span>(vec[p][<span class="number">0</span>] - vec[<span class="number">0</span>][<span class="number">0</span>]) + <span class="built_in">abs</span>(vec[p][<span class="number">1</span>] - vec[<span class="number">0</span>][<span class="number">1</span>]) &lt;            <span class="built_in">abs</span>(vec[i][<span class="number">0</span>] - vec[<span class="number">0</span>][<span class="number">0</span>]) + <span class="built_in">abs</span>(vec[i][<span class="number">1</span>] - vec[<span class="number">0</span>][<span class="number">1</span>]))            p = i;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)        &#123;            <span class="keyword">if</span> (mp[i][j] != <span class="string">&#x27;X&#x27;</span> &amp;&amp; <span class="built_in">abs</span>(i - vec[p][<span class="number">0</span>]) + <span class="built_in">abs</span>(j - vec[p][<span class="number">1</span>]) &lt;= k)                v<span class="number">2.</span><span class="built_in">push_back</span>(&#123;i, j&#125;);        &#125;    &#125;    <span class="keyword">for</span> (<span class="keyword">auto</span> [ax, ay] : v1)    &#123;        <span class="keyword">for</span> (<span class="keyword">auto</span> [bx, by] : v2)        &#123;            <span class="keyword">if</span> (ax == bx &amp;&amp; ay == by)                <span class="keyword">continue</span>;            s.<span class="built_in">clear</span>();            <span class="built_in">bfs</span>(ax, ay);            <span class="built_in">bfs</span>(bx, by);            <span class="keyword">if</span> (s.<span class="built_in">size</span>() == vec.<span class="built_in">size</span>())                <span class="keyword">return</span> cout &lt;&lt; ax &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ay &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; bx &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; by &lt;&lt; <span class="string">&#x27;\n&#x27;</span>, <span class="number">0</span>;        &#125;    &#125;    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] [模拟赛 20250113] P7803 [JOI Open 2021] Crossing</title>
      <link href="/archives/P7803/"/>
      <url>/archives/P7803/</url>
      
        <content type="html"><![CDATA[<h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>题目这个变化看上去是判断两个字符是否相同，相同选他否则选剩下的一个。但有个很深刻的事情是把字符分别设为 $1,2,3$。那么 $a \operatorname{cross} b$ 运算结果就是 $c\equiv 2a+2b\pmod 3$。模拟赛时一点没想到还可以这样变换。</p><p>交换律不难看出。设 $A$ 是一个运算过程，这个事情也告诉我们 $(a \operatorname{cross} A) \operatorname{cross} a&#x3D;a \operatorname{cross} (A \operatorname{cross} a)&#x3D;A$。因此在一个最后的表达式中，$S_A,S_B,S_C$ 不可能出现超过一次参与运算。</p><p>那么总状态只有 $9$ 类：</p><ol><li>$S_A$；</li><li>$S_B$；</li><li>$S_C$；</li><li>$S_A\operatorname{cross} S_B$；</li><li>$S_A\operatorname{cross} S_C$；</li><li>$S_B\operatorname{cross} S_C$；</li><li>$(S_A \operatorname{cross} S_B)\operatorname{cross} S_C$；</li><li>$(S_B \operatorname{cross} S_C)\operatorname{cross} S_A$；</li><li>$(S_C \operatorname{cross} S_A)\operatorname{cross} S_B$。</li></ol><p>我们要做的就是判断给定字符串有没有在这里出现过。可以直接存下这九种字符串的哈希值。再加一棵维护哈希值的线段树，支持区间推平和查询全局哈希。线段树维护一下当前覆盖的颜色，预处理出颜色连续段的哈希值。全局查询就是根节点的哈希值。</p><p>代码实现写的是单模随机 base。另外我在 Baekjoon 交这题交了三发改了两次模数才过？？？</p><h1 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h1><p><a href="https://www.luogu.com.cn/record/198170123">洛谷 record 198170123</a></p><p>代码有 modint 有点长，附一份 qoj 链接。</p><p><a href="https://qoj.ac/submission/856620">https://qoj.ac/submission/856620</a></p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] [模拟赛 20250113] P11392 [JOI Open 2019] 三段跳び</title>
      <link href="/archives/P11392/"/>
      <url>/archives/P11392/</url>
      
        <content type="html"><![CDATA[<h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>以下用 $a$ 表示原数组 $A$，$i,j,k$ 对应原文的 $a,b,c$。</p><p>模拟赛题，一个一个 sub 想可能简单点？</p><p>sub 1 直接暴力枚举所有情况就能过。</p><p>sub 2 <strong>如果</strong>是单测 $[1,n]$ 的情况下（话说我做出这题之后都不知道这档分咋做？？），可以发现我们只要枚举 $i,j$。合法的 $k$ 是一段后缀。直接用树状数组或者线段树维护后缀 $\max$ 即可。</p><p>考虑 sub 3。发现这个 $i,j$ 如果缩小到 $i\leq i’\leq j’\leq j$，那么 $k$ 的可行范围只会增大。$a_k$ 的选择是不劣的，我们尝试把 $i,j$ 缩小到一个最优的情况。只要中间有比 $\min{a_i,a_j}$ 大的数，就一定可以把 $i$ 或 $j$ 挪过去。递归地考虑这个过程，结束情况代表 $a_i,a_j$ 都比 $[i+1,j-1]$ 中间的大。</p><p>这个结束状态相当于是，前方第一个比自己大的 $pre_i$ 和自己 $i$，自己 $i$ 和后方第一个比自己大的 $nxt_i$，这两对区间。单调栈不难求出。<strong>这样的区间只有 $\mathcal O(n)$ 个</strong>。</p><p>考虑多测的情况。根据 sub 2 的做法，我们先求出每组 $i,j$ 对应的 $k$ 的范围。移项得到 $k\geq 2j-i$。加入的时候要保证 $i,j,k$ 至少都要 $\geq l$，所以倒序枚举 $l$。加入的时候就是对一个后缀 $[2j-i,n]$ 打标记，$tag_k\gets \max{tag_k,a_i+a_j}$。之后要求的是 $[l,r]$ 之间最大的 $tag_k+a_k$。通过线段树不难实现。这里线段树实现需要一个附加一个静态区间 $\max$，但是可以发现求的范围一定是线段树的一个节点的范围。在建树的时候多求一个 $mxk_i$ 表示这个节点内最大的 $a_k$ 即可。代码除去快读快写还是很短的。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://www.luogu.com.cn/record/198020029">洛谷 record 198020029</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span></span><span class="function"></span>&#123;    <span class="type">static</span> <span class="type">int</span> stk[<span class="number">30</span>];    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;    <span class="type">int</span> top = <span class="number">0</span>;    <span class="keyword">do</span>    &#123;        stk[top++] = x % <span class="number">10</span>, x /= <span class="number">10</span>;    &#125; <span class="keyword">while</span> (x);    <span class="keyword">while</span> (top)        <span class="built_in">putchar</span>(stk[--top] + <span class="string">&#x27;0&#x27;</span>);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x, <span class="type">char</span> lastChar)</span> </span>&#123; <span class="built_in">write</span>(x), <span class="built_in">putchar</span>(lastChar); &#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">max</span>(x, y); &#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">min</span>(x, y); &#125;<span class="meta">#<span class="keyword">define</span> FIO(s)                    \</span><span class="meta">    freopen(s <span class="string">&quot;.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); \</span><span class="meta">    freopen(s <span class="string">&quot;.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><span class="type">int</span> n, Q;<span class="type">int</span> a[<span class="number">500020</span>];<span class="type">int</span> ans[<span class="number">500020</span>];vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; q[<span class="number">500020</span>];<span class="type">int</span> stk[<span class="number">500020</span>], top;<span class="type">int</span> pre[<span class="number">500020</span>];<span class="type">int</span> nxt[<span class="number">500020</span>];vector&lt;<span class="type">int</span>&gt; vec[<span class="number">500020</span>];<span class="keyword">struct</span> <span class="title class_">SegTree</span>&#123;    <span class="keyword">struct</span> <span class="title class_">node</span>    &#123;        <span class="type">int</span> mx, mxk, lzy;    &#125; t[<span class="number">500020</span> &lt;&lt; <span class="number">2</span>];<span class="meta">#<span class="keyword">define</span> ls id &lt;&lt; 1</span><span class="meta">#<span class="keyword">define</span> rs id &lt;&lt; 1 | 1</span>    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123; t[id].mx = <span class="built_in">max</span>(t[ls].mx, t[rs].mx); &#125;    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r)</span></span><span class="function">    </span>&#123;        <span class="built_in">chkmx</span>(t[ls].lzy, t[id].lzy);        <span class="built_in">chkmx</span>(t[rs].lzy, t[id].lzy);        t[ls].mx = <span class="built_in">max</span>(t[ls].mx, t[ls].mxk + t[ls].lzy);        t[rs].mx = <span class="built_in">max</span>(t[rs].mx, t[rs].mxk + t[rs].lzy);    &#125;    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> id = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = n)</span></span><span class="function">    </span>&#123;        t[id].lzy = <span class="number">0</span>;        <span class="keyword">if</span> (l == r)            <span class="keyword">return</span> t[id].mx = t[id].mxk = a[l], <span class="built_in">void</span>();        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;        <span class="built_in">build</span>(ls, l, mid);        <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);        <span class="built_in">push_up</span>(id);        t[id].mxk = <span class="built_in">max</span>(t[ls].mxk, t[rs].mxk);    &#125;    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> k, <span class="type">int</span> id = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = n)</span></span><span class="function">    </span>&#123;        <span class="keyword">if</span> (r &lt; ql || l &gt; qr)            <span class="keyword">return</span>;        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)            <span class="keyword">return</span> <span class="built_in">chkmx</span>(t[id].lzy, k), t[id].mx = <span class="built_in">max</span>(t[id].mx, t[id].mxk + t[id].lzy), <span class="built_in">void</span>();        <span class="built_in">push_down</span>(id, l, r);        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;        <span class="built_in">modify</span>(ql, qr, k, ls, l, mid);        <span class="built_in">modify</span>(ql, qr, k, rs, mid + <span class="number">1</span>, r);        <span class="built_in">push_up</span>(id);    &#125;    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> id = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = n)</span></span><span class="function">    </span>&#123;        <span class="keyword">if</span> (r &lt; ql || l &gt; qr)            <span class="keyword">return</span> <span class="number">0</span>;        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)            <span class="keyword">return</span> t[id].mx;        <span class="built_in">push_down</span>(id, l, r);        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">query</span>(ql, qr, ls, l, mid), <span class="built_in">query</span>(ql, qr, rs, mid + <span class="number">1</span>, r));    &#125;&#125; T;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="comment">// FIO(&quot;triple&quot;);</span>    <span class="built_in">read</span>(n);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">read</span>(a[i]);    <span class="built_in">read</span>(Q);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)    &#123;        <span class="type">int</span> l, r;        <span class="built_in">read</span>(l, r);        q[l].<span class="built_in">push_back</span>(&#123;r, i&#125;);    &#125;    a[<span class="number">0</span>] = a[n + <span class="number">1</span>] = <span class="number">1e9</span>;    stk[top = <span class="number">1</span>] = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">while</span> (top &amp;&amp; a[stk[top]] &lt; a[i])            top--;        pre[i] = stk[top];        stk[++top] = i;    &#125;    stk[top = <span class="number">1</span>] = n + <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)    &#123;        <span class="keyword">while</span> (top &amp;&amp; a[stk[top]] &lt; a[i])            top--;        nxt[i] = stk[top];        stk[++top] = i;    &#125;    <span class="comment">// for (int i = 1; i &lt;= n; i++)</span>    <span class="comment">//     cout &lt;&lt; pre[i] &lt;&lt; &#x27; &#x27;;</span>    <span class="comment">// cout &lt;&lt; &#x27;\n&#x27;;</span>    <span class="comment">// for (int i = 1; i &lt;= n; i++)</span>    <span class="comment">//     cout &lt;&lt; nxt[i] &lt;&lt; &#x27; &#x27;;</span>    <span class="comment">// cout &lt;&lt; &#x27;\n&#x27;;</span>    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">if</span> (pre[i] != <span class="number">0</span>)            vec[pre[i]].<span class="built_in">push_back</span>(i);    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">if</span> (nxt[i] != n + <span class="number">1</span>)            vec[i].<span class="built_in">push_back</span>(nxt[i]);    &#125;    T.<span class="built_in">build</span>();    <span class="keyword">for</span> (<span class="type">int</span> l = n; l &gt;= <span class="number">1</span>; l--)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> r : vec[l])        &#123;            <span class="keyword">if</span> (r + r - l &lt;= n)                T.<span class="built_in">modify</span>(r + r - l, n, a[l] + a[r]);        &#125;        <span class="comment">// cout &lt;&lt; l &lt;&lt; &#x27;\n&#x27;;</span>        <span class="keyword">for</span> (<span class="keyword">auto</span> [r, id] : q[l])            ans[id] = T.<span class="built_in">query</span>(l, r);        <span class="comment">// for (int i = 1; i &lt;= n; i++)</span>        <span class="comment">//     cout &lt;&lt; T.query(i, i) &lt;&lt; &#x27; &#x27;;</span>        <span class="comment">// cout &lt;&lt; &#x27;\n&#x27;;</span>    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)        <span class="built_in">write</span>(ans[i], <span class="string">&#x27;\n&#x27;</span>);    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF2053G Naive String Splits</title>
      <link href="/archives/CF2053G/"/>
      <url>/archives/CF2053G/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这题太曲折了。最后的官方 Editorial 是我重写的。</p><p><a href="https://codeforces.com/blog/entry/136455">https://codeforces.com/blog/entry/136455</a></p><p><del>并非本文抄袭官方题解，是官方题解抄袭本文。</del></p><h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定长度为 $n$ 的字符串 $s$ 和长度为 $m$ 的字符串 $t$。对于每个 $k\in[1,n)$，问 $s$ 的长度为 $k$ 的前缀和 $s$ 的长度为 $n-k$ 的后缀这两个字符串，能不能拼接得到字符串 $t$。一个前缀 &#x2F; 后缀可以使用多次。</p><p>$2\leq n,m\leq 5\times 10^6$。</p><p>多测，$1\leq T\leq 10^5$，$1\leq \sum m\leq 10^7$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>不妨把前缀 $s_1$ 叫做短串，后缀 $s_2$ 叫做长串。如果 $|s_1|\gt |s_2|$ 换一下顺序不影响答案。</p><p>考虑一个贪心做法。我们每次先匹配几个短串，直到无法匹配。如果无法匹配，我们就尝试扔掉几个短串，放一个长串。枚举扔几个短串即可。<strong>找到第一个位置使得可以放一个长串</strong>。我们把这样放一次叫做一次『匹配过程』，每次『匹配过程』的开始位置就是上个『匹配过程』的下个位置。</p><p>但是这个做法是有漏洞的。下面将会说明这个漏洞的情况。</p><hr><p>不难把长串看作是若干个短串拼上一个『尾巴』。</p><p>为什么只要找到第一个位置呢？为什么多反悔几个 $s_1$ 再放不会更优呢？</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/v793c2d8.png"></p><p>上图是一个例子。红线是我们匹配 $s_1$ 的截止位置。三个橙色方框表示尝试匹配长串的选择。</p><p>最后一个是不合法的，跳过，换『第一个合法的放长串的位置』这个框。这个框是合理的。</p><p>选第二个框和选第一个框的差距在，结束匹配进行下一轮的时候，我们需要匹配的内容，是选择了一段 $s_1$ 的后缀放到了 $s_1$ 的开头。</p><p>如图。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/bmhz3e7z.png"></p><p>对齐得到下图。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/qur4odo1.png"></p><p>图中是 $|pre|\gt |suf|$ 的情况，另一种是同理的。</p><p>$pre+suf&#x3D;suf+pre$，通过图片不难看出这里是 $pre+suf$ 需要“错位相等”的。也就是 $s_1$ 需要存在一个循环节，且『尾巴』也需要能够通过循环节拼出来，$s_2$ 前面那 $|s_1|$ 个字符还是需要能被循环节拼出来。</p><p>总结一下就是相当于 $s_1,s_2$ 有<strong>公共循环节</strong>。</p><p>也就是说，<strong>反悔两次能凑出答案，反悔一次不一定可行</strong>，需要满足二者有公共循环节。</p><p>有公共循环节这个太特殊了。首先这两个的公共循环节一定会是 $s$ 这个串的循环节。提前找到这个循环节，然后相当于是解方程，设 $a&#x3D;|s_1|,b&#x3D;|s_2|$，即判断是否有非负整数解 $x,y$ 满足 $xa+yb&#x3D;|s|$。</p><p>这个解方程纯纯唬人。我们枚举 $y$，每一次计算枚举 $\mathcal O(\frac{m}{n})$ 次。最多 $n$ 次，复杂度 $\mathcal O(m)$。</p><hr><p>漏洞解决了，剩下的情况我们<strong>找到第一个可以放长串的位置就放</strong>这个贪心是对的。</p><p>直接实现的话，复杂度最劣是调和级数的。考虑这个情况，$s_1&#x3D;\texttt{a},s_2&#x3D;\texttt{aaaaaaaab},t&#x3D;\tt{aaaaaaaaaaaaaaaaaaaaaaaaab}$ 这种，我们尝试 $\mathcal O(\frac{m}{|s_1|})$ 步才能结束匹配短串。反悔每次至多 $\mathcal O(\frac{m}{|s_2|})$ 次，每次 $\mathcal O(\frac{|s_2|}{|s_1|})$。</p><hr><p>好吧这个题确实是可以线性的。</p><p>首先设长串的前缀包含了 $c$ 个短串，那么我们反悔到的第一个『可以放长串的位置』只可能是反悔 $c$ 个短串或者 $c+1$ 个短串得到的。</p><p>这个很好理解，反悔 $c$ 个就是看作是长串的前缀，然后加上长串的『尾巴』。反悔 $c+1$ 个当且仅当长串的『尾巴』部分是短串的前缀。例如 CF 评论区的 hack：</p><p><a href="https://codeforces.com/blog/entry/136455#comment-1234262">https://codeforces.com/blog/entry/136455?#comment-1234262</a></p><pre><code class="highlight plain">18 8abaabaababaababa</code></pre><p>正确输出应该为</p><pre><code class="highlight plain">0010000</code></pre><p>在 $k&#x3D;3$ 的时候 $s_1&#x3D;\texttt{aba},s_2&#x3D;\texttt{abaab}$，此时我们先填充了 $2$ 个短串，但是只撤销 $c&#x3D;1$ 个就会判成无解，std 的锅就是这么出的。只有在 $s_2$ 的『尾巴』部分是 $s_1$ 的前缀的时候才会出现这种情况。</p><p>所以我们每次计算的时候先二分出这个 $c$，复杂度是 $\mathcal O(\sum\limits_{i&#x3D;1}^n\log(\frac n i))&#x3D;\mathcal O(n)$ 的。之后反悔只需要进行两次判断。反悔过程做到线性了。</p><p>接下来对填充短串部分进行加速。暴力填充的 hack 上面已经给出了。如果直接使用一开始大家都认为是对的的『二分短串出现次数』的方法，那么可以通过</p><pre><code class="highlight plain">12 5000000ababababab....abababab</code></pre><p>这组 hack 卡到 $\log$。</p><p>@<a href="/user/99506"><em>LHF</em></a> 的评论指出两种替代方案。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/hozwdksl.png"></p><p>这里详细分析一下第二种做法。经过沟通，这里 lhf 老师笔误了。应该是匹配 $\frac{n}{|s_1|}$ 个。</p><p>类似分块，取 $B&#x3D;\frac{n}{|s_1|}$。我们先尝试匹配 $B$ 个 $s_1$，也就是说每次匹配都可以往前推动 $n$ 个位置。之后剩下的部分不会超过 $B$ 个，二分出剩下内容具体有几个。而前面一次推进 $B$ 个的部分，至多反悔掉一次，后面二分，就变成了 $\mathcal O(\log B)$。每次至少可以填充 $|s_2|$ 个。这里计算一次答案复杂度就变成了 $\mathcal O(\frac{m}{|s_2|}\log B)$，总复杂度由于 $\mathcal O(\sum\limits_{i&#x3D;1}^n\log(\frac n i))&#x3D;\mathcal O(n)$ 所以是 $\mathcal O(m)$ 的。</p><p>至此，本题在线性时间解决了。</p><h1 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h1><p>这是一份依据 @<a href="/user/99506"><em>LHF</em></a> 指出的做法的第二条的实现。</p><p><a href="https://codeforces.com/contest/2053/submission/299319348">CF submission 299319348</a></p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF2049F MEX OR Mania</title>
      <link href="/archives/CF2049F/"/>
      <url>/archives/CF2049F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给给定长度为 $a$ 的序列，定义长度为 $m$ 的序列 $b$ 是好的当且仅当 $\operatorname{mex}(b)-(\operatorname{OR}\limits_{i&#x3D;1}^m b_i)&#x3D;1$。</p><p>有 $q$ 次操作，每次操作给出 $i,x$ 表示 $a_i\gets a_i+x$。每次操作后求出最大的 $r-l+1$，满足 $a$ 的子串 $a_l,a_{l+1},\dots,a_r$ 是好的。 </p><hr><p>多测，$1\leq t\leq 10^4$。</p><p>$1\leq n,q,\sum n,\sum q\leq 10^5$，$0\leq a_i\leq n$，$1\leq i,x\leq n$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>不难发现 $\operatorname{mex}(b)-(\operatorname{OR}\limits_{i&#x3D;1}^m b_i)&#x3D;1$ 等价于存在一个 $k$ 满足 $[0,2^k)$ 间的数都在 $b$ 出现过且 $b$ 只包含 $[0,2^k)$ 间的数。</p><p>$k$ 的可选值很少，只有 $\mathcal O(\log n)$ 种。不妨枚举这个 $k$。</p><p>考虑把 $a_i\gt k$ 的位置看做断点。对于每个连线段我们判断这一段是不是有 $2^k$ 种不同的值即可。</p><p>观察到操作的数<strong>一定是正数</strong>。$a_i$ 在过程中单调不降。也就是 $a_i$ 只可能新成为断点。</p><p>听说可以直接启发式分裂，但是我不太会这个东西。那就把这个改成启发式合并。</p><p>把操作离线下来倒着操作，变成了每个 $a_i$ 只可能从断点转成非断点，也就是拼接左右两边的连续段。</p><p>这是好做的，并查集维护『连续段』、『连续段的左右端点编号』、『连续段内的元素种类及出现次数』。前两个是好维护的，第三个开一个 <code>std::map</code> 维护，合并的时候启发式合并 <code>std::map</code>。</p><p>由于一些点可能作为段内『关键点』，即修改之后就没有 $2^k$ 种元素了，再使用 <code>std::multiset</code> 维护每个合法连续段的答案。在并查集合并的时候，同步删除旧集合答案或添加新集合答案。答案就是 <code>std::multiset</code> 内的最大值。</p><p>时间复杂度 $\mathcal O(n\log^3 n)$。可以使用 <code>std::unordered_map</code> 且使用 <code>reserve</code> 等操作保证 umap 的复杂度。将复杂度降到 $\mathcal O(n\log^2 n)$。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://codeforces.com/contest/2049/submission/298442555">https://codeforces.com/contest/2049/submission/298442555</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span></span><span class="function"></span>&#123;    <span class="type">static</span> <span class="type">int</span> stk[<span class="number">30</span>];    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;    <span class="type">int</span> top = <span class="number">0</span>;    <span class="keyword">do</span>    &#123;        stk[top++] = x % <span class="number">10</span>, x /= <span class="number">10</span>;    &#125; <span class="keyword">while</span> (x);    <span class="keyword">while</span> (top)        <span class="built_in">putchar</span>(stk[--top] + <span class="string">&#x27;0&#x27;</span>);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x, <span class="type">char</span> lastChar)</span> </span>&#123; <span class="built_in">write</span>(x), <span class="built_in">putchar</span>(lastChar); &#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">min</span>(x, y); &#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">max</span>(x, y); &#125;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n, Q;    <span class="built_in">read</span>(n, Q);    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;    vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; <span class="built_in">q</span>(Q + <span class="number">1</span>);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">read</span>(a[i]);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)        <span class="built_in">read</span>(q[i][<span class="number">0</span>], q[i][<span class="number">1</span>]);    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(Q + <span class="number">1</span>)</span></span>;    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">30</span>; k++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> _ = <span class="number">1</span>; _ &lt;= Q; _++)            a[q[_][<span class="number">0</span>]] += q[_][<span class="number">1</span>];        vector&lt;map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">mp</span>(n + <span class="number">1</span>);        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fa</span><span class="params">(n + <span class="number">1</span>)</span></span>;        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(n + <span class="number">1</span>)</span></span>;        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">R</span><span class="params">(n + <span class="number">1</span>)</span></span>;        <span class="keyword">auto</span> F = [&amp;](<span class="keyword">auto</span> self, <span class="type">int</span> u) -&gt; <span class="type">int</span>        &#123; <span class="keyword">return</span> fa[u] ^ u ? fa[u] = <span class="built_in">self</span>(self, fa[u]) : u; &#125;;        multiset&lt;<span class="type">int</span>&gt; s;        s.<span class="built_in">insert</span>(<span class="number">0</span>);        <span class="keyword">auto</span> U = [&amp;](<span class="type">int</span> u, <span class="type">int</span> v)        &#123;            u = <span class="built_in">F</span>(F, u);            v = <span class="built_in">F</span>(F, v);            <span class="keyword">if</span> (u == v)                <span class="keyword">return</span>;            <span class="keyword">if</span> (mp[u].<span class="built_in">size</span>() &gt; mp[v].<span class="built_in">size</span>())                <span class="built_in">swap</span>(u, v);            <span class="keyword">if</span> (mp[v].<span class="built_in">size</span>() == (<span class="number">1</span> &lt;&lt; k))                s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(R[v] - L[v] + <span class="number">1</span>));            <span class="keyword">if</span> (mp[u].<span class="built_in">size</span>() == (<span class="number">1</span> &lt;&lt; k))                s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(R[u] - L[u] + <span class="number">1</span>));            fa[u] = v;            <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : mp[u])                mp[v][x] += y;            mp[u].<span class="built_in">clear</span>();            <span class="built_in">chkmn</span>(L[v], L[u]);            <span class="built_in">chkmx</span>(R[v], R[u]);            <span class="keyword">if</span> (mp[v].<span class="built_in">size</span>() == (<span class="number">1</span> &lt;&lt; k))                s.<span class="built_in">insert</span>(R[v] - L[v] + <span class="number">1</span>);        &#125;;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        &#123;            fa[i] = L[i] = R[i] = i;            <span class="keyword">if</span> (a[i] &lt; (<span class="number">1</span> &lt;&lt; k))            &#123;                <span class="keyword">if</span> (!k)                    s.<span class="built_in">insert</span>(<span class="number">1</span>);                mp[i][a[i]] = <span class="number">1</span>;                <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; a[i - <span class="number">1</span>] &lt; (<span class="number">1</span> &lt;&lt; k))                    <span class="built_in">U</span>(i - <span class="number">1</span>, i);            &#125;        &#125;        <span class="keyword">for</span> (<span class="type">int</span> _ = Q; _ &gt;= <span class="number">1</span>; _--)        &#123;            <span class="built_in">chkmx</span>(ans[_], *--s.<span class="built_in">end</span>());            <span class="keyword">auto</span> [p, x] = q[_];            a[p] -= x;            <span class="keyword">if</span> (_ == <span class="number">1</span> || a[p] &gt;= (<span class="number">1</span> &lt;&lt; k))                <span class="keyword">continue</span>;            <span class="type">int</span> q = <span class="built_in">F</span>(F, p);            <span class="keyword">if</span> (a[p] + x &lt; (<span class="number">1</span> &lt;&lt; k))            &#123;                <span class="keyword">if</span> (!--mp[q][a[p] + x])                &#123;                    <span class="keyword">if</span> (mp[q].<span class="built_in">size</span>() == (<span class="number">1</span> &lt;&lt; k))                        s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(R[q] - L[q] + <span class="number">1</span>));                    mp[q].<span class="built_in">erase</span>(a[p] + x);                &#125;            &#125;            mp[q][a[p]]++;            <span class="keyword">if</span> (mp[q].<span class="built_in">size</span>() == (<span class="number">1</span> &lt;&lt; k) &amp;&amp; mp[q][a[p]] == <span class="number">1</span>)                s.<span class="built_in">insert</span>(R[q] - L[q] + <span class="number">1</span>);            <span class="keyword">if</span> (p &gt; <span class="number">1</span> &amp;&amp; a[p - <span class="number">1</span>] &lt; (<span class="number">1</span> &lt;&lt; k))                <span class="built_in">U</span>(p - <span class="number">1</span>, p);            <span class="keyword">if</span> (p &lt; n &amp;&amp; a[p + <span class="number">1</span>] &lt; (<span class="number">1</span> &lt;&lt; k))                <span class="built_in">U</span>(p + <span class="number">1</span>, p);        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)        <span class="built_in">write</span>(ans[i], <span class="string">&#x27;\n&#x27;</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> t;    cin &gt;&gt; t;    <span class="keyword">while</span> (t--)        <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF2051 做题笔记</title>
      <link href="/archives/CF2051/"/>
      <url>/archives/CF2051/</url>
      
        <content type="html"><![CDATA[<p>我觉得这场 Div.3 难爆了。</p><h1 id="A-Preparing-for-the-Olympiad"><a href="#A-Preparing-for-the-Olympiad" class="headerlink" title="A. Preparing for the Olympiad"></a>A. Preparing for the Olympiad</h1><p>考虑<strong>贪心</strong>。对于所有的 $a_i\geq b_{i+1}$，选上之后答案不劣。不会让自己比 Stereocarp 少做题。$a_n$ 必选，因为 Stereocarp 第二天就已经过了期限了。对所有的 $a_i\geq b_{i+1}$ 的 $a_i$ 求和，再加上 $a_n$ 即为答案。</p><p>好吧我也不知道为什么 Div.3 的 A 这么难。</p><p><a href="https://codeforces.com/contest/2051/submission/297813124">https://codeforces.com/contest/2051/submission/297813124</a></p><h1 id="B-Journey"><a href="#B-Journey" class="headerlink" title="B. Journey"></a>B. Journey</h1><p>数据范围如此大考虑 $\mathcal O(1)$ 的<strong>数学</strong>做法。</p><p>先算出需要的周期个数是 $\lfloor\frac{n}{a+b+c}\rfloor$。则 $\lfloor\frac{n}{a+b+c}\rfloor\times 3$ 天是周期内的答案。之后考虑 $n\bmod (a+b+c)$ 也就是剩余路程的大小。自己模拟这个周期的跑步流程。</p><p>答案是 $\lfloor\frac{n}{a+b+c}\rfloor\times 3+[n\bmod (a+b+c)\gt 0]+[n\bmod (a+b+c)-a\gt 0]+[n\bmod (a+b+c)-a-b\gt 0]$。</p><p><a href="https://codeforces.com/contest/2051/submission/297815421">https://codeforces.com/contest/2051/submission/297815421</a></p><h1 id="C-Preparing-for-the-Exam"><a href="#C-Preparing-for-the-Exam" class="headerlink" title="C. Preparing for the Exam"></a>C. Preparing for the Exam</h1><p><strong>分类讨论</strong> $k$ 和 $n$ 的关系。</p><p>答案全 $0$ 和全 $1$ 可以先特判掉。全 $0$ 即 $k\leq n-2$，全 $1$ 即 $k&#x3D;n$。</p><p>除了这两种只有 $k&#x3D;n-1$ 的情况了，我们求出他不会的那一门，可以直接开桶记录，或者算 $x&#x3D;(\bigoplus\limits_{i&#x3D;1}^n i )\oplus (\bigoplus\limits_{i&#x3D;1}^k q_i )$。由于异或的性质我们可以知道最后答案就是遗失的那个数。</p><p>对于 $m$ 个询问，答案为 $[x&#x3D;a_i]$。</p><p><a href="https://codeforces.com/contest/2051/submission/297822232">https://codeforces.com/contest/2051/submission/297822232</a></p><h1 id="D-Counting-Pairs"><a href="#D-Counting-Pairs" class="headerlink" title="D. Counting Pairs"></a>D. Counting Pairs</h1><p>枚举一个 $a_i$，设 $s&#x3D;\sum\limits_{i&#x3D;1}^n a_i$，那么我们就是要找 $a_j$ 的数量满足 $x \leq s - a_j \leq y$，移项得到 $s - y \leq a_j \leq s - x$。</p><p>把数组复制一份一样的 $b$ 进行<strong>排序</strong>，通过<strong>二分</strong>求出满足条件的 $s - y \leq b_j \leq s - x$ 的 $j$ 的范围。那么 $a_i$ 和这些 $b_j$ 都可以满足条件。如果 $b_j$ 里包含了 $a_i$ 要减掉一的贡献。</p><p>这里计算的是无序对的数量，有序对数量除以二即可。</p><p><a href="https://codeforces.com/contest/2051/submission/297830381">https://codeforces.com/contest/2051/submission/297830381</a></p><h1 id="E-Best-Price"><a href="#E-Best-Price" class="headerlink" title="E. Best Price"></a>E. Best Price</h1><p>一个发现是，<strong>单价只可能在 $a_i$ 和 $b_i$ 这 $2n$ 个数中产生</strong>。</p><p>因为 $a_i$ 和 $b_i$ 是一个能接受的最大程度，我们要尽可能多地压榨（？）顾客。</p><p>将 $a,b$ 分别<strong>排序</strong>。设目前枚举的单价是 $c$，通过<strong>二分</strong>找到 $\geq c$ 的 $b_i$ 的个数 $B$。那么这些人就是<strong>可能</strong>会给出差评但是一定会买的人数。</p><p>剩下的人不可能买了，考虑这些<strong>可能</strong>给出差评的人是否会给出好评。好评同理，$\geq c$ 的 $a_i$ 的个数 $A$ 就是<strong>一定</strong>给出好评并且购买的人。如果 $B-A\leq k$ 说明这个单价是合理的。$c\times B$ 即为这个单价会购买的人产生的总花费。<strong>枚举</strong>所有的 $c$ 依次算出 $A,B$，如果 $B-A\leq k$ 则对 $c\times B$ 取 $\max$ 即可。</p><p><a href="https://codeforces.com/contest/2051/submission/297848639">https://codeforces.com/contest/2051/submission/297848639</a></p><h1 id="F-Joker"><a href="#F-Joker" class="headerlink" title="F. Joker"></a>F. Joker</h1><p>本场最后过的这题&#x2F;xk</p><p><strong>实现。</strong></p><p>维护集合 $pos$ 表示目前 Joker 可能处在的位置的集合。</p><p>每次操作第 $x$ 个位置就是考虑哪些位置可能前移，哪些位置可能后移，哪些位置可能被新加入。</p><p>设有 $y\in pos$，如果 $y\lt x$ 那么 $y+1$ 可能成为新的答案（把 $x$ 位置的卡牌放到第一个）；如果 $y\gt x$ 那么 $y-1$ 可能成为新的答案（把 $x$ 位置的卡牌放到最后一个）；如果有 $y&#x3D;x$ 那么先从集合中删去 $y$，把 $1$ 和 $n$ 添加进来。</p><p>直接模拟这个过程 TLE on 8。详见 <a href="https://codeforces.com/contest/2051/submission/297931501">https://codeforces.com/contest/2051/submission/297931501</a>。</p><p>分析这个做法的问题，就是一个位置可能本来就在集合里，但是被插进去太多次了。</p><p>我们维护两个<strong>可能成为答案</strong>的集合。分别表示通过 $y+1$ 成为答案或者通过 $y-1$ 成为答案。每次操作在集合中二分出这些位置，把它们全插到 $pos$ 里。每次往 $pos$ 里新插入的时候，判断是否有新的元素可能成为答案。删除的时候判断它是否有机会再次成为答案。</p><p><a href="https://codeforces.com/contest/2051/submission/297945489">https://codeforces.com/contest/2051/submission/297945489</a></p><p><a href="https://codeforces.com/contest/2051/submission/297946569">https://codeforces.com/contest/2051/submission/297946569</a></p><p><a href="https://codeforces.com/contest/2051/submission/297947497">https://codeforces.com/contest/2051/submission/297947497</a></p><p>上面是三发不同的初始和加了卡常的版本。</p><h1 id="G-Snakes"><a href="#G-Snakes" class="headerlink" title="G. Snakes"></a>G. Snakes</h1><p>抽象题意毁我青春。</p><p>这个数据范围很诱人啊&#x2F;se</p><p>这个数据范围无非就是往 $\mathcal O(nq)$ 或者 $\mathcal O(2^n)$ 什么复杂度上想。</p><p><del>但是如果复杂度是前者为什么不开 $n\leq 3000$，$q\leq 3000$。（x）</del></p><p>但是稍微想一下可以发现，如果我们知道的是 $n$ 条蛇的初始顺序，我们可以在 $\mathcal O(nq)$ 的时间求出这一组解的对应答案。但问题是我们没法枚举所有可能的初始位置。</p><p>但是这可以启发我们，我们可以先对所有的蛇的对，<strong>预处理</strong>出 $a_{i,j}$ 表示：如果 $i$ 蛇在 $1$，则 $j$ 蛇的初始位置最早在 $a_{i,j}$ 才合法。</p><p>这个位置是相对的，也就是如果蛇 $i$ 在 $x$，蛇 $j$ 最早在 $x+a_{i,j}-1$ 才合法。</p><p>考虑怎么处理这个 $a_{i,j}$，有两种做法。</p><p>一种是<strong>二分答案</strong>，我一开始写的这个。观察到这个是单调的，直接二分然后模拟操作进行比较。如果有相交即为不合法。这里如果写的丑一点就会 TLE。丑一点的做法，指的是把 $q$ 次操作都过一遍。这样子复杂度是 $\mathcal O(n^2q\log V)$ 的。很难通过。</p><p>改的好一点就是你把每条蛇对应的操作存下来，然后<strong>归并</strong>这两条蛇。复杂度是 $\mathcal O(nq\log V)$。</p><p>这里 $V$ 最无脑的取法就是 $10^9$。稍微分析一下发现其实 $\mathcal O(q)$ 的范围就行了。常数可以再小一倍。</p><p>还有一种是，发现这个二分答案完全不必要。直接归并两条蛇的时候，算一下 $j$ 蛇的 $L$ 和 $i$ 蛇的 $R$ 的距离，取 $\max$。还是一样，存操作然后归并的话复杂度是 $\mathcal O(nq)$，把所有操作都过一遍是 $\mathcal O(n^2q)$。</p><p>预处理 $a_{i,j}$ 之后直接套一个<strong>状压 DP</strong> 就行了。$f_{S,k}$ 表示目前选出来集合为 $S$，最后一个选到的是 $k$，此时的 $k$ 的最小开头。</p><p>注意求的内容不是最小开头是最小的覆盖位置，所有 $\operatorname{popcount}(S)&#x3D;n$ 的 DP 值要再加上一个最后的长度。</p><p><a href="https://codeforces.com/contest/2051/submission/297903050">https://codeforces.com/contest/2051/submission/297903050</a></p><p><a href="https://codeforces.com/contest/2051/submission/297908995">https://codeforces.com/contest/2051/submission/297908995</a></p><p>以上两份分别是归并二分答案和归并计算答案的两个版本。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[游记] NOIP 2024 游记</title>
      <link href="/archives/NOIP2024/"/>
      <url>/archives/NOIP2024/</url>
      
        <content type="html"><![CDATA[<h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day -3"></a>Day -3</h1><p>晚上 hb 突然找了 KingPowers 让他组模拟赛。原来赛前两天也是可以有模拟的！！！</p><p>KingPowers 看了发现是两个 NOI 模拟和两个省选模拟拼起来的。啊？</p><p>偷偷拿到了题面。Ivan 晚上就把 T1 过了。</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h1><p>八点十分起来。九点不到到的世贸，晚了半小时开模拟。</p><p>T1 真是绝世无敌奶龙题。。。。。。。。你需要对 24 个题做讨论。。。。。。。。。。。。。。</p><p>尝试翻转序列和乘上 $-1$ 等操作。最后优化到了 $8$ 个 case。要对 $8$ 个 case 写分讨做题，无敌了。</p><p>发现其中 $3$ 个 case 模拟赛之前放过，我当时打不出正解刚好打了 $\mathcal O(n^2)$ 部分分。直接写上去过了 3 个。自己又乱写 4 个，还剩 1 个 <code>2413</code>。发现可以通过计算 <code>?41?</code> 和 <code>3412</code> 容斥掉。写了一会儿过了。</p><p>暴力还挂了，笑。改了改过拍了。事实上也过了。</p><p>这题真无敌了，明年常外小朋友模拟赛我绝对把这个题放进去。我模拟场上写了 7kb。</p><p>啥，hb 又找 KingPowers 测题？但 KingPowers 在回家的火车上。这下成为群友的免费劳动力了。测出来 T4 没人得分，结果是文件夹里有两份数据，一份不知道是什么一份是正常数据。无敌了。</p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>我忘了干啥了。看了看板子摆了一会儿。</p><p>晚上爸妈来南京带我去吃了顿铁板烧。</p><p>咋都在面基，羡慕了。</p><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>好像是 6 点 50 起床的。</p><p>Anny 一大早问我是不是都到了，然而我刚睁眼吃早饭（）</p><p>喝了点粥就出发了。忘了啥时候到的了，反正我家离 nfls 很近。</p><p>一下车就看见一只 zhuzhu2891 和一只 hyman00。边 rua 我边说这是高贵的洛谷管理员。</p><p>蹭蹭 zhuzhu2891 和 hyman00，让他俩把 AK 后溢出的分数给我&#x2F;tyt</p><p>小 Syx 好像要找我面基但我没看到他。</p><p>进考场了。我忘记把身份证带进去了。难绷。查我信息的时候我还出考场去拿。</p><p>进去之后还是照常写个拍子和快读，内容写的线段树 1。但是很遗憾这场我没能用上线段树板子。</p><p>写完之后观察了下发的未解压的 down。创建了对应的文件，写了个 freopen。</p><p>我擦嘞，traverse 有 12 个样例？？？诶不是哥们怎么没有 traverse3.in？？？旁边老哥也发现了。笑死了。</p><p>喜报，08:33 才下发了正常的可以解压的 data.zip 和 noip.pdf。</p><p>开题开题。</p><p>T1 我猜是排序题。我测，过不去样例？？？完蛋了，我不会啊。</p><p>不可能，noip t1 我还不至于做不出来！！！重新读了一遍发现我没读错题。这下倒闭了。哦，直接贪心好像就行了。写一些。九点的时候过掉了。</p><p>T2 好像直接容斥就对了，写一发。大样例 wa 飞了。寄了，调不出来。此时距离我写完 T1 已经过了一个多小时了。我不能又要重现去年悲剧吧。</p><p>回去开 T3 T4。T3 不想读题了，看 T4。$\mathcal O(qn\log n+n\log^2 n)$ 是简单的。然后这个大概还能过掉特殊性质 B。32 有了。回去开 T2。</p><p>改了一会儿发现大样例 2 我只 wa 1 个，大样例 3 炸飞了。恰巧我看过大样例 2 成分，都是 $v&#x3D;2$。说明我少乘了一个 $v-1$。帅。过掉了。</p><p>截止 11:11，期望得分 100+100+0+32。</p><p>我猜 T4 链的特殊性质也是可做的，冲了一会儿不会，输！</p><p>T3 看了一眼一半都在教你怎么 DFS。憋憋。先把特殊性质过了，一个是输出 1 一个是组合数。</p><p>然后写了 $c&#x3D;1,2,3$ 的 case。发现 $k&#x3D;1$ 我不会。开摆。</p><p>期望得分 100+100+28+32。</p><p>然后我就一直反复在 T4 性质 A 和 T3 $k&#x3D;1$ 横跳想题，一个都没冲出来。</p><p>260 遗憾离场。</p><p>其实也不算遗憾？我本来今天就是对着去年的 D 线（250）冲的。只要我自信，我就是 D&#x2F;kuk</p><p>Anny 暴力拼满了，100+100+40+64。磕头。</p><p>我没测我 $n&#x3D;5\times 10^5$ 的时候的速度，B 性质可能有点完蛋。但我不太觉得会跑很慢啊，理论复杂度才 $10^8$。自信即巅峰。</p><p>出考场看群发现都被 T1 创了。</p><p>但是我走出考场听见全在讨论 T3 T4，都说自己过了。不是这两题这么简单？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？我不信啊？？？？？？？？？？？？？？？？？？？？？？？？都什么神人啊？？？？？？？？？？？？？？？？？？？？这里不是初中生考点吗？？？？？？？？？？？？？？？？？？</p><p>哎哟自闭了。</p><p>看 Daniel_lele 发的 CandyBar 的聊天记录说队线 348。感觉很遥远，要多过一个题再多打点暴力。</p><p>JS 好像 B3 稳了，一车 AK。不过好像和我没啥关系，我又不是正式选手&#x2F;hanx</p><p>回常州待两天，问了老秦可以去常外玩，好耶。大家等我 qwq！</p><h1 id="Day-998244353"><a href="#Day-998244353" class="headerlink" title="Day 998244353"></a>Day 998244353</h1><p>洛谷专栏倒闭了，我整理博客的时候发现这篇文章，似乎没有更新后续。</p><p>后续就是我 T3 写了个不符合题意的搜子过样例了。也没有发现 T3 $k&#x3D;1$ 其实很简单，倒闭了，大众分都没打到。</p>]]></content>
      
      
      <categories>
          
          <category> TravelNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[游记] THUPC 2025 游记</title>
      <link href="/archives/THUPC2025/"/>
      <url>/archives/THUPC2025/</url>
      
        <content type="html"><![CDATA[<h1 id="Day-1e9-7"><a href="#Day-1e9-7" class="headerlink" title="Day -(1e9 + 7)"></a>Day -(1e9 + 7)</h1><p>注册了 THUPC 2025 的账号。加了 happybob 的团队。</p><p>其实早就约好组队了。但是几场 CF 的 ICPC 赛制比赛都没以这个队伍的名义参加。不管了。</p><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>早上十点钟被叫起床了。吃了点东西去世贸。和队友连麦打。</p><p>牛魔的怎么还有一分钟有人喊开了开了。蓝的盆。</p><p>随机开题。</p><p>开场看了眼 M，打了个 Python 最后交一个 <code>print(83)</code>。48 秒过题，此时 rk.12，和队伍编号一样（</p><p>然后我们就在随机开题，我看了眼 C 觉得结论是至多一轮游戏，happybob 老师写了一发，WA 了。我看出 happybob 老师的码在多测 $n$ 递减的时候会 WA。改了一下还是挂了。原来结论是两次游戏，我一开始写了一大堆讨论，最后改了个还算好写的二分答案。在我也不知道啥时候终于是过了。</p><p>期间队友过了一车题，我过完 C 一共过了 5 个&#x2F;lh</p><p>然后我看 D 好像是可做的，自定义一下排序然后直接模拟是不是就对了。怎么 TLE 了，原来是我没取模，竟然还过样例了。</p><p>然后我就在 B 和 H 之间横跳，happybob 老师交了 A 但是 WA 了，好像说做法有问题。但我 B 和 H 都不会&#x2F;ll</p><p>摆之。</p><p>最后 7 个题，世贸垫底队伍。</p>]]></content>
      
      
      <categories>
          
          <category> TravelNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 2024 ICPC 台中 区域赛 游记 &amp; 题解 | Online Mirror</title>
      <link href="/archives/ICPC2024RegionalTaichung/"/>
      <url>/archives/ICPC2024RegionalTaichung/</url>
      
        <content type="html"><![CDATA[<blockquote><p>奶龙击败贝利亚，我纯躺赢 Rank.8。</p></blockquote><p>本场比赛可以在 <a href="https://codeforces.com/contest/2041">2024 ICPC Asia Taichung Regional Contest (Unrated, Online Mirror, ICPC Rules, Preferably Teams)</a> 参与。是 台中区域赛 的镜像赛。</p><p>我的队友分别是 <a href="/usrr/305891">夜明</a> 和 <a href="/user/447479">IvanZhang2009</a>。</p><h1 id="游记"><a href="#游记" class="headerlink" title="游记"></a>游记</h1><p>本来想单挑的，但是大家都组了队带队友来世贸打，夜明 老师也想给自己找个队友，就拉了我和 ivan 打。</p><p>我本来是一个大号两个小号组了一个队叫『我是奶龙』，加了新成员就还是叫『我是奶龙』了。</p><p>这个队名是我在上周一上课的时候偷摸打 <a href="https://codeforces.com/contest/2038">2024-2025 ICPC, NERC, Southern and Volga Russian Regional Contest (Unrated, Online Mirror, ICPC Rules, Preferably Teams)</a> 的时候起的。</p><p>值得一提的是 <a href="/user/530180">KingPowers</a> + <a href="/user/304524">崔化博</a> + <a href="/user/https://www.luogu.com.cn/user/503792">Svemit</a> 的队伍名称是『我是贝利亚』，是看了我们的队名临时改的。</p><p>那么，接下来是，奶龙大战贝利亚的时间。</p><p>三个人临时组的队一点策略没有，反正就随机开题。我先随机开了 A,B,C,E,M，挑了个题面最短的 A 读了一下，发现是个签到。00:00:46 的时候提交了 A 题。结果我没测样例挂了。还好 WA on 1 不罚时。00:01:04 的时候顺利过掉 A。</p><p>接下来随便看看发现 E 似乎也是简单题，已经有队伍过了。读了一下发现不难，一定在 $n&#x3D;3$ 有解，直接输出就行。00:06:58 过掉了 E。</p><p>ivan 先开的 C，在 00:08:44 的时候过掉了 C。夜明 在看 B，00:14:01 的时候也过掉了。</p><p>此时我们光速 4 题。</p><p>队友写完 C,B 的时候我看到有队伍过了 D，读了一下发现是搜索题，我上手几分钟就写完了。00:17:55 过了 D。</p><p>此时光速 5 题！</p><p>在队友写 C,B 期间我读了 H，把题意报了然后我就润了去写 D 了。Ivan 听完就会了，00:33:18 的时候提交了一发 WA on 3 发现是两行写反了。00:34:37 的时候过掉了 H。</p><p>夜明在手玩 M。他好像意识到了 M 的关键性质，00:43:55 过掉了 M。</p><p>7 题。靠着巨大的手速和罚时优势成为了 rk.1。</p><p>接下来就要靠我们自己开题了。</p><p>我随机读了一点，发现 I 可能是个简单题。但是不是很好写，我一度以为自己假了。但是世贸的别的队伍『我是贝利亚』和『Zhang BlgorixthW』都在开 I。简单想了一下好像就是离线一下就做完了。</p><p>上了个厕所冷静一下开写。我感觉还有点难写啊？？？</p><p>写了一半发现排序方式优先取长度更大的，我看成长度更小的了。本来一个 Trie 上面 BFS 就解决的事情还得补点东西。</p><p>此时我像个 dinner 一样，愣是没想到长度就是 Trie 上的深度，我还把字符串拎出来在排序的时候判长度处理了。排序部分写了一坨。</p><p>然后我就死活不知道自己挂哪里了。看了一眼数据范围，$id$ 的范围是 $[0,n]$。6。还没有保证编号连续，我开了个 vector 用 pair 存信息排序。</p><p>然后就莫名其妙 RE on 5 了。我觉得是字典树上 set 的删除问题，但是题目保证合法，为了验证我甚至我还在插入删除部分写了一个不合法就 exit(0) 的程序，发现没有异常，那说明不是这一段的问题。</p><p>查了半天我发现我从输入的 if 分支拷贝到离线的 if 分支的时候，由于我不需要处理 delete 操作，所以我把这个 if 删了，但是我判断操作最后一项写的是 else 不是 else if。导致我删除这个分支会让 delete 操作进入不该进入的分支执行。</p><p>这个真无敌了，谁看得出来啊？？？</p><p>改完就过了，这题纯纯我的锅，调了这么久还吃了一堆罚时。</p><p>02:05:37 的时候过掉了 I。此时排名十名开外了。</p><p>过掉之后我看 ivan 在贺 Miller Rabin。他说是判素数用的，然后说 F 自己复杂度是错的，不会求 $[l,r],r-l+1\leq 10^5$ 的素数。但我记得我入门线性筛的时候做过这个模板啊？洛谷的 <a href="/problem/P1835">P1835 素数密度</a>。我改了个线性筛上去，结果 TLE on 3 了。</p><p>然后发现记忆化搜索部分有一段可以预处理掉的二分，此时 ivan 已经开摆了，我帮他加了线性筛又改了预处理。结果还是 TLE 啊？测了一下本地发现线性筛部分是瓶颈，因为我在线性筛途中处理了素数，每次都做了一遍线性筛，测了一下线性筛耗时巨大，干脆这一部分也预处理了。把求区间内素数的再单独拿出来每组 case 算一下就行了。改了改过了，极限数据本地 500ms，稳了，交一发，过了，此时是 02:50:04。</p><p>在我改 F 期间夜明老师写了很久的 J。02:33:15 过掉了。此时的我还不知道这个 J 有多难，看榜发现 9 题和 10 题的 gap 就在这个 J 上。此时我们是 rk.5，和 <a href="/user/180242">kradcigam</a> 捆包队贴贴了。捆包队以罚时优势领先我们。</p><p>ivan 说看了 G 很久不会，我看了 L 是计算几何，我们三个都不会，N 我很早就开了，报了题意都不会。此时 <a href="/user/483824">MatrixGroup</a> 和 <a href="/user/515385">zhuzhu2891</a> 和我们罚时相同，他们过的是 K 没过 J。ivan 去吃饭了，我读了 K 题意发现很难，也摆了，和 <a href="/user/359270">是青白呀</a> 点了个外卖开吃。</p><p>吃着吃着我点开了好友提交界面，发现捆包队过了 K。我看了看榜不动了，应该是封榜了。诶不对，封榜了可以通过看好友提交记录然后知道别的队交题情况？？？逆天。</p><p>最后『我是奶龙』队以 10 题 851 罚时的成绩与 『shengqile.cpp』 队一起获得了 rk.8 的成绩。</p><p>是不是差在了我 A 不测样例直接交导致浪费了一分钟啊（？</p><p>不过奶龙队击败了贝利亚队，贝利亚队没过 J。高下立判，奶龙统治世界。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>无敌了，我写了俩小时然后没保存。小波发现了专栏编辑器的自动保存出 bug 了。</p><h2 id="A-The-Bento-Box-Adventure"><a href="#A-The-Bento-Box-Adventure" class="headerlink" title="A. The Bento Box Adventure"></a>A. The Bento Box Adventure</h2><p>给定 $4$ 个整数 $a,b,c,d$。求 ${1,2,3,4,5}$ 中没出现的那个数。</p><p>$1\leq a,b,c,d\leq 5$。保证数两两不同。</p><hr><p>根据异或的性质 $x\oplus x&#x3D;0,0\oplus x&#x3D;x$。我们用把这 $4$ 个数和 ${1,2,3,4,5}$ 都异或起来就是答案。</p><p>也就是输出 $1\oplus 2\oplus 3\oplus 4\oplus 5\oplus a\oplus b\oplus c\oplus d$。</p><p>推荐相似题目：<a href="/problem/P1469">P1469 找筷子</a>。</p><p><a href="https://codeforces.com/contest/2041/submission/293494235">https://codeforces.com/contest/2041/submission/293494235</a></p><h2 id="B-Bowling-Frame"><a href="#B-Bowling-Frame" class="headerlink" title="B. Bowling Frame"></a>B. Bowling Frame</h2><p>给定 $w$ 个白点和 $b$ 个黑点，拼三角形，要求三角形第 $i$ 行有 $i$ 个<strong>同色</strong>的点，最大化三角形行数。</p><p>多测，$1\leq t\leq 100$。</p><p>$0\leq w,b\leq 10^9$。</p><hr><p>赛时看了喜提第一眼不会。丢给队友去写别的题了。</p><p>结论题。</p><p>定义 $S(n)&#x3D;\frac{n(n+1)}{2}$ 即行数为 $n$ 的三角形需要的点数，不难通过等差数列求和推出。</p><p>答案即为最大的 $n$ 满足 $S(n)\leq w+b$。</p><p>接下来开始证明。首先如果 $w’\leq w,b’\leq b$ 且有 $w’$ 和 $b’$ 就可以组成一个三角形，那么 $w$ 和 $b$ 一定也能组成这么大的三角形。因为可以有剩余。</p><p>所以我们证明恰好等于的情况就可以。。</p><p>数学归纳法证明。</p><p>$n&#x3D;0$ 时，$w,b$ 取任何值都可以拼出大小为 $n$ 的三角形。相当于一个不用就可以了。</p><p>若 $n&#x3D;k$ 时，对于 $w$ 取任意值，$b$ 取任意值，成立，则 $n&#x3D;k+1$ 时，$w$ 取任意值，$b$ 取任意值，也成立。</p><p>考虑新加的第 $k+1$ 行填什么颜色。<strong>只要能填上，就可以化到 $n&#x3D;k$ 时的情况</strong>。</p><p>也就是说我们只需要证明：在拼出行数为 $k$ 的三角形时，此时 $w,b$ 取任何值（满足 $w+b&#x3D;S(k+1)$），他们的的最大值都会比 $k+1$ 大也就是可以拼出第 $k+1$ 行。</p><p>第 $k+1$ 行有 $k+1$ 个点，而 $k+1$ 行的三角形需要 $S(k)$ 个点，较多颜色的那个点<strong>至少</strong>有 $\lceil\frac{S(k+1)}{2}\rceil$ 个。</p><p>证明 $k$ 取任意值都有 $k+1\leq \lceil\frac{S(k+1)}{2}\rceil$ 即可。</p><p><del>仍然可以数学归纳法。</del></p><p>大力拆式子。</p><p>$$<br>\begin{aligned}<br>k+1 &amp;\leq \lceil\dfrac{S(k+1)}{2}\rceil\<br>k+1 &amp;\leq \lceil\dfrac{\frac{(k+1)(k+2)}{2}}{2}\rceil\<br>k+1 &amp;\leq \lfloor\dfrac{\frac{(k+1)(k+2)}{2}+1}{2}\rfloor\<br>2(k+1)&amp;\leq \dfrac{(k+1)(k+2)}{2}+1\<br>4(k+1)&amp;\leq (k+1)(k+2)+2\<br>2(k+1)+2k+2&amp;\leq 2(k+1)+k(k+1)+2\<br>2k&amp;\leq k(k+1)<br>\end{aligned}<br>$$</p><p>这个不等式在 $k&#x3D;0$ 和 $k\geq 1$ 的时候都显然成立。因此 $k+1\leq \lceil\frac{S(k+1)}{2}\rceil$ 就是成立的。</p><p><a href="https://codeforces.com/contest/2041/submission/293495113">https://codeforces.com/contest/2041/submission/293495113</a></p><h2 id="C-Cube"><a href="#C-Cube" class="headerlink" title="C. Cube"></a>C. Cube</h2><p>有 $n\times n\times n$ 的立方体，选 $n$ 个点，使得没有任意两点在同一平面，最小化点权。</p><p>对于点 $(x_1,y_1,z_1)$ 和点 $(x_2,y_2,z_2)$，在同一平面当且仅当 $x_1&#x3D;x_2\lor y_1&#x3D;y_2\lor z_1&#x3D;z_2$。</p><p>$1\leq n\leq 12$，$0\leq a_{i,j,k}\leq 2\times 10^7$</p><hr><p>敢写，敢交。</p><p>限制等价于所有点的 $x,y,z$ 坐标互不相同。</p><p>把 $x$ 互不相同拎出来，改成在 $1$ 到 $n$ 依次选择。</p><p>$n$ 范围很小，考虑状压 DP。</p><p>$f_{i,Sj,Sk}$ 表示 $x$ 坐标选到了 $i$，此时 $y$ 坐标集合为 $Sj$，$z$ 坐标集合为 $Sk$。</p><p>转移枚举合法的集合，枚举不在集合里的数即可。</p><p>看起来这非常的暴力，复杂度粗略一算是 $\mathcal O(2^{2n}n^3)$ 的。理论复杂度 $2\times 10^{10}$。</p><p>但其实精细表示一下，这个运算量其实是 $\sum \limits_{i&#x3D;0}^n \binom{n}{i}^2 (n-i)^2$。当 $n&#x3D;12$ 的时候其实是 $10^8$ 左右的运算量。3s 的时限随便过。</p><p><a href="https://codeforces.com/contest/2041/submission/294597429">https://codeforces.com/contest/2041/submission/294597429</a></p><h2 id="D-Drunken-Maze"><a href="#D-Drunken-Maze" class="headerlink" title="D. Drunken Maze"></a>D. Drunken Maze</h2><p>有 $n\times m$ 的地图，<code>#</code> 表示障碍，<code>.</code> 表示空地，<code>S</code> 表示起点，<code>T</code> 表示终点。要求不能<strong>超过</strong>连续三步走同一方向，不可以通过障碍。起点终点视作一种空地。</p><p>问 <code>S</code> 到 <code>T</code> 的最小步数。无法到达输出 <code>-1</code>。</p><p>$12\leq n\times m\leq 2\times 10^5$，$3\leq n,m\leq 10^4$。</p><hr><p>直接用 $4\times 3\times n\times m$ 的状态数的搜索是可过的。</p><p>$f_{i,j,0&#x2F;1&#x2F;2&#x2F;3,1&#x2F;2&#x2F;3}$，表示这是从什么方向走到 $(i,j)$ 的，这是第几步。</p><p>转移枚举下一步的方向。如果相同并且已经走了三步就无法转移，否则就可以走。如果这个状态之前搜过就跳过。每个状态至多入队一次，更新 $\mathcal O(1)$ 个状态，复杂度是 $\mathcal O(nmAB)$ 的。其中 $A&#x3D;4$ 表示方向的数量，$B&#x3D;3$ 表示约束的步数。</p><p>关于实现：这类约束了 $nm$ 的题，开数组可以使用 vector 或者开局部数组然后清空。一些函数可以写成 lambda 表达式的形式。</p><p><a href="https://codeforces.com/contest/2041/submission/293536077">https://codeforces.com/contest/2041/submission/293536077</a></p><h2 id="E-Beautiful-Array"><a href="#E-Beautiful-Array" class="headerlink" title="E. Beautiful Array"></a>E. Beautiful Array</h2><p>构造序列，满足序列中位数是 $b$，平均数是 $a$。</p><p>平均数：$n$ 个数 $A_i$ 的平均数是 $A_i$ 之和除以 $n$。即 $\dfrac{\sum\limits_{i&#x3D;1}^n A_i}{n}$。</p><p>中位数：$n$ 个数 $A_i$ 排序后，若 $n$ 为奇数则为 $A_{\frac{n+1}{2}}$，否则为 $A_{\frac{n}{2}}$ 和 $A_{\frac{n}{2}+1}$ 的平均数。</p><p>$-100\leq a,b\leq 100$。</p><p>要求构造的答案序列长度在 $[1,10^3]$ 之间，答案序列元素均为绝对值不超过 $10^6$ 的整数。</p><hr><p>考虑能不能用最朴素的构造求出来。$n&#x3D;3$ 的时候不妨令中位数 $A_2&#x3D;b$。然后调整平均数。</p><p>一开始令 $A&#x3D;[b,b,b]$，但是可能不满足条件。</p><p>如果平均数 $\gt a$ 则 $A_{1}$ 减小 $1$。</p><p>如果平均数 $\lt a$ 则 $A_{3}$ 增大 $1$。</p><p>显然这样一定能出解。出解至多需要做 $|3a-3b|$ 次操作。而在本题的数据范围 $|3a-3b|$ 至多为 $600$。</p><p><a href="https://codeforces.com/contest/2041/submission/293511197">https://codeforces.com/contest/2041/submission/293511197</a></p><h1 id="F-Segmentation-Folds"><a href="#F-Segmentation-Folds" class="headerlink" title="F. Segmentation Folds"></a>F. Segmentation Folds</h1><p>给定 $[l,r]$，你需要选择以下操作任一执行：</p><ul><li><p>选择一个最大的 $x(l\lt x\leq r)$ 满足 $l+x$ 是质数，$[l,r]\to [\frac{1}{2}(l+x),r]$。</p></li><li><p>选择一个最小的 $x(l\leq x\lt r)$ 满足 $r+x$ 是质数，$[l,r]\to [l,\frac{1}{2}(r+x)]$。</p></li></ul><p>如果这个区间 $[l,r]$ 无法操作，则称这个区间为一个结束状态。否则继续递归。</p><p>问所有结束状态中，长度最小的有多少个。答案对 $998244353$ 取模。</p><p>多测，$1\leq t\leq 10$。</p><p>$1\leq l\lt r\leq 10^{12}$，$r-l\leq 10^5$。</p><hr><p>为了规避浮点问题，我们把所有区间的 $l,r$ 都乘上 $2$。</p><p>我们首先要把 $[2l,2r]$ 之间的素数都筛出来。我们先预处理到 $\sqrt{2r}$ 的所有质数，然后把这些质数在 $[2l,2r]$ 内的倍数筛出来。具体参见 <a href="https://www.luogu.com.cn/problem/P1835">P1835 素数密度</a>。</p><p>然后大力搜索即可。</p><p>搜索的时候可以通过二分找到第一个和最后一个合法的 $x$。但是这样复杂度多带一个 $\log$。我们把二分的内容拎出去，在预处理完质数之后，枚举所有的情况找到上一个下一个质数。</p><p>搜索的结束状态一定是两个相邻的质数。只有 $\mathcal O(\frac{n}{\log n})$ 个。而每个状态只有 $\mathcal O(\log n)$ 个前驱状态，所以直接搜索甚至不带记忆化的复杂度是 $\mathcal O(n)$ 的。</p><p>总复杂度瓶颈在筛质数的 $\mathcal O(n\log \log n)$。</p><p>代码写的有点丑了，丑在了：</p><blockquote><p>我们把二分的内容拎出去，在预处理完质数之后，枚举所有的情况找到上一个下一个质数。</p></blockquote><p>这一部分。写的是二分，如果写双指针最后复杂度就是 $\mathcal O(n\log \log n)$。这份代码是 $\mathcal O(n\log n)$ 的。 </p><p><a href="https://codeforces.com/contest/2041/submission/294604119">https://codeforces.com/contest/2041/submission/294604119</a></p><h2 id="H-Sheet-Music"><a href="#H-Sheet-Music" class="headerlink" title="H. Sheet Music"></a>H. Sheet Music</h2><p>定义两个序列 $a,b$ 是同一『类型』当且仅当对于所有 $i$，$a_i$ 和 $a_{i+1}$ 的大小关系与 $b_i$ 和 $b_{i+1}$ 的大小关系一致。</p><p>大小关系指：大于，小于，等于。</p><p>给定 $n,k$，求值域在 $[1,k]$ 的长度为 $n$ 的序列有多少个『类型』，答案对 $998244353$ 取模。</p><p>$1\leq n\leq 10^6$，$1\leq k\leq 10^9$。</p><hr><p>等价于对符号序列计数，并且<strong>删去等号后</strong>满足不存在连续的 $k$ 个符号相同。</p><p>设 $f_{i,0&#x2F;1}$ 表示第 $i$ 个位置填大于号或小于号的方案数。</p><p>初值 $f_{0,0}&#x3D;f_{0,1}&#x3D;1$。</p><p>转移为 $f_{i,0}&#x3D;\sum\limits_{j&#x3D;i-k+2}^{i-1} f_{j,1}$，$f_{i,1}$ 的转移同理。</p><p>显然这个式子可以用前缀和优化 DP。</p><p>之后对答案计数。枚举大于小于号序列的长度。等号可以随意插入，长度为 $i$ 的序列，插入方案数为 $\binom{n-1}{i}$，这就是系数。</p><p>答案为 $(\sum\limits_{i&#x3D;0}^{n-1}\binom{n-1}{i}(f_{i,0}+f_{i,1}))-1$。</p><p>最后 $-1$ 是因为第 $0$ 个位置，就是不填符号，大于小于贡献一样，算一个的即可。</p><p><a href="https://codeforces.com/contest/2041/submission/293242222">https://codeforces.com/contest/2041/submission/293242222</a></p><h2 id="I-Auto-Complete"><a href="#I-Auto-Complete" class="headerlink" title="I. Auto Complete"></a>I. Auto Complete</h2><p>你需要维护一个搜索引擎。支持 $n$ 次操作。共 $4$ 种操作。</p><ol><li><code>add id str</code> 给搜索引擎插入编号为 $id$ 的内容为 $str$ 的『备选项』。</li><li><code>delete id</code> 删除编号为 $id$ 的『备选项』。</li><li><code>append str</code> 给搜索框后面继续输入 $str$ 的内容。</li><li><code>backspace cnt</code> 给搜索框后面删除 $cnt$ 个字符。</li></ol><p>每次操作后，你需要输出目前的『最优』的『备选项』。</p><p>『最优』的『备选项』定义为：</p><ol><li>搜索框内容是这个『备选项』的前缀。</li><li>若满足 1 的有多个，选最长的。</li><li>若满足 2 的有多个，选字典序最小的。</li><li>若满足 3 的有多个，选编号最小的。</li></ol><p>$1\leq n\leq 10^6$，$1\leq \sum |str|\leq 2\times 10^6$，$1\leq c\leq 2\times 10^6$。</p><p>保证字符串的字符 ASCII 码范围在 $[33,126]$ 以内。</p><p><code>add</code> 操作的 $id$ 两两不同。</p><p><code>delete</code> 操作的 $id$ 两两不同。</p><p>$id$ 范围在 $[0,n]$ 之间。</p><hr><p>这个前缀很引导我们往字典树上想。前缀就对应着祖先。</p><p>把这些备选项判定拎出来，前缀就对应着必须是祖先，长度对应深度，字典序对应着 DFS 序。</p><p>先离线操作，把所有操作全扔到字典树上。删除操作就是跳若干次父亲，所以需要记录字典树每个节点的父亲编号。</p><p>这里保证操作合法，所以往下走几步就至多往上走几步，跳父亲暴力跳就行了。</p><p>操作离线完就做一次深搜。处理出 DFS 序。</p><p>这个编号不是连续的，范围是 $[0,n]$。处理的时候要小心点。</p><p>字符集大小很大，直接开数组会浪费很多空间，可以用 map 换空间。</p><p>赛时太急了没好好看条件，忘判长度了，最后硬加了一个&#x2F;xk 写的有点丑。</p><p><a href="https://codeforces.com/contest/2041/submission/293614507">https://codeforces.com/contest/2041/submission/293614507</a></p><h2 id="M-Selection-Sort"><a href="#M-Selection-Sort" class="headerlink" title="M. Selection Sort"></a>M. Selection Sort</h2><p>给定长度为 $n$ 的序列 $a$，对长度为 $m$ 的序列使用一次 Alice-Sort 的代价为 $m^2$。</p><pre><code class="highlight cpp"><span class="function"><span class="type">int</span> <span class="title">alice_sort</span><span class="params">(<span class="type">int</span> *s, <span class="type">int</span> n)</span></span>&#123;  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;    <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;      <span class="keyword">if</span>(s[i] &gt; s[j])&#123;        <span class="type">int</span> swap = s[i];        s[i] = s[j];        s[j] = swap;      &#125;    &#125;  &#125;  <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p>有两种操作：</p><p>可以使用 Alice-Sort 对一个前缀排序。</p><p>可以使用 Alice-Sort 对一个后缀排序。</p><p>每种操作<strong>限用一次</strong>。</p><p>问把序列排好序的最小代价。</p><p>$1\leq n\leq 10^6$，$0\leq a_i\lt 2^{31}-1$。</p><hr><p>一共只排两次序，枚举先排前缀还是先排后缀。</p><p>不妨认为先排前缀。枚举前缀需要排序到哪里，然后算出后缀排到哪里。</p><p>重复值有点难搞（其实也不难搞，先处理了后面操作更顺利），我们把这个数组先改成 $[1,n]$ 的排列，相同值越前面的越小。</p><p>枚举前缀排序到了哪里，维护值的连续段。$lst$ 表示值在 $[1,lst]$ 的数都可以归为了。那么 $[lst+1,n]$ 的就是需要重排的。</p><p>$lst$ 可以直接维护。再维护一个小根堆，里面是已经在区间内但是连不起来的元素，$lst$ 每次根据堆里的元素尝试往后扩展。</p><p>但是这有个问题，我们无法判断那些，后缀无需排序的，和我们已经扩展了前缀的，但是没有必要把一些元素加进去排序的。</p><p>先处理第一个，我们找到原数组最后一个不合法（$a_i\neq i$）的位置记作 $r$，那么 $i&#x3D;r$ 的时候不要加上后缀排序的贡献。</p><p>第二个，我们维护<strong>上一个</strong>需要排序的位置，就是无法直接加入的，即堆内有元素，或者 $a_i\neq lst+1$。记这个位置为 $pos$，那么前缀排序到 $i$ 的代价只为 $pos^2$。</p><p>以上是先选前缀排序的做法，先选后缀排序本质一样。代码复制一遍改一改就行了。</p><p><a href="https://codeforces.com/contest/2041/submission/294548198">https://codeforces.com/contest/2041/submission/294548198</a></p><h2 id="N-Railway-Construction"><a href="#N-Railway-Construction" class="headerlink" title="N. Railway Construction"></a>N. Railway Construction</h2><p>有一张 $n$ 个点的完全图，连接 $(u,v)$ 的边边权为 $a_u+a_v$。其中删除了 $m$ 条边。</p><p>你需要回答 $n$ 个问题。第 $i$ 个问题你需要回答，删除 $i$ 号点之后，使剩余节点联通的最小代价。若无法联通输出 <code>-1</code>。<strong>问题互不影响</strong>。</p><p>$2\leq n\leq 10^5$，$0\leq m\leq 10^5$，$1\leq a_i\leq 10^9$，$1\leq u\lt v\leq n$，保证无重边。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] [模拟赛 20241105] CF722F Cyclic Cipher</title>
      <link href="/archives/CF722F/"/>
      <url>/archives/CF722F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定 $n$ 个序列，第 $i$ 个序列长度 $k_i$。保证元素都不超过 $m$。每一秒进行一次循环向左移位，问 $10^{100}$ 秒内，对于所有 $1\leq x\leq m$，回答开头最长连续 $x$ 的长度。</p><p>$1\leq n,m\leq 10^5$，$1\leq k_i\leq 40$，$1\leq \sum k_i \leq 2\times 10^5$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>一个序列，开头是 $x$，等价于一个 $t\equiv b\pmod k$ 形式的方程。两个组合在一起就是 $$\begin{cases}t\equiv b_1\pmod {k_1}\t\equiv b_2\pmod {k_2}\end{cases}$$。</p><p>其实等价于 $k_1x_1+b_1&#x3D;k_2x_2+b_2$ 的方程，$x_1,x_2$ 是否有解。</p><p>移项得到 $k_1x_1-k_2x_2&#x3D;b_2-b_1$，根据裴蜀定理，$ax+by&#x3D;c$ 形式的方程有解，当且仅当 $\gcd(a,b)\mid c$。那么我们就可以做两个序列的合法性判断了。</p><p>考虑双指针对于每个 $l$ 求出最远的 $r$。这里不难发现对于一个固定的 $l$，$r$ 合法则 $r-1$ 一定合法，一个合法连续段的子段是一定合法的。</p><p>双指针每次拓展 $r+1$ 的时候，对于 $[l,r]$ 的限制暴力 check。但是这样会导致我们对一些相同的限制重复 check 导致复杂度其实是错误的。我们对相同 $k$ 的去重 $b$ 即可。合法的 $k$ 一共只有 $40$ 个。那么每次 check 至多对于 $40$ 个限制进行 check。</p><p>复杂度 $\mathcal O(\sum k_i\times k)$。依据实现可能会多带个 $\log$ 用来去重。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://codeforces.com/contest/722/submission/290168515">CF submission 290168515</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span></span><span class="function"></span>&#123;    <span class="type">static</span> <span class="type">int</span> stk[<span class="number">30</span>];    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;    <span class="type">int</span> top = <span class="number">0</span>;    <span class="keyword">do</span>    &#123;        stk[top++] = x % <span class="number">10</span>, x /= <span class="number">10</span>;    &#125; <span class="keyword">while</span> (x);    <span class="keyword">while</span> (top)        <span class="built_in">putchar</span>(stk[--top] + <span class="string">&#x27;0&#x27;</span>);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x, <span class="type">char</span> lastChar)</span> </span>&#123; <span class="built_in">write</span>(x), <span class="built_in">putchar</span>(lastChar); &#125;<span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (!a | !b)        <span class="keyword">return</span> a + b;    <span class="type">int</span> az = __builtin_ctz(a);    <span class="type">int</span> bz = __builtin_ctz(b);    <span class="type">int</span> z = <span class="built_in">min</span>(az, bz);    a &gt;&gt;= az, b &gt;&gt;= bz;    <span class="keyword">while</span> (a ^ b)    &#123;        <span class="type">int</span> diff = b - a;        az = __builtin_ctz(diff);        b = <span class="built_in">min</span>(a, b), a = <span class="built_in">abs</span>(diff) &gt;&gt; az;    &#125;    <span class="keyword">return</span> a &lt;&lt; z;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">max</span>(x, y); &#125;<span class="type">int</span> n, m;vector&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; vec[<span class="number">100020</span>];map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;map&lt;<span class="type">int</span>, array&lt;<span class="type">int</span>, 2&gt;&gt; kb;set&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; s;<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> b)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (!kb.<span class="built_in">count</span>(k))        kb[k] = &#123;b, <span class="number">1</span>&#125;, s.<span class="built_in">insert</span>(&#123;k, b&#125;);    <span class="keyword">else</span>        kb[k][<span class="number">1</span>]++;&#125;<span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> b)</span></span><span class="function"></span>&#123;    kb[k][<span class="number">1</span>]--;    <span class="keyword">if</span> (!kb[k][<span class="number">1</span>])        kb.<span class="built_in">erase</span>(k), s.<span class="built_in">erase</span>(&#123;k, b&#125;);&#125;<span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (l &lt;= r - <span class="number">1</span> &amp;&amp; vec[x][r][<span class="number">0</span>] != vec[x][r - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>)        <span class="keyword">return</span> <span class="number">0</span>;    <span class="keyword">auto</span> [t2, k2, b2] = vec[x][r];    <span class="keyword">if</span> (kb.<span class="built_in">count</span>(k2) &amp;&amp; kb[k2][<span class="number">0</span>] != b2)        <span class="keyword">return</span> <span class="number">0</span>;    <span class="keyword">for</span> (<span class="keyword">auto</span> [k1, b1] : s)    &#123;        <span class="keyword">if</span> ((b1 - b2) % <span class="built_in">gcd</span>(k1, k2))            <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(n, m);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="type">int</span> k;        <span class="built_in">read</span>(k);        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)        &#123;            <span class="type">int</span> x;            <span class="built_in">read</span>(x);            vec[x].<span class="built_in">push_back</span>(&#123;i, k, j&#125;);        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= m; x++)    &#123;        <span class="keyword">if</span> (vec[x].<span class="built_in">empty</span>())        &#123;            <span class="built_in">write</span>(<span class="number">0</span>, <span class="string">&#x27;\n&#x27;</span>);            <span class="keyword">continue</span>;        &#125;        mp.<span class="built_in">clear</span>();        kb.<span class="built_in">clear</span>();        <span class="type">int</span> id = <span class="number">0</span>;        <span class="keyword">for</span> (<span class="keyword">auto</span> [t, k, b] : vec[x])        &#123;            <span class="keyword">if</span> (mp.<span class="built_in">count</span>(k))                <span class="keyword">continue</span>;            mp[k] = ++id;        &#125;        <span class="type">int</span> ans = <span class="number">1</span>;        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>;        s.<span class="built_in">clear</span>();        <span class="keyword">while</span> (l &lt; vec[x].<span class="built_in">size</span>())        &#123;            <span class="keyword">while</span> (r + <span class="number">1</span> &lt; vec[x].<span class="built_in">size</span>() &amp;&amp; <span class="built_in">check</span>(x, l, r + <span class="number">1</span>))                r++, <span class="built_in">chkmx</span>(ans, r - l + <span class="number">1</span>), <span class="built_in">add</span>(vec[x][r][<span class="number">1</span>], vec[x][r][<span class="number">2</span>]);            <span class="built_in">del</span>(vec[x][l][<span class="number">1</span>], vec[x][l][<span class="number">2</span>]), l++;        &#125;        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF2036G Library of Magic</title>
      <link href="/archives/CF2036G/"/>
      <url>/archives/CF2036G/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p><strong>本题是一道 I&#x2F;O 交互题。</strong></p><p>有 $1\sim n$ 的数各 $2$ 个（共 $2n$ 个），现在拿走 $3$ 个互不相同的数（还剩 $2n-3$ 个）。</p><p>你可以进行不超过 $150$ 次的询问 <code>xor l r</code> 表示询问数值大小在 $[l,r]$ 内的数的异或和。找出这 $3$ 个拿走的数之后用 <code>ans a b c</code> 回答这 $3$ 个数。</p><p>$3\leq n\leq 10^{18}$。</p><p>询问要求：询问的 <code>xor l r</code> 需要满足 $1\leq l\leq r\leq n$。如果超过 $150$ 次询问交互库会返回 $-1$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>下文约定 $\oplus$ 表示按位异或。</p><p>先刻画一下这个询问的本质。我们知道了 $x\oplus x&#x3D;0,0\oplus x &#x3D; x$。故两两相同的数会被抵消，那么 <code>xor l r</code> 其实就是在询问<strong>被拿走的 $3$ 个数</strong>，值在 $[l,r]$ 内的数的异或和。</p><p>一个比较朴素的想法是，我们可以直接二分出这个最大的一个和最小的一个，就是找到第一个前缀异或 <code>xor 1 k</code> 不为 $0$，找一个后缀异或 <code>xor k n</code> 不为 $0$ 的值，然后通过整体询问 <code>xor 1 n</code>，异或这个最大最小，求出这个中间值。</p><p>这个做法算是对了一半。考虑什么时候这个二分是错的，就是当 $a\oplus b\oplus c&#x3D;0$ 的时候，此时二分不具有单调性。由于题目保证两两不同，$a\oplus b$ 之类的情况是不可能发生的，只有 $a\oplus b\oplus c&#x3D;0$ 的时候二分没有单调性。</p><p>那不妨对 $a\oplus b\oplus c&#x3D;0$ 的情况单独做。考虑这种情况有什么特殊的性质。这其实是告诉我们，<strong>每个二进制位有偶数个 $1$</strong>。</p><p>那么，最高位不可能是 $3$ 个都为 $0$，一定是 $2$ 个 $1$。我们从大到小枚举这个最高位。即询问形如 <code>xor 1 2^k-1</code> 的操作。如果询问到的异或不为 $0$，就说明最小值就是这个异或。</p><p>找到了最小值，我们可以和上面一样，二分出最大的那个值。二分左边界设为最小值 $+1$ 即可。</p><p>这样的话其实只有一开始的一次 <code>xor 1 n</code> 和两轮 $\log$ 级别的询问。上限是 $121$ 次。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://codeforces.com/contest/2036/submission/289523319">CF submission 289523319</a></p><p>这个 <code>xor_n</code> 函数是我一开始看错题导致的。我以为还要求一个 $1\sim n$ 的数的异或和。iee。略过即可。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="function">ll <span class="title">xor_n</span><span class="params">(ll n)</span></span><span class="function"></span>&#123;    ll t = n &amp; <span class="number">3</span>;    <span class="keyword">if</span> (t &amp; <span class="number">1</span>)        <span class="keyword">return</span> t / <span class="number">2</span> ^ <span class="number">1</span>;    <span class="keyword">return</span> t / <span class="number">2</span> ^ n;&#125;<span class="function">ll <span class="title">query</span><span class="params">(ll l, ll r)</span></span><span class="function"></span>&#123;    cout &lt;&lt; <span class="string">&quot;xor &quot;</span> &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; r &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    ll x;    cin &gt;&gt; x;    <span class="keyword">return</span> x;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    ll n;    cin &gt;&gt; n;    ll axbxc = <span class="built_in">query</span>(<span class="number">1</span>, n);    <span class="keyword">if</span> (axbxc == <span class="number">0</span>)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">60</span>; i &gt;= <span class="number">0</span>; i--)        &#123;            <span class="keyword">if</span> ((<span class="number">1LL</span> &lt;&lt; i) - <span class="number">1</span> &gt; n)                <span class="keyword">continue</span>;            ll t = <span class="built_in">query</span>(<span class="number">1</span>, (<span class="number">1LL</span> &lt;&lt; i) - <span class="number">1</span>);            <span class="keyword">if</span> (t)            &#123;                ll a = t;                ll L = a + <span class="number">1</span>, R = n;                ll c = <span class="number">1</span>;                <span class="keyword">while</span> (L &lt;= R)                &#123;                    ll mid = L + R &gt;&gt; <span class="number">1</span>;                    <span class="keyword">if</span> (<span class="built_in">query</span>(mid, n))                        L = (c = mid) + <span class="number">1</span>;                    <span class="keyword">else</span>                        R = mid - <span class="number">1</span>;                &#125;                cout &lt;&lt; <span class="string">&quot;ans &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (axbxc ^ a ^ c) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c &lt;&lt; endl;                <span class="keyword">return</span>;            &#125;        &#125;    &#125;    <span class="keyword">else</span>    &#123;        ll L = <span class="number">1</span>, R = n, a = n;        <span class="keyword">while</span> (L &lt;= R)        &#123;            ll mid = L + R &gt;&gt; <span class="number">1</span>;            <span class="keyword">if</span> (<span class="built_in">query</span>(<span class="number">1</span>, mid))                R = (a = mid) - <span class="number">1</span>;            <span class="keyword">else</span>                L = mid + <span class="number">1</span>;        &#125;        L = <span class="number">1</span>, R = n;        ll c = <span class="number">1</span>;        <span class="keyword">while</span> (L &lt;= R)        &#123;            ll mid = L + R &gt;&gt; <span class="number">1</span>;            <span class="keyword">if</span> (<span class="built_in">query</span>(mid, n))                L = (c = mid) + <span class="number">1</span>;            <span class="keyword">else</span>                R = mid - <span class="number">1</span>;        &#125;        cout &lt;&lt; <span class="string">&quot;ans &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (axbxc ^ a ^ c) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c &lt;&lt; endl;    &#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> t;    cin &gt;&gt; t;    <span class="keyword">while</span> (t--)        <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] KEYENCE2019E Connecting Cities</title>
      <link href="/archives/KEYENCE2019E/"/>
      <url>/archives/KEYENCE2019E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>点 $i,j$ 连边的代价是 $|i-j|\times d+a_i+a_j$，问最小生成树边权之和。</p><p>$1\leq n\leq 2\times 10^5$，$1\leq d,a_i\leq 10^9$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>典。</p><p>$\mathcal O(n^2)$ 条边很多情况都可以直接上 Boruvka。</p><p>Boruvka 大致流程是维护联通块，每一轮把联通块之间最短的边连起来。每次联通块个数至少减半，一共进行 $\mathcal O(\log n)$ 轮。</p><p>那么考虑如何快速求出这些联通块间最短的边。</p><p>首先绝对值可以拆开，$w(i,j)&#x3D;\begin{cases}(a_i+i\times d)+(a_j - j\times d)&amp;i\lt j\(a_i-i\times d)+(a_j + j\times d)&amp;i\gt j\end{cases}$。</p><p>不妨设 $b_i&#x3D;a_i-i\times d,c_i&#x3D;a_i+i\times d$。</p><p>考虑枚举每个联通块之内的点，以及这个点 $i$ 属于 $i\leq j$ 还是 $i\gt j$。如果是 $i\lt j$ 的情况，相当于在 $[i+1,n]$ 找到最小的 $c_j$。$i\gt j$ 同理。</p><p>但是这样可能会导致连到同一个联通块的边，那么我们就把联通块内的点的相关的值全部设成 $+\infty$。</p><p>使用线段树维护单点修改，区间查询可以做到 $\mathcal O(n\log^2 n)$。Boruvka 和并查集带一只 $\log$，线段树带一只 $\log$。并查集这里需要按大小启发式合并（因为要维护联通块内的所有点）。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://atcoder.jp/contests/keyence2019/submissions/59342851">AT submission 59342851</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">min</span>(x, y); &#125;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="type">const</span> ll inf = <span class="number">1e18</span>;<span class="type">int</span> n;ll d;ll a[<span class="number">200020</span>];ll b[<span class="number">200020</span>];ll c[<span class="number">200020</span>];<span class="type">int</span> fa[<span class="number">200020</span>];<span class="type">int</span> sz[<span class="number">200020</span>];vector&lt;<span class="type">int</span>&gt; vec[<span class="number">200020</span>];array&lt;ll, 2&gt; p[<span class="number">200020</span>];<span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123; <span class="keyword">return</span> fa[u] ^ u ? fa[u] = <span class="built_in">F</span>(fa[u]) : u; &#125;<span class="function"><span class="type">void</span> <span class="title">U</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span><span class="function"></span>&#123;    u = <span class="built_in">F</span>(u), v = <span class="built_in">F</span>(v);    <span class="keyword">if</span> (u == v)        <span class="keyword">return</span>;    <span class="keyword">if</span> (sz[u] &gt; sz[v])        <span class="built_in">swap</span>(u, v);    fa[u] = v;    sz[v] += sz[u];    sz[u] = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i : vec[u])        vec[v].<span class="built_in">push_back</span>(i);    vec[u].<span class="built_in">clear</span>();&#125;<span class="keyword">struct</span> <span class="title class_">SegTree</span>&#123;    <span class="keyword">struct</span> <span class="title class_">node</span>    &#123;        array&lt;ll, 2&gt; mn;    &#125; t[<span class="number">200020</span> &lt;&lt; <span class="number">2</span>];<span class="meta">#<span class="keyword">define</span> ls id &lt;&lt; 1</span><span class="meta">#<span class="keyword">define</span> rs id &lt;&lt; 1 | 1</span>    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123; t[id].mn = <span class="built_in">min</span>(t[ls].mn, t[rs].mn); &#125;    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll *a, <span class="type">int</span> id = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = n)</span></span><span class="function">    </span>&#123;        <span class="keyword">if</span> (l == r)            <span class="keyword">return</span> t[id].mn = &#123;a[l], l&#125;, <span class="built_in">void</span>();        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;        <span class="built_in">build</span>(a, ls, l, mid);        <span class="built_in">build</span>(a, rs, mid + <span class="number">1</span>, r);        <span class="built_in">push_up</span>(id);    &#125;    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll p, ll k, <span class="type">int</span> id = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = n)</span></span><span class="function">    </span>&#123;        <span class="keyword">if</span> (r &lt; p || l &gt; p)            <span class="keyword">return</span>;        <span class="keyword">if</span> (p &lt;= l &amp;&amp; r &lt;= p)            <span class="keyword">return</span> t[id].mn[<span class="number">0</span>] = k, <span class="built_in">void</span>();        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;        <span class="built_in">update</span>(p, k, ls, l, mid);        <span class="built_in">update</span>(p, k, rs, mid + <span class="number">1</span>, r);        <span class="built_in">push_up</span>(id);    &#125;    <span class="function">array&lt;ll, 2&gt; <span class="title">query</span><span class="params">(<span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> id = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = n)</span></span><span class="function">    </span>&#123;        <span class="keyword">if</span> (r &lt; ql || l &gt; qr)            <span class="keyword">return</span> &#123;inf, <span class="number">0</span>&#125;;        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)            <span class="keyword">return</span> t[id].mn;        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">query</span>(ql, qr, ls, l, mid), <span class="built_in">query</span>(ql, qr, rs, mid + <span class="number">1</span>, r));    &#125;&#125; T1, T2;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(n, d);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">read</span>(a[i]);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        b[i] = a[i] - d * i;        c[i] = a[i] + d * i;    &#125;    T<span class="number">1.</span><span class="built_in">build</span>(b);    T<span class="number">2.</span><span class="built_in">build</span>(c);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        fa[i] = i, sz[i] = <span class="number">1</span>, vec[i].<span class="built_in">push_back</span>(i);    <span class="type">int</span> cnt = n;    ll ans = <span class="number">0</span>;    <span class="keyword">while</span> (cnt &gt; <span class="number">1</span>)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        &#123;            <span class="keyword">if</span> (<span class="built_in">F</span>(i) != i)                <span class="keyword">continue</span>;            p[i] = &#123;inf, <span class="number">0</span>&#125;;            <span class="keyword">for</span> (<span class="type">int</span> j : vec[i])            &#123;                T<span class="number">1.</span><span class="built_in">update</span>(j, inf);                T<span class="number">2.</span><span class="built_in">update</span>(j, inf);            &#125;            <span class="keyword">for</span> (<span class="type">int</span> j : vec[i])            &#123;                <span class="keyword">if</span> (j &gt; <span class="number">1</span>)                &#123;                    <span class="keyword">auto</span> [w, k] = T<span class="number">1.</span><span class="built_in">query</span>(<span class="number">1</span>, j - <span class="number">1</span>);                    <span class="built_in">chkmn</span>(p[i], &#123;w + c[j], k&#125;);                &#125;                <span class="keyword">if</span> (j &lt; n)                &#123;                    <span class="keyword">auto</span> [w, k] = T<span class="number">2.</span><span class="built_in">query</span>(j + <span class="number">1</span>, n);                    <span class="built_in">chkmn</span>(p[i], &#123;w + b[j], k&#125;);                &#125;            &#125;            <span class="keyword">for</span> (<span class="type">int</span> j : vec[i])            &#123;                T<span class="number">1.</span><span class="built_in">update</span>(j, b[j]);                T<span class="number">2.</span><span class="built_in">update</span>(j, c[j]);            &#125;        &#125;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        &#123;            <span class="keyword">if</span> (<span class="built_in">F</span>(i) == i &amp;&amp; <span class="built_in">F</span>(p[i][<span class="number">1</span>]) != <span class="built_in">F</span>(i))                <span class="built_in">U</span>(p[i][<span class="number">1</span>], i), ans += p[i][<span class="number">0</span>], cnt--;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1111D Destroy the Colony</title>
      <link href="/archives/CF1111D/"/>
      <url>/archives/CF1111D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定字符串 $s$，长度为偶数，和 $q$ 个询问，每次询问给出 $x,y$，问 $s$ 有多少个不同的排列满足，所有相同字符都在前 $\dfrac{|s|}{2}$ 个或者后 $\dfrac{|s|}{2}$ 个，且 $s_x$ 和 $s_y$ 在同一部分（要么都在前 $\dfrac{|s|}{2}$ 个或者都在后 $\dfrac{|s|}{2}$ 个）。排列不同当且仅当两个排列存在一个位置字符不同。答案对 $10^9+7$ 取模。</p><p>$2\leq |s|\leq 10^5$，$1\leq q\leq 10^5$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>本质不同的询问只有 $52\times 52$ 个，可以先全部求出来然后 $\mathcal O(1)$ 回答。</p><p>比较暴力的做法是枚举 $x,y$ 表示钦定哪两个字符在一起。DP 的时候同时跳过这两个字符，设 $f_{i,j}$ 表示前 $i$ 个字符凑出长度为 $j$ 的方案数，然后会得到复杂度 $\mathcal O(|\Sigma|^3 n)$ 的做法。</p><p>考虑优化，发现每次枚举 $y$ 都会重做一遍 DP，非常浪费。</p><p>如果我们可以快速删除 $y$ 就可以把复杂度降到 $\mathcal O(|\Sigma|^2 n)$。</p><p>可以考虑回退背包。但是有更简便的做法，我们设 $f_{i,j}$ 表示前 $[1,i]$ 的字符凑出长度为 $j$ 的方案数，设 $g_{i,j}$ 表示 $[i,52]$ 的字符凑出长度为 $j$ 的方案数。</p><p>那么枚举 $y$ 可以很方便的合并这两个 DP 求答案。</p><p>这是大致思路。转移的方程也比较复杂。这里只说 $f$ 的，$g$ 是对称的。</p><p>首先不放钦定 $x,y$ 都在前半段，方案数 $\times 2$ 就是总的方案数。</p><p>第一种转移情况是不选择这种字符到后半段，也就是选择这种字符到前半段。此时设前 $i$ 种字符总长度为 $len$，那么选择这种字符到前半段也就是对前半段有一个插入方案数的系数。</p><blockquote><p>引理 1：</p><p>对于长度为 $x$ 的字符串，插入 $y$ 个一样的字符，不同的字符串个数是 $\binom{x+y}{y}$ 的。</p></blockquote><p>也就是这里选择这种字符到前半段，会产生 $\binom{len-j}{cnt_i}$ 的系数。转移也就是 $f_{i,j} \gets f_{i-1,j} \times \binom{len - j}{cnt_i}$。</p><p>第二种情况是直接把这种字符选到后半段。转移与上面类似，是 $f_{i,j}\gets f_{i,j} + f_{i-1,j-cnt_i} \times \binom{j}{cnt_i}$。</p><p>$g$ 的转移是对称的。</p><p>合并的时候枚举 $y$，枚举 $[1,y-1]$ 选择长度为 $l$，令 $m&#x3D;\dfrac{n}{2}$，那么答案应该是 $2\times \binom{m}{cnt_y}\times \sum f_{y-1,l}\times g_{y+1,m-l}\times \binom{m}{l}\times \binom{m-cnt_y}{len-l}$。其中 $len$ 是前 $y-1$ 种字符的长度之和。</p><p>这个合并的几个组合数，分别对应了后半段插入的方案系数和前半段插入的方案系数。意义就是『引理 1』的部分。</p><p>使用预处理阶乘逆元后，复杂度是 $\mathcal O(|\Sigma|^2 n)$ 的。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://codeforces.com/contest/1111/submission/289044991">无卡常擦线过 CF submission 289044991</a></p><p><a href="https://codeforces.com/contest/1111/submission/289045577">轻度卡常 CF submission 289045577</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">typedef</span> __int128 LL;<span class="type">const</span> <span class="type">int</span> p = <span class="number">1000000007</span>;string s;<span class="type">int</span> n;<span class="type">int</span> q;<span class="type">int</span> cnt[<span class="number">55</span>];<span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span>;ll fac[<span class="number">50020</span>];ll inv[<span class="number">50020</span>];<span class="keyword">struct</span> <span class="title class_">Mod</span>&#123;    <span class="type">const</span> ll m = ((LL)<span class="number">1</span> &lt;&lt; <span class="number">64</span>) / p;    <span class="function"><span class="keyword">inline</span> ll <span class="title">operator</span><span class="params">()</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x - ((<span class="built_in">LL</span>(x) * m) &gt;&gt; <span class="number">64</span>) * p; &#125;&#125; mod;<span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i &gt; n || i &lt; <span class="number">0</span> || n &lt; <span class="number">0</span> ? <span class="number">0</span> : <span class="built_in">mod</span>(<span class="built_in">mod</span>(fac[n] * inv[i]) * inv[n - i]); &#125;<span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll x, ll y)</span></span><span class="function"></span>&#123;    ll ret = <span class="number">1</span>;    <span class="keyword">for</span> (; y &gt; <span class="number">0</span>; y &gt;&gt;= <span class="number">1</span>)    &#123;        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)            ret = <span class="built_in">mod</span>(ret * x);        x = <span class="built_in">mod</span>(x * x);    &#125;    <span class="keyword">return</span> ret;&#125;ll f[<span class="number">54</span>][<span class="number">50020</span>];ll g[<span class="number">54</span>][<span class="number">50020</span>];ll ans[<span class="number">54</span>][<span class="number">54</span>];<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">islower</span>(c) ? c - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span> : c - <span class="string">&#x27;A&#x27;</span> + <span class="number">27</span>; &#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);    fac[<span class="number">0</span>] = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)        fac[i] = <span class="built_in">mod</span>(fac[i - <span class="number">1</span>] * i);    inv[N] = <span class="built_in">qpow</span>(fac[N], p - <span class="number">2</span>);    <span class="keyword">for</span> (<span class="type">int</span> i = N; i &gt;= <span class="number">1</span>; i--)        inv[i - <span class="number">1</span>] = <span class="built_in">mod</span>(inv[i] * i);    cin &gt;&gt; s &gt;&gt; q;    <span class="keyword">for</span> (<span class="type">int</span> i : s)        cnt[<span class="built_in">id</span>(i)]++;    n = s.<span class="built_in">size</span>();    s = <span class="string">&#x27; &#x27;</span> + s;    <span class="type">int</span> m = n / <span class="number">2</span>;    <span class="comment">// cout &lt;&lt; fac[m] &lt;&lt; endl;</span>    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= <span class="number">52</span>; x++)    &#123;        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;        <span class="type">int</span> len = <span class="number">0</span>;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">52</span>; i++)        &#123;            len += cnt[i];            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">max</span>(<span class="number">0</span>, len - m); j &lt;= m; j++)                f[i][j] = <span class="built_in">mod</span>(f[i - <span class="number">1</span>][j] * <span class="built_in">C</span>(len - j, cnt[i]));            <span class="keyword">if</span> (i == x || !cnt[i])                <span class="keyword">continue</span>;            <span class="keyword">for</span> (<span class="type">int</span> j = cnt[i]; j &lt;= m; j++)                f[i][j] = <span class="built_in">mod</span>(f[i][j] + f[i - <span class="number">1</span>][j - cnt[i]] * <span class="built_in">C</span>(j, cnt[i]));        &#125;        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="built_in">sizeof</span>(g));        g[<span class="number">53</span>][<span class="number">0</span>] = <span class="number">1</span>;        len = <span class="number">0</span>;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">52</span>; i &gt;= <span class="number">1</span>; i--)        &#123;            len += cnt[i];            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">max</span>(<span class="number">0</span>, len - m); j &lt;= m; j++)                g[i][j] = <span class="built_in">mod</span>(g[i + <span class="number">1</span>][j] * <span class="built_in">C</span>(len - j, cnt[i]));            <span class="keyword">if</span> (i == x || !cnt[i])                <span class="keyword">continue</span>;            <span class="keyword">for</span> (<span class="type">int</span> j = cnt[i]; j &lt;= m; j++)                g[i][j] = <span class="built_in">mod</span>(g[i][j] + g[i + <span class="number">1</span>][j - cnt[i]] * <span class="built_in">C</span>(j, cnt[i]));        &#125;        len = <span class="number">0</span>;        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt; x; y++)            len += cnt[y];        <span class="keyword">for</span> (<span class="type">int</span> y = x; y &lt;= <span class="number">52</span>; y++)        &#123;            ll sum = <span class="number">0</span>;            <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt;= m; l++)            &#123;                <span class="type">int</span> r = m - l;                sum = <span class="built_in">mod</span>(sum + <span class="built_in">mod</span>(f[y - <span class="number">1</span>][l] * g[y + <span class="number">1</span>][r]) * <span class="built_in">mod</span>(<span class="built_in">C</span>(m, l) * <span class="built_in">C</span>(m - cnt[y], len - l)));            &#125;            len += cnt[y];            ans[x][y] = ans[y][x] = <span class="built_in">mod</span>(sum * <span class="number">2</span> * <span class="built_in">C</span>(m, cnt[y]));        &#125;    &#125;    <span class="keyword">while</span> (q--)    &#123;        <span class="type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        x = s[x], y = s[y];        cout &lt;&lt; <span class="built_in">mod</span>(ans[<span class="built_in">id</span>(x)][<span class="built_in">id</span>(y)]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC376G Treasure Hunting</title>
      <link href="/archives/ABC376G/"/>
      <url>/archives/ABC376G/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>每个点有 $\frac{a_i}{\sum\limits_{j&#x3D;1}^{n} a_j}$ 的概率是关键点。你可以走到这个点当且仅当他的父亲节点走过了。问到达关键点的期望步数的最小值，对 $998244353$ 取模。$0$ 号点是根。</p><p>$1\leq n\leq 2\times 10^5$，$1\leq \sum a_i\leq 10^8$，$1\leq a_i$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>题目等价于最小化每个点的访问顺序乘上点权。</p><p>不妨先把概率 $\times \sum\limits_{j&#x3D;1}^{n} a_j$ 得到一个新的概率，答案除以 $\sum\limits_{j&#x3D;1}^{n} a_j$ 即可。</p><p>一个点，如果是还未扩展的最大点，那么父亲被扩展之后一定直接选这个。</p><p>考虑这样的情况：你有若干个可以扩展到的点，共 $k$ 个，设 $p_i$ 表示访问顺序种第 $i$ 个点是哪个点，就是需要最小化 $\sum i \times a_{p_i}$。设最大点是访问顺序中的 $m$ 号点，则把最大点调到第一个可以产生 $(\sum\limits_{i&#x3D;1}^{m-1} a_{p_i})-(m-1)a_{p_m}$。由于这是最大点，这个式子一定是非正的。调过去会产生更小的代价，把最大值调到第一个是最优的。</p><p>考虑合并一些节点的扩展顺序。绑定 $(x,y)$ 说明扩展 $x$ 之后必须直接扩展 $y$。</p><p>接下来来讨论有若干个节点应该先扩展哪一个。先从最简单的 $(x,y)$ 绑定而 $z$ 是单点的情况考虑。也就是解方程组 $x+2y+3z\leq z+2x+3y$ 的情况。解得 $\dfrac{a_x+a_y}{2}\geq \dfrac{a_z}{1}$。</p><p>猜测是按照绑定节点的平均代价排序的。严谨证明一下。不妨设第一个绑定节点内容是 $p_1,p_2,p_3,\dots,p_{k_1}$，第二个内容是 $q_1,q_2,q_3,\dots,q_{k_2}$。也就是 $(\sum\limits_{i&#x3D;1}^{k_1} a_{p_i}\times i)+(\sum\limits_{i&#x3D;1}^{k_2} a_{q_i}\times (i+k_1))\leq (\sum\limits_{i&#x3D;1}^{k_2} a_{q_i}\times i)+(\sum\limits_{i&#x3D;1}^{k_1} a_{p_i}\times (i+k_2))$。解得 $\dfrac{\sum a_{p_i}}{k_1}\geq \dfrac{\sum a_{q_i}}{k_2}$。选平均值大的绑定节点是正确的。</p><p>在堆里维护这些绑定节点，每次弹出平均值最大的，与父亲合并，放回堆里。维护一个访问顺序的链表，做完操作之后遍历一遍链表即可。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>*2858？*1858！</p><p>代码太臭就不放了。贴个链接。</p><p><a href="https://atcoder.jp/contests/abc376/submissions/59034795">AT submission 59034795</a></p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] MX-J8 题解</title>
      <link href="/archives/MXJ8/"/>
      <url>/archives/MXJ8/</url>
      
        <content type="html"><![CDATA[<p>免责声明：本篇题解在比赛结束前属于私有状态，一般用户无法查看。</p><h1 id="A-竹竿"><a href="#A-竹竿" class="headerlink" title="A. 竹竿"></a>A. 竹竿</h1><p>不难发现最多只会左右调换一根竹竿。如果调换了超过一根，一定可以全调回去或者留一根，答案不劣。</p><p>不妨枚举调换的是哪一根竹竿。</p><p>设 $l_i&#x3D;b_i,r_i&#x3D;a_i-b_i$ 是第 $i$ 根竹竿的左右长度。</p><p>枚举第 $j$ 根竹竿调换了顺序，那么左侧就是 ${l_j\mid j\neq k}$ 和 $r_j$，右侧就是 ${r_j\mid j\neq k}$ 和 $l_j$。分别求出左侧和右侧的 $\max$ 相加即可。</p><p>直接做可能会实现出 $\mathcal O(n^2)$ 的复杂度，不难发现这是一个前缀和一个后缀，记录前缀 $\max$ 后缀 $\max$ 即可。</p><p>更简便的做法本质相同，只是化简了式子，为了防止理不清逻辑这里不细说。</p><h1 id="B-黑洞"><a href="#B-黑洞" class="headerlink" title="B. 黑洞"></a>B. 黑洞</h1><p>看到 $|a_i-b_i|&#x3D;k$，我们分别考虑每一维选择 $a_i-b_i\lt 0$ 和 $a_i-b_i\geq 0$ 的两种情况。</p><p>$\mathcal O(2^n)$ 枚举每一维选了什么情况。设 $l_i&#x3D;a_i,r_i&#x3D;m_i-a_i$，那么每一维的两种选择分别表示选了 $l_i$ 还是 $r_i$。</p><p>不难发现对应情况延伸出去的对角线长度应该是 $\min{len_i}$，其中如果选择了 $a_i-b_i\lt 0$ 则 $len_i\gets l_i$，否则 $len_i\gets r_i$。</p><p>此时有一个 $\mathcal O(2^n n)$ 的暴力，足以获得 $52$ 分。</p><p>进一步优化，我们不妨枚举每个维度的两个选择作为 $\min$ 的情况会出现几次。</p><p>对于第 $i$ 个维度的选择 $len_i$，如果第 $j$ 个维度的 $l_j,r_j$ 均 $\geq len_i$，那么第 $j$ 个维度可以给这次选择带来 $\times 2$ 的方案数。同理，如果只有一个 $\geq len_i$，只能选这一个。如果都 $\lt len_i$ 说明这个维度无法选择，这种方案不成立。</p><p>稍微注意一下前后去重（例如取到 $&#x3D;$ 的时候强制钦定 $j\lt i$ 才有效，读者自行思考为什么要这么做）就可以做到 $\mathcal O(n^2)$。可以获得 $76$ 分。</p><p>继续优化，如果你打出了 $\mathcal O(n^2)$ 的程序，我们只需要按 $\min{l_i,r_i}$ 排序即可。因为不难发现只有 $\min{l_i,r_i}$ 或者 $\min\limits_{i&#x3D;1}^{n}{r_i}$ 可以作为全局选择的 $\min$，而 $\min\limits_{i&#x3D;1}^{n}{r_i}$ 只有一种，用上面说的 $\mathcal O(n)$ 枚举 $\mathcal O(n)$ 判断可以只做 $\mathcal O(n)$ 判断的这一步，复杂度就是 $\mathcal O(n)$。</p><p>记下来考虑按 $\min{l_i,r_i}$ 排序之后 $\min{l_i,r_i}$ 成为全局最小值的可能方案数。由于排序了，排在 $i$ 后面的一定满足 $l_j,r_j$ 均 $\geq \min{l_i,r_i}$，看一下前面的 $\min\limits_{j&#x3D;1}^{i-1}{\max{l_j,r_j}}$ 是否 $\geq \min{l_i,r_i}$ 即可知道前面能造成 $\times 0$ 的贡献还是 $\times 1$ 的贡献。</p><p>复杂度瓶颈在排序。剩余部分与输入同阶。</p><p>虽然说的乱七八糟的但是相信讲到 $\mathcal O(n^2)$ 之后如果真的自己实现了一版 $\mathcal O(n^2)$ 是很容易想到排序以及之后的判断的。</p><h1 id="C-水星湖"><a href="#C-水星湖" class="headerlink" title="C. 水星湖"></a>C. 水星湖</h1><p>一个很关键的性质是，一棵树如果周围有树，或者周围有湖，就不会死。</p><p>虽然这是题面告诉你的，但是稍微想一下就知道，每个位置只可能有过树然后死掉了，或者根本没有过树，或者种下的树一直活着。</p><p>再想一下就知道，如果树的生长蔓延了，被蔓延到的位置全都是永久存活的。这个蔓延会形成一个个绕着湖的<strong>联通块</strong>，中间靠一些零散的树连接起来，联通块内部一定是树挨着的，满足『周围有树』的生长条件。</p><p>那么如果我们发现这棵树种下之后会永久存活，就从这棵树开始搜索，搜出一个全都能生长树的联通块，标记成永久存活的位置即可。</p><p>复杂度是正确的，因为如果已经被标记为永久存活，下一次搜到这里想给它打标记，就可以直接不管这棵树。这样一个位置只可能被标记一次，复杂度正确。</p><p>处理树的死亡可以开一个队列储存。每一次种树的时候看一下队首元素，如果生长了超过 $k$ 秒就尝试让它死亡。只有标记成永久存活的位置的树才可以不死亡。</p><h1 id="D-2048"><a href="#D-2048" class="headerlink" title="D. 2048"></a>D. 2048</h1><p>废了。错完了。</p><pre><code class="highlight gams">观察这个游戏，发现一个关键性质：局面一定是形成了一个单峰的序列。每一次都会把东西全部移到一侧，然后在另一侧生成，不可能出现 <span class="symbol">$</span><span class="number">2</span><span class="symbol">$</span> 生成在中间的情况，那就更不可能有中间夹了个 <span class="symbol">$</span><span class="number">4</span><span class="symbol">$</span> 的情况了。再手玩一下这个死局的情况，如果你每次从一侧删掉一个数。设这个数为 <span class="symbol">$</span><span class="number">2</span>^y<span class="symbol">$</span>，你能删掉当且仅当这个数旁边有 <span class="symbol">$</span>\geq y<span class="symbol">$</span> 个空位可用。一个死局的贡献次数，等价于这样子删的方案数。例如 <span class="symbol">$</span>[<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>]<span class="symbol">$</span> 这个死局，如下 <span class="symbol">$</span><span class="number">3</span><span class="symbol">$</span> 种删的方案。<span class="number">1.</span> 先删左侧的 <span class="symbol">$</span><span class="number">2</span><span class="symbol">$</span>，右侧依次删除 <span class="symbol">$</span><span class="number">2</span>,<span class="number">4</span><span class="symbol">$</span>。<span class="number">2.</span> 先删右侧的 <span class="symbol">$</span><span class="number">2</span><span class="symbol">$</span>，再删左侧的 <span class="symbol">$</span><span class="number">2</span><span class="symbol">$</span>，最后删右侧的 <span class="symbol">$</span><span class="number">4</span><span class="symbol">$</span>。<span class="number">2.</span> 先删右侧的 <span class="symbol">$</span><span class="number">2</span><span class="symbol">$</span>，再删右侧的 <span class="symbol">$</span><span class="number">4</span><span class="symbol">$</span>，最后删左侧的 <span class="symbol">$</span><span class="number">2</span><span class="symbol">$</span>。这其实就是死局的生成方式，反过来操作。那么考虑 DP 一个死局的删除方式。<span class="meta"><span class="keyword">$f</span>_&#123;i,j,k&#125;$ 表示已经删除了 $i$ 次，左边剩下了 $j$，右边剩下了 $k$。</span>转移枚举目前删到了第 <span class="symbol">$</span>i<span class="symbol">$</span> 轮，左边剩下 <span class="symbol">$</span>j<span class="symbol">$</span>，右边剩下 <span class="symbol">$</span>k<span class="symbol">$</span>。如果这一次是删左边过渡来的，左边可以删一个 <span class="symbol">$</span>[<span class="number">0</span>,\<span class="built_in">min</span>\&#123;i<span class="number">-1</span>,j<span class="number">-1</span>\&#125;]<span class="symbol">$</span> 的数，右边可以删一个 <span class="symbol">$</span>[<span class="number">0</span>,\<span class="built_in">min</span>\&#123;i<span class="number">-1</span>,k<span class="number">-1</span>\&#125;]<span class="symbol">$</span> 的数。暴力的 DP 转移就是 <span class="symbol">$</span>f_&#123;i,j,k&#125;\gets(\<span class="keyword">sum</span>\limits_&#123;l=<span class="number">0</span>&#125;^&#123;\<span class="built_in">min</span>\&#123;i<span class="number">-1</span>,j<span class="number">-1</span>\&#125;&#125; f_&#123;i<span class="number">-1</span>,l,k&#125;)+(\<span class="keyword">sum</span>\limits_&#123;l=<span class="number">0</span>&#125;^&#123;\<span class="built_in">min</span>\&#123;i<span class="number">-1</span>,k<span class="number">-1</span>\&#125;&#125; f_&#123;i<span class="number">-1</span>,j,l&#125;)<span class="symbol">$</span>。状态 <span class="symbol">$</span>\mathcal O(n^<span class="number">3</span>)<span class="symbol">$</span>，转移 <span class="symbol">$</span>\mathcal O(n)<span class="symbol">$</span>，复杂度是 <span class="symbol">$</span>\mathcal O(n^<span class="number">4</span>)<span class="symbol">$</span> 的，无法接受。发现这个转移不难用前缀和优化，转移直接变成了 <span class="symbol">$</span>\mathcal O(<span class="number">1</span>)<span class="symbol">$</span> 的。初值是 <span class="symbol">$</span>f_&#123;<span class="number">0</span>,i,<span class="number">0</span>&#125;\gets <span class="number">1</span>,f_&#123;<span class="number">0</span>,<span class="number">0</span>,i&#125;\gets <span class="number">1</span><span class="symbol">$</span>。接下来考虑每组询问的回答，就是删 <span class="symbol">$</span>n<span class="number">-1</span><span class="symbol">$</span> 次之后剩下那个数的情况。而剩下的数只可能在 <span class="symbol">$</span>[<span class="number">2</span>^&#123;<span class="number">0</span>&#125;,<span class="number">2</span>^&#123;\<span class="built_in">min</span>\&#123;n<span class="number">-1</span>,x<span class="number">-1</span>\&#125;&#125;]<span class="symbol">$</span> 中，直接枚举即可，回答询问复杂度 <span class="symbol">$</span>\mathcal O(n)<span class="symbol">$</span>。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] [模拟赛 20241008] CodeChef DISTNUM</title>
      <link href="/archives/CC_DISTNUM/"/>
      <url>/archives/CC_DISTNUM/</url>
      
        <content type="html"><![CDATA[<p>考虑离线操作。用 FHQ-Treap 维护，这样拓展成 $\mathcal O(n+q)$ 长度的序列，单点修改。删除就是相当于改为 $0$。</p><p>平衡树节点打上 $del$ 标记表示这个节点是否被删除。</p><p>直接 split 出来可能找不到合法点，是一个删除的点。再写一个 find 用来找合法点。</p><p>之后对平衡树做中序遍历搜一遍，时间戳即为对应点在新序列的编号。</p><p>平衡树 $val$ 值填这是树上第几个节点。之后根据排名查询值就可以得到我们需要修改的节点。</p><p>这里『根据排名查询值』就需要 find 查询合法点。</p><p>插入就是 split 开新开一个点 merge 进去。</p><p>这样操作 4 解决了，操作 3 等价于操作 2 的 $y&#x3D;0$ 的情况。</p><p>考虑操作 1。</p><p>设 $S_1,S_2,S_3$ 表示区间内不同颜色的数的和，平方和，立方和，那么 $\dfrac{S_1^3-3S_1S_2+2S_3}{6}$ 即为答案。简单的容斥刻意推出。</p><p>操作 1 可以拆分成查询 $i\in[l,r]$ 的 $a_i^k$，其中 $k\in[1,3]$。</p><p>操作 5 可以看为查询 $i\in[l,r]$ 的 $a_i^k$，其中 $k&#x3D;0$。</p><p>那我们索性直接维护 $a_i^k,k\in[0,3]$。</p><p>考虑经典的区间数颜色问题，记录 $pre_i$ 表示上一个和 $i$ 一样的点在哪里。那么数 $[l,r]$ 颜色就是数多少 $i\in[l,r]$ 有 $pre_i\lt l$。</p><p>考虑 $(pre_i,i)$ 看做平面上的一个点，就是计数 $[0,l-1]\times [l,r]$ 范围的点的个数。</p><p>考虑修改点颜色的更新，记录一个 $nxt_i$ 表示下一个和 $i$ 一样的点在哪里，链表维护一下。然后对权值离散化用 set 维护某个颜色的点的位置，集合内二分可以算出 $i$ 的新的 $pre,nxt$。</p><p>现在最难点在单点加，矩形求和。</p><p>直接上二维 BIT 会 MLE，上分块会 TLE。</p><p>二维 BIT 就是模板，分块对更优复杂度有启发性。</p><p>考虑分成边长为 $B&#x3D;\sqrt n$ 的 $\sqrt n\times \sqrt n$ 块，二维前缀和维护，然后对于每一行每一列，显然只有一个数（$pre_i,i$ 互相对应），直接存这个数在哪里。二维前缀和和每行每列的修改，每根号次重构。根号个散点的贡献直接算即可。这个根号次重构实际大一点效果更好，因为一次操作本质会加很多点进去。</p><p>这个理论复杂度是根号的，但是过不去，可能是我写的太丑了。</p><p>考虑结合一下。分成 $B&#x3D;100$ 的 $2000\times 2000$ 块，这 $2000\times 2000$ 块用二维树状数组维护。剩下的散块和上面一样直接做。只是少了那几个散点。</p><p>放点恶臭代码。</p><p><a href="https://www.codechef.com/viewsolution/1097871655">CODECHEF solution 1097871655</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span></span><span class="function"></span>&#123;    <span class="type">static</span> <span class="type">int</span> stk[<span class="number">10</span>];    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;    <span class="type">int</span> top = <span class="number">0</span>;    <span class="keyword">do</span>    &#123;        stk[top++] = x % <span class="number">10</span>, x /= <span class="number">10</span>;    &#125; <span class="keyword">while</span> (x);    <span class="keyword">while</span> (top)        <span class="built_in">putchar</span>(stk[--top] + <span class="string">&#x27;0&#x27;</span>);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x, <span class="type">char</span> lastChar)</span> </span>&#123; <span class="built_in">write</span>(x), <span class="built_in">putchar</span>(lastChar); &#125;<span class="keyword">template</span> &lt;<span class="type">int</span> P&gt;<span class="keyword">class</span> <span class="title class_">mod_int</span>&#123;    <span class="keyword">using</span> Z = mod_int;<span class="keyword">private</span>:    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">0</span> ? x + P : x; &#125;<span class="keyword">public</span>:    <span class="type">int</span> x;    <span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;    <span class="built_in">mod_int</span>() : <span class="built_in">x</span>(<span class="number">0</span>) &#123;&#125;    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;    <span class="built_in">mod_int</span>(<span class="type">const</span> T &amp;x_) : <span class="built_in">x</span>(x_ &gt;= <span class="number">0</span> &amp;&amp; x_ &lt; P ? <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(x_) : <span class="built_in">mo</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(x_ % P))) &#123;&#125;    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Z &amp;rhs) <span class="type">const</span> &#123; <span class="keyword">return</span> x == rhs.x; &#125;    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Z &amp;rhs) <span class="type">const</span> &#123; <span class="keyword">return</span> x != rhs.x; &#125;    Z <span class="keyword">operator</span>-() <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Z</span>(x ? P - x : <span class="number">0</span>); &#125;    <span class="function">Z <span class="title">pow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> k)</span> <span class="type">const</span></span><span class="function">    </span>&#123;        Z res = <span class="number">1</span>, t = *<span class="keyword">this</span>;        <span class="keyword">while</span> (k)        &#123;            <span class="keyword">if</span> (k &amp; <span class="number">1</span>)                res *= t;            <span class="keyword">if</span> (k &gt;&gt;= <span class="number">1</span>)                t *= t;        &#125;        <span class="keyword">return</span> res;    &#125;    Z &amp;<span class="keyword">operator</span>++()    &#123;        x &lt; P - <span class="number">1</span> ? ++x : x = <span class="number">0</span>;        <span class="keyword">return</span> *<span class="keyword">this</span>;    &#125;    Z &amp;<span class="keyword">operator</span>--()    &#123;        x ? --x : x = P - <span class="number">1</span>;        <span class="keyword">return</span> *<span class="keyword">this</span>;    &#125;    Z <span class="keyword">operator</span>++(<span class="type">int</span>)    &#123;        Z ret = x;        x &lt; P - <span class="number">1</span> ? ++x : x = <span class="number">0</span>;        <span class="keyword">return</span> ret;    &#125;    Z <span class="keyword">operator</span>--(<span class="type">int</span>)    &#123;        Z ret = x;        x ? --x : x = P - <span class="number">1</span>;        <span class="keyword">return</span> ret;    &#125;    <span class="function">Z <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">pow</span>(P - <span class="number">2</span>); &#125;    Z &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> Z &amp;rhs)    &#123;        (x += rhs.x) &gt;= P &amp;&amp; (x -= P);        <span class="keyword">return</span> *<span class="keyword">this</span>;    &#125;    Z &amp;<span class="keyword">operator</span>-=(<span class="type">const</span> Z &amp;rhs)    &#123;        (x -= rhs.x) &lt; <span class="number">0</span> &amp;&amp; (x += P);        <span class="keyword">return</span> *<span class="keyword">this</span>;    &#125;    Z <span class="keyword">operator</span>-() &#123; <span class="keyword">return</span> -x; &#125;    Z &amp;<span class="keyword">operator</span>*=(<span class="type">const</span> Z &amp;rhs)    &#123;        x = <span class="number">1ULL</span> * x * rhs.x % P;        <span class="keyword">return</span> *<span class="keyword">this</span>;    &#125;    Z &amp;<span class="keyword">operator</span>/=(<span class="type">const</span> Z &amp;rhs) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>(); &#125;<span class="meta">#<span class="keyword">define</span> setO(T, o)                                  \</span><span class="meta">    friend T operator o(const Z &amp;lhs, const Z &amp;rhs) \</span><span class="meta">    &#123;                                               \</span><span class="meta">        Z res = lhs;                                \</span><span class="meta">        return res o## = rhs;                       \</span><span class="meta">    &#125;</span>    <span class="built_in">setO</span>(Z, +) <span class="built_in">setO</span>(Z, -) <span class="built_in">setO</span>(Z, *) <span class="built_in">setO</span>(Z, /)<span class="meta">#<span class="keyword">undef</span> setO</span>        <span class="keyword">friend</span> istream &amp;        <span class="keyword">operator</span>&gt;&gt;(istream &amp;is, mod_int &amp;x)    &#123;        <span class="type">long</span> <span class="type">long</span> tmp;        is &gt;&gt; tmp;        x = tmp;        <span class="keyword">return</span> is;    &#125;    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> mod_int &amp;x)    &#123;        os &lt;&lt; x.<span class="built_in">val</span>();        <span class="keyword">return</span> os;    &#125;&#125;;<span class="keyword">using</span> Z = mod_int&lt;<span class="number">1000000007</span>&gt;;<span class="keyword">struct</span> <span class="title class_">query</span>&#123;    <span class="type">int</span> op, x, y;&#125; q[<span class="number">100005</span>];<span class="type">int</span> n, Q;<span class="type">int</span> a[<span class="number">100005</span>];<span class="type">int</span> val[<span class="number">200005</span>];<span class="type">int</span> pre[<span class="number">200005</span>];<span class="type">int</span> nxt[<span class="number">200005</span>];<span class="type">int</span> to[<span class="number">200005</span>], tot;<span class="function">mt19937 <span class="title">rnd</span><span class="params">(chrono::system_clock::now().time_since_epoch().count())</span></span>;<span class="keyword">struct</span> <span class="title class_">FHQ_Treap</span>&#123;<span class="meta">#<span class="keyword">define</span> ls a[p].l</span><span class="meta">#<span class="keyword">define</span> rs a[p].r</span>    <span class="keyword">struct</span> <span class="title class_">node</span>    &#123;        <span class="type">int</span> l, r;        <span class="type">int</span> val, pri, siz;        <span class="type">bool</span> del;    &#125; a[<span class="number">200005</span>];    <span class="type">int</span> tot, rt;    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">create</span><span class="params">(<span class="type">int</span> val)</span></span><span class="function">    </span>&#123;        tot++;        a[tot].val = val;        a[tot].pri = <span class="built_in">rnd</span>();        a[tot].siz = <span class="number">1</span>;        a[tot].del = <span class="number">0</span>;        <span class="keyword">return</span> tot;    &#125;    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; a[p].siz = a[ls].siz + a[rs].siz + (!a[p].del); &#125;    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;&#125;    <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span><span class="function">    </span>&#123;        <span class="comment">// cerr &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; endl;</span>        <span class="keyword">if</span> (!p)            <span class="keyword">return</span> x = y = <span class="number">0</span>, <span class="built_in">void</span>();        <span class="built_in">pushdown</span>(p);        <span class="keyword">if</span> (a[ls].siz + (!a[p].del) &lt;= k)        &#123;            k -= a[ls].siz + (!a[p].del);            x = p;            <span class="built_in">split</span>(rs, k, rs, y);        &#125;        <span class="keyword">else</span>        &#123;            y = p;            <span class="built_in">split</span>(ls, k, x, ls);        &#125;        <span class="built_in">pushup</span>(p);    &#125;    <span class="function"><span class="type">void</span> <span class="title">outdfs</span><span class="params">(<span class="type">int</span> p)</span></span><span class="function">    </span>&#123;        <span class="keyword">if</span> (!p)            <span class="keyword">return</span>;        cout &lt;&lt; p &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ls &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; rs &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a[p].siz &lt;&lt; endl;        <span class="built_in">outdfs</span>(ls);        <span class="built_in">outdfs</span>(rs);    &#125;    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> op = <span class="number">0</span>)</span></span><span class="function">    </span>&#123;        <span class="keyword">if</span> (!p)            <span class="keyword">return</span> <span class="number">0</span>;        a[p].siz -= op;        <span class="keyword">if</span> (a[ls].siz)            <span class="keyword">return</span> <span class="built_in">find</span>(ls, op);        <span class="keyword">else</span> <span class="keyword">if</span> (a[p].del)            <span class="keyword">return</span> <span class="built_in">find</span>(rs, op);        <span class="keyword">else</span>            <span class="keyword">return</span> p;    &#125;    <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span><span class="function">    </span>&#123;        <span class="keyword">if</span> (!p || !q)            <span class="keyword">return</span> p + q;        <span class="keyword">if</span> (a[p].pri &lt; a[q].pri)        &#123;            <span class="built_in">pushdown</span>(p);            <span class="built_in">pushup</span>(p);            rs = <span class="built_in">merge</span>(rs, q);            <span class="built_in">pushup</span>(p);            <span class="keyword">return</span> p;        &#125;        <span class="built_in">swap</span>(p, q);        <span class="built_in">pushup</span>(p);        <span class="built_in">pushdown</span>(p);        ls = <span class="built_in">merge</span>(q, ls);        <span class="built_in">pushup</span>(p);        <span class="keyword">return</span> p;    &#125;    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getval</span><span class="params">(<span class="type">int</span> rk)</span></span><span class="function">    </span>&#123;        <span class="comment">// cout &lt;&lt; rk &lt;&lt; endl;</span>        <span class="type">int</span> x, y, z;        <span class="built_in">split</span>(rt, rk - <span class="number">1</span>, x, y);        <span class="built_in">split</span>(y, <span class="number">1</span>, y, z);        <span class="comment">// outdfs(y);</span>        <span class="type">int</span> u = <span class="built_in">find</span>(y);        rt = <span class="built_in">merge</span>(x, <span class="built_in">merge</span>(y, z));        <span class="comment">// cout &lt;&lt; u &lt;&lt; &#x27; &#x27; &lt;&lt; a[u].val &lt;&lt; endl;</span>        <span class="comment">// cout &lt;&lt; rk &lt;&lt; &#x27; &#x27; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; &#x27; &#x27; &lt;&lt; z &lt;&lt; &#x27; &#x27; &lt;&lt; u &lt;&lt; &#x27;\n&#x27;;</span>        <span class="keyword">return</span> a[u].val;    &#125;    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span></span><span class="function">    </span>&#123;        <span class="keyword">if</span> (!p)            <span class="keyword">return</span>;        <span class="built_in">dfs</span>(ls);        to[a[p].val] = ++::tot;        <span class="built_in">dfs</span>(rs);    &#125;&#125; T;<span class="comment">// struct BIT</span><span class="comment">// &#123;</span><span class="comment">//     int n = 2e5;</span><span class="comment">//     unordered_map&lt;int, Z&gt; c[200020];</span><span class="comment">//     inline int lowbit(int x) &#123; return x &amp; -x; &#125;</span><span class="comment">//     inline void add(int x, int y, Z w)</span><span class="comment">//     &#123;</span><span class="comment">//         x++, y++;</span><span class="comment">//         if (w == 0)</span><span class="comment">//             return;</span><span class="comment">//         // cerr &lt;&lt; &quot;BIT: &quot; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; &#x27; &#x27; &lt;&lt; w &lt;&lt; &#x27; &#x27; &lt;&lt; f &lt;&lt; &#x27;\n&#x27;;</span><span class="comment">//         for (int i = x; i &lt;= n; i += lowbit(i))</span><span class="comment">//         &#123;</span><span class="comment">//             for (int j = y; j &lt;= n; j += lowbit(j))</span><span class="comment">//                 c[i][j] += w;</span><span class="comment">//         &#125;</span><span class="comment">//     &#125;</span><span class="comment">//     inline Z query(int x, int y)</span><span class="comment">//     &#123;</span><span class="comment">//         // cerr &lt;&lt; &quot;QUERY: &quot; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; &#x27;\n&#x27;;</span><span class="comment">//         x++, y++;</span><span class="comment">//         Z ret = 0;</span><span class="comment">//         for (int i = x; i &gt; 0; i &amp;= i - 1)</span><span class="comment">//         &#123;</span><span class="comment">//             for (int j = y; j &gt; 0; j &amp;= j - 1)</span><span class="comment">//                 ret += c[i].count(j) ? c[i][j] : 0;</span><span class="comment">//         &#125;</span><span class="comment">//         return ret;</span><span class="comment">//     &#125;</span><span class="comment">//     inline Z query(int u, int v, int x, int y) &#123; return query(x, y) - query(u - 1, y) - query(x, v - 1) + query(u - 1, v - 1); &#125;</span><span class="comment">// &#125; ds[4];</span><span class="comment">// struct Block</span><span class="comment">// &#123;</span><span class="comment">//     const int B = 450;</span><span class="comment">//     array&lt;int, 2&gt; block(int x, int y) &#123; return &#123;(x + B - 1) / B + 1, (y + B - 1) / B + 1&#125;; &#125;</span><span class="comment">//     Z s[450][450];</span><span class="comment">//     Z t[450][450];</span><span class="comment">//     unordered_map&lt;int, Z&gt; R[200020];</span><span class="comment">//     unordered_map&lt;int, Z&gt; C[200020];</span><span class="comment">//     vector&lt;array&lt;int, 3&gt;&gt; v;</span><span class="comment">//     inline void add(int x, int y, Z w)</span><span class="comment">//     &#123;</span><span class="comment">//         v.push_back(&#123;x, y, w.val()&#125;);</span><span class="comment">//         auto [p, q] = block(x, y);</span><span class="comment">//         t[p][q] += w;</span><span class="comment">//         if (v.size() &gt;= 700)</span><span class="comment">//         &#123;</span><span class="comment">//             memset(s, 0, sizeof(s));</span><span class="comment">//             for (auto [x, y, w] : v)</span><span class="comment">//             &#123;</span><span class="comment">//                 R[x][y] += w;</span><span class="comment">//                 if (R[x][y] == 0)</span><span class="comment">//                     R[x].erase(y);</span><span class="comment">//                 C[y][x] += w;</span><span class="comment">//                 if (C[y][x] == 0)</span><span class="comment">//                     C[y].erase(x);</span><span class="comment">//             &#125;</span><span class="comment">//             for (int i = 1; i &lt; B; i++)</span><span class="comment">//             &#123;</span><span class="comment">//                 for (int j = 1; j &lt; B; j++)</span><span class="comment">//                     s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + t[i][j];</span><span class="comment">//             &#125;</span><span class="comment">//             v.clear();</span><span class="comment">//         &#125;</span><span class="comment">//     &#125;</span><span class="comment">//     inline Z query(int x, int y)</span><span class="comment">//     &#123;</span><span class="comment">//         if (x &lt; 0)</span><span class="comment">//             return 0;</span><span class="comment">//         if (y &lt; 0)</span><span class="comment">//             return 0;</span><span class="comment">//         auto [p, q] = block(x, y);</span><span class="comment">//         Z ans = 0;</span><span class="comment">//         ans += s[p - 1][q - 1];</span><span class="comment">//         int ed = 0;</span><span class="comment">//         for (int i = x; ~i &amp;&amp; (i + B - 1) / B + 1 == p; i--)</span><span class="comment">//         &#123;</span><span class="comment">//             ed = i;</span><span class="comment">//             for (auto [v, w] : R[i])</span><span class="comment">//             &#123;</span><span class="comment">//                 if (v &lt;= y)</span><span class="comment">//                     ans += w;</span><span class="comment">//             &#125;</span><span class="comment">//         &#125;</span><span class="comment">//         for (int j = y; ~j &amp;&amp; (j + B - 1) / B + 1 == q; j--)</span><span class="comment">//         &#123;</span><span class="comment">//             for (auto [u, w] : C[j])</span><span class="comment">//             &#123;</span><span class="comment">//                 if (u &lt; ed)</span><span class="comment">//                     ans += w;</span><span class="comment">//             &#125;</span><span class="comment">//         &#125;</span><span class="comment">//         for (auto [p, q, w] : v)</span><span class="comment">//         &#123;</span><span class="comment">//             if (p &lt;= x &amp;&amp; q &lt;= y)</span><span class="comment">//                 ans += w;</span><span class="comment">//         &#125;</span><span class="comment">//         return ans;</span><span class="comment">//     &#125;</span><span class="comment">//     inline Z query(int u, int v, int x, int y) &#123; return query(x, y) - query(u - 1, y) - query(x, v - 1) + query(u - 1, v - 1); &#125;</span><span class="comment">// &#125; ds[4];</span><span class="keyword">struct</span> <span class="title class_">Block</span>&#123;    <span class="type">const</span> <span class="type">int</span> B = <span class="number">100</span>;    <span class="function">array&lt;<span class="type">int</span>, 2&gt; <span class="title">block</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> &#123;(x + B - <span class="number">1</span>) / B + <span class="number">1</span>, (y + B - <span class="number">1</span>) / B + <span class="number">1</span>&#125;; &#125;    Z s[<span class="number">2020</span>][<span class="number">2020</span>];    unordered_map&lt;<span class="type">int</span>, Z&gt; R[<span class="number">200020</span>];    unordered_map&lt;<span class="type">int</span>, Z&gt; C[<span class="number">200020</span>];    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, Z w)</span></span><span class="function">    </span>&#123;        <span class="keyword">auto</span> [p, q] = <span class="built_in">block</span>(x, y);        <span class="keyword">for</span> (<span class="type">int</span> i = p; i &lt;= <span class="number">2005</span>; i += <span class="built_in">lowbit</span>(i))        &#123;            <span class="keyword">for</span> (<span class="type">int</span> j = q; j &lt;= <span class="number">2005</span>; j += <span class="built_in">lowbit</span>(j))                s[i][j] += w;        &#125;        R[x][y] += w;        <span class="keyword">if</span> (R[x][y] == <span class="number">0</span>)            R[x].<span class="built_in">erase</span>(y);        C[y][x] += w;        <span class="keyword">if</span> (C[y][x] == <span class="number">0</span>)            C[y].<span class="built_in">erase</span>(x);    &#125;    <span class="function"><span class="keyword">inline</span> Z <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><span class="function">    </span>&#123;        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)            <span class="keyword">return</span> <span class="number">0</span>;        <span class="keyword">if</span> (y &lt; <span class="number">0</span>)            <span class="keyword">return</span> <span class="number">0</span>;        <span class="keyword">auto</span> [p, q] = <span class="built_in">block</span>(x, y);        Z ans = <span class="number">0</span>;        <span class="keyword">for</span> (<span class="type">int</span> i = p - <span class="number">1</span>; i &gt; <span class="number">0</span>; i &amp;= i - <span class="number">1</span>)        &#123;            <span class="keyword">for</span> (<span class="type">int</span> j = q - <span class="number">1</span>; j &gt; <span class="number">0</span>; j &amp;= j - <span class="number">1</span>)                ans += s[i][j];        &#125;        <span class="type">int</span> ed = <span class="number">0</span>;        <span class="keyword">for</span> (<span class="type">int</span> i = x; ~i &amp;&amp; (i + B - <span class="number">1</span>) / B + <span class="number">1</span> == p; i--)        &#123;            ed = i;            <span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : R[i])            &#123;                <span class="keyword">if</span> (v &lt;= y)                    ans += w;            &#125;        &#125;        <span class="keyword">for</span> (<span class="type">int</span> j = y; ~j &amp;&amp; (j + B - <span class="number">1</span>) / B + <span class="number">1</span> == q; j--)        &#123;            <span class="keyword">for</span> (<span class="keyword">auto</span> [u, w] : C[j])            &#123;                <span class="keyword">if</span> (u &lt; ed)                    ans += w;            &#125;        &#125;        <span class="keyword">return</span> ans;    &#125;    <span class="function"><span class="keyword">inline</span> Z <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">query</span>(x, y) - <span class="built_in">query</span>(u - <span class="number">1</span>, y) - <span class="built_in">query</span>(x, v - <span class="number">1</span>) + <span class="built_in">query</span>(u - <span class="number">1</span>, v - <span class="number">1</span>); &#125;&#125; ds[<span class="number">4</span>];set&lt;<span class="type">int</span>&gt; mp[<span class="number">200020</span>];vector&lt;<span class="type">int</span>&gt; vec;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (!x || !val[x])        <span class="keyword">return</span>;    <span class="comment">// for (int i = 0; i &lt; 4; i++)</span>    <span class="comment">//     bit.add(pre[x], x, -pw(val[x], i), i);</span>    Z pw = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)        ds[i].<span class="built_in">add</span>(pre[x], x, -pw), pw *= val[x];&#125;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (!x || !val[x])        <span class="keyword">return</span>;    <span class="comment">// for (int i = 0; i &lt; 4; i++)</span>    <span class="comment">//     bit.add(pre[x], x, pw(val[x], i), i);</span>    Z pw = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)        ds[i].<span class="built_in">add</span>(pre[x], x, pw), pw *= val[x];&#125;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><span class="function"></span>&#123;    <span class="built_in">del</span>(x);    <span class="type">int</span> p = pre[x], q = nxt[x];    <span class="built_in">del</span>(q);    pre[q] = p;    <span class="built_in">add</span>(q);    nxt[p] = q;    <span class="keyword">if</span> (val[x])        mp[<span class="built_in">lower_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), val[x]) - vec.<span class="built_in">begin</span>()].<span class="built_in">erase</span>(x);    val[x] = y;    <span class="keyword">if</span> (y)    &#123;        <span class="type">int</span> id = <span class="built_in">lower_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), val[x]) - vec.<span class="built_in">begin</span>();        <span class="keyword">auto</span> &amp;s = mp[id];        <span class="keyword">auto</span> it = s.<span class="built_in">upper_bound</span>(x);        <span class="keyword">if</span> (it != s.<span class="built_in">end</span>())            nxt[x] = *it, <span class="built_in">del</span>(*it), pre[*it] = x, <span class="built_in">add</span>(*it);        <span class="keyword">else</span>            nxt[x] = <span class="number">0</span>;        it = s.<span class="built_in">lower_bound</span>(x);        <span class="keyword">if</span> (it == s.<span class="built_in">begin</span>())            pre[x] = <span class="number">0</span>;        <span class="keyword">else</span>            it--, pre[x] = *it, nxt[*it] = x;        s.<span class="built_in">insert</span>(x);    &#125;    <span class="comment">// cerr &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; &#x27; &#x27; &lt;&lt; pre[x] &lt;&lt; &#x27; &#x27; &lt;&lt; nxt[x] &lt;&lt; &#x27;\n&#x27;;</span>    <span class="built_in">add</span>(x);&#125;<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">queryTuple</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span><span class="function"></span>&#123;    <span class="comment">// cerr &lt;&lt; &quot;QUERY TUPLE: &quot; &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; &#x27;\n&#x27;;</span>    <span class="comment">// Z S1 = bit.query(0, l, l - 1, r, 1);</span>    <span class="comment">// Z S2 = bit.query(0, l, l - 1, r, 2);</span>    <span class="comment">// Z S3 = bit.query(0, l, l - 1, r, 3);</span>    Z S1 = ds[<span class="number">1</span>].<span class="built_in">query</span>(<span class="number">0</span>, l, l - <span class="number">1</span>, r);    Z S2 = ds[<span class="number">2</span>].<span class="built_in">query</span>(<span class="number">0</span>, l, l - <span class="number">1</span>, r);    Z S3 = ds[<span class="number">3</span>].<span class="built_in">query</span>(<span class="number">0</span>, l, l - <span class="number">1</span>, r);    <span class="comment">// cerr &lt;&lt; &quot;Tuple: &quot; &lt;&lt; S1 &lt;&lt; &#x27; &#x27; &lt;&lt; S2 &lt;&lt; &#x27; &#x27; &lt;&lt; S3 &lt;&lt; &#x27;\n&#x27;;</span>    <span class="keyword">return</span> ((S1 * S1 * S1 - <span class="number">3</span> * S1 * S2 + <span class="number">2</span> * S3) / <span class="number">6</span>).<span class="built_in">val</span>();&#125;<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">queryKinds</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span><span class="function"></span>&#123;    <span class="comment">// cerr &lt;&lt; &quot;QUERY TUPLE: &quot; &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; &#x27;\n&#x27;;</span>    <span class="comment">// return bit.query(0, l, l - 1, r, 0).val();</span>    <span class="keyword">return</span> ds[<span class="number">0</span>].<span class="built_in">query</span>(<span class="number">0</span>, l, l - <span class="number">1</span>, r).<span class="built_in">val</span>();&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="comment">// freopen(&quot;simple.in&quot;, &quot;r&quot;, stdin);</span>    <span class="comment">// freopen(&quot;simple.out&quot;, &quot;w&quot;, stdout);</span>    <span class="built_in">read</span>(n, Q);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">read</span>(a[i]), vec.<span class="built_in">push_back</span>(a[i]);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        T.rt = T.<span class="built_in">merge</span>(T.rt, T.<span class="built_in">create</span>(i));    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)    &#123;        <span class="built_in">read</span>(q[i].op, q[i].x);        <span class="keyword">if</span> (q[i].op != <span class="number">3</span>)            <span class="built_in">read</span>(q[i].y);        <span class="keyword">if</span> (!(q[i].op &amp; <span class="number">1</span>))            vec.<span class="built_in">push_back</span>(q[i].y);    &#125;    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());    vec.<span class="built_in">erase</span>(<span class="built_in">unique</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()), vec.<span class="built_in">end</span>());    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)    &#123;        <span class="keyword">auto</span> &amp;[op, p, q] = ::q[i];        <span class="keyword">if</span> (op == <span class="number">1</span>)        &#123;            <span class="comment">// cerr &lt;&lt; p &lt;&lt; &#x27; &#x27; &lt;&lt; q &lt;&lt; &#x27;\n&#x27;;</span>            p = T.<span class="built_in">getval</span>(p);            q = T.<span class="built_in">getval</span>(q);            <span class="comment">// cerr &lt;&lt; p &lt;&lt; &#x27; &#x27; &lt;&lt; q &lt;&lt; &#x27;\n&#x27;;</span>        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)        &#123;            p = T.<span class="built_in">getval</span>(p);        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>)        &#123;            <span class="type">static</span> <span class="type">int</span> x, y, z;            <span class="comment">// int tmp = T.getval(p);</span>            T.<span class="built_in">split</span>(T.rt, p - <span class="number">1</span>, x, y);            T.<span class="built_in">split</span>(y, <span class="number">1</span>, y, z);            <span class="comment">// cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; z &lt;&lt; endl;</span>            <span class="comment">// T.rt = T.merge(x, y);</span>            <span class="type">int</span> u = T.<span class="built_in">find</span>(y, <span class="number">1</span>);            <span class="comment">// T.a[u].siz = 0;</span>            T.a[u].del = <span class="number">1</span>;            p = T.a[u].val;            <span class="comment">// cerr &lt;&lt; tmp &lt;&lt; &#x27; &#x27; &lt;&lt; z &lt;&lt; &#x27; &#x27; &lt;&lt; T.a[z].siz &lt;&lt; &#x27; &#x27; &lt;&lt; T.a[z].val &lt;&lt; &#x27;\n&#x27;;</span>            T.rt = T.<span class="built_in">merge</span>(x, T.<span class="built_in">merge</span>(y, z));            <span class="comment">// T.outdfs(T.rt);</span>            <span class="comment">// cerr &lt;&lt; tmp &lt;&lt; &#x27; &#x27; &lt;&lt; z &lt;&lt; &#x27; &#x27; &lt;&lt; T.a[z].siz &lt;&lt; &#x27; &#x27; &lt;&lt; T.a[z].val &lt;&lt; &#x27;\n&#x27;;</span>        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>)        &#123;            <span class="type">static</span> <span class="type">int</span> x, y;            <span class="comment">// int tmp = T.getval(p);</span>            T.<span class="built_in">split</span>(T.rt, p, x, y);            T.rt = T.<span class="built_in">merge</span>(x, T.<span class="built_in">merge</span>(T.<span class="built_in">create</span>(T.tot + <span class="number">1</span>), y));            p = T.tot;            <span class="comment">// p = T.getval(p + 1);</span>            <span class="comment">// cerr &lt;&lt; p &lt;&lt; &#x27;\n&#x27;;</span>        &#125;        <span class="keyword">else</span>        &#123;            p = T.<span class="built_in">getval</span>(p);            q = T.<span class="built_in">getval</span>(q);            <span class="comment">// cout &lt;&lt; p &lt;&lt; &#x27; &#x27; &lt;&lt; q &lt;&lt; &#x27;\n&#x27;;</span>        &#125;        <span class="comment">// for (int j = 1; j &lt;= n; j++)</span>        <span class="comment">//     cout &lt;&lt; T.getval(j) &lt;&lt; &#x27; &#x27;;</span>        <span class="comment">// cout &lt;&lt; endl;</span>    &#125;    T.<span class="built_in">dfs</span>(T.rt);    <span class="comment">// cerr &lt;&lt; endl;</span>    <span class="comment">// for (int i = 1; i &lt;= n + Q; i++)</span>    <span class="comment">//     cerr &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; to[i] &lt;&lt; endl;</span>    <span class="type">int</span> nodes = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">assign</span>(to[++nodes], a[i]);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)    &#123;        <span class="keyword">auto</span> [op, x, y] = q[i];        <span class="keyword">if</span> (op == <span class="number">1</span>)            <span class="built_in">write</span>(<span class="built_in">queryTuple</span>(to[x], to[y]), <span class="string">&#x27;\n&#x27;</span>);        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)            <span class="built_in">assign</span>(to[x], y);        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>)            <span class="built_in">assign</span>(to[x], <span class="number">0</span>);        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>)            <span class="built_in">assign</span>(to[++nodes], y);        <span class="keyword">else</span>            <span class="built_in">write</span>(<span class="built_in">queryKinds</span>(to[x], to[y]), <span class="string">&#x27;\n&#x27;</span>);    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1736C2 Good Subarrays (Hard Version)</title>
      <link href="/archives/CF1736C2/"/>
      <url>/archives/CF1736C2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定长度为 $n$ 的序列 $a$，定义一个序列 $b$ 是好的，当且仅当对于所有 $i$ 都有 $b_i\geq i$。</p><p>给出 $q$ 次修改，每次修改给出 $p,x$ 表示 $a_p\gets x$。每次修改之后求出好的<strong>子串</strong>的数量。</p><p><strong>询问独立，也就是本次修改不影响下一次的序列。</strong></p><p>$1\leq n,q\leq 2\times 10^5$，$1\leq a_i,p,x\leq n$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>2400？1400！</p><p>不难发现修改了这个位置，要么是原来瓶颈卡在这里的序列变长了，要么是更长的序列到这里就瓶颈了。</p><p>考虑给修改分类。</p><ol><li><p>$a_p&#x3D;x$</p><p> 这是最好做的。直接回答原序列的答案即可。</p><p> 不难发现 $l&#x3D;i+1$ 的右端点一定不小于 $l&#x3D;i$ 的右端点。原序列答案双指针维护 $l,r$，每次尝试扩展 $r$，记 $f_i$ 表示 $i$ 开始的最长的好的序列的长度，$g_i$ 表示 $i$ 开始的最长好的序列的结束点。</p><p> $\sum\limits_{i&#x3D;1}^n f_i$ 即为答案。</p></li><li><p>$x\gt a_p$</p><p> 这就对应了『原来瓶颈卡在这里的序列变长了』的情况。</p><p> 在双指针预处理 $f_i,g_i$ 的时候同时维护 $h_i,t_i$ 表示 $i$ 开始的<strong>中间允许不满足一次</strong>最长的好的序列的长度，$t_i$ 表示 $i$ 开始的<strong>中间允许不满足一次</strong>最长好的序列的结束点。</p><p> 同时用 $vec_i$ 存下右端点为 $i$ 的所有左端点。</p><p> 二分 $vec_{p-1}$ 中的内容。找到第一个 $t_i\geq p$ 的点 $l$，和最后一个 $t_i\geq p$ 的点 $r$。那么 $i\in[l,r]$ 的都可以造成 $h_i$ 的贡献。$i\in[1,l-1]$ 和 $i\in [r+1,n]$ 的只能造成原有的 $f_i$ 的贡献。</p><p> 二分注意一个边界条件是 $i\geq p-x+1$。必须先满足这个条件才可能让 $p$ 不是瓶颈。</p></li><li><p>$x\lt a_p$</p><p> 这就对应了『更长的序列到这里就瓶颈』的情况。</p><p> 还是考虑哪一部分回到这里变成瓶颈。刚才说 $i\geq p-x+1$ 才能让 $p$ 不是瓶颈，那么 $i\lt p-x+1$ 就一定都是瓶颈。</p><p> $[1,p-x]$ 里二分，找到第一个 $g_i\geq p$ 的点 $l$ 和最后一个 $r$，这里面必须卡到 $p$ 就结束。贡献是 $(p-l+1)+(p-(l+1)-1)+(p-(l+2)-1)+\cdots +(p-r-1)$。</p><p> $i\in[1,l-1]$ 和 $i\in [r+1,n]$ 的还是只能造成原有的 $f_i$ 的贡献。</p></li></ol><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://codeforces.com/contest/1736/submission/284879626">CF submission 284879626</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span></span><span class="function"></span>&#123;    <span class="type">static</span> <span class="type">int</span> stk[<span class="number">30</span>];    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;    <span class="type">int</span> top = <span class="number">0</span>;    <span class="keyword">do</span>    &#123;        stk[top++] = x % <span class="number">10</span>, x /= <span class="number">10</span>;    &#125; <span class="keyword">while</span> (x);    <span class="keyword">while</span> (top)        <span class="built_in">putchar</span>(stk[--top] + <span class="string">&#x27;0&#x27;</span>);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x, <span class="type">char</span> lastChar)</span> </span>&#123; <span class="built_in">write</span>(x), <span class="built_in">putchar</span>(lastChar); &#125;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="type">int</span> n, q;<span class="type">int</span> a[<span class="number">200020</span>];ll f[<span class="number">200020</span>];<span class="type">int</span> g[<span class="number">200020</span>];ll h[<span class="number">200020</span>];<span class="type">int</span> t[<span class="number">200020</span>];vector&lt;<span class="type">int</span>&gt; vec[<span class="number">200020</span>];ll ans;ll cnt;<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, k = <span class="number">0</span>;    <span class="keyword">while</span> (l &lt;= n)    &#123;        <span class="keyword">while</span> (r + <span class="number">1</span> &lt;= n &amp;&amp; a[r + <span class="number">1</span>] &gt;= r + <span class="number">1</span> - l + <span class="number">1</span>)            r++;        k = <span class="built_in">min</span>(n, <span class="built_in">max</span>(k, r + <span class="number">1</span>));        <span class="keyword">while</span> (k + <span class="number">1</span> &lt;= n &amp;&amp; a[k + <span class="number">1</span>] &gt;= k + <span class="number">1</span> - l + <span class="number">1</span>)            k++;        h[l] = (t[l] = k) - l + <span class="number">1</span>;        cnt += (f[l] = (g[l] = r) - l + <span class="number">1</span>);        vec[r].<span class="built_in">push_back</span>(l);        l++;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)        f[i] += f[i + <span class="number">1</span>];    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)        h[i] += h[i + <span class="number">1</span>];&#125;<span class="function">ll <span class="title">S</span><span class="params">(ll l, ll r)</span> </span>&#123; <span class="keyword">return</span> l &gt; r ? <span class="number">0</span> : (l + r) * (r - l + <span class="number">1</span>) / <span class="number">2</span>; &#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(n);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">read</span>(a[i]);    <span class="built_in">init</span>();    <span class="built_in">read</span>(q);    <span class="keyword">while</span> (q--)    &#123;        <span class="type">int</span> p, x;        <span class="built_in">read</span>(p, x);        <span class="keyword">if</span> (x == a[p])        &#123;            <span class="built_in">write</span>(cnt, <span class="string">&#x27;\n&#x27;</span>);            <span class="keyword">continue</span>;        &#125;        ll ans = <span class="number">0</span>;        <span class="comment">// x &gt;= p - l + 1</span>        <span class="comment">// l &gt;= p - x + 1</span>        <span class="keyword">if</span> (x &gt; a[p])        &#123;            <span class="keyword">if</span> (vec[p - <span class="number">1</span>].<span class="built_in">empty</span>())            &#123;                <span class="built_in">write</span>(cnt, <span class="string">&#x27;\n&#x27;</span>);                <span class="keyword">continue</span>;            &#125;            <span class="type">int</span> L = <span class="built_in">max</span>(p - x + <span class="number">1</span>, vec[p - <span class="number">1</span>].<span class="built_in">front</span>()), R = vec[p - <span class="number">1</span>].<span class="built_in">back</span>();            <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;            <span class="keyword">while</span> (L &lt;= R)            &#123;                <span class="type">int</span> mid = L + R &gt;&gt; <span class="number">1</span>;                <span class="keyword">if</span> (t[mid] &gt;= p)                    R = (l = mid) - <span class="number">1</span>;                <span class="keyword">else</span>                    L = mid + <span class="number">1</span>;            &#125;            L = l, R = vec[p - <span class="number">1</span>].<span class="built_in">back</span>();            <span class="keyword">while</span> (L &lt;= R)            &#123;                <span class="type">int</span> mid = L + R &gt;&gt; <span class="number">1</span>;                <span class="keyword">if</span> (t[mid] &gt;= p)                    L = (r = mid) + <span class="number">1</span>;                <span class="keyword">else</span>                    R = mid - <span class="number">1</span>;            &#125;            ans += h[l] - h[r + <span class="number">1</span>];            ans += f[r + <span class="number">1</span>];            ans += f[<span class="number">1</span>] - f[l];        &#125;        <span class="keyword">if</span> (x &lt; a[p])        &#123;            <span class="type">int</span> L = <span class="number">1</span>, R = p - x;            <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;            <span class="keyword">while</span> (L &lt;= R)            &#123;                <span class="type">int</span> mid = L + R &gt;&gt; <span class="number">1</span>;                <span class="keyword">if</span> (g[mid] &gt;= p)                    R = (l = mid) - <span class="number">1</span>;                <span class="keyword">else</span>                    L = mid + <span class="number">1</span>;            &#125;            L = l, R = p - x;            <span class="keyword">while</span> (L &lt;= R)            &#123;                <span class="type">int</span> mid = L + R &gt;&gt; <span class="number">1</span>;                <span class="keyword">if</span> (g[mid] &gt;= p)                    L = (r = mid) + <span class="number">1</span>;                <span class="keyword">else</span>                    R = mid - <span class="number">1</span>;            &#125;            ans += <span class="built_in">S</span>(p - r, p - l);            ans += f[r + <span class="number">1</span>];            ans += f[<span class="number">1</span>] - f[l];        &#125;        <span class="built_in">write</span>(ans, <span class="string">&#x27;\n&#x27;</span>);    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF2008H Sakurako&#39;s Test</title>
      <link href="/archives/CF2008H/"/>
      <url>/archives/CF2008H/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定一个长度为 $n$ 的序列 $a$，你可以每次选择一个 $i$ 满足 $a_i\geq x$ 并且执行 $a_i\gets a_i-x$。</p><p>现在给出 $q$ 个询问，每次给出一个 $x$，查询操作之后序列的最小中位数是多少。</p><p>$1\leq n,q,\sum n,\sum q\leq 10^5$，$1\leq a_i,x\leq n$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>把每一个 $a_i$ 都减到 $\lt x$ 的部分肯定不劣。</p><p>还是套路性的二分中位数，统计 $\leq mid$ 的个数共有多少即可。</p><p>又联想到 $a_i\bmod x&#x3D;a_i-\lfloor\dfrac{a_i}{x}\rfloor\times x$，按 $\lfloor\dfrac{a_i}{x}\rfloor$ 分类即可。这至多有 $\lfloor\dfrac{n}{x}\rfloor$ 段。</p><p>先对 $a_i$ 做前缀和，$sum_i$ 表示 $\leq i$ 有多少数。这样可以 $\mathcal O(1)$ 求出区间内的数的个数。</p><p>之后维护两个数 $l,r$，初始 $l\gets 0,r\gets x-1$，之后跳 $l\gets l+x,r\gets r+x$，做一个前缀和就可以算出 $[l,l+mid]$ 内的数的个数。注意前缀和边界问题。</p><p>又由于 $\sum\limits_{i&#x3D;1}^n \frac{n}{i} &#x3D; n\log n$，所以对于 $x$ 记忆化之后就是本质不同的 $x$，$l\gets l+x,r\gets r+x$ 这个跳的过程至多 $\mathcal O(n\log n)$ 段。加上二分的 $\log$ 复杂度就是 $\mathcal O(n\log^2n)$ 的。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://codeforces.com/contest/2008/submission/279211847">CF submission 279211847</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span></span><span class="function"></span>&#123;    <span class="type">static</span> <span class="type">int</span> stk[<span class="number">30</span>];    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;    <span class="type">int</span> top = <span class="number">0</span>;    <span class="keyword">do</span>    &#123;        stk[top++] = x % <span class="number">10</span>, x /= <span class="number">10</span>;    &#125; <span class="keyword">while</span> (x);    <span class="keyword">while</span> (top)        <span class="built_in">putchar</span>(stk[--top] + <span class="string">&#x27;0&#x27;</span>);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x, <span class="type">char</span> lastChar)</span> </span>&#123; <span class="built_in">write</span>(x), <span class="built_in">putchar</span>(lastChar); &#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n, q;    <span class="built_in">read</span>(n, q);    <span class="type">int</span> a[n + <span class="number">1</span>] = &#123;&#125;;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">read</span>(a[i]);    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);    <span class="type">int</span> sum[n + <span class="number">1</span>] = &#123;&#125;;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        sum[a[i]]++;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        sum[i] += sum[i - <span class="number">1</span>];    <span class="type">int</span> vis[n + <span class="number">1</span>];    <span class="built_in">memset</span>(vis, <span class="number">-1</span>, <span class="built_in">sizeof</span>(vis));    <span class="keyword">while</span> (q--)    &#123;        <span class="type">int</span> x;        <span class="built_in">read</span>(x);        <span class="keyword">if</span> (~vis[x])        &#123;            <span class="built_in">write</span>(vis[x], <span class="string">&#x27; &#x27;</span>);            <span class="keyword">continue</span>;        &#125;        <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> mid)        &#123;            <span class="type">int</span> cnt = <span class="number">0</span>;            <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = x - <span class="number">1</span>; l &lt;= n; l += x, r += x)                cnt += (sum[<span class="built_in">min</span>(&#123;l + mid, r, n&#125;)]) - (sum[<span class="built_in">max</span>(<span class="number">0</span>, l - <span class="number">1</span>)]);            <span class="keyword">return</span> cnt &gt;= (n + <span class="number">2</span>) / <span class="number">2</span>;        &#125;;        <span class="type">int</span> L = <span class="number">0</span>, R = n + <span class="number">20</span>, ans = n + <span class="number">20</span>;        <span class="keyword">while</span> (L &lt;= R)        &#123;            <span class="type">int</span> mid = L + R &gt;&gt; <span class="number">1</span>;            <span class="keyword">if</span> (<span class="built_in">check</span>(mid))                R = (ans = mid) - <span class="number">1</span>;            <span class="keyword">else</span>                L = mid + <span class="number">1</span>;        &#125;        vis[x] = ans;        <span class="built_in">write</span>(vis[x], <span class="string">&#x27; &#x27;</span>);    &#125;    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> t;    cin &gt;&gt; t;    <span class="keyword">while</span> (t--)        <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF2014H Robin Hood Archery</title>
      <link href="/archives/CF2014H/"/>
      <url>/archives/CF2014H/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>有一个长度为 $n$ 的序列 $a$。</p><p>A 和 B 进行决斗。</p><p>决斗指每个人在选择一个数之后删除，全部选完之后比较谁选择的数之和更大。，</p><p>一共进行 $q$ 次，每次决斗范围是 $[l,r]$。也就是两人只可以用 $a_l,a_{l+1},\dots,a_{r-1},a_r$ 这 $r-l+1$ 个数。</p><p>B 先手，判断每次决斗 A 是否不会输，也就是 A 选择的数不小于 B 选择的数。</p><p>$1\leq n,q,\sum n,\sum q\leq 2\times 10^5$，$1\leq a_i\leq 10^6$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>显然 A 和 B 都会选择目前最大的数。</p><p>如果此时有奇数个数可选，B 每次选最大，而且多拿一次，一定会比 A 拿到的要大。</p><p>如果有偶数个数，大部分情况 B 也会比 A 拿得多。除非 $a_l,a_{l+1},\dots,a_{r-1},a_r$ 可以两两匹配，也就是分成两个完全相同的序列。那么 B 拿什么 A 就跟着拿什么，就会平局。</p><p>因此我们判断 $a_l,a_{l+1},\dots,a_{r-1},a_r$ 是否可以两两抵消。考虑到异或有 $0\oplus x&#x3D;x$ 且 $x\oplus x&#x3D;0$，判断 $a_l,a_{l+1},\dots,a_{r-1},a_r$ 异或和是否为 $0$ 即可。</p><p>但这随便 hack 都能死。不妨随机赋权，把 $[1,10^6]$ 映射到一个极大范围，一般我们选择 $[0,2^{64})$ 也就是 C++ 中 unsigned long long 的范围。之后再使用异或哈希。</p><h1 id="正义制裁"><a href="#正义制裁" class="headerlink" title="正义制裁"></a>正义制裁</h1><p>这个做法真的是对的吗？</p><p>不难发现，我们如果知道了随机种子，我们用 $\log$ 个数就可以构造一个两两不同但是异或为 $0$ 的序列。</p><p>如何找到这样的序列？我们可以使用线性基。如果插入发现这个数已经被基内的数凑出来了那么就说明这些异或起来为 $0$。</p><p>具体的，我们知道了对方的随机种子和随机生成方法，按着他的方法生成随机数，扔到基内，直到基没有成功插入这个值。期望 $\log$ 个数就可以干掉一个随机方法。</p><p>例子是 <a href="https://codeforces.com/contest/2014/submission/282293924">https://codeforces.com/contest/2014/submission/282293924</a> 和 <a href="https://codeforces.com/contest/2014/submission/282345418">https://codeforces.com/contest/2014/submission/282345418</a>。前者使用了没有给种子，但是也相当于生成方式固定。后者使用了固定种子 $10^{18}$。</p><p>但是为什么有人使用了 time(0) 也被我卡了？例如 74TrAkToR 的 <a href="https://codeforces.com/contest/2014/submission/282303785">https://codeforces.com/contest/2014/submission/282303785</a>。<del>薄纱 74，最正义的一集。</del></p><p>考虑到 time(0) 本质是秒为单位的时间戳，我们虽然不知道 hack 的时候的具体时间，但是可以，跑出此刻开始 200s 的时间戳作为种子的 hack，提交上去。</p><p>但是 CF 时间和本地时间似乎有区别，可以在 custom test 里测一下。我测了一下跑出 $[t-200,t]$ 的时间戳的 hack 即可。其中 $t$ 是本地目前时间。</p><p>那么为了避免被卡，推荐使用 <code>random_device</code> 或者 <code>chrono::system_clock::now().time_since_epoch().count()</code> 作为种子。前者不太懂原理，cppreference 上的描述是：</p><blockquote><p>std::random_device may be implemented in terms of an implementation-defined pseudo-random number engine if a non-deterministic source (e.g. a hardware device) is not available to the implementation. In this case each std::random_device object may generate the same number sequence.</p></blockquote><p><del>后者是毫秒级别的。理论上后者也可以被叉掉，但是需要刻意控制时间到很精密的时刻，</del>正常人指定干不出这种事<del>。即使在本题控制 10s 的 hack 也需要 $10^4$ 组，带上前面的 $\log$ 还是有点困难的。并且除了本题，有点题的 hack 规模可能不止 $\log$。实在是太难卡。</del></p><p>感谢 @<a href="/user/175087">Z_301</a> 提醒，后者不加限制直接调用是纳秒级别的。那么用后面的是根本不会被卡的。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://codeforces.com/contest/2014/submission/282295625">CF submission 282295625</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span></span><span class="function"></span>&#123;    <span class="type">static</span> <span class="type">int</span> stk[<span class="number">30</span>];    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;    <span class="type">int</span> top = <span class="number">0</span>;    <span class="keyword">do</span>    &#123;        stk[top++] = x % <span class="number">10</span>, x /= <span class="number">10</span>;    &#125; <span class="keyword">while</span> (x);    <span class="keyword">while</span> (top)        <span class="built_in">putchar</span>(stk[--top] + <span class="string">&#x27;0&#x27;</span>);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x, <span class="type">char</span> lastChar)</span> </span>&#123; <span class="built_in">write</span>(x), <span class="built_in">putchar</span>(lastChar); &#125;<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;<span class="function">mt19937_64 <span class="title">rnd</span><span class="params">(chrono::system_clock::now().time_since_epoch().count())</span></span>;<span class="type">int</span> n, q;ull a[<span class="number">200020</span>];ull to[<span class="number">1000020</span>];<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(n, q);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="built_in">read</span>(a[i]);        a[i] = a[i - <span class="number">1</span>] ^ to[a[i]];    &#125;    <span class="keyword">while</span> (q--)    &#123;        <span class="type">int</span> l, r;        <span class="built_in">read</span>(l, r);        <span class="keyword">if</span> (r - l + <span class="number">1</span> &amp; <span class="number">1</span>)        &#123;            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);            <span class="keyword">continue</span>;        &#125;        <span class="built_in">puts</span>(a[r] == a[l - <span class="number">1</span>] ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);    &#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++)        to[i] = <span class="built_in">rnd</span>();    <span class="type">int</span> t;    <span class="built_in">read</span>(t);    <span class="keyword">while</span> (t--)        <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p>Hack Generator 直接找 <a href="https://www.luogu.com.cn/problem/P3812">P3812 【模板】线性基</a> 的任意代码。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1221G Graph And Numbers</title>
      <link href="/archives/CF1221G/"/>
      <url>/archives/CF1221G/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定 $n$ 个点 $m$ 条边的图，定义边权为边连接的端点点权之和。你可以为点权赋值 $0$ 或 $1$，求<strong>同时</strong>存在至少一条边权为 $0$ 的边，存在至少一条边权为 $1$ 的边，存在至少一条边权为 $2$ 的边的方案数。</p><p>$1\leq n\leq 40$，$0\leq m\leq \dfrac{n(n-1)}{2}$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>$m&#x3D;0$ 显然答案为 $0$，是个 corner case 要判掉。</p><p>考虑先把答案容斥出来。设 $S_{ {k} }$ 表示<strong>可以</strong>包含为 $k$ 的边权的方案数。$ans&#x3D;S_{ {0,1,2} }-S_{ {0,1} }-S_{ {0,2} }-S_{ {1,2} }+S_{ {0} }+S_{ {1} }+S_{ {2} }-S_{\emptyset}$。</p><p>由于已经判掉了 $m&#x3D;0$ 所以 $S_{\emptyset}&#x3D;0$。</p><p>不难发现 $S_{ {0,1,2} }&#x3D;2^n$ 也就是每个点任意选的方案。</p><p>接下来处理 $S_{ {0,1} },S_{ {0,2} },S_{ {1,2} },S_{ {0} },S_{ {1} },S_{ {2} }$。</p><p>不难发现 $S_{ {0,1} }$ 与 $S_{ {1,2} }$ 等价，而 $S_{ {0} }$ 与 $S_{ {2} }$ 也等价。</p><p>我们只需要算出 $S_{ {0,1} },S_{ {0,2} },S_{ {0} },S_{ {1} }$ 即可。</p><p>$S_{ {0} }$ 孤点可以随便选，而 $size\gt 1$ 的联通块必须全选 $0$。也就是设 $x$ 为孤点数量，则 $S_{ {0} }&#x3D;2^x$。$x$ 可以并查集求出。</p><p>$S_{ {1} }$ 那相邻点点权不同，不难联想到二分图。这等价于对原图做二分图染色的方案数。由于原图不一定联通，若会分成 $y$ 个联通块。如果 $y$ 个联通块都是二分图，则 $S_{ {1} }&#x3D;2^y$，否则 $S_{ {1} }&#x3D;0$，这可以直接跑二分图染色进行判定。</p><p>$S_{ {0,2} }$ 那么每个联通块要么是全 $0$ 要么是全 $1$。设 $z$ 为原图联通块个数，则 $S_{ {0,2} }&#x3D;2^z$。这也可以并查集得到 $z$。</p><p>$S_{ {0,1} }$ 就是原图的独立集个数。考虑若点权为 $1$ 看做是独立集中的点，点权为 $0$ 表示不是。不难发现这恰好满足了点权为 $1$ 的点不能相邻。</p><p>一般图独立集计数是困难的。但是数据范围启发我们折半搜索。</p><p>设 $h&#x3D;\lceil\dfrac{n}{2}\rceil$。我们 $\mathcal O(2^{n&#x2F;2})$ 枚举 $[1,h]$ 的点是否在独立集中，并且 $\mathcal O(n^2)$ 判掉是否存在边 $(x,y)$ 满足 $x,y\in [1,h]$ 且 $x,y$ 都在独立集中。</p><p>同理 $[h+1,n]$ 也可以这样算出来。</p><p>之后枚举 $[1,h]$ 的合法状态。我们根据这个合法状态，能够得到若干条限制。每条限制形如：$[h+1,n]$ 中的点 $x$ 不可以出现在独立集中。</p><p>我们对限制取补集，那么这个补集的所有子集，都是合法的可以构成独立集的。对于 $[h+1,n]$ 的状态做高维前缀和即可。</p><p>时间复杂度瓶颈在计算 $S_{ {0,1} }$ 上。复杂度为 $\mathcal O(2^{n&#x2F;2} n^2)$。其余别的都是线性或者带一个并查集的 $\alpha(n)$。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://codeforces.com/problemset/submission/1221/283754107">CF submission 283754107</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="type">int</span> fa[<span class="number">40</span>];<span class="type">int</span> sz[<span class="number">40</span>];<span class="type">int</span> tot, o;<span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123; <span class="keyword">return</span> fa[u] ^ u ? fa[u] = <span class="built_in">F</span>(fa[u]) : u; &#125;<span class="function"><span class="type">void</span> <span class="title">U</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span><span class="function"></span>&#123;    u = <span class="built_in">F</span>(u), v = <span class="built_in">F</span>(v);    <span class="keyword">if</span> (u == v)        <span class="keyword">return</span>;    sz[v] += sz[u];    sz[u] = <span class="number">0</span>;    fa[u] = v;&#125;<span class="type">int</span> n, m;<span class="type">int</span> hf;<span class="type">bool</span> e[<span class="number">40</span>][<span class="number">40</span>];ll f[<span class="number">1</span> &lt;&lt; <span class="number">20</span>];ll g[<span class="number">1</span> &lt;&lt; <span class="number">20</span>];<span class="function">ll <span class="title">calc_any</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1LL</span> &lt;&lt; n; &#125;<span class="function">ll <span class="title">calc_01</span><span class="params">()</span></span><span class="function"></span>&#123;    ll ans = <span class="number">0</span>;    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="built_in">sizeof</span>(g));    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; <span class="number">1</span> &lt;&lt; hf; mask++)    &#123;        <span class="type">bool</span> ok = <span class="number">1</span>;        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; hf; x++)        &#123;            <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; hf; y++)            &#123;                <span class="keyword">if</span> (!e[x][y])                    <span class="keyword">continue</span>;                <span class="keyword">if</span> ((mask &gt;&gt; x &amp; <span class="number">1</span>) &amp;&amp; (mask &gt;&gt; y &amp; <span class="number">1</span>))                &#123;                    ok = <span class="number">0</span>;                    <span class="keyword">break</span>;                &#125;            &#125;            <span class="keyword">if</span> (!ok)                <span class="keyword">break</span>;        &#125;        f[mask] = ok;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; <span class="number">1</span> &lt;&lt; n - hf; mask++)    &#123;        <span class="type">bool</span> ok = <span class="number">1</span>;        <span class="keyword">for</span> (<span class="type">int</span> x = hf; x &lt; n; x++)        &#123;            <span class="keyword">for</span> (<span class="type">int</span> y = hf; y &lt; n; y++)            &#123;                <span class="keyword">if</span> (!e[x][y])                    <span class="keyword">continue</span>;                <span class="keyword">if</span> ((mask &gt;&gt; x - hf &amp; <span class="number">1</span>) &amp;&amp; (mask &gt;&gt; y - hf &amp; <span class="number">1</span>))                &#123;                    ok = <span class="number">0</span>;                    <span class="keyword">break</span>;                &#125;            &#125;            <span class="keyword">if</span> (!ok)                <span class="keyword">break</span>;        &#125;        g[mask] = ok;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - hf; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; <span class="number">1</span> &lt;&lt; n - hf; mask++)        &#123;            <span class="keyword">if</span> (mask &gt;&gt; i &amp; <span class="number">1</span>)                g[mask] += g[mask ^ (<span class="number">1</span> &lt;&lt; i)];        &#125;    &#125;    <span class="type">const</span> <span class="type">int</span> full = (<span class="number">1</span> &lt;&lt; n - hf) - <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> maskX = <span class="number">0</span>; maskX &lt; <span class="number">1</span> &lt;&lt; hf; maskX++)    &#123;        <span class="keyword">if</span> (!f[maskX])            <span class="keyword">continue</span>;        <span class="type">int</span> maskY = <span class="number">0</span>;        <span class="type">bool</span> ok = <span class="number">1</span>;        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; hf; x++)        &#123;            <span class="keyword">for</span> (<span class="type">int</span> y = hf; y &lt; n; y++)            &#123;                <span class="keyword">if</span> (!e[x][y])                    <span class="keyword">continue</span>;                <span class="keyword">if</span> (maskX &gt;&gt; x &amp; <span class="number">1</span>)                    maskY |= <span class="number">1</span> &lt;&lt; y - hf;            &#125;        &#125;        ans += f[maskX] * g[full ^ maskY];    &#125;    <span class="keyword">return</span> ans;&#125;<span class="function">ll <span class="title">calc_02</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1LL</span> &lt;&lt; tot; &#125;<span class="function">ll <span class="title">calc_12</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">calc_01</span>(); &#125;<span class="function">ll <span class="title">calc_0</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1LL</span> &lt;&lt; o; &#125;<span class="function">ll <span class="title">calc_1</span><span class="params">()</span></span><span class="function"></span>&#123;    ll ans = <span class="number">1</span>;    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">col</span><span class="params">(n, <span class="number">-1</span>)</span></span>;    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> self, <span class="type">int</span> u, <span class="type">int</span> c) -&gt; <span class="type">void</span>    &#123;        col[u] = c;        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v++)        &#123;            <span class="keyword">if</span> (!e[u][v])                <span class="keyword">continue</span>;            <span class="keyword">if</span> (~col[v])            &#123;                <span class="keyword">if</span> (col[v] == c)                    ans = <span class="number">0</span>;                <span class="keyword">continue</span>;            &#125;            <span class="built_in">self</span>(self, v, c ^ <span class="number">1</span>);        &#125;    &#125;;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)    &#123;        <span class="keyword">if</span> (~col[i])            <span class="keyword">continue</span>;        <span class="built_in">dfs</span>(dfs, i, <span class="number">0</span>);        ans &lt;&lt;= <span class="number">1</span>;    &#125;    <span class="keyword">return</span> ans;&#125;<span class="function">ll <span class="title">calc_2</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">calc_0</span>(); &#125;<span class="function">ll <span class="title">calc_none</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    hf = n + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;    <span class="keyword">if</span> (!m)        <span class="keyword">return</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl, <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)        fa[i] = i, sz[i] = <span class="number">1</span>;    <span class="keyword">while</span> (m--)    &#123;        <span class="type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        x--, y--;        <span class="built_in">U</span>(x, y);        e[x][y] = e[y][x] = <span class="number">1</span>;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)    &#123;        <span class="keyword">if</span> (<span class="built_in">F</span>(i) == i)            tot++, o += sz[i] == <span class="number">1</span>;    &#125;    <span class="comment">// cout &lt;&lt; calc_any() &lt;&lt; endl</span>    <span class="comment">//      &lt;&lt; calc_01() &lt;&lt; endl</span>    <span class="comment">//      &lt;&lt; calc_02() &lt;&lt; endl</span>    <span class="comment">//      &lt;&lt; calc_12() &lt;&lt; endl</span>    <span class="comment">//      &lt;&lt; calc_0() &lt;&lt; endl</span>    <span class="comment">//      &lt;&lt; calc_1() &lt;&lt; endl</span>    <span class="comment">//      &lt;&lt; calc_2() &lt;&lt; endl</span>    <span class="comment">//      &lt;&lt; calc_none() &lt;&lt; endl;</span>    cout &lt;&lt; <span class="built_in">calc_any</span>() - <span class="built_in">calc_01</span>() - <span class="built_in">calc_02</span>() - <span class="built_in">calc_12</span>() + <span class="built_in">calc_0</span>() + <span class="built_in">calc_1</span>() + <span class="built_in">calc_2</span>() - <span class="built_in">calc_none</span>() &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">任意 - 有 01 - 有 02 - 有 12 + 有 0 + 有 1 + 有 2 - 都没有</span><span class="comment"></span><span class="comment">任意 2 ^ n</span><span class="comment"></span><span class="comment">有 01 == 有 12</span><span class="comment">有 0 == 有 2</span><span class="comment"></span><span class="comment">有 02</span><span class="comment">有 1</span><span class="comment"></span><span class="comment">都没有 2 ^ n</span><span class="comment"></span><span class="comment">corner: m == 0</span><span class="comment">*/</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[游记] CSP 2024 游记</title>
      <link href="/archives/CSP2024/"/>
      <url>/archives/CSP2024/</url>
      
        <content type="html"><![CDATA[<h1 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h1><h2 id="Day-1e9-7"><a href="#Day-1e9-7" class="headerlink" title="Day -(1e9+7)"></a>Day -(1e9+7)</h2><p>好吧我其实忘了 Day -(1e9+7) 和 Day -998244353 的先后顺序。</p><p>所以可能这里其实才是 Day -998244353 发生的事情。</p><p>很荣幸收到了 Aya 的私信找我验初赛模拟。</p><p>做了一下感觉选择问题不大。阅读和完善到处开花。</p><p>成功砍下 62.5 分高分。</p><p>好像是验题人倒数第二还是倒数第一来着。</p><p>尺子阿克，太强大。</p><h2 id="Day-998244353"><a href="#Day-998244353" class="headerlink" title="Day -998244353"></a>Day -998244353</h2><p>报名了爱死组且缴费了。</p><p>但我顺手把勾组报了，然后没缴费，有神秘短信私信我让我缴费。我不认识啊。可能是转学了新学校老师给我发的。</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h2><p>怎么要初赛了。以前在常外每周还能做初赛卷。现在只能自己复习了。</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p>不是哥们云斗初赛解析这么多锅？</p><p>常外教练老秦怎么在云斗群看见我了。让我重写一份解析。&#x2F;shui</p><p>顺便还把出模拟赛的钱转我了&#x2F;se</p><p>vp 了一下去年 S 组，瞎做，提交发现 66 分。这不对吧。</p><p>看了一下我一车正确错误选错了，可能是划来划去导致小题题号我看错了。</p><p>重新填了一下高了二十分。6。</p><p>明天目标是，不涂错卡。</p><p>偷偷打了一晚上雀。还没上雀士。</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>早上忘了睡到几点了，起来吃了个午饭打了会儿雀就走了。</p><p>早上一睁眼看消息就看到粉兔在无锡一中考。原来昨天沃若发的床上照片是小粉兔。</p><p>坐地铁到常州站然后火车到无锡站。</p><p>下车在火车站打出租车，一上车司机就吐槽等了两小时等到我们去无锡一中，两小时才赚十多块。还让多付两三块。</p><p>啊？</p><p>我怎么是全考点最早到的。</p><p>保安来和我聊天说让我以后考无锡一中。啊？</p><p>然后还来个家长和我聊初赛。我擦我第一次在无锡考我咋知道无锡情况。只能说我第一次考喽。</p><p>逮捕到了 wrkwrkwrk。两个人进行了一个校门口的随机游走。</p><p>Ivan 来了看 Ivan 开了一把玉之间。二位掉分了。然后就顺着天一的队伍混进去了。</p><p>【暴戾语言过滤】irris 让我迎接他。我看到一个猥琐男拿着手机对着我就跑了。</p><p>到了报告厅。坐在了 irris 旁边。</p><p>Anny 说找不到位置。赶紧给她拍个视频。</p><p>ET 来了但是瞎猪 ET 没找到我。然后发现我在 irris 旁边。联合 irris 把我撅了。</p><p>手机还被抢走了。和她的聊天记录被转发出来了。</p><p>呜呜呜。</p><p>兔子不是说在无锡一中吗，怎么没人。</p><p>原来是开考前半小时刚起。</p><p>选择了跟着大部队去排队。</p><p>我擦，小 cyh 怎么也在。我是不是看错了。</p><p>不对他怎么来找我了，真是 cyh。</p><p>小 cyh 竟然润天一了，太牛。</p><p>有哥们来找我面基。牛牛牛。</p><p>【暴戾语言过滤】irris 怎么在大喊 “我是 沉石鱼惊旋。我是高贵的洛谷管理员。”</p><p>【暴戾语言过滤】。</p><p>进考场看见【保护隐私】直勾勾往女厕进了。啊？赶紧给他喊出来。</p><p>我座位在最后一排，旁边一个省锡中哥一个小朋友。</p><p>拿到试卷看了一眼感觉都不是很难啊，两个完善程序我甚至都做过原题。阅读程序扫了一眼也知道在干啥了。一个快排，一个 DP 和暴力，一个树哈希。</p><p>选择题过程非常不顺利。做完就感觉不大妙啊。</p><p>欧拉图是啥我不知道啊。</p><p>哈希这个咋做，给了 $\alpha$ 是不是就要选带 $\alpha$ 的，但我咋记得是 $\mathcal O(n)$？不管了选个带 $\alpha$ 的。事实上暴毙了哦。</p><p>四元环计数也不会。这个要不要考虑起点不同但是点集相同啊，不知道。好像又 WA 这个了。</p><p>选择最后一题不是我们平面图转对偶图吗，偷笑。</p><p>但是不是很会。加上我其实还看错边方向了，又 WA 了。</p><p>阅读程序 T1 一眼了。这个 logic 函数有点怪。但是随便算算还是算出来了。</p><p>我擦嘞怎么还要判断 logic 在干啥。原来是按位或。</p><p>T1 秒了。</p><p>T2 一眼了这个 DP 是长度为 $m$ 的 $\tt{01}$ 串十进制下的数的和。诶那这个 solve2 和 solve 有啥区别？？？</p><p>摆了，跳 T3。</p><p>T3 也秒了。</p><p>完善程序 T1 怎么考二分写法这太邪恶了，乱选吧。我咋选了 4 个 A？<del>草正确答案是 5 个 A。</del></p><p>完善程序 T2 写的太抽象。怎么还考 memset 0x3f 和 0x1f。还好知道 0x3f 是 1e9 的。那就选 0x1f。</p><p>回去看阅读程序，原来一个算前导零一个不算。</p><p>考完感觉问题不大，应该能过（</p><p>和省锡中 4 巨头还有 Anny 合影就走了。</p><p>一上车就看见 irris 给我发消息说小粉兔要见我。草？？？上次在 nju 我没徽章没换到，这次都带徽章了没见到人。666666666666。</p><p>晚上 ABC 启动。二十分钟过了前五个，无敌。F 一眼会了。然后到了 70min 的时候才过。草。我甚至都不知道为什么交上去能过。赛后想了好久才懂，</p><p>ABC 掉分了雀不能掉了吧。开雀。给我从初心三大圆满干到了初心三零分。&#x2F;wx&#x2F;wx&#x2F;wx。</p><p>洗个澡 CF。这个 H 不是一眼莫队？诶我看错题了捏麻麻。哦看对之后照样莫队。不对可以 xor hash。写了一发直接过。</p><p>很多人随机种子不是 random_device 或者毫秒微秒级别随机，杀杀杀。</p><h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>被我叉的老哥请教我 time(0) 为什么能被叉。显然我预处理 200 个左右的时间戳缝一起就死了。</p><p>怎么有群友亮出了自己被 hack 的记录。还是我干的。谢罪谢罪。</p><h1 id="复赛"><a href="#复赛" class="headerlink" title="复赛"></a>复赛</h1><h2 id="Day-1e9-7-1"><a href="#Day-1e9-7-1" class="headerlink" title="Day -(1e9+7)"></a>Day -(1e9+7)</h2><p>打洛谷模拟。</p><p>上午入门组口胡一下感觉不难。Ivan 挂了 5 分，获得了前 3% 的好成绩。&#x2F;qiang</p><p>下午提高，T1 看了一眼写了个子序列自动机很快就过了。T2 不会。然后玉玉了，思考了三个小时的人生顺便睡了一会儿。睡完半小时写了下 T3，过了。大家 T3 都挂分了？</p><h2 id="Day-998244353-1"><a href="#Day-998244353-1" class="headerlink" title="Day -998244353"></a>Day -998244353</h2><p>MX-J8。非常顺利。</p><p><del>赛后发现锅了。我钱近似被扣光了。</del></p><h2 id="Day-2-1"><a href="#Day-2-1" class="headerlink" title="Day -2"></a>Day -2</h2><p>忘了干啥了。晚上打了个 Div. 3，本来是涨信心的，结果被 G 创飞了。死因如下。</p><p><img src="https://s21.ax1x.com/2024/10/27/pA0nEhd.png"></p><h2 id="Day-1-2"><a href="#Day-1-2" class="headerlink" title="Day -1"></a>Day -1</h2><p>早上很晚起了，下午去世贸。发现我没写过点双，写个模板。然后随便背了一点，仅存的三个人就开了个空岛玩（）晚饭我点了个外卖就回家打牛客了。被牛客 D 的初中数学创飞了，什么破机子，这种 std 都是带 log 的大常你还开 1e6，【暴戾语言过滤】。</p><p>E 是搞笑题。F 是一个巨大无敌赤石模拟题。怎么没人过，我感觉写起来也不是很难啊？不管了不写了开摆了。</p><p>赛后发现 F 的 std 锅了，乐乐乐。</p><h2 id="Day-0-1"><a href="#Day-0-1" class="headerlink" title="Day 0"></a>Day 0</h2><p>牛客有验题人找我给我吐槽了出题人，D 和 F 都是大常 log 开 1e6。666。我还以为 F 有什么高超的线性。</p><p>真【暴戾语言过滤】。</p><p>早上十点半起了，好像还没出 J 组题。随便看看群下去吃了个饭买了一瓶红牛。</p><p>打车去 nuaa。看到 J 组题了，口胡了一下 T4，感觉不难。比去年稍微难一点点。</p><p>T4 考虑设 $f_{i,j}$ 表示第 $i$ 轮 $j$ 结尾是否可行，显然发现超过一组合法解就无效随便转移。只有一组就记录一下是哪一个。转移 $\mathcal O(\sum |s_i|)$ 枚举一下，容易双指针贪心做到 $\mathcal O(1)$ 判断并转移。</p><p>进去了，看到了 Anny1225 和 EasonTao。EasonTao 没看到 J T4 的 $r\leq 100$ 在场外口胡线段树优化建图。【暴戾语言过滤】。</p><p>看到了很多 CFS 新一届小朋友，但是都不认识我。难过哦。没看到大朋友。</p><p>上了个厕所进考场。键盘位置和我笔记本完全不一样，吐了，<code>\n</code> 总是按到 Enter 上。真就换行呗。</p><p>打了一个对拍，写了个线段树作为对拍的 test。记住这个线段树，后面要考。</p><p>其实由于键盘难绷我开场 5 min 才调完对拍。</p><p>T1 一眼 Dilworth 三分钟过了。</p><p>T2 一眼二分第二问随便做。写完第一问发现对第二问做前缀和是一个形如差分约束的东西，但是边权都是 $1$，还是个 DAG，直接 DP 就过了。</p><p>红温的来了。</p><p>想了一会儿 T3。先写了个指数的暴力，然后发现就是维护两个栈，显然只要维护栈顶，有一个朴素的 $\mathcal O(n\times A^2)$ 的做法。</p><p>对这个朴素做法优化，发现 DP 两维至少一维一定是 $a_i$。状态数是 $\mathcal O(a)$ 的，就有了一个 $\mathcal O(nA)$ 的了。</p><p>然后我对这个优化了好一会儿，发现是一个全局 max 和一堆单点全局操作。写了好久发现我的全局加打的 tag 有问题，无法区分时间影响，遂写线段树。</p><p>记住我对拍打的线段树，此时还剩大约半小时。我改了改剩 15 min 的时候过小样例，不想测大样例直接放到了拍子里。结果拍了一会儿 WA 了。我看见过了几十个点的时候很开心啊还在念叨着自己过了。&#x2F;ll</p><p>最后显然我没调完，大样例也是 wa 了没细看挂了几个。最后交了个 $\mathcal O(nA)$ 的上去。</p><p>这下这下了，对着 300 分打打了个 265。真菜。</p><p>听说王小蕊（not irris）打了 320。太牛。</p><p>还有一车人近似 ak 啊。太牛。</p><p>终于面到了兔子。换到了徽章。兔子一上来就压力我问我 ak 没。加上出考场问了一圈人均 300+，我很慌。结果兔子也不会 T4 只是为了压力我。6。</p><p>以及听我妈讲了个故事，据说小粉兔进考场是从一个很矮的闸机上跳过去的。真就兔子啊（）</p><p>CSP-S 2023 告诉我不要一个题写 3h，CSP-S 2024 告诉我不要一个题暴力过了，一个假的优化写 2.5h 还以为它对完了。</p><h1 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h1><p>故事的起源是，DP 题卡常卡红温了最后 1999ms 过了。看了眼官方题解，出题人脑子进水了 std 是 $\mathcal O(nk^2)$ 出 $n\leq 10^5$，$k\leq 52$。字符串字符集是大写字母和小写字母纯有病。卡常卡到了接近两点钟。</p><p>除去卡常的时间，想了一下自己为什么 2600 的 dp 可以挺快想到做法，怎么就过不去 CSP T3 这个 2100 的基础 dp。</p><p>问了一下 Ivan 觉得这个 T3 的线性做法是不是属于比较人类智慧的。然后问着问着我想起来我代码复杂度瓶颈部分是一个很愚蠢的 case。刚准备睡觉就起来把 65pts 的部分分代码改了一下，就过了。。。。。。。。。我做法复杂度瓶颈是 $a_i&#x3D;a_{i-1}$，大家都特判掉了这个情况的基础贡献。哈哈。哈哈。哈哈。</p><p>比赛打到一半还真就得上个厕所缓缓。。。</p>]]></content>
      
      
      <categories>
          
          <category> TravelNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1310C Au Pont Rouge</title>
      <link href="/archives/CF1310C/"/>
      <url>/archives/CF1310C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定长度为 $n$ 的字符串 $s$，将其分成 $m$ 个非空子串。定义一种划分方式的『代表』，是这 $m$ 个子串种，字典序最小的那个子串。</p><p>求所有分割方式中，所有『代表』按字典序<strong>从大到小</strong>排的第 $k$ 个『代表』。</p><p>$1\leq n,m\leq 1000$，$1\leq k\leq 10^{18}$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>首先可以套路性地二分答案。但是二分字符串不太好做，考虑先把所有子串给找出来排序。</p><p>直接截取 substr 显然复杂度是假的，子串个数无法缩减了，考虑在存储和比较字符串上做文章。</p><p>一个字符串可以用一个区间表示，比较大小就是找到第一个不同的问题。可以通过倒着 DP，$\mathcal O(n^2)$ 预处理 $\operatorname{lcp}$ 做。</p><p>之后这些子串只要存左右端点，排序复杂度 $\mathcal O(n^2 \log n)$。</p><p>考虑二分答案的 check 怎么实现。</p><p>一个显然的 DP 做法是设 $f_{i,j}$ 表示前 $i$ 个数分了 $j$ 段并且每一段的字典序都比二分的 $mid$ 大的方案数。</p><p>直接转移，枚举前一个分割位置。但是这样复杂度是 $\mathcal O(n^2 m)$ 的。具体实现可以看 <a href="https://codeforces.com/problemset/submission/1310/281117038">CF submission 281117038</a>。</p><p>这样子看上去三个枚举都不好优化掉。</p><p>考虑不是『别人更新自己』，而是『自己更新别人』的转移方式。</p><p>枚举下一个分割位置，且满足目前位置到这个分割位置，组成的字符串，比二分的 $mid$ 大。</p><p>这时候我们发现这样有效的下一个分割位置，是一个后缀。</p><p>因为我们注意到字典序比较方式，如果 $s_i$ 是 $s_j$ 的前缀，必然存在 $s_i\leq s_j$。</p><p>也就是若 $s_{i+1\sim j}\geq mid$，则一定有 $s_{i+1\sim k}\geq mid(k\geq j)$。所以说有效的下一个分割位置，是一个后缀。</p><p>那么直接在第一个满足 $s_{i+1\sim j}\geq mid$ 的 $j$ 的位置打一个标记即可。</p><p>对标记做前缀和就是这一轮最新的 DP 值。</p><p>由于方案数很大会爆 long long。所以对于 $\geq 2\times 10^{18}$ 的 DP 值不妨都当成 $2\times 10^{18}$ 考虑。对最后答案是没有影响的。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>难度好像打错了，2800 感觉是乱评的，800 吧。</p><p><a href="https://codeforces.com/contest/1310/submission/281119576">CF submission 281119576</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="type">const</span> ll inf = <span class="number">2e18</span>;<span class="type">int</span> n, m;ll K;string s;<span class="type">int</span> lcp[<span class="number">1020</span>][<span class="number">1020</span>];<span class="keyword">struct</span> <span class="title class_">substr</span>&#123;    <span class="type">int</span> l, r;    <span class="function"><span class="type">int</span> <span class="title">len</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> r - l + <span class="number">1</span>; &#125;    <span class="function">string <span class="title">ss</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s.<span class="built_in">substr</span>(l, r - l + <span class="number">1</span>); &#125;&#125; sub[<span class="number">1000020</span>];<span class="type">bool</span> <span class="keyword">operator</span>&lt;(substr a, substr b)&#123;    <span class="keyword">if</span> (a.l == b.l)        <span class="keyword">return</span> a.r &lt; b.r;    <span class="type">int</span> l = lcp[a.l][b.l];    <span class="keyword">if</span> (l &gt;= a.<span class="built_in">len</span>() || l &gt;= b.<span class="built_in">len</span>())        <span class="keyword">return</span> a.<span class="built_in">len</span>() &lt; b.<span class="built_in">len</span>();    <span class="keyword">return</span> s[a.l + l] &lt; s[b.l + l];&#125;;<span class="type">bool</span> <span class="keyword">operator</span>==(substr a, substr b) &#123; <span class="keyword">return</span> a.<span class="built_in">len</span>() == b.<span class="built_in">len</span>() &amp;&amp; lcp[a.l][b.l] &gt;= a.<span class="built_in">len</span>(); &#125;;<span class="type">bool</span> <span class="keyword">operator</span>&lt;=(substr a, substr b) &#123; <span class="keyword">return</span> a &lt; b || a == b; &#125;<span class="type">int</span> tot;ll f[<span class="number">1020</span>][<span class="number">1020</span>];ll g[<span class="number">1020</span>][<span class="number">1020</span>];<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123; x = <span class="built_in">min</span>(x + y, inf); &#125;<span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(substr mid)</span></span><span class="function"></span>&#123;    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="built_in">sizeof</span>(g));    g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)    &#123;        <span class="keyword">if</span> (i)        &#123;            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)                <span class="built_in">add</span>(g[i][j], g[i - <span class="number">1</span>][j]);        &#125;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)            f[i][j] = g[i][j];        <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt;= n; k++)        &#123;            <span class="keyword">if</span> (mid &lt;= (substr)&#123;i + <span class="number">1</span>, k&#125;)            &#123;                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)                    <span class="comment">// add(f[k][j], f[i][j - 1]);</span>                    <span class="built_in">add</span>(g[k][j], f[i][j - <span class="number">1</span>]);                <span class="keyword">break</span>;            &#125;        &#125;    &#125;    <span class="comment">// cout &lt;&lt; mid.l &lt;&lt; &quot; &quot; &lt;&lt; mid.r &lt;&lt; &quot; &quot; &lt;&lt; mid.ss() &lt;&lt; endl;</span>    <span class="comment">// cout &lt;&lt; f[n][m] &lt;&lt; endl;</span>    <span class="keyword">return</span> f[n][m] &gt;= K;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; K &gt;&gt; s;    s = <span class="string">&#x27; &#x27;</span> + s;    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= <span class="number">1</span>; j--)        &#123;            <span class="keyword">if</span> (s[i] == s[j])                lcp[i][j] = lcp[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span>;        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> r = l; r &lt;= n; r++)            sub[++tot] = &#123;l, r&#125;;    &#125;    <span class="built_in">sort</span>(sub + <span class="number">1</span>, sub + tot + <span class="number">1</span>);    <span class="comment">// for (int i = 1; i &lt;= tot; i++)</span>    <span class="comment">//     cout &lt;&lt; sub[i].l &lt;&lt; &quot; &quot; &lt;&lt; sub[i].r &lt;&lt; &quot; &quot; &lt;&lt; sub[i].ss() &lt;&lt; endl;</span>    <span class="comment">// cout &lt;&lt; endl;</span>    <span class="type">int</span> L = <span class="number">1</span>, R = tot, ans = <span class="number">0</span>;    <span class="keyword">while</span> (L &lt;= R)    &#123;        <span class="type">int</span> mid = L + R &gt;&gt; <span class="number">1</span>;        <span class="keyword">if</span> (<span class="built_in">check</span>(sub[mid]))            L = (ans = mid) + <span class="number">1</span>;        <span class="keyword">else</span>            R = mid - <span class="number">1</span>;    &#125;    cout &lt;&lt; sub[ans].<span class="built_in">ss</span>() &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] [模拟赛 20240913] TopCoder 12844 OneBlack</title>
      <link href="/archives/TC12844/"/>
      <url>/archives/TC12844/</url>
      
        <content type="html"><![CDATA[<p>Ivan 太牛。</p><p>首先那些无法从 $(1,1)$ 到达或者无法到达 $(n,m)$ 的点填任何颜色都无所谓，遇到这样一个就把最后答案 $\times 2$。之后就把他们视作墙即可。</p><p>套路性地把割点转成割边。</p><p>众所周知网格图是平面图。</p><blockquote><p>然后你画出来那个图，长得一脸平面图，又是割，那就对偶。</p><p>By Ivan</p></blockquote><p>然后考虑平面图转对偶图。</p><p>对偶图的边穿过那些我们拆点拆出来的入边。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/yjiw4h2n.png"></p><p>把左上到右下割开的方案数，等价于对偶图的左下到右上的路径条数。</p><p>显然这是个 DAG，可以拓扑排序计数。</p><p>对于墙，那么不需要建出墙的对应的用来点拆边的辅助点。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/zr4r7sit.png"></p><p>如图，打叉的就不用建出来。</p><p>那么我们发现一个墙会合并周围的四个平面组成新的平面。</p><p>并查集合并平面，然后拓扑排序计数即可。代码非常好写。</p><pre><code class="highlight cpp"><span class="keyword">using</span> Z = mod_int&lt;<span class="number">998244353</span>&gt;;<span class="type">int</span> n, m;<span class="type">char</span> mp[<span class="number">1020</span>][<span class="number">1020</span>];<span class="type">bool</span> v11[<span class="number">1020</span>][<span class="number">1020</span>];<span class="type">bool</span> vnm[<span class="number">1020</span>][<span class="number">1020</span>];<span class="type">bool</span> vis[<span class="number">1020</span>][<span class="number">1020</span>];Z f[<span class="number">1000020</span>];vector&lt;<span class="type">int</span>&gt; a[<span class="number">1000020</span>];<span class="type">int</span> deg[<span class="number">1000020</span>];<span class="type">int</span> fa[<span class="number">1000020</span>];<span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123; <span class="keyword">return</span> fa[u] ^ u ? fa[u] = <span class="built_in">F</span>(fa[u]) : u; &#125;<span class="function"><span class="type">void</span> <span class="title">U</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123; fa[<span class="built_in">F</span>(u)] = <span class="built_in">F</span>(v); &#125;<span class="type">int</span> S, T;<span class="function"><span class="type">bool</span> <span class="title">in</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> &lt;= x &amp;&amp; x &lt;= n &amp;&amp; <span class="number">1</span> &lt;= y &amp;&amp; y &lt; m; &#125;<span class="function"><span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> !<span class="built_in">in</span>(x, y) ? y &lt; <span class="number">1</span> || x &gt; n ? S : T : (x - <span class="number">1</span>) * m + y; &#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    S = n * m + <span class="number">1</span>;    T = n * m + <span class="number">2</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * m + <span class="number">2</span>; i++)        fa[i] = i;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)            cin &gt;&gt; mp[i][j];    &#125;    v11[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)        &#123;            <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>)                <span class="keyword">continue</span>;            <span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;#&#x27;</span>)                <span class="keyword">continue</span>;            v11[i][j] = v11[i - <span class="number">1</span>][j] | v11[i][j - <span class="number">1</span>];        &#125;    &#125;    vnm[n][m] = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">1</span>; j--)        &#123;            <span class="keyword">if</span> (i == n &amp;&amp; j == m)                <span class="keyword">continue</span>;            <span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;#&#x27;</span>)                <span class="keyword">continue</span>;            vnm[i][j] = vnm[i + <span class="number">1</span>][j] | vnm[i][j + <span class="number">1</span>];        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)            vis[i][j] = v11[i][j] &amp; vnm[i][j];    &#125;    Z pw = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)        &#123;            <span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; !vis[i][j])                pw *= <span class="number">2</span>, mp[i][j] = <span class="string">&#x27;#&#x27;</span>;        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)        &#123;            <span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;-&#x27;</span>)                <span class="keyword">continue</span>;            <span class="built_in">U</span>(<span class="built_in">id</span>(i, j), <span class="built_in">id</span>(i + <span class="number">1</span>, j));            <span class="built_in">U</span>(<span class="built_in">id</span>(i, j), <span class="built_in">id</span>(i, j - <span class="number">1</span>));            <span class="built_in">U</span>(<span class="built_in">id</span>(i, j), <span class="built_in">id</span>(i + <span class="number">1</span>, j - <span class="number">1</span>));        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)        &#123;            <span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;#&#x27;</span>)                <span class="keyword">continue</span>;            a[<span class="built_in">F</span>(<span class="built_in">id</span>(i + <span class="number">1</span>, j - <span class="number">1</span>))].<span class="built_in">push_back</span>(<span class="built_in">F</span>(<span class="built_in">id</span>(i, j)));            deg[<span class="built_in">F</span>(<span class="built_in">id</span>(i, j))]++;        &#125;    &#125;    queue&lt;<span class="type">int</span>&gt; q;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * m + <span class="number">2</span>; i++)    &#123;        <span class="keyword">if</span> (<span class="built_in">F</span>(i) == i &amp;&amp; !deg[i])            q.<span class="built_in">push</span>(i), f[i] = <span class="number">1</span>;    &#125;    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())    &#123;        <span class="type">int</span> u = q.<span class="built_in">front</span>();        q.<span class="built_in">pop</span>();        <span class="keyword">for</span> (<span class="type">int</span> v : a[u])        &#123;            f[v] += f[u];            <span class="keyword">if</span> (!--deg[v])                q.<span class="built_in">push</span>(v);        &#125;    &#125;    cout &lt;&lt; f[<span class="built_in">F</span>(T)] * pw &lt;&lt; endl;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1661E Narrow Components</title>
      <link href="/archives/CF1661E/"/>
      <url>/archives/CF1661E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定 $3\times n$ 的 $\tt{0&#x2F;1}$ 网格图，给定 $q$ 个询问 $[l,r]$，查询 $[l,r]$ 部分有几个 $\tt 1$ 组成的联通块。</p><p>联通是四联通。</p><p>$1\leq n\leq 5\times 10^5$，$1\leq q\leq 3\times 10^5$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>可以离线的区间询问，尝试普通莫队。</p><p>考虑预处理出 $8\times 8$ 的表表示加了新列会增加多少的联通块。</p><p>但是这样有问题。</p><pre><code class="highlight yaml"><span class="number">1111</span><span class="number">1001</span><span class="number">1111</span></code></pre><p>我们把最后一列的 $\tt 111$ 加入的时候不确定是会减少一个联通块，还是联通块个数不变。</p><p>不难发现这只取决于上一个 $\tt 111$ 的位置，满足这个位置到目前位置，中间都是 $\tt 101$ 的形式。</p><p>预处理出每个位置往前往后能摸到的第 $1$ 个 $\tt 111$ 在哪里，莫队扩展 &#x2F; 收缩区间的时候判一下有没有提前用 $\tt 111$ 连接起来了。</p><p>这个只和边界两侧是 $\tt 111$ 和 $\tt 101$ 的情况有关，别的情况用上面的表即可。</p><p>预处理表可以用并查集维护 $6$ 个点连通性然后状压存下来。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://codeforces.com/contest/1661/submission/280804332">CF submission 280804332</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span></span><span class="function"></span>&#123;    <span class="type">static</span> <span class="type">int</span> stk[<span class="number">30</span>];    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;    <span class="type">int</span> top = <span class="number">0</span>;    <span class="keyword">do</span>    &#123;        stk[top++] = x % <span class="number">10</span>, x /= <span class="number">10</span>;    &#125; <span class="keyword">while</span> (x);    <span class="keyword">while</span> (top)        <span class="built_in">putchar</span>(stk[--top] + <span class="string">&#x27;0&#x27;</span>);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x, <span class="type">char</span> lastChar)</span> </span>&#123; <span class="built_in">write</span>(x), <span class="built_in">putchar</span>(lastChar); &#125;<span class="keyword">struct</span> <span class="title class_">DSU</span>&#123;    <span class="type">int</span> fa[<span class="number">7</span>];    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span><span class="function">    </span>&#123;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++)            fa[i] = i;    &#125;    <span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123; <span class="keyword">return</span> fa[u] ^ u ? fa[u] = <span class="built_in">F</span>(fa[u]) : fa[u]; &#125;    <span class="function"><span class="type">void</span> <span class="title">U</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123; fa[<span class="built_in">F</span>(u)] = <span class="built_in">F</span>(v); &#125;    <span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> msk)</span></span><span class="function">    </span>&#123;        <span class="type">int</span> ans = <span class="number">0</span>;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++)        &#123;            <span class="keyword">if</span> ((msk &gt;&gt; (<span class="number">6</span> - i)) &amp; <span class="number">1</span>)            &#123;                <span class="keyword">if</span> (<span class="built_in">F</span>(i) == i)                    ans++;            &#125;        &#125;        <span class="keyword">return</span> ans;    &#125;&#125; D;<span class="type">int</span> n, Q;string s[<span class="number">3</span>];<span class="type">int</span> bel[<span class="number">500020</span>];<span class="type">int</span> tol[<span class="number">500020</span>];<span class="type">int</span> tor[<span class="number">500020</span>];<span class="type">int</span> ans[<span class="number">300020</span>];<span class="type">int</span> adl[<span class="number">8</span>][<span class="number">8</span>];<span class="type">int</span> adr[<span class="number">8</span>][<span class="number">8</span>];<span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123; <span class="keyword">return</span> ((s[<span class="number">0</span>][c] ^ <span class="string">&#x27;0&#x27;</span>) &lt;&lt; <span class="number">2</span>) | ((s[<span class="number">1</span>][c] ^ <span class="string">&#x27;0&#x27;</span>) &lt;&lt; <span class="number">1</span>) | ((s[<span class="number">2</span>][c] ^ <span class="string">&#x27;0&#x27;</span>) &lt;&lt; <span class="number">0</span>); &#125;<span class="type">int</span> B;<span class="keyword">struct</span> <span class="title class_">query</span>&#123;    <span class="type">int</span> l, r, id;&#125; q[<span class="number">300020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(n);    B = <span class="built_in">sqrt</span>(n);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)    &#123;        s[i] += <span class="string">&#x27;0&#x27;</span>;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)        &#123;            <span class="type">char</span> c = <span class="string">&#x27; &#x27;</span>;            <span class="keyword">while</span> (c != <span class="string">&#x27;0&#x27;</span> &amp;&amp; c != <span class="string">&#x27;1&#x27;</span>)                c = <span class="built_in">getchar</span>();            s[i] += c;        &#125;        s[i] += <span class="string">&#x27;0&#x27;</span>;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)        &#123;            D.<span class="built_in">init</span>();            <span class="keyword">if</span> ((i &gt;&gt; <span class="number">2</span> &amp; <span class="number">1</span>) &amp;&amp; (i &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>))                D.<span class="built_in">U</span>(<span class="number">1</span>, <span class="number">2</span>);            <span class="keyword">if</span> ((i &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>) &amp;&amp; (i &gt;&gt; <span class="number">0</span> &amp; <span class="number">1</span>))                D.<span class="built_in">U</span>(<span class="number">2</span>, <span class="number">3</span>);            <span class="type">int</span> t = D.<span class="built_in">C</span>(i &lt;&lt; <span class="number">3</span> | <span class="number">0</span>);            <span class="keyword">if</span> ((i &gt;&gt; <span class="number">2</span> &amp; <span class="number">1</span>) &amp;&amp; (j &gt;&gt; <span class="number">2</span> &amp; <span class="number">1</span>))                D.<span class="built_in">U</span>(<span class="number">1</span>, <span class="number">4</span>);            <span class="keyword">if</span> ((i &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>) &amp;&amp; (j &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>))                D.<span class="built_in">U</span>(<span class="number">2</span>, <span class="number">5</span>);            <span class="keyword">if</span> ((i &gt;&gt; <span class="number">0</span> &amp; <span class="number">1</span>) &amp;&amp; (j &gt;&gt; <span class="number">0</span> &amp; <span class="number">1</span>))                D.<span class="built_in">U</span>(<span class="number">3</span>, <span class="number">6</span>);            <span class="keyword">if</span> ((j &gt;&gt; <span class="number">2</span> &amp; <span class="number">1</span>) &amp;&amp; (j &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>))                D.<span class="built_in">U</span>(<span class="number">4</span>, <span class="number">5</span>);            <span class="keyword">if</span> ((j &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>) &amp;&amp; (j &gt;&gt; <span class="number">0</span> &amp; <span class="number">1</span>))                D.<span class="built_in">U</span>(<span class="number">5</span>, <span class="number">6</span>);            adr[i][j] = D.<span class="built_in">C</span>(i &lt;&lt; <span class="number">3</span> | j) - t;        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)        &#123;            D.<span class="built_in">init</span>();            <span class="keyword">if</span> ((j &gt;&gt; <span class="number">2</span> &amp; <span class="number">1</span>) &amp;&amp; (j &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>))                D.<span class="built_in">U</span>(<span class="number">4</span>, <span class="number">5</span>);            <span class="keyword">if</span> ((j &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>) &amp;&amp; (j &gt;&gt; <span class="number">0</span> &amp; <span class="number">1</span>))                D.<span class="built_in">U</span>(<span class="number">5</span>, <span class="number">6</span>);            <span class="type">int</span> t = D.<span class="built_in">C</span>(<span class="number">0</span> &lt;&lt; <span class="number">3</span> | j);            <span class="keyword">if</span> ((i &gt;&gt; <span class="number">2</span> &amp; <span class="number">1</span>) &amp;&amp; (j &gt;&gt; <span class="number">2</span> &amp; <span class="number">1</span>))                D.<span class="built_in">U</span>(<span class="number">1</span>, <span class="number">4</span>);            <span class="keyword">if</span> ((i &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>) &amp;&amp; (j &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>))                D.<span class="built_in">U</span>(<span class="number">2</span>, <span class="number">5</span>);            <span class="keyword">if</span> ((i &gt;&gt; <span class="number">0</span> &amp; <span class="number">1</span>) &amp;&amp; (j &gt;&gt; <span class="number">0</span> &amp; <span class="number">1</span>))                D.<span class="built_in">U</span>(<span class="number">3</span>, <span class="number">6</span>);            <span class="keyword">if</span> ((i &gt;&gt; <span class="number">2</span> &amp; <span class="number">1</span>) &amp;&amp; (i &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>))                D.<span class="built_in">U</span>(<span class="number">1</span>, <span class="number">2</span>);            <span class="keyword">if</span> ((i &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>) &amp;&amp; (i &gt;&gt; <span class="number">0</span> &amp; <span class="number">1</span>))                D.<span class="built_in">U</span>(<span class="number">2</span>, <span class="number">3</span>);            adl[i][j] = D.<span class="built_in">C</span>(i &lt;&lt; <span class="number">3</span> | j) - t;        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        bel[i] = (i + B - <span class="number">1</span>) / B;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++)        tol[i] = <span class="number">0</span>, tor[i] = n + <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)    &#123;        <span class="keyword">if</span> (<span class="built_in">val</span>(i) == <span class="number">0b111</span>)            tol[i] = i;        <span class="keyword">if</span> (<span class="built_in">val</span>(i) == <span class="number">0b101</span>)            tol[i] = tol[i - <span class="number">1</span>];    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)    &#123;        <span class="keyword">if</span> (<span class="built_in">val</span>(i) == <span class="number">0b111</span>)            tor[i] = i;        <span class="keyword">if</span> (<span class="built_in">val</span>(i) == <span class="number">0b101</span>)            tor[i] = tor[i + <span class="number">1</span>];    &#125;    <span class="built_in">read</span>(Q);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)    &#123;        <span class="type">int</span> l, r;        <span class="built_in">read</span>(l, r);        q[i] = &#123;l, r, i&#125;;    &#125;    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + Q + <span class="number">1</span>, [&amp;](query a, query b)         &#123; <span class="keyword">return</span> bel[a.l] ^ bel[b.l] ? a.l &lt; b.l : bel[a.l] &amp; <span class="number">1</span> ? a.r &gt; b.r                                                                 : a.r &lt; b.r; &#125;);    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, cnt = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)    &#123;        <span class="keyword">while</span> (l &gt; q[i].l)        &#123;            l--;            <span class="keyword">if</span> (<span class="built_in">val</span>(l) == <span class="number">0b111</span> &amp;&amp; <span class="built_in">val</span>(l + <span class="number">1</span>) == <span class="number">0b101</span>)                cnt += tor[l + <span class="number">1</span>] &lt;= r ? <span class="number">0</span> : <span class="number">-1</span>;            <span class="keyword">else</span>                cnt += adl[<span class="built_in">val</span>(l)][<span class="built_in">val</span>(l + <span class="number">1</span>)];        &#125;        <span class="keyword">while</span> (r &lt; q[i].r)        &#123;            r++;            <span class="keyword">if</span> (<span class="built_in">val</span>(r) == <span class="number">0b111</span> &amp;&amp; <span class="built_in">val</span>(r - <span class="number">1</span>) == <span class="number">0b101</span>)                cnt += tol[r - <span class="number">1</span>] &gt;= l ? <span class="number">0</span> : <span class="number">-1</span>;            <span class="keyword">else</span>                cnt += adr[<span class="built_in">val</span>(r - <span class="number">1</span>)][<span class="built_in">val</span>(r)];        &#125;        <span class="keyword">while</span> (l &lt; q[i].l)        &#123;            <span class="keyword">if</span> (<span class="built_in">val</span>(l) == <span class="number">0b111</span> &amp;&amp; <span class="built_in">val</span>(l + <span class="number">1</span>) == <span class="number">0b101</span>)                cnt -= tor[l + <span class="number">1</span>] &lt;= r ? <span class="number">0</span> : <span class="number">-1</span>;            <span class="keyword">else</span>                cnt -= adl[<span class="built_in">val</span>(l)][<span class="built_in">val</span>(l + <span class="number">1</span>)];            l++;        &#125;        <span class="keyword">while</span> (r &gt; q[i].r)        &#123;            <span class="keyword">if</span> (<span class="built_in">val</span>(r) == <span class="number">0b111</span> &amp;&amp; <span class="built_in">val</span>(r - <span class="number">1</span>) == <span class="number">0b101</span>)                cnt -= tol[r - <span class="number">1</span>] &gt;= l ? <span class="number">0</span> : <span class="number">-1</span>;            <span class="keyword">else</span>                cnt -= adr[<span class="built_in">val</span>(r - <span class="number">1</span>)][<span class="built_in">val</span>(r)];            r--;        &#125;        ans[q[i].id] = cnt;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)        <span class="built_in">write</span>(ans[i], <span class="string">&#x27;\n&#x27;</span>);    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC370F Cake Division</title>
      <link href="/archives/ABC370F/"/>
      <url>/archives/ABC370F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>你有一个圆形的蛋糕，被分成了 $n$ 块，每一块都有美味程度 $a_i$。第 $i$ 条分割线位于第 $i$ 块和第 $i+1$ 块之间。</p><p>你需要选择 $k$ 条分割线分出 $k$ 段交给 $k$ 个人，满足每个人都收到了一段连续的蛋糕块，且不存在有块没有交给任何人。</p><p>你需要解决两问。设 $w_i$ 表示第 $i$ 个人得到的连续的蛋糕块的美味程度。第一问需要求出 $\min{w_1,w_2,\dots,w_k}$ 的最大值。第二问需要求出，在满足 $\min{w_1,w_2,\dots,w_k}$ 最大的所有可能划分方案中，有多少分割线从没被使用过。</p><p>$2 \leq k \leq n \leq 2 \times 10^5$，$1 \leq a_i \leq 10^4$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>先破环成链两条链拼一起。</p><p>最大化最小值可以考虑二分答案。设二分需要 check 的是 $mid$，我们就是问能不能凑出 $\geq k$ 段满足每段和都 $\geq mid$。</p><p>我们先处理 $nxt_i$ 表示从 $i$ 开始在 $nxt_i-1$ 的位置结尾，也就是 $[i,nxt_i)$ 的区间和 $\geq mid$。如果不存在这样的 $nxt_i$ 就把 $nxt_i$ 设为极大值。</p><p>之后我们就是要判断跳 $k$ 次 $nxt_i$ 是否会跳到边界外。这里认为边界是 $i+n$。</p><p>直接暴力跳肯定不行，考虑倍增优化跳的过程。设 $nxt_{i,j}$ 表示 $i$ 开始往后跳 $2^j$ 步到了哪里。倍增转移显然。</p><p>之后我们枚举开头的 $i$，倍增跳至多跳 $\log n$ 次，这样单次 check 复杂度降为了 $\mathcal O(n\log n)$。加上二分是 $\mathcal O(n\log^2 n)$。</p><p>第一问做完了，考虑第二问。我们发现这个有 $i$ 的分割线就代表从 $i$ 开始跳是合法的。我们重复上面判定『跳 $k$ 次 $nxt_i$ 是否会跳到边界外』的过程，如果有一个没跳出的就说明在 $i$ 位置可以成为分割线。</p><p>找出所有可能成为分割线的位置用 $n$ 减掉这个个数即可。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://atcoder.jp/contests/abc370/submissions/57561975">AT submission 57561975</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;<span class="type">int</span> n, k;ll s[<span class="number">400020</span>];ll a[<span class="number">400020</span>];<span class="type">int</span> nxt[<span class="number">20</span>][<span class="number">400020</span>];<span class="function">ll <span class="title">S</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> l &gt; r ? <span class="number">0</span> : s[r] - s[l - <span class="number">1</span>]; &#125;<span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(ll mid)</span></span><span class="function"></span>&#123;    <span class="built_in">memset</span>(nxt, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(nxt));    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;    <span class="keyword">while</span> (l &lt;= <span class="number">2</span> * n)    &#123;        <span class="keyword">if</span> (r &lt; l)            r = l;        <span class="keyword">while</span> (r + <span class="number">1</span> &lt;= <span class="number">2</span> * n &amp;&amp; <span class="built_in">S</span>(l, r) &lt; mid)            r++;        <span class="keyword">if</span> (<span class="built_in">S</span>(l, r) &gt;= mid)            nxt[<span class="number">0</span>][l] = r + <span class="number">1</span>;        l++;    &#125;    <span class="comment">// if (mid &gt; 20)</span>    <span class="comment">//     return 0;</span>    <span class="comment">// cout &lt;&lt; mid &lt;&lt; endl;</span>    <span class="comment">// for (int i = 1; i &lt;= 2 * n; i++)</span>    <span class="comment">//     cout &lt;&lt; nxt[0][i] &lt;&lt; &quot; &quot;;</span>    <span class="comment">// cout &lt;&lt; endl;</span>    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">20</span>; j++)        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++)            nxt[j][i] = nxt[j - <span class="number">1</span>][i] == inf ? inf : nxt[j - <span class="number">1</span>][nxt[j - <span class="number">1</span>][i]];    <span class="type">int</span> ret = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="type">int</span> cnt = <span class="number">0</span>;        <span class="type">int</span> p = i;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">19</span>; j &gt;= <span class="number">0</span>; j--)        &#123;            <span class="keyword">if</span> (nxt[j][p] &lt;= i + n)                p = nxt[j][p], cnt |= <span class="number">1</span> &lt;&lt; j;        &#125;        <span class="keyword">if</span> (cnt &gt;= k)            ret++;    &#125;    <span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n &gt;&gt; k;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        cin &gt;&gt; a[i];        a[i + n] = a[i];    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++)        s[i] = s[i - <span class="number">1</span>] + a[i];    ll L = <span class="number">0</span>, R = <span class="number">4e9</span>, ans = <span class="number">0</span>;    <span class="keyword">while</span> (L &lt;= R)    &#123;        ll mid = L + R &gt;&gt; <span class="number">1</span>;        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))            L = (ans = mid) + <span class="number">1</span>;        <span class="keyword">else</span>            R = mid - <span class="number">1</span>;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n - <span class="built_in">check</span>(ans) &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC370E Avoid K Partition</title>
      <link href="/archives/ABC370E/"/>
      <url>/archives/ABC370E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定长度为 $n$ 的序列 $a$，求有多少种划分方式（不可划分出空段）使得 $a$ 可以被分成若干个段，每段之和都 $\neq k$。</p><p>对于划分的具体定义：选定 $1&#x3D;i_1\lt i_2\lt  \dots\lt i_k\lt i_{k+1}&#x3D;n+1$。分成 $[i_p,i_{p+1})$ 共 $k$ 个小段。显然你一共有 $2^{n-1}$ 种划分方案。</p><p>答案对 $998244353$ 取模。</p><p>$1 \leq n \leq 2 \times 10^5$，$-10^{15} \leq k \leq 10^{15}$，$-10^9 \leq A_i \leq 10^9$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>设 $f_{i}$ 表示第 $i$ 个位置作为结尾的合法方案数。</p><p>$f_i$ 可以从 $f_j(j\lt i)$ 转移过来。绝大多数 $f_j$ 都可以顺利转移。考虑那些不能顺利转移的。</p><p>不能顺利转移说明存在 $s_i-s_j&#x3D;k$ 的情况。$s_i$ 表示前缀和。</p><p>那么我们找到那些满足 $s_j&#x3D;s_i-k$ 的位置，排除掉即可。</p><p>这样做仍然不好做，考虑改变状态设计，我们状态可以不和 $i$ 有关，直接和 $s_i$ 有关。</p><p>$g_{s_i}$ 表示前缀和为 $s_i$ 的方案数。</p><p>那么 $f_i\gets (\sum g) - g_{s_i-k}$。也就是全集扣除 $g_{s_i-k}$。更新了 $f$ 之后更新这一位相关的 $g$，也就是 $g_{s_i}\gets g_{s_i}+f_i$。</p><p>那么我们直接维护全局的 $g_{s_i}$ 的总数记为 $tot$。这个 $tot$ 的更新是 $\mathcal O(1)$ 的。每次根据 $tot$ 和 $g_{s_i-k}$ 算出这里的 $f_i$。</p><p>由于前缀和范围很大所以可以使用 <code>std::map</code> 等 STL 容器映射。</p><h1 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h1><p><a href="https://atcoder.jp/contests/abc370/submissions/57560977">AT submission 57560977</a></p><p>忽略了 mod_int 的实现。</p><pre><code class="highlight cpp"><span class="keyword">using</span> Z = mod_int&lt;<span class="number">998244353</span>&gt;;map&lt;ll, Z&gt; mp;ll sum;Z tot;<span class="type">int</span> n;ll k;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n &gt;&gt; k;    mp[<span class="number">0</span>] = <span class="number">1</span>;    tot = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        ll x;        cin &gt;&gt; x;        sum += x;        Z add = tot - (mp.<span class="built_in">count</span>(sum - k) ? mp[sum - k] : <span class="number">0</span>);        mp[sum] += add;        tot += add;        <span class="keyword">if</span> (i == n)            <span class="keyword">return</span> cout &lt;&lt; add &lt;&lt; endl, <span class="number">0</span>;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC370D Cross Explosion</title>
      <link href="/archives/ABC370D/"/>
      <url>/archives/ABC370D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定 $h\times w$ 的网格，初始每个格子上都有一堵墙，给出 $q$ 个操作，每次给出 $(r,c)$ 表示操作位置，若 $(r,c)$ 位置上有墙就破坏掉这个墙。如果没有，破坏掉这堵墙上、下、左、右四个方向各看到的第一堵墙。</p><p>操作之后给出目前剩下的墙的个数。</p><p>$1\leq h,w,h\times w\leq 4\times 10^5$，$1\leq q\leq  2\times 10^5$，$1\leq r\leq h$，$1\leq c\leq w$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>考虑到每一次至多影响 $4$ 堵墙，变化量很少，总数也只有 $4\times 10^5$ 个，可以直接模拟这个删除的过程。</p><p>直接往前找第一个没被删除的墙显然是有问题的。</p><p>考虑加速这个查找墙和删除墙的过程。</p><p><code>std::set</code> 支持 $\mathcal O(\log n)$ 时间在集合内二分和删除。</p><p>维护 $sr_i$ 和 $sc_j$ 表示第 $i$ 行剩余的列的集合以及第 $j$ 列剩余的行的集合。</p><p>先判断是否 $(r,c)$ 位置上有墙，有的话直接删除掉。记得同时更新 $sr$ 和 $sc$。</p><p>如果没有就在集合内二分，使用提供的 <code>upper_bound</code> 函数找到第一个比自己大的位置。之后往前走一个就可以得到比自己小的位置。</p><p>每一次尝试删除元素都要判断迭代器是否合法。</p><p>最后把所有 $sr_i$ 内的元素个数加起来就是答案。</p><hr><p>还有一种链表的做法，不依赖 STL。</p><p>先把这些二维坐标重新编号成一维的，编号方式是 $(x,y)$ 为 $(x-1)\times w+y$。</p><p>以样例 $2$ 为例，这是初始棋盘。</p><p>设 $faU_{i}$ 表示 $\tt U$ 方向上，编号为 $i$ 的，最近的一个没有被删除的位置。别的同理。一开始每个人都指向了自己。<br>$$<br>\def\arraystretch{1.5}<br>\begin{array} {|c|c|c|c|c|}<br>\hline<br>   \tt{<em>} &amp; \tt{</em>} &amp; \tt{<em>} &amp; \tt{</em>} &amp; \tt{<em>}  \cr\hline<br>   \tt{</em>} &amp; \tt{<em>} &amp; \tt{</em>} &amp; \tt{<em>} &amp; \tt{</em>}  \cr\hline<br>   \tt{<em>} &amp; \tt{</em>} &amp; \tt{<em>} &amp; \tt{</em>} &amp; \tt{<em>}  \cr\hline<br>   \tt{</em>} &amp; \tt{<em>} &amp; \tt{</em>} &amp; \tt{<em>} &amp; \tt{</em>}  \cr\hline<br>   \tt{<em>} &amp; \tt{</em>} &amp; \tt{<em>} &amp; \tt{</em>} &amp; \tt{*}  \cr\hline<br>\end{array}<br>$$</p><p>通过打的标记我们可以知道 $(3,3)$ 上有墙，那就只需要删除 $(3,3)$。<br>$$<br>\def\arraystretch{1.5}<br>\begin{array} {|c|c|c|c|c|}<br>\hline<br>   \tt{<em>} &amp; \tt{</em>} &amp; \tt{<em>} &amp; \tt{</em>} &amp; \tt{<em>}  \cr\hline<br>   \tt{</em>} &amp; \tt{<em>} &amp; \tt{</em>} &amp; \tt{<em>} &amp; \tt{</em>}  \cr\hline<br>   \tt{<em>} &amp; \tt{</em>} &amp; \tt{.} &amp; \tt{<em>} &amp; \tt{</em>}  \cr\hline<br>   \tt{<em>} &amp; \tt{</em>} &amp; \tt{<em>} &amp; \tt{</em>} &amp; \tt{<em>}  \cr\hline<br>   \tt{</em>} &amp; \tt{<em>} &amp; \tt{</em>} &amp; \tt{<em>} &amp; \tt{</em>}  \cr\hline<br>\end{array}<br>$$<br>那么 $(3,3)$ 删除之后影响了 $(2,3)$ 位置上的 $\tt D$ 等位置。</p><p>把自己的链表改掉。比如 $\tt U$ 属性的链，$(3,3)$ 这个点挂到 $(2,3)$ 上。</p><p>同理别的四个方向自己也要挂到下一个上面。</p><p>这就是删除一个点。第二种如果标记了删除，例如样例中第二次操作 $(3,3)$ 的时候。</p><p>那么我们就跳这个链，跳到第一个没有被标记删除的位置。比如这一次如果查询 $(3,3)$ 的 $\tt U$ 属性，我们会跳到 $(2,3)$ 上。$(2,3)$ 没有被标记删除，那么就取 $(2,3)$ 作为我们的目标。之后删除掉 $(2,3)$，同理修改掉 $(2,3)$ 在 $4$ 种方向上指向的对象。</p><p>所以经过第二次操作之后，图一共被删掉了 $5$ 堵墙。<br>$$<br>\def\arraystretch{1.5}<br>\begin{array} {|c|c|c|c|c|}<br>\hline<br>   \tt{<em>} &amp; \tt{</em>} &amp; \tt{<em>} &amp; \tt{</em>} &amp; \tt{<em>}  \cr\hline<br>   \tt{</em>} &amp; \tt{<em>} &amp; \tt{.} &amp; \tt{</em>} &amp; \tt{<em>}  \cr\hline<br>   \tt{</em>} &amp; \tt{.} &amp; \tt{.} &amp; \tt{.} &amp; \tt{<em>}  \cr\hline<br>   \tt{</em>} &amp; \tt{<em>} &amp; \tt{.} &amp; \tt{</em>} &amp; \tt{<em>}  \cr\hline<br>   \tt{</em>} &amp; \tt{<em>} &amp; \tt{</em>} &amp; \tt{<em>} &amp; \tt{</em>}  \cr\hline<br>\end{array}<br>$$<br>那么这时候忽略掉那些自己指向自己的部分，$\tt{U,D,L,R}$ 四个属性的链有如下形式：</p><p>$\texttt{U}:(4,3)\to (3,3)\to(2,3)\to (1,3)$</p><p>$\texttt{D}:(2,3)\to (3,3)\to(4,3)\to (5,3)$</p><p>$\texttt{L}:(2,3)\to (2,2) \ \ \ &#x2F;\ \ \  (3,4)\to (3,3) \to(3,2)\to (3,1)\ \ \ &#x2F;\ \ \ (4,3)\to (4,2)$</p><p>$\texttt{R}:(2,3) \to (2,4)\ \ \ &#x2F;\ \ \  (3,2) \to (3,3) \to (3,4)\to (3,5) \ \ \ &#x2F;\ \ \  (4,3)\to (4,4)$</p><p>当然直接写链表维护这个过程是会 TLE 的。每一次都可能会跳很多步。</p><p>这时候如果我们跳的过程中有已经被删除的点，可以直接把自己指向最头上的没有被删除的。</p><p>这个过程就是并查集中的路径压缩。</p><p>并查集就可以看成是一个森林，每棵树都可以看成是若干条链拼在一起，每个点都挂到自己的父亲节点。本题的父亲节点，意义就是最近的一个没有被删除的位置。每一次跳父亲，然后路径压缩全部挂到最高的祖先上。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://atcoder.jp/contests/abc370/submissions/57560468">AT submission 57560468</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> h, w, q;set&lt;<span class="type">int</span>&gt; sr[<span class="number">400020</span>];set&lt;<span class="type">int</span>&gt; sc[<span class="number">400020</span>];<span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span></span><span class="function"></span>&#123;    sr[r].<span class="built_in">erase</span>(c);    sc[c].<span class="built_in">erase</span>(r);&#125;<span class="type">int</span> ans;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; h &gt;&gt; w &gt;&gt; q;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= h; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= w; j++)        &#123;            sr[i].<span class="built_in">insert</span>(j);            sc[j].<span class="built_in">insert</span>(i);        &#125;    &#125;    <span class="keyword">while</span> (q--)    &#123;        <span class="type">int</span> r, c;        cin &gt;&gt; r &gt;&gt; c;        <span class="keyword">if</span> (sr[r].<span class="built_in">count</span>(c))        &#123;            <span class="built_in">del</span>(r, c);            <span class="keyword">continue</span>;        &#125;        <span class="keyword">if</span> (!sr[r].<span class="built_in">empty</span>())        &#123;            <span class="keyword">auto</span> it = sr[r].<span class="built_in">upper_bound</span>(c);            <span class="keyword">if</span> (it != sr[r].<span class="built_in">end</span>())                <span class="built_in">del</span>(r, *it);            <span class="keyword">if</span> (!sr[r].<span class="built_in">empty</span>())            &#123;                it = sr[r].<span class="built_in">upper_bound</span>(c);                <span class="keyword">if</span> (it != sr[r].<span class="built_in">begin</span>())                    it--, <span class="built_in">del</span>(r, *it);            &#125;        &#125;        <span class="keyword">if</span> (!sc[c].<span class="built_in">empty</span>())        &#123;            <span class="keyword">auto</span> it = sc[c].<span class="built_in">upper_bound</span>(r);            <span class="keyword">if</span> (it != sc[c].<span class="built_in">end</span>())                <span class="built_in">del</span>(*it, c);            <span class="keyword">if</span> (!sc[c].<span class="built_in">empty</span>())            &#123;                it = sc[c].<span class="built_in">upper_bound</span>(r);                <span class="keyword">if</span> (it != sc[c].<span class="built_in">begin</span>())                    it--, <span class="built_in">del</span>(*it, c);            &#125;        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= h; i++)        ans += sr[i].<span class="built_in">size</span>();    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p><a href="https://atcoder.jp/contests/abc370/submissions/57574774">AT submission 57574774</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> h, w, q;<span class="type">int</span> faU[<span class="number">400020</span>];<span class="type">int</span> faD[<span class="number">400020</span>];<span class="type">int</span> faL[<span class="number">400020</span>];<span class="type">int</span> faR[<span class="number">400020</span>];<span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> *fa)</span> </span>&#123; <span class="keyword">return</span> fa[u] ^ u ? fa[u] = <span class="built_in">F</span>(fa[u], fa) : u; &#125;<span class="function"><span class="type">void</span> <span class="title">U</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> *fa)</span> </span>&#123; fa[<span class="built_in">F</span>(u, fa)] = <span class="built_in">F</span>(v, fa); &#125;<span class="function"><span class="type">bool</span> <span class="title">in</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &lt;= x &amp;&amp; x &lt;= h &amp;&amp; <span class="number">1</span> &lt;= y &amp;&amp; y &lt;= w; &#125;<span class="function"><span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">in</span>(x, y) ? (x - <span class="number">1</span>) * w + y : <span class="number">0</span>; &#125;<span class="type">bool</span> del[<span class="number">400020</span>];<span class="type">int</span> ans;<span class="function"><span class="type">void</span> <span class="title">ers</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (!<span class="built_in">in</span>(r, c))        <span class="keyword">return</span>;    ans--;    del[<span class="built_in">id</span>(r, c)] = <span class="number">1</span>;    <span class="built_in">U</span>(<span class="built_in">id</span>(r, c), <span class="built_in">id</span>(r - <span class="number">1</span>, c), faU);    <span class="built_in">U</span>(<span class="built_in">id</span>(r, c), <span class="built_in">id</span>(r + <span class="number">1</span>, c), faD);    <span class="built_in">U</span>(<span class="built_in">id</span>(r, c), <span class="built_in">id</span>(r, c - <span class="number">1</span>), faL);    <span class="built_in">U</span>(<span class="built_in">id</span>(r, c), <span class="built_in">id</span>(r, c + <span class="number">1</span>), faR);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; h &gt;&gt; w &gt;&gt; q;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= h * w; i++)        faU[i] = i;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= h * w; i++)        faD[i] = i;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= h * w; i++)        faL[i] = i;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= h * w; i++)        faR[i] = i;    ans = h * w;    <span class="keyword">while</span> (q--)    &#123;        <span class="type">int</span> r, c;        cin &gt;&gt; r &gt;&gt; c;        <span class="keyword">if</span> (!del[<span class="built_in">id</span>(r, c)])        &#123;            <span class="built_in">ers</span>(r, c);            <span class="keyword">continue</span>;        &#125;        <span class="type">int</span> t;        t = <span class="built_in">F</span>(<span class="built_in">id</span>(r, c), faU);        <span class="keyword">if</span> (t)            <span class="built_in">ers</span>(t % w == <span class="number">0</span> ? t / w : t / w + <span class="number">1</span>, c);        t = <span class="built_in">F</span>(<span class="built_in">id</span>(r, c), faD);        <span class="keyword">if</span> (t)            <span class="built_in">ers</span>(t % w == <span class="number">0</span> ? t / w : t / w + <span class="number">1</span>, c);        t = <span class="built_in">F</span>(<span class="built_in">id</span>(r, c), faL);        <span class="keyword">if</span> (t)            <span class="built_in">ers</span>(r, t % w == <span class="number">0</span> ? w : t % w);        t = <span class="built_in">F</span>(<span class="built_in">id</span>(r, c), faR);        <span class="keyword">if</span> (t)            <span class="built_in">ers</span>(r, t % w == <span class="number">0</span> ? w : t % w);    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF2008 做题笔记</title>
      <link href="/archives/CF2008/"/>
      <url>/archives/CF2008/</url>
      
        <content type="html"><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>看 $a$ 个 $1$ 和 $b\bmod 2$ 个 $2$ 能不能匹配。</p><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>打到一半加解释，牛牛牛。</p><p>先判断 $n$ 是否为完全平方数，如果是的话设 $m&#x3D;\sqrt n$。看原图形分成 $m\times m$ 的图形是否满足要求。</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>不难发现只和 $r-l$ 有关。</p><p>二分答案 $mid$ 表示能增加几项，中间一共增加了 $\frac{mid(mid+1)}{2}$ 个元素，要满足 $\frac{mid(mid+1)}{2}\leq r-l$。</p><p>最后二分的答案 $+1$ 就是原序列长度。</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>$i\to p_i$ 连边，由于排列每个点入度出度都是 $1$，图形成若干环。</p><p>用并查集合并点最后看该点所在集合有多少个黑点。</p><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>$n\ \text{is even}$ 的时候直接枚举奇数位置和偶数位置的颜色。$\mathcal O(n+|\Sigma| ^2)$ 解决。</p><p>$n\ \text{is odd}$ 的时候预处理前缀和后缀和。</p><p>$pre_{i,j,0&#x2F;1}$ 表示前 $i$ 个位置颜色是 $j$ 下标奇偶性是 $0&#x2F;1$ 有几个。$suf_{i,j,0&#x2F;1}$ 同理。</p><p>枚举删除哪个位置，枚举剩下奇偶位颜色。</p><p>$\mathcal O(n\times |\Sigma| ^2)$ 解决。</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>笑死我了开场第 $3$ 个过的这个。</p><p>模板题，根据小学学过的乘法分配律可以知道 $ab+ac&#x3D;a(b+c)$。那么 $\sum\limits_{i&#x3D;1}^n \sum\limits_{j&#x3D;i+1}^n a_ia_j&#x3D;\sum\limits_{i&#x3D;1}^n a_i(\sum \limits_{j&#x3D;i+1}^n a_j)$。直接算出原数组总和每次减掉 $a_i$ 乘起来即可。</p><p>最后除以 $\frac{n(n-1)}{2}$。考虑到 $p&#x3D;10^9+7$ 是质数，$x$ 的逆元可以用 $x^{p-2}\bmod p$ 代替。</p><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>考虑裴蜀定理，那么 $\gcd$ 和 $\gcd$ 的倍数都能凑出来。我们这里认为 $0$ 是所有数的倍数。</p><p>$n&#x3D;1$ 没法凑自己所以特判掉。</p><p>先把能凑出的不同的数记下来。就是 $k\times \gcd$ 的形式。</p><p>二分答案，能凑出答案 $mid$ 说明满足 $k+cnt\gt mid$。$cnt$ 表示原序列中比 $mid$ 小的数。二分 $mid$ 在原序<br>列的位置即可。</p><p>出题人不会做 $a_i&#x3D;0$ 也太菜了。$a_i&#x3D;0$ 对答案没影响。如果所有 $a_i$ 都是 $0$ 判掉即可。</p><h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><p>考虑一个朴素的 $\mathcal O(nq\log n)$ 的暴力。二分答案 $mid$ 然后统计有多少 $a_i\bmod x\leq mid$。若这个数量 $cnt\geq \lfloor\frac{cnt+2}{2}\rfloor$ 说明 $mid$ 可以作为中位数。</p><p>这个慢在了统计有多少 $a_i\bmod x\leq mid$ 的部分上。考虑优化这个。</p><p>不难把 $a_i\bmod x$ 改写成 $a_i-kx$ 的形式。那么 $k$ 最大只会到 $\lfloor\frac{n}{x}\rfloor$。</p><p>根据调和级数我们知道 $\mathcal O(\sum\limits_{x&#x3D;1}^n \lfloor\frac{n}{x}\rfloor)&#x3D;\mathcal O(n\log n)$，所以对于不同的 $x$ 枚举 $k$ 只有 $\mathcal O(n\log n)$ 次枚举。</p><p>那么问题就变成了对于 $[kx,(k+1)x)$ 里有多少数 $\bmod x\leq mid$。</p><p>那就是 $[kx,kx+mid]$ 范围内的数的个数。</p><p>用一个前缀和优化查询 $[l,r]$ 中有多少数在 $a$ 种出现过。</p><p>注意判断区间左右端点。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] P10637 BZOJ4262 Sum</title>
      <link href="/archives/P10637/"/>
      <url>/archives/P10637/</url>
      
        <content type="html"><![CDATA[<h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p><strong>本文提供一种依赖 $a_i$ 随机生成的解决方式。</strong></p><p>首先 $\min$ 和 $\max$ 可以拆开，原式就是：</p><p>$$(\sum_{l \in [l_1,r_1]} \sum_{r \in [l_2,r_2]} \max_{i \in [l,r]} a_i)-(\sum_{l \in [l_1,r_1]} \sum_{r \in [l_2,r_2]} \min_{i \in [l,r]} a_i)$$</p><p>然而把 $a$ 序列取相反数之后的 $\max$ 就是原序列的 $\min$，做两次 $\max$ 就行，这个 $\min$ 也可以先忽略不计。</p><p>那么我们其实求的就是：</p><p>$$\sum_{l \in [l_1,r_1]} \sum_{r \in [l_2,r_2]} \max_{i \in [l,r]} a_i$$</p><p>这个第二个 $\sum$ 可以前缀和优化。</p><p>设 $f_{lx,rx,x}$ 表示：</p><p>$$\sum_{l \in [lx,rx]} \sum_{r \in [1,x]} \max_{i \in [l,r]} a_i$$</p><p>就是左端点在 $[lx,rx]$ 且右端点不超过 $x$ 的和。那么 $f_{l_1,r_1,r_2}-f_{l_1,r_1,l_2-1}$ 就是我们这个询问的答案。</p><p>先把询问 $(l_1,r_1,l_2,r_2)$ 拆成 $(l_1,r_1,l_2-1,-1)$ 和 $(l_1,r_1,r_2,1)$ 这 $2$ 条询问。后面的 $-1$ 和 $1$ 表示应该减还是加。</p><p>那么这个问题我们可以对 $x$ 做扫描线处理。</p><p>具体的，我们从 $1$ 到 $n$ 扫一遍，观察到每一次修改，会在上一个比自己大的位置停下来。那么我们维护这样的单调下降的单调栈，栈内储存的是单调下降的元素的下标，设 $stk_j$ 为栈内元素。那么我们每一次会对 $(stk_{j-1},stk_j]$ 的元素造成 $a_{stk_j}$ 的贡献。</p><p>对拆出来的 $2Q$ 条询问以 $(l,r,x,sign)$ 的 $x$ 为关键字排序，维护一个指针，表示目前处理到了哪一条询问。对于 $x&#x3D;i$ 的询问，我们只需要对于对应的原询问的 $ans$ 加上或减去 $[l,r]$ 部分的总和。</p><p>那么我们需要一个支持『区间加法，区间求和』的数据结构。两棵 BIT 或者一棵 SGT 即可。</p><p>这个做法的复杂度是 $\mathcal O(n\log^2 n)$。</p><p>复杂度是两只 $\log$ 而不是 $\mathcal O(n^2\log n)$ 的原因，是因为这个 $a_i$ 生成是随机的。随机数据情况下，单调栈的大小期望是 $\mathcal O(\log n)$ 级别的。</p><p>特殊处理一下如果询问 $l_2&#x3D;1$ 那么会有 $l_2-1&#x3D;0$ 的情况，这时候相当于没有任何需要减掉的东西，把这一部分的询问丢掉。</p><p>上面讲的是 $\max$ 的实现，把 $a_i$ 取相反数再做一次一模一样的就是 $\min$。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://www.luogu.com.cn/record/174940433">洛谷 record 174940433</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span></span><span class="function"></span>&#123;    <span class="type">static</span> <span class="type">int</span> stk[<span class="number">30</span>];    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;    <span class="type">int</span> top = <span class="number">0</span>;    <span class="keyword">do</span>    &#123;        stk[top++] = x % <span class="number">10</span>, x /= <span class="number">10</span>;    &#125; <span class="keyword">while</span> (x);    <span class="keyword">while</span> (top)        <span class="built_in">putchar</span>(stk[--top] + <span class="string">&#x27;0&#x27;</span>);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x, <span class="type">char</span> lastChar)</span> </span>&#123; <span class="built_in">write</span>(x), <span class="built_in">putchar</span>(lastChar); &#125;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="type">const</span> <span class="type">int</span> p = <span class="number">1000000000</span>;ll pw1023 = <span class="number">1</span>, pw1025 = <span class="number">1</span>;<span class="type">const</span> <span class="type">int</span> n = <span class="number">100000</span>;<span class="type">int</span> a[<span class="number">100020</span>];ll ans[<span class="number">40020</span>];<span class="keyword">struct</span> <span class="title class_">SegTree</span>&#123;    <span class="keyword">struct</span> <span class="title class_">node</span>    &#123;        ll sum, lzy;    &#125; t[<span class="number">100020</span> &lt;&lt; <span class="number">2</span>];<span class="meta">#<span class="keyword">define</span> ls id &lt;&lt; 1</span><span class="meta">#<span class="keyword">define</span> rs id &lt;&lt; 1 | 1</span><span class="meta">#<span class="keyword">define</span> Llen (mid - l + 1)</span><span class="meta">#<span class="keyword">define</span> Rlen (r - mid)</span>    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span><span class="function">    </span>&#123;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span> &lt;&lt; <span class="number">2</span>; i++)            t[i].sum = t[i].lzy = <span class="number">0</span>;    &#125;    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123; t[id].sum = t[ls].sum + t[rs].sum; &#125;    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r)</span></span><span class="function">    </span>&#123;        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;        t[ls].sum += t[id].lzy * Llen;        t[rs].sum += t[id].lzy * Rlen;        t[ls].lzy += t[id].lzy;        t[rs].lzy += t[id].lzy;        t[id].lzy = <span class="number">0</span>;    &#125;    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> id = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = n)</span></span><span class="function">    </span>&#123;        <span class="keyword">if</span> (l == r)            <span class="keyword">return</span> t[id].sum = <span class="number">0</span>, <span class="built_in">void</span>();        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;        <span class="built_in">build</span>(ls, l, mid);        <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);        <span class="built_in">push_up</span>(id);    &#125;    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> ql, <span class="type">int</span> qr, ll k, <span class="type">int</span> id = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = n)</span></span><span class="function">    </span>&#123;        <span class="keyword">if</span> (r &lt; ql || l &gt; qr)            <span class="keyword">return</span>;        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)            <span class="keyword">return</span> t[id].lzy += k, t[id].sum += k * (r - l + <span class="number">1</span>), <span class="built_in">void</span>();        <span class="built_in">push_down</span>(id, l, r);        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;        <span class="built_in">add</span>(ql, qr, k, ls, l, mid);        <span class="built_in">add</span>(ql, qr, k, rs, mid + <span class="number">1</span>, r);        <span class="built_in">push_up</span>(id);    &#125;    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> id = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = n)</span></span><span class="function">    </span>&#123;        <span class="keyword">if</span> (r &lt; ql || l &gt; qr)            <span class="keyword">return</span> <span class="number">0</span>;        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)            <span class="keyword">return</span> t[id].sum;        <span class="built_in">push_down</span>(id, l, r);        ll ans = <span class="number">0</span>;        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;        ans += <span class="built_in">query</span>(ql, qr, ls, l, mid);        ans += <span class="built_in">query</span>(ql, qr, rs, mid + <span class="number">1</span>, r);        <span class="keyword">return</span> ans;    &#125;&#125; T;<span class="type">int</span> Q;<span class="keyword">struct</span> <span class="title class_">query</span>&#123;    <span class="type">int</span> l, r, x, sign, id;&#125; q[<span class="number">80020</span>];<span class="type">int</span> stk[<span class="number">100020</span>], top;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    top = <span class="number">0</span>;    <span class="type">int</span> j = <span class="number">1</span>;    <span class="keyword">while</span> (j &lt;= <span class="number">2</span> * Q &amp;&amp; q[j].x == <span class="number">0</span>)        j++;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">while</span> (top &gt;= <span class="number">1</span> &amp;&amp; a[stk[top]] &lt;= a[i])            top--;        stk[++top] = i;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= top; j++)            T.<span class="built_in">add</span>(stk[j - <span class="number">1</span>] + <span class="number">1</span>, stk[j], a[stk[j]]);        <span class="keyword">while</span> (j &lt;= <span class="number">2</span> * Q &amp;&amp; q[j].x == i)            ans[q[j].id] += q[j].sign * T.<span class="built_in">query</span>(q[j].l, q[j].r), j++;    &#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        (pw1023 *= <span class="number">1023</span>) %= p;        (pw1025 *= <span class="number">1025</span>) %= p;        a[i] = pw1023 ^ pw1025;        <span class="comment">// cout &lt;&lt; a[i] &lt;&lt; &quot; \n&quot;[i == n];</span>    &#125;    <span class="built_in">read</span>(Q);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)    &#123;        <span class="type">int</span> l1, r1, l2, r2;        <span class="built_in">read</span>(l1, r1, l2, r2);        q[i * <span class="number">2</span> - <span class="number">1</span>] = &#123;l1, r1, l2 - <span class="number">1</span>, <span class="number">-1</span>, i&#125;;        q[i * <span class="number">2</span>] = &#123;l1, r1, r2, <span class="number">1</span>, i&#125;;    &#125;    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">2</span> * Q + <span class="number">1</span>, [&amp;](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)         &#123; <span class="keyword">return</span> x.x &lt; y.x; &#125;);    <span class="built_in">solve</span>();    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        a[i] = -a[i];    T.<span class="built_in">clear</span>();    <span class="built_in">solve</span>();    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)        <span class="built_in">write</span>(ans[i], <span class="string">&#x27;\n&#x27;</span>);    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[游记] 百度之星 2024 游记</title>
      <link href="/archives/ASTAR2024/"/>
      <url>/archives/ASTAR2024/</url>
      
        <content type="html"><![CDATA[<h1 id="Day-3e8"><a href="#Day-3e8" class="headerlink" title="Day -3e8"></a>Day -3e8</h1><p>第一次打百度之星。这个软件只有 Windows 版本的？被迫切回我一年没用的 Windows 系统了。</p><p>卡死了，一点 coding 体验都没有。</p><p>喜提两题走人了 &gt;_&lt;</p><h1 id="Day-2e8"><a href="#Day-2e8" class="headerlink" title="Day -2e8"></a>Day -2e8</h1><p>第二把，这一把撞中考，可能是晋级希望最大的。但是事实上我被汉诺塔单防若干小时。</p><p>喜提三题走人了 &gt;_&lt;</p><p>寄。</p><h1 id="Day-1e8"><a href="#Day-1e8" class="headerlink" title="Day -1e8"></a>Day -1e8</h1><p>第三把。最后一把了，吓人。</p><p>开局很不顺利啊，我 T1 挂了 $3$ 发。后面题不是太难？随便写写 1h 的时候就过了 $4$ 个题。</p><p>卡卡卡卡了一会儿 T5，结果 WA 在没开 long long，有惊无险过掉了。封榜前 rk 是 110 左右，菜完了。</p><p>开 T7，这不是我们 CF498D 吗？我一周前刚做过？但这个数据范围很可以分块啊。写起来很自然，写个分块。分块写的比线段树熟练多了。</p><p>不是哥们我怎么 TLE 了。还 TLE 这么多。卡了半天常还是过不去啊，最后几分钟狂码一个线段树，但是没调完。</p><p>赛后我对于卡常表示不满，但是 SFlyer 大神认为我是唐氏，因为复杂度为 $\mathcal O(VB),V&#x3D;100$ 的重构和复杂度为 $\mathcal O(\frac{n}{B})$ 的查询，我取了 $B&#x3D;\sqrt n$。</p><p>真的太唐了。两百多名感觉也炸掉了。</p><h1 id="Day-5e7"><a href="#Day-5e7" class="headerlink" title="Day -5e7"></a>Day -5e7</h1><p>好好好，出去剪头发坐着看短视频的时候 QQ 疯狂被 at。怎么百度之星出成绩了，rk 48 卡线过。</p><h1 id="Day-1e6"><a href="#Day-1e6" class="headerlink" title="Day -1e6"></a>Day -1e6</h1><p>订购了 $100$ 枚徽章。</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h1><p>今天是第一天报道，报道有两天，那就叫做 Day -2 吧。</p><p>把板子打印了一下，虽然我不觉得我能场上使用写的不熟练的算法过题。能拿到气球就是胜利！</p><p>我的包材质好像不方便把徽章挂上面，系了两根绳子用来捆徽章。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5fy0frjf.png"></p><p>有需要的话可以根据这几根彩色绳子和这个徽章找我？</p><p>民间开了百度之星面基群。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/w33ymzq1.png"></p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>车站全是北京南的车。坐上车开始冲业绩审核题解，审核不知道几篇就累了开摆了。摆也摆累了，睡了一觉。真累，不如 Ivan 晚上十点的卧铺睡醒就到了。</p><p>一点半到的，北京南站。找到了 Anny 和 袁神，进行了一个麦当劳的吃。真的贵啊，一个汉堡 27 块，怎么敢的。</p><p>然后坐了不知道几站的地铁到了天通苑。本来打算先吃东西所以没到天通苑北，虽然也没吃上。</p><p>打车去九华山庄。</p><p>车上在玩飞行棋和简易版三国杀（？）</p><p>wosile 说等我去了要【】我。赶紧跑。</p><p>报道的时候旁边好像报的是 sunzihang？但是没敢问没面。不过是不是也算单方向面了。</p><p>酒店入住的时候就看到了 夜明，换到了第一个徽章，赢！</p><p>回房间放了点东西，夜明 带着 Register_int 来单杀我了，好恐怖。赶紧跑。到一半被抓到了，换到了 Ri 的徽章。</p><p>跑到电梯里下一楼迎面走来一个活着的 wosile，电梯艳遇（不是</p><p>在楼下看见一桌扑克爆改麻将，应该是 滴叉、矩阵群、SF 然后不知道了。旁边有 铁锭。然后 fairytale 也来换徽章了。</p><p>在大厅随机游走之后找到了 BrotherCall，我给当成星巴克工作人员了。</p><p>还看到了 OutsiderZz，老登好帅。</p><p>然后回房间吃了点东西，点了奶茶，在下面坐了一会儿，和大猩猩组群主换了徽章，就去会场了。怎么用网线？我没转接头啊，借了一个，还没法用？？？换了个 Type C 的插上了，但是没法充电了。我旁边坐的是 carefree_Zhuang，赛前几天刚帮他换了 NEAR。</p><p>我附近有个我不认识的老哥一直和我讲话啊，好像很牛。说让我更新 CZOJ，问我 Milmon 有没有在 CZOJ 搞事（）</p><p>试机，启动！</p><p>我擦 T1 是不是直接枚举中间的算算就行。诶诶不要写组合数。诶诶怎么过样例了。诶诶怎么 WA 了。这都能 WA？哦 $\tt{shsshsshsshs}$ 我会算重。无敌了，跳。</p><p>T2 不是普及题吗，解鸡兔同笼方程。怎么 WA 样例了。怎么解得 $x&#x3D;y$ 要特殊处理。怎么 RE 了。怎么是我没处理解不合法只处理了过大没处理过小。我无敌了。</p><p>T3 不是普及题吗，二分一下就做完了吧。怎么过样例了。怎么 WA 了。怎么快结束了。怎么都 AK 了。怎么 wosile 来拷打我了。怎么 wosile 和我挂的一样。怎么我看不出。怎么我看出来了。怎么我没判 $mid\lt s_i$ 的情况。怎么过了。</p><p>怎么试机结束了。怎么没 AK。怎么都是 3min AK，贺原题，素质这么差？</p><p>打到一半看见一个不知道谁来找我，看了眼牌子原来是 青白。还好提前找别人要了 青白 盒子（）好像还看到了 紫陌 Zeeman。紫陌 老师长得太有特色了。</p><p>打完试机在大厅吃饭，面了 Southern_Dynasty。打扑克，打斗地主和掼蛋。我斗地主 5 把出 3 个王炸 1 个炸，无敌了。还被 wosile rua rua 了。</p><p>九华洗澡地方太逆天了，我在防滑垫上滑了。大猩猩组群主说我要在在防 AK 题上 A 了。</p><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>早上起来感觉喉咙不舒服，好冷，但是过一会儿就好了。听说昨天晚上有小朋友排练，但我没听到。</p><p>早饭随便吃了点就去会场了。开摆，看 QQ。wosile 用我的 QQ 看消息，无敌了。</p><p>怎么开始说可以登录了，我准考证号错误？原来大家都这样。</p><p>找了 SFlyer 换徽章。</p><p>请准考证号错误的同学举手。全场都举起来了，无敌了。</p><p>开开开。开 T1。签到题不能难吧，一看就是搜一下就过了。怎么寄了。怎么都没过 T1？？？被骗了，赶紧开 T2。</p><p>T2 一眼高精度，可以 Python。但我不会十进制转二进制函数。维护操作过于简单了，瞎写一个过了。</p><p>T3 一眼 DP，然后错了，怎么可以往上往左。值域很小直接搜就可以了，跑 01 BFS 就过了。</p><p>T6 是蠢题，离散化然后 BIT 维护一下 DP 值就行了。</p><p>回去开 T5，第一问蠢，第二问是第一问的子问题，第三问写个 ST 表然后倍增就行了。蠢。</p><p>T1 发现是状压，但是我只会 $\mathcal O(2^n n^3)$ 的。事实上只用 lowbit 就行了，但我写了个 DP 到 $12$ 然后有序枚举 $(i,j,k)$ 就过了。1.7s 很极限啊。</p><p>6 题跑路。我过 3 个没给我气球，最后我周围全是气球我都没有，无敌了。过了 6 个赶紧拷打志愿者。</p><p>然后后面 2h 一点贡献没有。摆。T4 实际上猜出来是每个字母做然后倍增跳了，但是我倍增的是消除过程不是消掉第一个的位置。不会了。封榜前 rk 261。</p><p>午饭是大厅 KFC，吃完去找了 咖啡 面基，滴叉 也在，还有一个我好像不认识。刚走 矩阵群 就来了，来面麻的。</p><p>然后带着 夜明 和 Disjoint_cat 约了面基，怎么就是我找 咖啡 走错的地方。</p><p>尝试找了好久的 雾 没找到。</p><p>吃晚饭的时候面到了 honglan。怎么群里喊 wosile 拿身份证。wosile 冬令营丢身份证 NOI 丢密码条百度之星丢身份证，无敌了。</p><p>吃完了随便坐一会儿就回了赛场。前面滚榜后面几个志愿者在审核题解滚队列，无敌了。我怎么 rk 288，太吉利了。铁牌锁定了。</p><p>被活着的 wosile 疯狂 rua。</p><p>怎么大家都没 Au，我场上看一车 hba 省队爷只过 6&#x2F;7 个就摆了，结果是寄了。</p><p>雾 和 Nanani 坐一起，女选手这么少，非常好定位。怎么旁边一群男的，诶我旁边这个怎么牌子挂的 雾 真名。就你辣！送了徽章就跑路了。</p><p>看了小星星的金之后就跑路了。打车去天通苑北，坐车去环球影城旁边的酒店。</p><p>酒店旁边有烧烤，好吃，爱吃。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/vudan78s.png"></p><h1 id="Day-114514"><a href="#Day-114514" class="headerlink" title="Day 114514"></a>Day 114514</h1><p>我发现那个我不认识的让我更新 CZOJ 的老哥是 Moeebius。</p>]]></content>
      
      
      <categories>
          
          <category> TravelNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC365G AtCoder Office</title>
      <link href="/archives/ABC365G/"/>
      <url>/archives/ABC365G/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>有 $n$ 个人，给定 $m$ 个信息，第 $i$ 条表示 $t_i$ 时刻人 $p_i$ 进 &#x2F; 出了房间。</p><p>进还是出由之前的状态决定。保证最后所有人都是出的。</p><p>现在给定 $q$ 个询问，查询 $a,b$ 表示 $a$ 在房间和 $b$ 在房间的时间的交集大小。</p><p>$2\leq n,m\leq 2\times 10^5$，$1\leq p_i,a,b\leq n$，$1\leq t_i\leq 10^9$，保证 $t_i$ 严格递增。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>后文复杂度不严格区分 $n$ 与 $m$ 还有 $q$。默认都是 $n$ 量级的。</p><p>我们先把进出房间的时刻看成线段的两个端点，线段就是这个人在房间里的时间。</p><p>那么这个题转化成问两个人线段的交集大小。</p><p>设 $cnt_i$ 表示第 $i$ 个人的线段个数，我们可以得到 $\mathcal O(\sum\limits_{i&#x3D;1}^n cnt_i)&#x3D;\mathcal O(n)$。</p><p>$n$ 个人 $n$ 条线段，不难想到是根号分治，线段数量 $\gt B$ 的人数量是 $\leq \frac n B$ 的。</p><p>根据这个，我们把人分为大人和小人。根据这个讨论怎么做。</p><ul><li><p>两个小人</p><p>那么我们把这些线段合并，记 $lst_{0&#x2F;1}$ 表示 $a$ 或 $b$ 上一个左端点在哪里。往序列里扔每个人的端点，记录三个值 $t,o,p$ 表示时间刻，是左端点还是右端点，是 $a$ 还是 $b$ 的时间刻。</p><p>如果找到左端点更新 $lst$。找到右端点算 $t-\max{lst_0,lst_1}$ 就是这一段线段的答案。</p><p>把每个人的线段加进来的过程，需要排序。但是我们如果本来线段就是有序存放的，我们归并即可。两个有序地数组归并到一起只需要维护两个指针移动。这样这部分就是 $\mathcal O(\sqrt n)$ 时间内解决。</p></li><li><p>一大一小</p><p>不妨设 $a$ 是小人 $b$ 是大人。</p><p>单独分这一类不是很必要，但这是两个大人处理的基础。</p><p>枚举小人的区间，那么我们就要支持查询区间内 $b$ 的时间有多长。</p><p>端点数量是 $\mathcal O(n)$ 的，我们设 $sum_{i,j}$ 表示第 $i$ 个大人的前 $j$ 个时刻（时刻是 $10^9$ 级别的，但是可以离散化成 $n$ 级别的）有多少时间在房间里。这个 $sum$ 提前预处理出来，处理方式很简单，不细说了。</p><p>通过前缀和减一下就能得到我们区间内 $b_i$ 的时间数量。</p><p>这一段复杂度 $\mathcal O(\sqrt n)$。</p></li><li><p>两个大人</p><p>设 $ans_{i,j}$ 表示第 $i$ 个大人和第 $j$ 个大人的答案。</p><p>枚举第 $i$ 个大人，枚举第 $j$ 个大人。由于 $\mathcal O(\sum\limits_{i&#x3D;1}^n cnt_i)&#x3D;\mathcal O(n)$，那么所有可能的第 $j$ 个大人的线段总数是 $\mathcal O(n)$ 的。<strong>所以暴力预处理 $ans_{i,j}$ 复杂度就是正确的。</strong></p><p>事实上，一大一小可以和两个大人合并在一起， 设 $ans_{i,j}$ 表示第 $i$ 个大人和第 $j$ 个人的答案。 <del>但是赛时想到了一大一小的做法就先敲上了，不改了。</del></p></li></ul><p>所以我们在 $\mathcal O(n\sqrt n)$ 的时间内完成了这个问题。</p><p>实现的时候注意一些小问题，比如要提前离散化信息，两个小人的处理归并合并。这些多的 $\log$ 都可以简单优化掉，这里不细说了。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://atcoder.jp/contests/abc365/submissions/56309131">AT submission 56309131</a></p><p>成为了全场倒数第二个过 G 的。</p><p>一开始写的 $\mathcal O(n\sqrt n\log n)$ 的 TLE 了 $2$ 个点。但是有人 $\mathcal O(n\sqrt n\log n)$ 卡过去了，可能我写的常数有点大。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span></span><span class="function"></span>&#123;    <span class="type">static</span> <span class="type">int</span> stk[<span class="number">30</span>];    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;    <span class="type">int</span> top = <span class="number">0</span>;    <span class="keyword">do</span>    &#123;        stk[top++] = x % <span class="number">10</span>, x /= <span class="number">10</span>;    &#125; <span class="keyword">while</span> (x);    <span class="keyword">while</span> (top)        <span class="built_in">putchar</span>(stk[--top] + <span class="string">&#x27;0&#x27;</span>);&#125;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x, <span class="type">char</span> lastChar)</span> </span>&#123; <span class="built_in">write</span>(x), <span class="built_in">putchar</span>(lastChar); &#125;<span class="type">const</span> <span class="type">int</span> inf = <span class="number">2e9</span>;<span class="type">const</span> <span class="type">int</span> B = <span class="number">300</span>;<span class="type">int</span> n, m;<span class="type">int</span> Q;array&lt;<span class="type">int</span>, 2&gt; a[<span class="number">200020</span>];vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; vec[<span class="number">200020</span>];<span class="type">bool</span> in[<span class="number">200020</span>];<span class="type">int</span> lst[<span class="number">200020</span>];<span class="type">int</span> sum[<span class="number">700</span>][<span class="number">200020</span>];<span class="type">int</span> lsh[<span class="number">200020</span>];<span class="type">int</span> id[<span class="number">200020</span>], tot;<span class="type">bool</span> hav[<span class="number">200020</span>];<span class="type">int</span> aa[<span class="number">700</span>][<span class="number">700</span>];vector&lt;<span class="type">int</span>&gt; big;unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(n, m);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)    &#123;        <span class="built_in">read</span>(a[i][<span class="number">0</span>], a[i][<span class="number">1</span>]);        <span class="keyword">if</span> (in[a[i][<span class="number">1</span>]])            vec[a[i][<span class="number">1</span>]].<span class="built_in">push_back</span>(&#123;lst[a[i][<span class="number">1</span>]], a[i][<span class="number">0</span>]&#125;);        <span class="keyword">else</span>            lst[a[i][<span class="number">1</span>]] = a[i][<span class="number">0</span>];        in[a[i][<span class="number">1</span>]] ^= <span class="number">1</span>;        mp[a[i][<span class="number">0</span>]] = i;    &#125;    big.<span class="built_in">push_back</span>(<span class="number">0</span>);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">if</span> (vec[i].<span class="built_in">size</span>() &lt;= B)            <span class="keyword">continue</span>;        big.<span class="built_in">push_back</span>(i);        id[i] = ++tot;        <span class="built_in">memset</span>(hav, <span class="number">0</span>, <span class="built_in">sizeof</span>(hav));        <span class="keyword">for</span> (<span class="keyword">auto</span> [l, r] : vec[i])        &#123;            <span class="keyword">for</span> (<span class="type">int</span> j = mp[l] + <span class="number">1</span>, ed = mp[r]; j &lt;= ed; j++)                hav[j] = <span class="number">1</span>;        &#125;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)        &#123;            <span class="keyword">if</span> (hav[i])                sum[tot][i] = a[i][<span class="number">0</span>] - a[i - <span class="number">1</span>][<span class="number">0</span>];        &#125;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)            sum[tot][i] += sum[tot][i - <span class="number">1</span>];    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; big.<span class="built_in">size</span>(); i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; big.<span class="built_in">size</span>(); j++)        &#123;            <span class="keyword">if</span> (i == j)                <span class="keyword">continue</span>;            <span class="type">int</span> y = big[j];            <span class="keyword">for</span> (<span class="keyword">auto</span> [l, r] : vec[y])                aa[i][j] += sum[i][mp[r]] - sum[i][mp[l]];        &#125;    &#125;    <span class="built_in">read</span>(Q);    <span class="keyword">while</span> (Q--)    &#123;        <span class="type">int</span> x, y;        <span class="built_in">read</span>(x, y);        <span class="keyword">if</span> (vec[x].<span class="built_in">size</span>() &gt; vec[y].<span class="built_in">size</span>())            <span class="built_in">swap</span>(x, y);        <span class="keyword">if</span> (vec[y].<span class="built_in">size</span>() &lt;= B) <span class="comment">// 小小</span>        &#123;            vector&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; u, v;            <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;            <span class="keyword">for</span> (<span class="keyword">auto</span> [l, r] : vec[x])            &#123;                u.<span class="built_in">push_back</span>(&#123;l, <span class="number">0</span>, <span class="number">0</span>&#125;);                u.<span class="built_in">push_back</span>(&#123;r, <span class="number">1</span>, <span class="number">0</span>&#125;);            &#125;            <span class="keyword">for</span> (<span class="keyword">auto</span> [l, r] : vec[y])            &#123;                <span class="keyword">while</span> (i &lt; u.<span class="built_in">size</span>() &amp;&amp; u[i][<span class="number">0</span>] &lt;= l)                    v.<span class="built_in">push_back</span>(u[i]), i++;                v.<span class="built_in">push_back</span>(&#123;l, <span class="number">0</span>, <span class="number">1</span>&#125;);                <span class="keyword">while</span> (i &lt; u.<span class="built_in">size</span>() &amp;&amp; u[i][<span class="number">0</span>] &lt;= r)                    v.<span class="built_in">push_back</span>(u[i]), i++;                v.<span class="built_in">push_back</span>(&#123;r, <span class="number">1</span>, <span class="number">1</span>&#125;);            &#125;            <span class="type">int</span> lst[<span class="number">2</span>] = &#123;inf, inf&#125;;            <span class="type">int</span> ans = <span class="number">0</span>;            <span class="keyword">for</span> (<span class="keyword">auto</span> [t, o, p] : v)            &#123;                <span class="keyword">if</span> (o == <span class="number">1</span>)                &#123;                    <span class="keyword">if</span> (lst[<span class="number">0</span>] &lt; inf &amp;&amp; lst[<span class="number">1</span>] &lt; inf)                        ans += t - <span class="built_in">max</span>(lst[<span class="number">0</span>], lst[<span class="number">1</span>]);                    lst[p] = inf;                &#125;                <span class="keyword">else</span>                &#123;                    lst[p] = t;                &#125;            &#125;            <span class="built_in">write</span>(ans, <span class="string">&#x27;\n&#x27;</span>);        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (vec[x].<span class="built_in">size</span>() &lt;= B) <span class="comment">// 小大</span>        &#123;            <span class="type">int</span> j = id[y];            <span class="type">int</span> ans = <span class="number">0</span>;            <span class="keyword">for</span> (<span class="keyword">auto</span> [l, r] : vec[x])                ans += sum[j][mp[r]] - sum[j][mp[l]];            <span class="built_in">write</span>(ans, <span class="string">&#x27;\n&#x27;</span>);        &#125;        <span class="keyword">else</span> <span class="comment">// 大大</span>        &#123;            <span class="built_in">write</span>(aa[id[x]][id[y]], <span class="string">&#x27;\n&#x27;</span>);        &#125;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1997E Level Up</title>
      <link href="/archives/CF1997E/"/>
      <url>/archives/CF1997E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>打怪操作是指，顺次对于 $[1,n]$ 的每个怪，每个怪有 $a_i$ 的等级，如果你的等级 $lv$ <strong>严格</strong>大于怪的等级 $a_i$，它就会逃跑。反之你会和它战斗。</p><p>你每与 $k$ 个怪战斗就会升一级，即 $lv\gets lv+1$。</p><p>现在有若干组查询，每次查询 $i,x$ 表示询问 $k&#x3D;x$ 时，你是否会和第 $i$ 个怪战斗。</p><p>$1\leq n,q\leq 2\times 10^5$，$1\leq a_i\leq 2\times 10^5$，$1\leq i,x\leq n$</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>首先考虑一个 $\log^3$ 的最暴力做法，然后在这上面优化。</p><p>由于每打 $k$ 个怪就会升级，所以你最多会升 $\lfloor\frac{n}{k}\rfloor$ 次。而 $\sum\limits_{k&#x3D;1}^{n} \frac nk \approx n \log n$。也就是对于所有的 $k&#x3D;x$ 我们只会有 $\mathcal O(n \log n )$ 次升级。</p><p>对于每一组 $k&#x3D;x$，我们可以找到若干升级段，也就是 $[l,r]$ 满足击杀了第 $l$ 到第 $r$ 只怪会正好升级。</p><p>因为最多升级 $\mathcal O(n\log n)$ 次，因此每次升级二分右端点，接下来处理怎么判定 $[l,r]$ 是可以恰好升级的段。我们需要判断 $[l,r]$ 是否满足 $\sum\limits_{i&#x3D;l}^r [a_i\geq lv] \geq k$，其中的 $[]$ 为艾弗森括号，取值为 $[x]&#x3D;\begin{cases}1&amp;x\ \text{is True}\0&amp; \text{Otherwise}\end{cases}$。</p><p>那么我们可以使用主席树等数据结构求解。详见 <a href="https://ac.nowcoder.com/acm/contest/275/E">牛客小白月赛 9 E. 换个角度思考</a> 或 <a href="https://acm.hdu.edu.cn/showproblem.php?pid=4417">HDU 4417 Super Mario</a>。</p><p>这样就得到了一个没有什么思维含量的 $\mathcal O(n\log^3 n)$ 的做法。</p><p>调和级数一共 $\mathcal O(n\log n)$ 种区间，二分一只 $\log$，这两个都无法优化了，我们尝试在计算 $\sum\limits_{i&#x3D;l}^r [a_i\geq lv] \geq k$ 上做文章。</p><p>由于随着 $k$ 的上升，那么相对升级就会变慢，<strong>等级高的怪我们不需要考虑</strong>。准确的说只有 $a_i\leq \frac n k$ 的怪才有可能给我们升级带来影响。</p><p>然而如果我们 $a_i$ 都很小的话，我们可以通过预处理前缀和计算 $\sum\limits_{i&#x3D;l}^r [a_i\geq lv] \geq k$。我们设 $sum_{i,j}$ 表示前 $i$ 个数中，怪物等级 $\leq j$ 的怪物个数。那么 $\sum\limits_{i&#x3D;l}^r [a_i\geq lv]$ 就等价于 $(r-l+1)-(sum_{r,lv-1}-sum_{l-1,lv-1})$。这样就可以把这个一个 $\log$ 优化掉。</p><p>这个预处理是 $\mathcal O(\frac{n^2}{B})$ 的。这样我们就处理了 $k\gt B$ 的情况。</p><p>如果 $k\leq B$，那么我们直接做 $\mathcal O(Bn)$ 的暴力就行。</p><p>把两个做法结合一下，取 $B&#x3D;\sqrt n$，那么两种算法的复杂度分别是：</p><ul><li><p>$k\leq B$</p><p>暴力 $\mathcal O(n\sqrt n)$。</p></li><li><p>$k\gt B$</p><p>预处理 $\mathcal O(n\sqrt n)$。</p><p>做查询 $\mathcal O(n\log^2 n)$。</p></li></ul><p>这样我们就在 $\mathcal O(n\sqrt n+n\log^2 n)$ 的时间中做完了这个问题。</p><p>因此，简单说一下过程，就是预处理 $sum_{i,j}$ 表示前 $i$ 个等级 $\leq j$ 的怪兽个数，离线询问，对于 $k\leq B$ 的暴力扫一遍序列模拟，对于 $k\gt B$ 的二分区间端点，通过预处理的 $sum$ 数组判断是否合法。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://codeforces.com/contest/1997/submission/273823527">CF submission 273823527</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="type">const</span> <span class="type">int</span> B = <span class="number">448</span>;<span class="type">int</span> n, Q;<span class="type">int</span> a[<span class="number">200020</span>];vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; q[<span class="number">200020</span>];<span class="type">bool</span> ans[<span class="number">200020</span>];<span class="type">int</span> sum[<span class="number">450</span>][<span class="number">200020</span>];<span class="type">bool</span> skip[<span class="number">200020</span>];<span class="type">int</span> level[<span class="number">200020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(n, Q);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="built_in">read</span>(a[i]);        <span class="keyword">if</span> (a[i] &lt;= B)            sum[a[i]][i]++;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= B; j++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)            sum[j][i] += sum[j - <span class="number">1</span>][i] + sum[j][i - <span class="number">1</span>] - sum[j - <span class="number">1</span>][i - <span class="number">1</span>];    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)    &#123;        <span class="type">int</span> p, k;        <span class="built_in">read</span>(p, k);        q[k].<span class="built_in">push_back</span>(&#123;p, i&#125;);    &#125;    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)    &#123;        <span class="keyword">if</span> (q[k].<span class="built_in">empty</span>())            <span class="keyword">continue</span>;        <span class="keyword">if</span> (k &lt;= B)        &#123;            <span class="type">int</span> lvl = <span class="number">1</span>;            <span class="type">int</span> cnt = <span class="number">0</span>;            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)            &#123;                skip[i] = <span class="number">0</span>;                <span class="keyword">if</span> (a[i] &lt; lvl)                &#123;                    skip[i] = <span class="number">1</span>;                    <span class="keyword">continue</span>;                &#125;                cnt++;                <span class="keyword">if</span> (cnt == k)                    cnt = <span class="number">0</span>, lvl++;            &#125;            <span class="keyword">for</span> (<span class="keyword">auto</span> [p, i] : q[k])            &#123;                <span class="keyword">if</span> (!skip[p])                    ans[i] = <span class="number">1</span>;            &#125;        &#125;        <span class="keyword">else</span>        &#123;            <span class="built_in">sort</span>(q[k].<span class="built_in">begin</span>(), q[k].<span class="built_in">end</span>());            <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, lvl = <span class="number">1</span>;            <span class="type">int</span> j = <span class="number">0</span>;            <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> r)            &#123; <span class="built_in">return</span> (r - l + <span class="number">1</span>) - (sum[lvl - <span class="number">1</span>][r] - sum[lvl - <span class="number">1</span>][l - <span class="number">1</span>]) &gt;= k; &#125;;            <span class="keyword">while</span> (l &lt;= n)            &#123;                <span class="type">int</span> L = l, R = n, r = n;                <span class="keyword">while</span> (L &lt;= R)                &#123;                    <span class="type">int</span> mid = L + R &gt;&gt; <span class="number">1</span>;                    <span class="keyword">if</span> (<span class="built_in">check</span>(mid))                        R = (r = mid) - <span class="number">1</span>;                    <span class="keyword">else</span>                        L = mid + <span class="number">1</span>;                &#125;                <span class="keyword">while</span> (j &lt; q[k].<span class="built_in">size</span>() &amp;&amp; l &lt;= q[k][j][<span class="number">0</span>] &amp;&amp; q[k][j][<span class="number">0</span>] &lt;= r)                    level[q[k][j][<span class="number">0</span>]] = lvl, j++;                l = r + <span class="number">1</span>;                lvl++;            &#125;            <span class="keyword">for</span> (<span class="keyword">auto</span> [p, i] : q[k])            &#123;                <span class="keyword">if</span> (level[p] &lt;= a[p])                    ans[i] = <span class="number">1</span>;            &#125;        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)        <span class="built_in">puts</span>(ans[i] ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF558C Amr and Chemistry</title>
      <link href="/archives/CF558C/"/>
      <url>/archives/CF558C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是对 <a href="https://www.luogu.com.cn/article/l942y6ye">DennyQi</a> 题解思想的补充做法。</p><h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>$n$ 个数 $a_i$，每次可以选择 $a_i\gets a_i\times 2$ 或者 $a_i\gets \lfloor\frac{a_i}{2}\rfloor$。</p><p>问几次操作后 $a_i$ 全部一样。</p><p>$1\leq n\leq 10^5$，$1\leq a_i\leq 10^5$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>考虑把这个操作对应到二进制上，那么就是删除一位和添加一个 $0$，其实就是位运算中的右移 $1$ 位和左移 $1$ 位。</p><p>你不会对这些数进行很多次移位，这样子不如每个数都少移动几位。因此最后这些数的二进制长度也就是 $\log_2 10^5$ 级别左右的，实现的时候可以取到 $18$ 防止一些不必要的判断。</p><p>每一个数最多移动 $\log$ 位就会变成 $0$，由于刚才说的，操作之后也是 $\log$ 级别，因此每右移一位都可以左移 $\log$ 位，一个数至多有 $\log^2$ 种可达状态。</p><p>但是状态有重复，考虑去重。本身复杂度已经是 $\mathcal O(n \log^2 V)$ 了，去重使用单次 $\mathcal O(\log n)$ 复杂度的数据结构可能过不去，我们需要设计一种单次 $\mathcal O(1)$ 得到重复状态中步数最小的。</p><p>那么我们考虑记录 $mn_i,lst_i$ 表示，我们上一次往答案里面扔的数，是 $a_{lst_i}$ 造成的，且对于所有的 $lst_j&#x3D;lst_i$，他们最小扔进去的是 $mn_i$。</p><p>那么如果我们再往里面扔一个 $lst_j&#x3D;lst_i$ 的方案，直接对于这个 $mn_i$ 判断要不要更新答案和 $mn_i$。如果扔进去的不是 $lst_i$ 造成的贡献，我们直接把 $lst_i,mn_i$ 等重构成目前的信息即可。</p><p>说这么多，其实本质就是记录上次修改是不是自己造成的，如果是自己造成的就把修改的数取最优。</p><p>实现的时候还要记录每个状态被不同的数贡献了几次，只有恰好贡献 $n$ 次才可能让所有数都变成它。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://codeforces.com/contest/558/submission/273070746">CF submission 273070746</a></p><p>复杂度 $\mathcal O(n\log^2 n)$。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">min</span>(x, y); &#125;<span class="type">const</span> <span class="type">int</span> LOG = <span class="number">18</span>;<span class="type">int</span> n;<span class="type">int</span> cnt[<span class="number">1</span> &lt;&lt; <span class="number">20</span>];<span class="type">int</span> tot[<span class="number">1</span> &lt;&lt; <span class="number">20</span>];<span class="type">int</span> lst[<span class="number">1</span> &lt;&lt; <span class="number">20</span>];<span class="type">int</span> mn[<span class="number">1</span> &lt;&lt; <span class="number">20</span>];<span class="type">int</span> ans = <span class="number">1e9</span>;<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> <span class="comment">// cnt[y] += x id = z</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (lst[y] == z)    &#123;        cnt[y] -= mn[y];        <span class="built_in">chkmn</span>(mn[y], x);        cnt[y] += mn[y];    &#125;    <span class="keyword">else</span>        mn[y] = x, lst[y] = z, cnt[y] += x, tot[y]++;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="type">int</span> x;        cin &gt;&gt; x;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= LOG; j++)        &#123;            <span class="type">int</span> y = x;            <span class="type">int</span> tmp = <span class="number">0</span>;            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= j; k++)                y &gt;&gt;= <span class="number">1</span>, tmp++;            <span class="built_in">add</span>(tmp, y, i);            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= LOG &amp;&amp; (y &lt;&lt; <span class="number">1</span>) &lt; (<span class="number">1</span> &lt;&lt; <span class="number">20</span>); k++)                y &lt;&lt;= <span class="number">1</span>, tmp++, <span class="built_in">add</span>(tmp, y, i);        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; <span class="number">20</span>; i++)    &#123;        <span class="keyword">if</span> (tot[i] == n)            <span class="built_in">chkmn</span>(ans, cnt[i]);    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[闲话] 487633277 群内魔怔哥语录节选</title>
      <link href="/archives/mzcup2nd_2/"/>
      <url>/archives/mzcup2nd_2/</url>
      
        <content type="html"><![CDATA[<p>487633277 是一个质数群号。</p><p>群友都很魔怔。</p><hr><p>有无时无刻不在想着找 maze 的。</p><p><img src="https://s21.ax1x.com/2024/06/18/pk0vuh6.png"></p><p>有鸣潮魔怔哥。</p><p><img src="https://s21.ax1x.com/2024/06/18/pk0v1je.png"></p><p>有至高无上的管理员。</p><p><img src="https://s21.ax1x.com/2024/06/18/pk0vNNt.png"></p><p>有魔怔哥几餐自己。</p><p><img src="https://s21.ax1x.com/2024/06/18/pk0vgNq.png"></p><p>有亦狂亦侠亦温文的小南梁。</p><p><img src="https://s21.ax1x.com/2024/06/18/pk0vHER.png"></p><p>有无时无刻不被骂的群主。</p><p><img src="https://s21.ax1x.com/2024/06/18/pk0vX8K.png"></p><p>有魔怔哥锐评魔怔哥。</p><p><img src="https://s21.ax1x.com/2024/06/18/pk0vvvD.png"></p><p>有魔怔上位方式。</p><p><img src="https://s21.ax1x.com/2024/06/18/pk0xpbd.png"></p><p>有因式分解魔怔哥。</p><p><img src="https://s21.ax1x.com/2024/06/18/pk0xoz8.png"></p><p>有 wordle 口嗨魔怔哥。</p><p><img src="https://s21.ax1x.com/2024/06/18/pk0xHsg.png"></p><p><img src="https://s21.ax1x.com/2024/06/18/pk0xbLQ.png"></p><p>有拼音联想魔怔哥。</p><p><img src="https://s21.ax1x.com/2024/06/18/pk0xviq.png"></p><p>有魔怔鲲队偷窥群聊消息默默把群主被几餐的言论设为精华。</p><p><img src="https://s21.ax1x.com/2024/06/18/pk0xzWV.png"></p><p>有上古时期的魔怔哥逆天发言。如果不是精华消息里存了早就被清了。</p><p><img src="https://s21.ax1x.com/2024/06/18/pk0zSzT.png"></p><p>有众所周知的表面人畜无害的魔怔哥天波不为人知的一面。</p><p><img src="https://s21.ax1x.com/2024/06/18/pk0zCyF.png"></p><p>有魔怔哥王小蕊的神仙发言。</p><p><img src="https://s21.ax1x.com/2024/06/18/pk0zPL4.png"></p><p>有群主评价自己的可爱桌宠被魔怔哥断章取义。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5zflchcs.png"></p><p>有魔怔哥分不清 npy 和单相思的区别。魔怔小朋友也成为了魔怔复读机。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/vsdc1y9x.png"></p><p>有魔怔 xp 哥。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/nm4kn21z.png"></p><p>有打搅 15min 的魔怔 xp 哥。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/08n5tsbd.png"></p><p>有打搅 15min 的魔怔 xp 哥让大家不要魔怔。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ysfgi46v.png"></p><p>有暴躁波特痛斥魔怔哥。恭喜它通过了图灵测试。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/mr82ov1w.png"></p><p>有打几把游戏的魔怔哥。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/dijbc7r2.png"></p><p>有可爱魔怔学姐（？）</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7rh057oa.png"></p><p>有魔怔人 win。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4jvkfjan.png"></p><p>有魔怔 zzp(s) 互换真名。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/10c7gl5d.png"></p><hr><p>唉，不能魔怔了，要学术。</p>]]></content>
      
      
      <categories>
          
          <category> Essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 魔怔杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[闲话] 20091119 身边的奇质数</title>
      <link href="/archives/mzcup2nd_1/"/>
      <url>/archives/mzcup2nd_1/</url>
      
        <content type="html"><![CDATA[<p>众所周知，$2009,2010,1119,0119$ 都不是质数。</p><p>但是组合起来能得到很多质数。</p><p>$20091119$ 是一个质数，$20102009$ 是一个质数，$11190119$ 是一个质数。</p><p>这有什么用呢，好吧在 OI 中除了可以多做一个被卡概率很大的 Hash 模数没什么用。</p><p>但！是！</p><p>$2010111901192009$ 也是一个质数。</p><pre><code class="highlight cpp"><span class="type">const</span> ull p = <span class="number">2010111901192009</span>;<span class="function">ull <span class="title">shift</span><span class="params">(ull x)</span></span><span class="function"></span>&#123;    x ^= p;    x ^= (x &lt;&lt; <span class="number">7</span>);    x ^= (x &gt;&gt; <span class="number">13</span>);    x ^= (x &lt;&lt; <span class="number">17</span>);    x ^= p;    <span class="keyword">return</span> x;&#125;</code></pre><p>可以用这份 Shift Hash 通过 <a href="https://www.luogu.com.cn/record/152049929"><br>SP7826 TREEISO - Tree Isomorphism</a>。</p><p>但是 OI 中没意义，这和 whk 学习没意义有什么关系。</p><p>$20100119$ 虽然不是质数，但是可以和 $20091119$ 组成奇质数。</p><hr><p>我记得，那天下午第【第【不是奇质数的质数】小奇质数】，去给你送了块巧克力祝你生日快乐，给你送了【不是奇质数的质数】块巧克力。</p><p>你说语文考到 $86$ 随便考，我确实做到了啊。我第二个学期的期中，考到了【小于九十的最大奇质数】。好吧其实就是 $89$。而 $89$ 性质非常优美。众所周知 $\frac{1}{89}$ 小数部分内含斐波那契数列。</p><p>唉，但是九年级应该就要分开了。以后能再见上哪怕一面吗。</p><p>山有木兮，</p><hr><p>任意【不是奇质数的质数】个奇质数的和不是一个奇质数。</p><p>任意【不是奇质数的质数】个奇质数的差不是一个奇质数。</p><p>但是，一个大于【不是奇质数的质数】的【不是奇质数的质数】次幂的【不是奇质数的偶数】也许是可以被拆分成【不是奇质数的质数】个【奇质数】之和。</p><p>好吧我自己都蚌埠住了。什么逆天查找替换。</p>]]></content>
      
      
      <categories>
          
          <category> Essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 魔怔杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC358G AtCoder Tour</title>
      <link href="/archives/ABC358G/"/>
      <url>/archives/ABC358G/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定 $n\times m$ 的网格，每个格子里有一个正整数 $a_{i,j}$。你需要在从 $(sx,sy)$ 开始，执行 $k$ 次操作。每一操作可以选择不动或者走到任意一个四联通（上下左右）的格子。操作之后，可以获得所在格子的 $a_{i,j}$ 的收益。</p><p>$1\leq n,m\leq 50$</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>可以证明，选择的路线一定是，移动若干步（可以是 $0$ 步）然后一直停留在一个格子获得收益。假设你选定了一条路径作为答案，那么你走到这条路径上的最大值后一直停留，一定是不比继续往后走差的。也不会出现在一个格子停一会儿转下一个更大的格子，因为这样不如把之前停留的步数留给后面更大的格子。</p><hr><p>做法一：</p><p>考虑到停留在一个格子获得收益部分与你移动所花步数相关，因此，我们不妨枚举『行走步数』。设 $f_{i,x,y}$ 表示走了 $i$ 步停留在 $(x,y)$ 的收益最大路径所得到的收益。</p><p>转移枚举『行走步数』$i$，『起始点』$(x,y)$，『方向』，通过『起始点』和『方向』可以得到『目标点』$(tx,ty)$，转移即为 $f_{i+1,tx,ty}\gets \max f_{i,x,y}+a_{tx,ty}$。</p><p>但是，『行走步数』很大。可是稍微想一下就可以发现至多 $\mathcal O(n^2)$ 步就能到达。虽然说用 $\mathcal O(n)$ 步一定能从任意一点出发，到达网格任意一点。但是收益会有区别。例如下面这组数据：</p><pre><code class="highlight cpp"><span class="number">6</span> <span class="number">3</span> <span class="number">1000000000</span><span class="number">6</span> <span class="number">1</span><span class="number">100</span> <span class="number">100</span> <span class="number">100</span><span class="number">100</span> <span class="number">1</span> <span class="number">100</span><span class="number">100</span> <span class="number">1</span> <span class="number">100</span><span class="number">100</span> <span class="number">1</span> <span class="number">100</span><span class="number">100</span> <span class="number">1</span> <span class="number">100</span><span class="number">100</span> <span class="number">1</span> <span class="number">101</span></code></pre><p>虽然可以从 $(6,1)$ 两步到 $(6,3)$，但是经过 $1$ 收益太差了。我们必须要绕过 $1$ 走。</p><p>因此形如上方的网格，构造一个大数填充，小数做墙的网格，就可以强制走 $\mathcal O(n^2)$ 步。</p><p>因此状态是 $\mathcal O(n^4)$ 的，转移是 $\mathcal O(1)$ 的。</p><p>$n,m$ 同阶，时间复杂度 $\mathcal O(n^4)$。</p><hr><p>做法二：</p><p>考虑枚举『最后停在哪一个格子』$(ex,ey)$。</p><p>那么你每次移动到 $(tx,ty)$ 的代价相较于待在 $(ex,ey)$，代价就是 $a_{ex,ey}-a_{tx,ty}$。</p><p>之后直接建图跑最短路。</p><p>负数边权可以直接忽略，因为你走到大的没有必要继续走下去，而显然这个更大的点之后会被枚举到。从而将图转化为非负权图，可以使用 Dijkstra 求解。</p><p>那么答案即为 $a_{ex,ey}\times k-dis((sx,sy),(ex,ey))$。也就是停在一直最后格子的收益减去赶路时间。</p><p>$n,m$ 同阶，时间复杂度 $\mathcal O(n^4\log n)$。</p><h1 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h1><p><a href="https://atcoder.jp/contests/abc358/submissions/54574838">Code by @cayaxi09</a></p><p>这是我自己的代码。赛时看了一眼就会了，关键结论有点典，DP 部分也比较基础。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;<span class="type">const</span> <span class="type">int</span> dy[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">max</span>(x, y); &#125;<span class="type">int</span> n, m, k;ll a[<span class="number">55</span>][<span class="number">55</span>];<span class="type">int</span> x, y;ll dis[<span class="number">2520</span>][<span class="number">55</span>][<span class="number">55</span>];ll ans;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; x &gt;&gt; y;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)            cin &gt;&gt; a[i][j];    ans = a[x][y] * k;    <span class="keyword">auto</span> in = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y)    &#123; <span class="keyword">return</span> <span class="number">1</span> &lt;= x &amp;&amp; x &lt;= n &amp;&amp; <span class="number">1</span> &lt;= y &amp;&amp; y &lt;= m; &#125;;    <span class="built_in">memset</span>(dis, <span class="number">128</span>, <span class="built_in">sizeof</span>(dis));    dis[<span class="number">0</span>][x][y] = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">min</span>(n * m, k); i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)        &#123;            <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt;= m; y++)            &#123;                <span class="keyword">for</span> (<span class="type">int</span> _ = <span class="number">0</span>; _ &lt; <span class="number">4</span>; _++)                &#123;                    <span class="type">int</span> tx = x + dx[_];                    <span class="type">int</span> ty = y + dy[_];                    <span class="keyword">if</span> (!<span class="built_in">in</span>(tx, ty))                        <span class="keyword">continue</span>;                    <span class="built_in">chkmx</span>(dis[i][tx][ty], dis[i - <span class="number">1</span>][x][y] + a[tx][ty]);                &#125;            &#125;        &#125;        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)            <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt;= m; y++)                <span class="built_in">chkmx</span>(ans, dis[i][x][y] + a[x][y] * (k - i));    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p><a href="https://atcoder.jp/contests/abc358/submissions/54586348">Code by @hitoare</a></p><p>滚动数组写法，空间复杂度更优，时间复杂度无差别。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> ll long long</span><span class="meta">#<span class="keyword">define</span> ld long double</span><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    ll H, W, K;    cin &gt;&gt; H &gt;&gt; W &gt;&gt; K;    ll sx, sy;    cin &gt;&gt; sx &gt;&gt; sy;    sx--;sy--;    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">A</span>(H, <span class="built_in">vector</span>&lt;ll&gt;(W, <span class="number">0</span>));    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; H; i++) &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; W; j++) cin &gt;&gt; A[i][j];    &#125;    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">from</span>(H, <span class="built_in">vector</span>&lt;ll&gt;(W, <span class="number">-2e18</span>));    from[sx][sy] = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> z = <span class="number">0</span>; z &lt; <span class="number">5000</span>; z++) &#123;        <span class="keyword">if</span> (K == <span class="number">0</span>) <span class="keyword">break</span>;        K--;        vector&lt;vector&lt;ll&gt;&gt; to = from;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; H; i++) &#123;            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; W; j++) &#123;                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) to[i][j] = <span class="built_in">max</span>(from[i<span class="number">-1</span>][j], to[i][j]);                <span class="keyword">if</span> (i &lt; H<span class="number">-1</span>) to[i][j] = <span class="built_in">max</span>(from[i<span class="number">+1</span>][j], to[i][j]);                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) to[i][j] = <span class="built_in">max</span>(from[i][j<span class="number">-1</span>], to[i][j]);                <span class="keyword">if</span> (j &lt; W<span class="number">-1</span>) to[i][j] = <span class="built_in">max</span>(from[i][j<span class="number">+1</span>], to[i][j]);                to[i][j] += A[i][j];            &#125;        &#125;        <span class="built_in">swap</span>(from, to);    &#125;    ll ans = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; H; i++) &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; W; j++) &#123;            ans = <span class="built_in">max</span>(ans, from[i][j]+K*A[i][j]);        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p><a href="https://atcoder.jp/contests/abc358/submissions/54570824">Code by PCTprobability</a></p><p>写的是第二种做法。</p><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(ll s)</span></span>&#123;  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v;i++)&#123;    d[i]=inf;  &#125;  d[s]=<span class="number">0</span>;  priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt;&gt; que;  que.<span class="built_in">push</span>(<span class="built_in">P</span>(<span class="number">0</span>,s));  <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;    P p=que.<span class="built_in">top</span>();    que.<span class="built_in">pop</span>();    ll V=p.second;    <span class="keyword">if</span>(d[V]&lt;p.first) <span class="keyword">continue</span>;    <span class="keyword">for</span>(<span class="keyword">auto</span> e:g[V])&#123;      <span class="keyword">if</span>(d[e.to]&gt;d[V]+e.cost)&#123;        d[e.to]=d[V]+e.cost;        que.<span class="built_in">push</span>(<span class="built_in">P</span>(d[e.to],e.to));      &#125;    &#125;  &#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  <span class="built_in">cincout</span>();  ll n,m,v;  cin&gt;&gt;n&gt;&gt;m&gt;&gt;v;  ll p,q;  cin&gt;&gt;p&gt;&gt;q;  p--;  q--;  vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">a</span>(n,<span class="built_in">vector</span>&lt;ll&gt;(m));  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) cin&gt;&gt;a[i][j];  &#125;  ll ans=-inf;  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;      <span class="function">graph <span class="title">g</span><span class="params">(n*m)</span></span>;      vector&lt;<span class="type">int</span>&gt; px=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,py=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;      <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;n;x++)&#123;        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;m;y++)&#123;          <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;            <span class="type">int</span> nx=x+px[k],ny=y+py[k];            <span class="keyword">if</span>(nx&lt;<span class="number">0</span>||nx&gt;=n||ny&lt;<span class="number">0</span>||ny&gt;=m) <span class="keyword">continue</span>;            <span class="keyword">if</span>(a[nx][ny]&gt;a[i][j]) <span class="keyword">continue</span>;            g.<span class="built_in">add_edge</span>(x*m+y,nx*m+ny,a[i][j]-a[nx][ny]);          &#125;        &#125;      &#125;      g.<span class="built_in">dijkstra</span>(p*m+q);      ll d=g.d[i*m+j];      <span class="built_in">chmax</span>(ans,a[i][j]*v-d);    &#125;  &#125;  cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 信息与未来 2024 做题笔记</title>
      <link href="/archives/JSOI2024/"/>
      <url>/archives/JSOI2024/</url>
      
        <content type="html"><![CDATA[<h1 id="幸运数字"><a href="#幸运数字" class="headerlink" title="幸运数字"></a>幸运数字</h1><p>一个很小朋友的做法是把每个数转二进制字符串或者用数组存下来判断。这里给一个时间复杂度为 $\mathcal O(n\log V)$ 但空间复杂度为 $\mathcal O(1)$ 的写法：使用位运算，通过 <code>x &gt;&gt; i &amp; 1</code> 获得 $x$ 在二进制下的第 $i$ 位。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a, b;<span class="type">int</span> ans;<span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span><span class="function"></span>&#123;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)    &#123;        <span class="keyword">if</span> ((i &lt; <span class="number">30</span> ? (x &gt;&gt; i + <span class="number">1</span> &amp; <span class="number">1</span>) ^ (x &gt;&gt; i &amp; <span class="number">1</span>) : <span class="number">1</span>) &amp;&amp; (i &gt; <span class="number">0</span> ? (x &gt;&gt; i &amp; <span class="number">1</span>) ^ (x &gt;&gt; i - <span class="number">1</span> &amp; <span class="number">1</span>) : <span class="number">1</span>))            <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; a &gt;&gt; b;    <span class="keyword">for</span> (<span class="type">int</span> i = a; i &lt;= b; i++)        ans += <span class="built_in">check</span>(i);    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="红绿灯"><a href="#红绿灯" class="headerlink" title="红绿灯"></a>红绿灯</h1><p>如果一个数应该亮的位置没亮，说明一定不亮。</p><p>如果一个数不该亮的位置亮了，说明一定常亮。</p><p>我们根据生活常识把每种灯应该点亮的位置存下来，对于这两种情况判断即可。</p><p>表格如下。请自行在程序内根据这个表格判断。</p><pre><code class="highlight mathematica"><span class="number">0</span><span class="operator">:</span> <span class="variable">A</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="built_in">D</span> <span class="built_in">E</span> <span class="variable">F</span> <span class="number">1</span><span class="operator">:</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="number">2</span><span class="operator">:</span> <span class="variable">A</span> <span class="variable">B</span> <span class="built_in">D</span> <span class="built_in">E</span> <span class="variable">G</span> <span class="number">3</span><span class="operator">:</span> <span class="variable">A</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="built_in">D</span> <span class="variable">G</span> <span class="number">4</span><span class="operator">:</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="variable">F</span> <span class="variable">G</span> <span class="number">5</span><span class="operator">:</span> <span class="variable">A</span> <span class="built_in">C</span> <span class="built_in">D</span> <span class="variable">F</span> <span class="variable">G</span> <span class="number">6</span><span class="operator">:</span> <span class="variable">A</span> <span class="built_in">C</span> <span class="built_in">D</span> <span class="built_in">E</span> <span class="variable">F</span> <span class="variable">G</span> <span class="number">7</span><span class="operator">:</span> <span class="variable">A</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="number">8</span><span class="operator">:</span> <span class="variable">A</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="built_in">D</span> <span class="built_in">E</span> <span class="variable">F</span> <span class="variable">G</span> <span class="number">9</span><span class="operator">:</span> <span class="variable">A</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="built_in">D</span> <span class="variable">F</span> <span class="variable">G</span></code></pre><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;vector&lt;<span class="type">int</span>&gt; a[<span class="number">10</span>];<span class="type">int</span> n;string ans = <span class="string">&quot;-------&quot;</span>;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    a[<span class="number">0</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;    a[<span class="number">1</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;    a[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;    a[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;    a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;    a[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;    a[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;    a[<span class="number">7</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;    a[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;    a[<span class="number">9</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;    cin &gt;&gt; n;    <span class="keyword">while</span> (n--)    &#123;        string s;        cin &gt;&gt; s;        <span class="type">int</span> k = s[<span class="number">0</span>] ^ <span class="string">&#x27;0&#x27;</span>;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++)        &#123;            <span class="type">bool</span> ok = <span class="number">0</span>;            <span class="keyword">for</span> (<span class="type">int</span> j : a[k])                <span class="keyword">if</span> (j == s[i] - <span class="string">&#x27;A&#x27;</span>)                    ok = <span class="number">1</span>;            <span class="keyword">if</span> (!ok)                ans[s[i] - <span class="string">&#x27;A&#x27;</span>] = <span class="string">&#x27;X&#x27;</span>;        &#125;        <span class="keyword">for</span> (<span class="type">int</span> j : a[k])        &#123;            <span class="type">bool</span> ok = <span class="number">0</span>;            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++)                <span class="keyword">if</span> (j == s[i] - <span class="string">&#x27;A&#x27;</span>)                    ok = <span class="number">1</span>;            <span class="keyword">if</span> (!ok)                ans[j] = <span class="string">&#x27;x&#x27;</span>;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="间谍卫星"><a href="#间谍卫星" class="headerlink" title="间谍卫星"></a>间谍卫星</h1><p>通过观察图片我们发现除了平行于坐标轴的正方形，其他的情况，一定存在一个编号最小的行，满足行内只有一个正方形的顶点。不妨钦定这个点，找到另外的和它在一条边上的另一个顶点计算边长。那么由于正方形的四个角都是直角，所以我们只需要找到编号最小的列，满足行内只有一个正方形的顶点，就可以了。证明显然。</p><p>接下来我们考虑怎么把这个代码写得更加优美：如果正方形边都垂直于坐标轴，那么就是找行里最右边的和列里最上面的。<del>干脆直接特判也可以吧。</del></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> n = <span class="number">128</span>;string s[<span class="number">150</span>];<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        cin &gt;&gt; s[i], s[i] = <span class="string">&#x27; &#x27;</span> + s[i];    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= <span class="number">1</span>; j--)        &#123;            <span class="keyword">if</span> (!(s[i][j] ^ <span class="string">&#x27;0&#x27;</span>))                <span class="keyword">continue</span>;            <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt;= n; y++)            &#123;                <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)                &#123;                    <span class="keyword">if</span> (s[x][y] ^ <span class="string">&#x27;0&#x27;</span>)                        <span class="keyword">return</span> cout &lt;&lt; <span class="built_in">sqrt</span>((x - i) * (x - i) + (y - j) * (y - j)) &lt;&lt; endl, <span class="built_in">void</span>();                &#125;            &#125;        &#125;    &#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> t;    cin &gt;&gt; t;    <span class="keyword">while</span> (t--)        <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="图灵完备"><a href="#图灵完备" class="headerlink" title="图灵完备"></a>图灵完备</h1><p>这个 $5000$ 的限制就很烦，否则我们可以构造一个 $1$ 然后拼在一起。</p><p>但是这启发我们，答案一定是用什么东西拼起来的。正常的什么二进制不行，因为本题没有乘法操作，只能加法凑。</p><p>但是我们根据已有的 JavaScript 语法经验或者单纯对于给出的字符组合，发现 <code>+[]</code> 返回一个 Number，<code>[]+[]</code> 返回一个 String。执行 <code>+([]+[])</code> 对一个空字符串求值又得到了一个 $0$。也就是说，我们把 $n$ 的每一位用 String 表示出来拼接在一起，然后转成 Number 类型即可。一个 <code>+!![]</code> 就是 $1$，每一位最多拼接 $9$ 次。长度显然不会超过 $5000$。</p><p>Fun Fact：有一个为本题而生的网站 <a href="https://jsfuck.com/">https://jsfuck.com/</a>。也许下面的信息可以对于做这题给出一些启发。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;string s;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; s;    cout &lt;&lt; <span class="string">&quot;+(&quot;</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)    &#123;        <span class="keyword">if</span> (i)            cout &lt;&lt; <span class="string">&quot;+&quot;</span>;        s[i] ^= <span class="string">&#x27;0&#x27;</span>;        cout &lt;&lt; <span class="string">&quot;(&quot;</span>;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j++)            cout &lt;&lt; <span class="built_in">string</span>(<span class="string">&quot;+!![]&quot;</span>).<span class="built_in">substr</span>(!(j &gt;= <span class="number">1</span>));        cout &lt;&lt; <span class="string">&quot;+[])&quot;</span>;    &#125;    cout &lt;&lt; <span class="string">&quot;)&quot;</span>;    cout &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h1><p>码量一般的模拟。</p><p>把表头和学生信息以 <code>,</code> 为分隔符拎出来，存起来。由于（据我所知）不同类型数组不能开在一起，所以信息存的是 $3$ 个内容，分别表示为数还是字符串，以及数字的值和字符串的值。</p><p>排序部分，把排序方式先离线下来。比较两个元素时，按顺序遍历排序方式，判断升序降序，为数还是字符串，然后进行比较。</p><p>由于给定排序方法相同需要按照原顺序，所以多加一个 $id$ 用来判断全部一样时的先后顺序。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n, m, c;string s, t;<span class="type">int</span> cnt;string cmp[<span class="number">20</span>];string tt;map&lt;string, <span class="type">int</span>&gt; title;<span class="keyword">struct</span> <span class="title class_">node</span>&#123;    <span class="type">bool</span> op; <span class="comment">// int 0 str 1</span>    <span class="type">int</span> x;    string y;&#125;;vector&lt;node&gt; a[<span class="number">120</span>];<span class="function"><span class="type">bool</span> <span class="title">isstr</span><span class="params">(string s)</span></span><span class="function"></span>&#123;    <span class="type">int</span> cnt = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">char</span> c : s)        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))            cnt++;    <span class="keyword">return</span> cnt &lt; s.<span class="built_in">size</span>();&#125;<span class="function"><span class="type">bool</span> <span class="title">ccmp</span><span class="params">(vector&lt;node&gt; a, vector&lt;node&gt; b)</span></span><span class="function"></span>&#123;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c; i++)    &#123;        <span class="type">int</span> op = cmp[i].<span class="built_in">back</span>();        string t = cmp[i].<span class="built_in">substr</span>(<span class="number">0</span>, cmp[i].<span class="built_in">size</span>() - <span class="number">1</span>);        <span class="type">int</span> j = title[t];        <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>)        &#123;            <span class="keyword">if</span> (!a[j].op)            &#123;                <span class="keyword">if</span> (a[j].x == b[j].x)                    <span class="keyword">continue</span>;                <span class="keyword">return</span> a[j].x &lt; b[j].x;            &#125;            <span class="keyword">else</span>            &#123;                <span class="keyword">if</span> (a[j].y == b[j].y)                    <span class="keyword">continue</span>;                <span class="keyword">return</span> a[j].y &lt; b[j].y;            &#125;        &#125;        <span class="keyword">else</span>        &#123;            <span class="keyword">if</span> (!a[j].op)            &#123;                <span class="keyword">if</span> (a[j].x == b[j].x)                    <span class="keyword">continue</span>;                <span class="keyword">return</span> a[j].x &gt; b[j].x;            &#125;            <span class="keyword">else</span>            &#123;                <span class="keyword">if</span> (a[j].y == b[j].y)                    <span class="keyword">continue</span>;                <span class="keyword">return</span> a[j].y &gt; b[j].y;            &#125;        &#125;    &#125;    <span class="keyword">return</span> a[<span class="number">0</span>].x &lt; b[<span class="number">0</span>].x;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n &gt;&gt; s;    tt = s;    s += <span class="string">&#x27;,&#x27;</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)    &#123;        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;,&#x27;</span>)        &#123;            title[t] = ++m;            t = <span class="string">&quot;&quot;</span>;            <span class="keyword">continue</span>;        &#125;        t += s[i];    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)    &#123;        a[i].<span class="built_in">resize</span>(m + <span class="number">20</span>);        cin &gt;&gt; s;        s += <span class="string">&#x27;,&#x27;</span>;        t = <span class="string">&quot;&quot;</span>;        a[i][<span class="number">0</span>].x = i;        <span class="type">int</span> cnt = <span class="number">0</span>;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s.<span class="built_in">size</span>(); j++)        &#123;            <span class="keyword">if</span> (s[j] == <span class="string">&#x27;,&#x27;</span>)            &#123;                cnt++;                a[i][cnt].op = <span class="built_in">isstr</span>(t);                <span class="keyword">if</span> (!a[i][cnt].op)                    a[i][cnt].x = <span class="built_in">stoi</span>(t);                <span class="keyword">else</span>                    a[i][cnt].y = t;                t = <span class="string">&quot;&quot;</span>;                <span class="keyword">continue</span>;            &#125;            t += s[j];        &#125;    &#125;    cin &gt;&gt; c;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c; i++)        cin &gt;&gt; cmp[i];    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n, ccmp);    cout &lt;&lt; tt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)        &#123;            <span class="keyword">if</span> (!a[i][j].op)                cout &lt;&lt; a[i][j].x;            <span class="keyword">else</span>                cout &lt;&lt; a[i][j].y;            <span class="built_in">putchar</span>(j == m ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27;,&#x27;</span>);        &#125;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="AI-机器人"><a href="#AI-机器人" class="headerlink" title="AI 机器人"></a>AI 机器人</h1><p>真神啊。不低于省选难度吧？</p><p>我们每一步移动的本质，其实是相当于有若干个一样的机器人在很多位置移动，按操作方法移动到了一个位置。最后答案就是这些机器人移动位置的交集。</p><p>然而我们发现，对于一个位置 $(x_1,y_1)$，这上面的机器人所能移动到的位置 $(x_2,y_2)$ 是固定的。因此可以用一个大小为 $(n\times m)\times (n\times m)$ 的 01 矩阵，$a_{i,j}$ 表示编号 $i$ 的点能否到达编号 $j$ 的点。我们这里需要把矩形空间压缩成线性空间，把一个点对映射成一个编号。</p><p>我们不妨对于 $\tt{U,L,D,R}$ 每种操作先处理出每种操作，所有位置经过操作时候能到达的位置。这是可以读入了这个矩形空间就能解决的。</p><p>接下来我们可以递归（或者用栈处理）这个表达式。</p><p>我们简单定义一下以后说到的操作：</p><ol><li>矩阵乘法：此处为广义的。我们的矩阵由于维护的是是否可达，所以就是乘法改成做一个 bit_or 运算。也就是 <code>c[i][j] = a[i][k] | b[k][j];</code>。</li><li>矩阵加法：还是，广义……？其实表达成矩阵 bit_or 更合适，但是和上文有些重复，还是表述成矩阵加法吧。这里加法也改成 bit_or。也就是 <code>c[i][j] = a[i][j] | b[i][j];</code>。</li></ol><p>众所周知，矩阵乘法可以算图上行走 $k$ 步的方案数。类比过来，这里的矩阵乘法可以让我们知道走 $k$ 步能到哪里。而这里的矩阵加法是用来合并路径的。</p><p>单次操作是简单的，我们把目前的操作得到的结果和目前这个单次操作做一个矩阵乘法即可。</p><p>带有括号不好处理。我们先来讲固定次数怎么做。</p><p>在我们已知括号内的操作时，直接循环这么多次，每次用已有操作序列做矩阵乘法，然后路径做一个矩阵加法。</p><p>星号同理，但是循环次数不唯一。我们可以发现，其实下面这组测试数据星号需要的循环次数会比较多。</p><pre><code class="highlight cpp"><span class="number">10</span> <span class="number">10</span>..........#########.#########.#########.#########.#########.#########.#########.#########...........(RD)*</code></pre><p>这样的话最坏情况就是 $(1,1)\to (1,n)\to(n,m)$ 得到 $18$ 的长度（第一个点默认走过）。</p><p>所以星号跑 $18$ 次，把结果全凑一起就行。</p><p>然而还构造出要跑更多次的数据，所以这个方法这个方法太菜了。我们可以做到更好的复杂度。</p><p>先对目前括号内的操作序列做一个传递闭包，相当于得到了每个点能前往的所有点。然后相当于对这个做一次行走即可。</p><p>那么接下来我们求出括号内操作序列即可。对于每个 <code>(</code> 找到与之匹配的 <code>)</code>，递归搜出这两个中间的操作序列即可。</p><p>最后，这题矩阵运算有一个技巧。因为是 01 矩阵，可以用 bitset 优化，这样矩阵乘法复杂度就是 $\mathcal O(\frac{n^3}{w})$ 的。但是，又发现这题矩阵大小至多 $100\times 100$，可以用状压的思想把一行压成一个数。这样理论上针对这题的矩阵乘法复杂度就是 $\mathcal O(n^2)$。可以用 C++ 中的 <code>__int128</code> 储存。</p><p>这个方法甚至星号不是瓶颈，有界限的循环才是瓶颈。</p><p>时间复杂度 $\mathcal O(|s|(nm)^2k)$，其中 $k&#x3D;9$。可以通过。并且不可能卡满，因此实际效率非常快。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> array&lt;__int128, 100&gt; Matrix;<span class="keyword">typedef</span> pair&lt;Matrix, Matrix&gt; pMM;<span class="type">int</span> n, m;<span class="type">char</span> mp[<span class="number">10</span>][<span class="number">10</span>];<span class="type">int</span> id[<span class="number">10</span>][<span class="number">10</span>];__int128 pw[<span class="number">100</span>];<span class="type">int</span> N;<span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;<span class="type">const</span> <span class="type">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">in</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span> &lt;= x &amp;&amp; x &lt; n &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; m; &#125;<span class="type">char</span> to[<span class="number">100</span>];Matrix base[<span class="number">4</span>];Matrix ans;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">(Matrix &amp;x)</span></span><span class="function"></span>&#123;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)        x[i] = <span class="number">0</span>;&#125;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(Matrix &amp;x)</span></span><span class="function"></span>&#123;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)        x[i] |= pw[i];&#125;Matrix <span class="keyword">operator</span>|(<span class="type">const</span> Matrix &amp;x, <span class="type">const</span> Matrix &amp;y)&#123;    Matrix z;    <span class="built_in">clear</span>(z);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)        z[i] = x[i] | y[i];    <span class="keyword">return</span> z;&#125;Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix &amp;x, <span class="type">const</span> Matrix &amp;y)&#123;    Matrix z;    <span class="built_in">clear</span>(z);    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; N; k++)        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)            <span class="keyword">if</span> (x[i] &gt;&gt; k &amp; <span class="number">1</span>)                z[i] |= y[k];    <span class="keyword">return</span> z;&#125;Matrix &amp;<span class="keyword">operator</span>|=(Matrix &amp;x, <span class="type">const</span> Matrix &amp;y) &#123; <span class="keyword">return</span> x = x | y; &#125;Matrix &amp;<span class="keyword">operator</span>*=(Matrix &amp;x, <span class="type">const</span> Matrix &amp;y) &#123; <span class="keyword">return</span> x = x * y; &#125;string s;<span class="function">pMM <span class="title">dfs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> <span class="comment">// [l, r)</span></span><span class="function"></span>&#123;    Matrix opt;    <span class="built_in">clear</span>(opt);    <span class="built_in">build</span>(opt);    Matrix path;    <span class="built_in">clear</span>(path);    <span class="built_in">build</span>(path);    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt; r; i++)    &#123;        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(s[i]))        &#123;            opt *= base[to[s[i]]];            path |= opt;            <span class="keyword">continue</span>;        &#125;        <span class="type">int</span> cnt = <span class="number">0</span>;        <span class="type">int</span> j = i;        <span class="keyword">while</span> (j &lt; r)        &#123;            <span class="keyword">if</span> (s[j] == <span class="string">&#x27;(&#x27;</span>)                cnt++;            <span class="keyword">if</span> (s[j] == <span class="string">&#x27;)&#x27;</span>)                cnt--;            j++;            <span class="keyword">if</span> (!cnt)                <span class="keyword">break</span>;        &#125;        <span class="keyword">auto</span> [op, mp] = <span class="built_in">dfs</span>(i + <span class="number">1</span>, j - <span class="number">1</span>);        <span class="keyword">if</span> (s[j] == <span class="string">&#x27;*&#x27;</span>)        &#123;            <span class="built_in">build</span>(op);            <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; N; x++)                <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; N; y++)                    <span class="keyword">if</span> (op[x] &gt;&gt; y &amp; <span class="number">1</span>)                        op[x] |= op[y];            path |= opt * op * mp;            opt *= op;        &#125;        <span class="keyword">else</span>        &#123;            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; (s[j] ^ <span class="string">&#x27;0&#x27;</span>); k++)            &#123;                path |= opt * mp;                opt *= op;            &#125;        &#125;        i = j;    &#125;    <span class="keyword">return</span> &#123;opt, path&#125;;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    to[<span class="string">&#x27;R&#x27;</span>] = <span class="number">0</span>, to[<span class="string">&#x27;L&#x27;</span>] = <span class="number">1</span>, to[<span class="string">&#x27;D&#x27;</span>] = <span class="number">2</span>, to[<span class="string">&#x27;U&#x27;</span>] = <span class="number">3</span>;    pw[<span class="number">0</span>] = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++)        pw[i] = pw[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;    cin &gt;&gt; n &gt;&gt; m;    N = n * m;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)            cin &gt;&gt; mp[i][j];    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)            id[i][j] = i * m + j;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; n; x++)        &#123;            <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; m; y++)            &#123;                <span class="type">int</span> tx = x + dx[i];                <span class="type">int</span> ty = y + dy[i];                base[i][id[x][y]] |= pw[<span class="built_in">in</span>(tx, ty) &amp;&amp; mp[tx][ty] == <span class="string">&#x27;.&#x27;</span> ? id[tx][ty] : id[x][y]];            &#125;        &#125;    &#125;    cin &gt;&gt; s;    ans = <span class="built_in">dfs</span>(<span class="number">0</span>, s.<span class="built_in">size</span>()).second;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)        &#123;            <span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;#&#x27;</span>)                <span class="built_in">putchar</span>(<span class="string">&#x27;#&#x27;</span>);            <span class="keyword">else</span> <span class="keyword">if</span> (ans[<span class="number">0</span>] &gt;&gt; id[i][j] &amp; <span class="number">1</span>)                <span class="built_in">putchar</span>(<span class="string">&#x27;+&#x27;</span>);            <span class="keyword">else</span>                <span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);        &#125;        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>对于 p6 研究了很久，发现赛时通过的同学代码有误，特地写了份报告发给了 jyy 老师。</p><blockquote><p>OI 之外还有一个很大的世界（但你们可能暂时理解不到这一层），这个活动更深层次的目的是能够通过一些测试数据看一看选手们的解题直觉，因此不必如此较真。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1975E Chain Queries</title>
      <link href="/archives/CF1975E/"/>
      <url>/archives/CF1975E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定一棵 $n$ 个节点的数，$c_i&#x3D;1$ 表示这个点为黑色，$c_i&#x3D;0$ 表示这个点为白色。</p><p>接下来有 $q$ 次询问，每次给定一个 $u$，把 $u$ 的颜色取反（即黑变白，白变黑），问黑色点是否构成一条链。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>$k$ 个黑点，构成长度为 $k$ 的链的充要条件是，恰好存在 $k-2$ 个点的度数为 $2$。当然 $k\leq 2$ 需要特判一手。$0$ 个黑点不为链，$1$ 个为链，$2$ 个判断是否相邻。</p><p>因此，我们可以得到一个很暴力的做法就是每次维护 $deg_i$ 表示 $i$ 的度数，然后加点删点直接对 $deg_v\gets deg_v-1$。其中 $v$ 是 $u$ 的父亲或者 $u$ 的儿子。</p><p>每个点父亲唯一，儿子可能有很多，直接暴力不可取。因此，我们只要一个东西可以快速处理儿子的加减操作即可。</p><p>考虑维护 BFS 序。</p><p>这样就很容易连续维护自己儿子的贡献。</p><p>那么我们直接上线段树，维护『区间加法』，『全局最大值』，『全局最大值出现次数』这三个东西即可。</p><p>『全局最大值』和『全局最大值出现次数』是可以直接找根节点信息得到的。</p><p>这个是好维护的。</p><p>但是这样容易导致我们算进去白点的度数，为了处理这个，我们把白点的度数一开始全设置为 $-\inf$ 即可。每次改成黑点就加上一个 $\inf$。</p><p>多测要清空。多清空一点。最后五分钟吃一发 WA on 7 因为清空不到位。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>不是，哥们？我咋写了 $4.7\ \text{kb}$？</p><pre><code class="highlight cpp"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;<span class="type">int</span> n, q;vector&lt;<span class="type">int</span>&gt; a[<span class="number">200020</span>];<span class="type">int</span> c[<span class="number">200020</span>];<span class="type">int</span> dfn[<span class="number">200020</span>];<span class="type">bool</span> vis[<span class="number">200020</span>];<span class="type">int</span> par[<span class="number">200020</span>];<span class="type">int</span> L[<span class="number">200020</span>];<span class="type">int</span> R[<span class="number">200020</span>];<span class="keyword">struct</span> <span class="title class_">SegTree</span>&#123;    <span class="keyword">struct</span> <span class="title class_">node</span>    &#123;        <span class="type">int</span> mx, cnt, lzy;    &#125; t[<span class="number">200020</span> &lt;&lt; <span class="number">2</span>];<span class="meta">#<span class="keyword">define</span> ls id &lt;&lt; 1</span><span class="meta">#<span class="keyword">define</span> rs id &lt;&lt; 1 | 1</span>    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> id)</span></span><span class="function">    </span>&#123;        t[id].mx = <span class="built_in">max</span>(t[ls].mx, t[rs].mx);        <span class="keyword">if</span> (t[ls].mx == t[rs].mx)            t[id].cnt = t[ls].cnt + t[rs].cnt;        <span class="keyword">else</span> <span class="keyword">if</span> (t[ls].mx &gt; t[rs].mx)            t[id].cnt = t[ls].cnt;        <span class="keyword">else</span>            t[id].cnt = t[rs].cnt;    &#125;    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r)</span></span><span class="function">    </span>&#123;        t[ls].mx += t[id].lzy;        t[rs].mx += t[id].lzy;        t[ls].lzy += t[id].lzy;        t[rs].lzy += t[id].lzy;        t[id].lzy = <span class="number">0</span>;    &#125;    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> id = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = n)</span></span><span class="function">    </span>&#123;        <span class="keyword">if</span> (l == r)            <span class="keyword">return</span> t[id].mx = t[id].lzy = <span class="number">0</span>, t[id].cnt = <span class="number">1</span>, <span class="built_in">void</span>();        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;        <span class="built_in">build</span>(ls, l, mid);        <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);        <span class="built_in">push_up</span>(id);    &#125;    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> m)</span></span><span class="function">    </span>&#123;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m &lt;&lt; <span class="number">2</span>; i++)            t[i].mx = t[i].cnt = t[i].lzy = <span class="number">0</span>;    &#125;    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> k, <span class="type">int</span> id = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = n)</span></span><span class="function">    </span>&#123;        <span class="keyword">if</span> (r &lt; ql || l &gt; qr)            <span class="keyword">return</span>;        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)            <span class="keyword">return</span> t[id].mx += k, t[id].lzy += k, <span class="built_in">void</span>();        <span class="built_in">push_down</span>(id, l, r);        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;        <span class="built_in">add</span>(ql, qr, k, ls, l, mid);        <span class="built_in">add</span>(ql, qr, k, rs, mid + <span class="number">1</span>, r);        <span class="built_in">push_up</span>(id);    &#125;&#125; T;<span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> times = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        vis[i] = <span class="number">0</span>;    queue&lt;<span class="type">int</span>&gt; q;    q.<span class="built_in">push</span>(<span class="number">1</span>);    vis[<span class="number">1</span>] = <span class="number">1</span>;    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())    &#123;        <span class="type">int</span> u = q.<span class="built_in">front</span>();        q.<span class="built_in">pop</span>();        dfn[u] = ++times;        <span class="built_in">chkmn</span>(L[par[u]], dfn[u]);        <span class="built_in">chkmx</span>(R[par[u]], dfn[u]);        <span class="keyword">for</span> (<span class="type">int</span> v : a[u])            <span class="keyword">if</span> (!vis[v])                par[v] = u, q.<span class="built_in">push</span>(v), vis[v] = <span class="number">1</span>;    &#125;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(n, q);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        dfn[i] = R[i] = par[i] = <span class="number">0</span>, L[i] = inf, a[i].<span class="built_in">clear</span>();    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">read</span>(c[i]);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)    &#123;        <span class="type">int</span> u, v;        <span class="built_in">read</span>(u, v);        a[u].<span class="built_in">push_back</span>(v);        a[v].<span class="built_in">push_back</span>(u);    &#125;    <span class="built_in">bfs</span>();    T.<span class="built_in">build</span>();    <span class="comment">// for (int i = 1; i &lt;= n; i++)</span>    <span class="comment">//     cout &lt;&lt; dfn[i] &lt;&lt; &quot; &quot;;</span>    <span class="comment">// cout &lt;&lt; endl;</span>    <span class="comment">// for (int i = 1; i &lt;= n; i++)</span>    <span class="comment">//     cout &lt;&lt; L[i] &lt;&lt; &quot; &quot; &lt;&lt; R[i] &lt;&lt; endl;</span>    <span class="type">int</span> black = <span class="number">0</span>;    set&lt;<span class="type">int</span>&gt; blk;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        T.<span class="built_in">add</span>(dfn[i], dfn[i], -inf);        <span class="keyword">if</span> (c[i])        &#123;            <span class="type">int</span> u = i;            black++;            blk.<span class="built_in">insert</span>(u);            T.<span class="built_in">add</span>(dfn[u], dfn[u], inf);            T.<span class="built_in">add</span>(dfn[par[u]], dfn[par[u]], <span class="number">1</span>);            <span class="keyword">if</span> (L[u] &lt;= R[u])                T.<span class="built_in">add</span>(L[u], R[u], <span class="number">1</span>);        &#125;    &#125;    <span class="keyword">while</span> (q--)    &#123;        <span class="type">int</span> u;        <span class="built_in">read</span>(u);        <span class="keyword">if</span> (c[u])        &#123;            black--;            blk.<span class="built_in">erase</span>(u);            T.<span class="built_in">add</span>(dfn[u], dfn[u], -inf);            T.<span class="built_in">add</span>(dfn[par[u]], dfn[par[u]], <span class="number">-1</span>);            <span class="keyword">if</span> (L[u] &lt;= R[u])                T.<span class="built_in">add</span>(L[u], R[u], <span class="number">-1</span>);            c[u] = <span class="number">0</span>;        &#125;        <span class="keyword">else</span>        &#123;            black++;            blk.<span class="built_in">insert</span>(u);            T.<span class="built_in">add</span>(dfn[u], dfn[u], inf);            T.<span class="built_in">add</span>(dfn[par[u]], dfn[par[u]], <span class="number">1</span>);            <span class="keyword">if</span> (L[u] &lt;= R[u])                T.<span class="built_in">add</span>(L[u], R[u], <span class="number">1</span>);            c[u] = <span class="number">1</span>;        &#125;        <span class="keyword">if</span> (!black)        &#123;            <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);            <span class="keyword">continue</span>;        &#125;        <span class="keyword">if</span> (black == <span class="number">1</span>)        &#123;            <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);            <span class="keyword">continue</span>;        &#125;        <span class="keyword">if</span> (black == <span class="number">2</span>)        &#123;            <span class="type">int</span> uu = *blk.<span class="built_in">begin</span>();            <span class="type">int</span> vv = *--blk.<span class="built_in">end</span>();            <span class="built_in">puts</span>(par[uu] == vv || par[vv] == uu ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);            <span class="keyword">continue</span>;        &#125;        <span class="comment">// cout &lt;&lt; T.t[1].mx &lt;&lt; &quot; &quot; &lt;&lt; T.t[1].cnt &lt;&lt; endl;</span>        <span class="keyword">if</span> (T.t[<span class="number">1</span>].mx == <span class="number">2</span> &amp;&amp; T.t[<span class="number">1</span>].cnt == black - <span class="number">2</span>)            <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);        <span class="keyword">else</span>            <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);    &#125;    T.<span class="built_in">clear</span>(n + <span class="number">5</span>);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1968G1 Division + LCP (easy version)</title>
      <link href="/archives/CF1968G2/"/>
      <url>/archives/CF1968G2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定长度为 $n$ 的字符串 $s$ 以及 $l,r$。</p><p>对于所有 $k\in[l,r]$ 求出将 $s$ 分成 $k$ 段后每段的 LCP 最大值。</p><p>LCP 是最长公共前缀。</p><p>$1\leq n\leq 2\times 10^5,1\leq l\leq r\leq n$。多测。$1\leq \sum n \leq 2\times 10^5$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>这一问需要求出很多 $l,r$。那么对于这类问题，往往是 $i$ 的答案可以推导出 $i+1$ 的答案，或者有一部分答案是一样的，需要你找出这个连续段。</p><p><del>考虑到我 duel 到的 CF786C 这题和这题做法完全一样就做完了。</del></p><p>但这题做法确实与 CF786C 一样。我慢慢说。</p><p>我们观察样例发现，最后总是有连续的相同段。大胆猜测这个就是关键。</p><p>考虑到对于 $k\geq B$ 的部分，一定存在 $|\operatorname{LCP}|\leq n&#x2F;B$。</p><p>也就是说，如果我们取 $B&#x3D;\sqrt n$，那么 对于 $k\geq \sqrt n$ 的部分只有 $\sqrt n$ 种答案。也就是会存在很多位置的 LCP 是一样的。</p><p><del>那么对于 $k\gt B$，我们先算一个答案，然后二分后面部分的位置找到最远的答案和自己一样的点。</del></p><p>喜报，上面划掉的做法复杂度和 $k\leq B$ 复杂度一样，常数过大我 ST 死掉了。</p><p>不这么做，考虑对于每个 LCP 长度，找到能分多少段，打个标记，之后做一个后缀 max。复杂度更优。</p><p>对于 $k\leq B$，直接做 G1 的单测即可。</p><h1 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h1><p><a href="https://codeforces.com/contest/1968/submission/259503068">https://codeforces.com/contest/1968/submission/259503068</a></p><p>写得很丑。第一发 Hacked 是因为赛时卡常卡到一半莫名其妙过了。后来改了一发 Hash 的随机 Base。然后请群友把第一发叉了。<del>锻炼 Hack 能力（雾）。</del></p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1968G1 Division + LCP (easy version)</title>
      <link href="/archives/CF1968G1/"/>
      <url>/archives/CF1968G1/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定长度为 $n$ 的字符串 $s$ 以及 $l,r$。</p><p>对于所有 $k\in[l,r]$ 求出将 $s$ 分成 $k$ 段后每段的 LCP 长度最大值。</p><p>LCP 是最长公共前缀。</p><p>$1\leq n\leq 2\times 10^5,1\leq l\leq r\leq n$。多测。$1\leq \sum n \leq 2\times 10^5$。</p><p>在 Easy Version 中，满足 $l&#x3D;r$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>也就是 Easy Version 只要求出一个 $k$ 对应的解。</p><p>我们考虑到 LCP 长度有单调性，可以二分答案。</p><p>当然开头的若干个就是需要判断是否合法的 LCP。</p><p>check 考虑贪心枚举每一位，判断将这一位作为开头是否有一个 LCP，如果可以直接跳掉。最后判一下是否有 $\geq mid$ 个位置开头能构成 LCP。</p><p>考虑到你不在前一位截出一个 LCP，在后一位开始只会导致少截出 LCP。贪心正确。</p><h1 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h1><p><a href="https://codeforces.com/contest/1968/submission/259503131">https://codeforces.com/contest/1968/submission/259503131</a></p><p>这个代码是 G2 过了交上的，但是问题不大。这里的 calc 函数就是求答案。直接 <code>cout &lt;&lt; calc(l) &lt;&lt; endl;</code> 是可以过 G1 的。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1968F Equal XOR Segments</title>
      <link href="/archives/CF1968F/"/>
      <url>/archives/CF1968F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定 $n$ 个数 $a_1,a_2,\dots a_n$。有 $q$ 个询问。</p><p>每次询问给出 $l,r$，询问是否可以将 $a_l,a_{l+1},\dots a_r$ 分为 $k&gt;1$ 段，使得每一段异或后相同。</p><p>$1\leq n,q\leq 2\times 10^5$。多测。$1\leq \sum n,\sum q\leq 2\times 10 ^5$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>首先，如果分成 $2$ 段或者 $3$ 段合法，可以证明分成更多段一定合法。如果分成 $2$ 段和不 $3$ 段不合法，可以证明分成更多段一定合法。</p><p>因为拆分成更多段一定可以拆成一个 $2$ 段和 $3$ 段。证明显然，自己稍微试几个就懂了。</p><p>那么就有一个 $\mathcal O(qn^2)$ 的做法。枚举分割点 $p$ 和 $(p,q)$，则判断是否满足 $\bigoplus\limits_{i&#x3D;l}^p&#x3D;\bigoplus\limits_{i&#x3D;p+1}^r$ 或 $\bigoplus\limits_{i&#x3D;l}^p&#x3D;\bigoplus\limits_{i&#x3D;p+1}^q&#x3D;\bigoplus\limits_{i&#x3D;q+1}^r$。</p><p>那么可以用类似前缀和的方式优化这一段异或。写出来就是判断是否满足 $b_{l-1}\oplus b_p&#x3D;b_r\oplus b_p$ 和 $b_{l-1}\oplus b_p&#x3D;b_q\oplus b_p &#x3D;b_r\oplus b_q$。</p><p>容易发现由于异或的性质 $b_{l-1}\oplus b_p&#x3D;b_r\oplus b_p$ 也就是 $b_r&#x3D;b_{l-1}$，分成两段很好处理，直接判断就完了。</p><p>分成三段需要稍微处理一下。类似于两段的做法，我们就是需要找到合法的 $p,q$ 满足 $l\leq p\lt q\lt r$ 且 $b_{l-1}&#x3D;b_p \operatorname{and} b_r&#x3D;b_q$。</p><p>那么我们考虑把相同的一个异或 $x$ 扔到一个 vector 叫 $have_x$ 里，存前缀异或为 $x$ 的位置，那么每次二分处理即可。</p><p>异或很大我们提前离散化一下。</p><p>时间复杂度 $\mathcal O(q\log n)$。</p><h1 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h1><p>写的有点丑。</p><p>注意不能每次拷贝一个 STL 容器，hack 杀疯了。</p><p><a href="https://codeforces.com/contest/1968/submission/259198233">https://codeforces.com/contest/1968/submission/259198233</a></p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 逆天 Pollard Rho</title>
      <link href="/archives/pollardrho/"/>
      <url>/archives/pollardrho/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/record/156977790">https://www.luogu.com.cn/record/156977790</a></p><p>对于题解中的给出的调用系统函数思路进行了 cpp 风格的封装。</p><p>原题解：<a href="https://www.luogu.com/article/y2bnvunz">https://www.luogu.com/article/y2bnvunz</a></p><p>大致思路就是调用 Linux 的 <code>factor</code> 函数，取出输出内容，然后格式化一下。所有因数会从小到大存在 <code>pr(n, v)</code> 的 $v$ 中。</p><pre><code class="highlight cpp"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="function"><span class="type">void</span> <span class="title">execCMD</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd, string &amp;result)</span></span><span class="function"></span>&#123;    <span class="type">char</span> buf_ps[<span class="number">1024</span>];    <span class="type">char</span> ps[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;    FILE *ptr;    <span class="built_in">strcpy</span>(ps, cmd);    <span class="keyword">if</span> ((ptr = <span class="built_in">popen</span>(ps, <span class="string">&quot;r&quot;</span>)) != <span class="literal">NULL</span>)    &#123;        <span class="keyword">while</span> (<span class="built_in">fgets</span>(buf_ps, <span class="number">1024</span>, ptr) != <span class="literal">NULL</span>)            result += buf_ps;        <span class="built_in">pclose</span>(ptr);        ptr = <span class="literal">NULL</span>;    &#125;&#125;<span class="function"><span class="type">void</span> <span class="title">pr</span><span class="params">(ll n, <span class="keyword">auto</span> &amp;v)</span></span><span class="function"></span>&#123;    string s = <span class="built_in">to_string</span>(n);    string cmd = <span class="string">&quot;factor &quot;</span> + s;    v.<span class="built_in">clear</span>();    string t = <span class="string">&quot;&quot;</span>;    <span class="built_in">execCMD</span>(cmd.<span class="built_in">c_str</span>(), t);    t.<span class="built_in">erase</span>(<span class="number">0</span>, s.<span class="built_in">size</span>() + <span class="number">2</span>);    ll d = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">char</span> c : t)    &#123;        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))            (d *= <span class="number">10</span>) += c ^ <span class="string">&#x27;0&#x27;</span>;        <span class="keyword">else</span>            v.<span class="built_in">push_back</span>(d), d = <span class="number">0</span>;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乱搞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1957E Carousel of Combinations</title>
      <link href="/archives/CF1957E/"/>
      <url>/archives/CF1957E/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>赛时一直在做这题但是没推出来呜呜，下次还是不能懒，多打表。一些东西也不要随便化简，可能化简之后反而看不出结论了。</p><p>感谢 ciuim 和 NaCly_Fish 等大神在 LA 群教会我做这题。</p><h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定 $n$，求 $(\sum\limits_{j&#x3D;1}^n\sum \limits_{i&#x3D;j}^n(C(i,j)\bmod j))\bmod p$。</p><p>其中 $p&#x3D;10^9+7$。</p><p>$C(i,j)$ 表示圆排列，即 $\binom{i}{j}(j-1)!$。</p><p>$n!$ 表示阶乘，即 $n\times (n-1)\times (n-2)\times \dots\times 1$。</p><p>$t$ 组询问。</p><p>$1\leq t\leq 5\times 10^5,1\leq n\leq 10^6$。<strong>与大部分 CF 类型题不一样的是，本题没有对 $\sum n$ 的约束</strong>。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>首先先把题目这个鬼式子打开来。即为 $(\sum\limits_{j&#x3D;1}^n\sum \limits_{i&#x3D;j}^n(\dfrac{i!(j-1)!}{j!(i-j)!}\bmod j))\bmod p$。</p><p>这时容易发现，对于每个 $j$ 分开处理比较好，因为都带一个 $\bmod j$。</p><p>然后看到这个时间限制，不难猜测是不劣于 $\mathcal O(n\log n)$ 的解法。</p><p>当然虽然没有保证 $\sum n$ 但是我们可以提前把 $[1,10^6]$ 的答案都算出来然后 $\mathcal O(1)$ 回答。</p><p>那么我们大概猜测这样一个东西：对于任意 $j$ 在<strong>均摊</strong>不劣于 $\mathcal O(\log n)$ 时间求出 $(\sum\limits_{i&#x3D;j}^n(\dfrac{i!(j-1)!}{j!(i-j)!}\bmod j))\bmod p$。</p><p>考虑到这个 $\bmod j$ 的循环节什么的，很容易往调和级数上去想。事实上我赛时也推到了这一步。</p><p>这个时候集中注意力观察。考虑到这个式子是一个二项式系数乘上一个 $(j-1)!$。那么 $(j-1)! \equiv 0\pmod j$ 是上式为 $0$ 的<strong>充分</strong>条件。</p><p>接下来把注意力再次放大，发现不满足 $j&#x3D;4\operatorname{or}j\text{ is prime}$ 的 $j$ 贡献都是 $0$。</p><p>不满足 $j\text{ is prime}$ 的 $j$ 贡献都是 $0$，这个结论如何证明？</p><p>首先 $j&#x3D;1$ 显然任何数 $\equiv 0\pmod 1$。</p><p>然而当 $j$ 是合数且 $j\neq 4$ 的时候，$(j-1)!\equiv 0\pmod j$ 的证明如下。</p><p>考虑合数书写是 $a\times b$ 满足 $a\neq 1\operatorname{and} b\neq 1$，那么朴素情况下即 $a\neq b$，显然 $a$ 与 $b$ 分别作为一个因子在 $(j-1)!$ 中出现了。</p><p>极端一点，$a&#x3D;b$，且 $a,b$ 均为质数，这是最不好处理的。</p><p>然而，由于对于 $a\gt2$ 的情况，一定可以被证明成 $2a$ 与 $b$ 也分别作为一个因子在 $(j-1)!$ 中出现了。</p><p>$a&#x3D;b&#x3D;2$ 是最特殊的情况，因此 $4$ 不被包括在这类合数中。 </p><hr><p>这里有个问题我想了很久，感觉是熬夜打 CF 然后熬夜补题导致的脑子生锈。我们并不是说满足 $(j-1)! \equiv 0\pmod j$ 的才可以满足上式为 $0$。只是说满足 $(j-1)! \equiv 0\pmod j$ 一定满足上式为 $0$，而且可以筛去大部分无用的数。操作起来很方便。</p><hr><p>接下来有了这个结论就很好做了。</p><p>之后的推导需要『威尔逊定理』和『卢卡斯定理』作为前置知识。</p><p>威尔逊定理：对于任意质数 $p$ 满足 $(p-1)!\equiv p-1 \pmod p$。</p><p>卢卡斯定理：对于任意质数 $p$ 满足 $ \binom n m\bmod p&#x3D;\binom{\lfloor n&#x2F;p\rfloor}{\lfloor n&#x2F;m\rfloor}\times \binom{n\bmod p}{m\bmod p}\bmod p$。</p><p>$j&#x3D;4$ 部分很简单，直接按上式算就可以，$\mathcal O(n)$ 解决。乘法过程会炸 long long，可以使用 __int128 解决。</p><p>$j\text { is prime}$ 部分，把上面两个定理组合起来，得到 $\binom ij(j-1)!\equiv \binom ij(j-1)\equiv -\binom i j\equiv-\lfloor\frac i j\rfloor\pmod j$。</p><p>因此，$[kj,(k+1)j-1]$ 之间产生的贡献是一样的，都是 $-\lfloor\frac i j\rfloor&#x3D;-k$。</p><p>所以我们直接枚举这个 $k$ 即可。区间加法可以使用差分解决。</p><p>复杂度是一个类似调和级数的东西。当然，这里只有质数，所以复杂度等同埃筛即 $\mathcal O(n\log \log n)$。</p><p>注意做完之后需要再做一次前缀和才能 $\mathcal O(1)$ 回答。</p><h1 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h1><p><a href="https://codeforces.com/contest/1957/submission/257645847">https://codeforces.com/contest/1957/submission/257645847</a></p><p>省略了 modint 部分。</p><blockquote><p>注意做完之后需要再做一次前缀和才能 $\mathcal O(1)$ 回答。</p></blockquote><p>所以代码最后出现了 2 次前缀和。第一次是差分操作，第二次是前缀和。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;<span class="keyword">using</span> Z = mod_int&lt;P&gt;;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">typedef</span> __int128 LL;<span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>;<span class="type">int</span> p[<span class="number">1000020</span>];<span class="type">bool</span> np[<span class="number">1000020</span>];Z ans[<span class="number">1000020</span>];<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, Z w)</span></span><span class="function"></span>&#123;    ans[l] += w, ans[<span class="built_in">min</span>(r, N) + <span class="number">1</span>] -= w;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n;    cin &gt;&gt; n;    cout &lt;&lt; ans[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    np[<span class="number">1</span>] = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++)    &#123;        <span class="keyword">if</span> (!np[i])            p[++p[<span class="number">0</span>]] = i;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= p[<span class="number">0</span>] &amp;&amp; i * p[j] &lt;= N; j++)        &#123;            np[i * p[j]] = <span class="number">1</span>;            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>)                <span class="keyword">break</span>;        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; j++)    &#123;        <span class="keyword">if</span> (np[j])        &#123;            <span class="keyword">if</span> (j == <span class="number">4</span>)            &#123;                <span class="keyword">for</span> (LL k = <span class="number">4</span>; k &lt;= N; k++)                    <span class="built_in">add</span>(k, k, k * (k - <span class="number">1</span>) * (k - <span class="number">2</span>) * (k - <span class="number">3</span>) / <span class="number">4</span> / <span class="number">3</span> / <span class="number">2</span> / <span class="number">1</span> * <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span> % <span class="number">4</span>);            &#125;            <span class="keyword">continue</span>;        &#125;        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k * j &lt;= N; k++)            <span class="built_in">add</span>(k * j, (k + <span class="number">1</span>) * j - <span class="number">1</span>, (-k % j + j) % j);    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)        ans[i] += ans[i - <span class="number">1</span>];    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)        ans[i] += ans[i - <span class="number">1</span>];    <span class="type">int</span> t;    cin &gt;&gt; t;    <span class="keyword">while</span> (t--)        <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] P3475 这都能过？</title>
      <link href="/archives/P3475/"/>
      <url>/archives/P3475/</url>
      
        <content type="html"><![CDATA[<p>天知道我是在怎样的精神状态下写出来的。</p><p>感觉是很新奇的随机化做法（）</p><hr><p>前 $0.45$ 秒，第一个排列开始找 next_permutation 并且 check。</p><p>前 $0.45\sim 0.9$ 秒，最后一个排列开始找 prev_permutation 并且 check。</p><p>前 $0.9\sim 0.995$ 秒，对于排列随机交换位置，然后如果答案与之前相同，有 $0.9$ 的概率交换。</p><p>最后 $0.005$ 秒用来输出。</p><p>随机种子写奇怪大质数就行。</p><hr><p><a href="https://www.luogu.com.cn/record/155391395">https://www.luogu.com.cn/record/155391395</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;<span class="function">mt19937 <span class="title">rnd</span><span class="params">(<span class="number">2010111901192009</span>)</span></span>;<span class="type">const</span> <span class="type">int</span> ED1 = <span class="number">0.45</span> * CLOCKS_PER_SEC;<span class="type">const</span> <span class="type">int</span> ED2 = <span class="number">0.9</span> * CLOCKS_PER_SEC;<span class="type">const</span> <span class="type">int</span> ED = <span class="number">0.995</span> * CLOCKS_PER_SEC;<span class="function"><span class="type">int</span> <span class="title">R</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">rnd</span>() % (r - l + <span class="number">1</span>) + l; &#125;<span class="type">int</span> mp[<span class="number">30</span>][<span class="number">30</span>];<span class="type">int</span> n, m;<span class="type">int</span> p[<span class="number">30</span>];<span class="type">int</span> ap[<span class="number">30</span>];<span class="type">int</span> ans = inf;<span class="type">int</span> chosen[<span class="number">30</span>];<span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">bool</span> f = <span class="number">0</span>)</span></span><span class="function"></span>&#123;    <span class="type">int</span> tmp = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)            tmp += mp[p[i]][p[j]];    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; i++)        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n &lt;&lt; <span class="number">1</span>; j++)            tmp += mp[p[i]][p[j]];    tmp = m - tmp;    <span class="keyword">if</span> (tmp &gt; ans)        <span class="keyword">return</span>;    <span class="keyword">if</span> (tmp &lt; ans)    &#123;        ans = tmp;        <span class="built_in">memcpy</span>(ap, p, <span class="built_in">sizeof</span>(ap));        <span class="keyword">return</span>;    &#125;    <span class="keyword">if</span> (!f)    &#123;        <span class="keyword">if</span> (<span class="built_in">R</span>(<span class="number">1</span>, <span class="number">100</span>) &gt;= <span class="number">90</span>)            <span class="built_in">memcpy</span>(ap, p, <span class="built_in">sizeof</span>(ap));    &#125;&#125;<span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> l = <span class="built_in">R</span>(<span class="number">1</span>, n);    <span class="type">int</span> r = <span class="built_in">R</span>(n + <span class="number">1</span>, n &lt;&lt; <span class="number">1</span>);    <span class="built_in">swap</span>(p[l], p[r]);    <span class="built_in">upd</span>(<span class="number">1</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(n, m);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        p[i] = i;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)    &#123;        <span class="type">int</span> u, v;        <span class="built_in">read</span>(u, v);        mp[u][v] = mp[v][u] = <span class="number">1</span>;    &#125;    n &gt;&gt;= <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; i++)        chosen[i] = (i &gt; n);    <span class="keyword">do</span>    &#123;        <span class="type">int</span> tot = <span class="number">0</span>;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; i++)        &#123;            <span class="keyword">if</span> (chosen[i])                p[++tot] = i;        &#125;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; i++)        &#123;            <span class="keyword">if</span> (!chosen[i])                p[++tot] = i;        &#125;        <span class="built_in">upd</span>();        <span class="keyword">if</span> (<span class="built_in">clock</span>() &gt; ED1)            <span class="keyword">break</span>;    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(chosen + <span class="number">1</span>, chosen + (n &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>));    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; i++)        chosen[i] = (i &lt;= n);    <span class="keyword">do</span>    &#123;        <span class="type">int</span> tot = <span class="number">0</span>;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; i++)        &#123;            <span class="keyword">if</span> (chosen[i])                p[++tot] = i;        &#125;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n &lt;&lt; <span class="number">1</span>; i++)        &#123;            <span class="keyword">if</span> (!chosen[i])                p[++tot] = i;        &#125;        <span class="built_in">upd</span>();        <span class="keyword">if</span> (<span class="built_in">clock</span>() &gt; ED2)            <span class="keyword">break</span>;    &#125; <span class="keyword">while</span> (<span class="built_in">prev_permutation</span>(chosen + <span class="number">1</span>, chosen + (n &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>));    <span class="keyword">while</span> (<span class="built_in">clock</span>() &lt; ED)        <span class="built_in">check</span>();    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        cout &lt;&lt; ap[i] &lt;&lt; <span class="string">&quot; &quot;</span>;    cout &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乱搞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] UVA1109 Mummy Madness</title>
      <link href="/archives/UVA1109/"/>
      <url>/archives/UVA1109/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>平面直角坐标系中，有 $n$ 个木乃伊，分别为 $(x_i,y_i)$。你在原点 $(0,0)$ 上。</p><p>每一个时刻你可以往 $8$ 个相邻位置逃跑，或者待在原地。之后，木乃伊会向 $8$ 个方向移动到最靠近你（距离为欧几里得距离）的位置。多只木乃伊可以在一个格子。</p><p>问你多久可以不被木乃伊抓住。当然，也可能有永远不被抓住。</p><p>放一张样例的最佳走法的图：</p><p>原图来自于原版题面。其中，$\tt H$ 表示你，$\tt M$ 表示木乃伊。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ekx5uxvr.png"></p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>首先，二分答案是显然的。假设你现在没被抓住，且之前被抓住了，那么木乃伊一定是可以跟着你走让你现在也被抓住。因此，若你在 $k$ 时刻没被抓住，$k-1$ 时刻肯定也没被抓住。因此具有单调性。</p><p>然后考虑如何 check。我们发现因为是八方向，所以你得到的人和木乃伊的行走范围一定是一个正方形。</p><p>考虑你在 $k$ 时刻，不能走的位置，也就是木乃伊的行走范围。</p><p>那么只需要看一下，在你能行走的范围内，木乃伊的行走范围，占了多大。如果你的行走范围，木乃伊全都可以到达，就说明你会被抓住。</p><p>因此就是矩形面积并。注意多测清空。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="type">int</span> n;<span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;    <span class="type">int</span> x, yd, yu, c;&#125;;vector&lt;Seg&gt; a;vector&lt;<span class="type">int</span>&gt; v;<span class="keyword">struct</span> <span class="title class_">SegTree</span>&#123;    <span class="keyword">struct</span> <span class="title class_">node</span>    &#123;        <span class="type">int</span> len, lzy;    &#125; t[<span class="number">200020</span> &lt;&lt; <span class="number">2</span>];<span class="meta">#<span class="keyword">define</span> ls id &lt;&lt; 1</span><span class="meta">#<span class="keyword">define</span> rs id &lt;&lt; 1 | 1</span>    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; t[id].len = (t[id].lzy ? v[r] - v[l - <span class="number">1</span>] : (l == r ? <span class="number">0</span> : t[ls].len + t[rs].len)); &#125;    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> id = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = v.size() - <span class="number">1</span>)</span></span><span class="function">    </span>&#123;        t[id].len = t[id].lzy = <span class="number">0</span>;        <span class="keyword">if</span> (l == r)            <span class="keyword">return</span>;        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;        <span class="built_in">build</span>(ls, l, mid);        <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);    &#125;    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> k, <span class="type">int</span> id = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = v.size() - <span class="number">1</span>)</span></span><span class="function">    </span>&#123;        <span class="keyword">if</span> (r &lt; ql || l &gt; qr)            <span class="keyword">return</span>;        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)            <span class="keyword">return</span> t[id].lzy += k, <span class="built_in">push_up</span>(id, l, r);        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;        <span class="built_in">add</span>(ql, qr, k, ls, l, mid);        <span class="built_in">add</span>(ql, qr, k, rs, mid + <span class="number">1</span>, r);        <span class="built_in">push_up</span>(id, l, r);    &#125;&#125; T;<span class="function"><span class="type">int</span> <span class="title">Q</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), x) - v.<span class="built_in">begin</span>() + <span class="number">1</span>; &#125;<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> xl, <span class="type">int</span> yd, <span class="type">int</span> xr, <span class="type">int</span> yu)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (xl &gt; xr || yd &gt; yu)        <span class="keyword">return</span>;    v.<span class="built_in">push_back</span>(yd), v.<span class="built_in">push_back</span>(yu);    a.<span class="built_in">push_back</span>(&#123;xl, yd, yu, <span class="number">1</span>&#125;);    a.<span class="built_in">push_back</span>(&#123;xr, yd, yu, <span class="number">-1</span>&#125;);&#125;<span class="keyword">struct</span> <span class="title class_">Mummy</span>&#123;    <span class="type">int</span> x, y;&#125; mummy[<span class="number">100020</span>];<span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> k)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (!n)        <span class="keyword">return</span> <span class="number">0</span>;    v.<span class="built_in">clear</span>(), a.<span class="built_in">clear</span>();    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="type">int</span> x = mummy[i].x, y = mummy[i].y;        <span class="built_in">add</span>(<span class="built_in">max</span>(-k, x - k), <span class="built_in">max</span>(-k, y - k), <span class="built_in">min</span>(k + <span class="number">1</span>, x + k + <span class="number">1</span>), <span class="built_in">min</span>(k + <span class="number">1</span>, y + k + <span class="number">1</span>));    &#125;    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());    v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()), v.<span class="built_in">end</span>());    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [&amp;](Seg a, Seg b)         &#123; <span class="keyword">return</span> a.x ^ b.x ? a.x &lt; b.x : a.c &gt; b.c; &#125;);    T.<span class="built_in">build</span>();    ll ans = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; a.<span class="built_in">size</span>(); i++)    &#123;        <span class="type">int</span> x = a[i].x, yd = a[i].yd, yu = a[i].yu, c = a[i].c;        T.<span class="built_in">add</span>(<span class="built_in">Q</span>(yd), <span class="built_in">Q</span>(yu) - <span class="number">1</span>, c);        ans += <span class="number">1LL</span> * T.t[<span class="number">1</span>].len * (a[i + <span class="number">1</span>].x - x);    &#125;    <span class="keyword">return</span> ans == <span class="number">1LL</span> * (k + k + <span class="number">1</span>) * (k + k + <span class="number">1</span>);&#125;<span class="type">int</span> testcase;<span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e6</span>;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    testcase++;    <span class="built_in">read</span>(n);    <span class="keyword">if</span> (!(~n))        <span class="keyword">return</span> <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">read</span>(mummy[i].x, mummy[i].y);    <span class="type">int</span> L = <span class="number">1</span>, R = inf, ans = <span class="number">-1</span>;    <span class="keyword">while</span> (L &lt;= R)    &#123;        <span class="type">int</span> mid = L + R &gt;&gt; <span class="number">1</span>;        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))            R = (ans = mid) - <span class="number">1</span>;        <span class="keyword">else</span>            L = mid + <span class="number">1</span>;    &#125;    <span class="keyword">if</span> (~ans)        cout &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; testcase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    <span class="keyword">else</span>        cout &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; testcase &lt;&lt; <span class="string">&quot;: never\n&quot;</span>;    <span class="built_in">main</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] P6453 [COCI2008-2009#4] PERIODNI</title>
      <link href="/archives/P6453/"/>
      <url>/archives/P6453/</url>
      
        <content type="html"><![CDATA[<h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>原来这种多边形转成笛卡尔树建树是常见 trick。练的太少导致的。</p><p>但是这题其实不用笛卡尔树建树，因为 DP 部分复杂度较高其实这个优化（至少在我的程序上）没有太大作用。</p><hr><p>为了方便描述，定义中国象棋中的『車』为题目中的颜色，本质一样。</p><p>考虑把这个多边形转成树，分割方式就是以底层开割。</p><p>机房电脑的 NOI Linux 2.0 没有好用的画图软件，这里用一张别人题解的图。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6a5lp8on.png"></p><p>我们找到最低点，分成左右两边，分治建树。把最低端想象成子树的根，向上的一层不同颜色既是子节点。</p><p>如果不能分成恰好两棵子树，其实没有影响，把某两个放到一起先当成一个节点下一次分开来就好了，没有必要特别判这个问题。</p><p>然后这个问题被我们抽象成了树上问题，直接采取树形 DP 解决。</p><hr><p>这里再提一个东西：</p><blockquote><p>大小为 $n\times m$ 的棋盘，放入 $k$ 个『車』，互不攻击的方案数是 $\binom{n}{k}\times \binom{m}{k}\times k!$。</p></blockquote><p>考虑选择 $k$ 行再选择 $k$ 列，方案数是 $\binom{n}{k}\times \binom{m}{k}$。因为列可以任意排列之后和行拼在一起成为不同的方案，所以还要乘上全排列方案数 $k!$。</p><hr><p>回归本题，设计 $F_{u,i}$ 表示以 $u$ 为根的子树，放了 $i$ 个『車』的方案数。</p><p>但是直接乱转移复杂度有点烂，所以先处理 $G_{u,i}$ 表示以 $u$ 为根的子树，<strong>不包括矩形 $u$</strong>，也就是只考虑以 $u$ 的子节点为根的子树，放了 $i$ 个『車』的方案数。</p><p>$G$ 数组的转移是显然的，枚举两边分别放了几个。</p><p>以下定义 $ls$ 和 $rs$ 表示 $u$ 的左右子树根节点编号。</p><p>$$G_{u,i}\gets \sum\limits_{j&#x3D;0}^{i} F_{ls,j} \times F_{rs,i-j},\forall i\in[1,k]$$</p><p>有了这个 $G$ 我们的 $F$ 就可以很快乐的转移了。枚举不包括自己的子树部分，放了几个，然后乘上自己选择的方案数。</p><p>但是，因为矩形之间联通，你需要处理有几列被子树部分的『車』覆盖的情况。直接把这几个位置扔掉就行了，剩下的同上面所说的方案数。</p><p>因此，$F$ 的转移呼之欲出。定义 $H_u,W_u$ 表示矩形 $u$ 的高和宽。</p><p>$$F_{u,i}\gets \sum\limits_{j&#x3D;0}^{i} \binom {H_u}{i-j}\times \binom {W_u-j}{i-j}\times(i-j)! \times G_{u,j},\forall i\in[1,k]$$</p><p>总复杂度为 $\mathcal O(nk^2+n^2)$。</p><h1 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h1><p><a href="https://www.luogu.com.cn/record/154003111">洛谷 record 154003111</a></p><pre><code class="highlight cpp"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>;Z fac[N + <span class="number">20</span>];Z inv[N + <span class="number">20</span>];<span class="function">Z <span class="title">C</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> n &lt; <span class="number">0</span> || i &lt; <span class="number">0</span> || n &lt; i ? <span class="number">0</span> : fac[n] * inv[i] * inv[n - i]; &#125;<span class="meta">#<span class="keyword">define</span> ls c[u][0]</span><span class="meta">#<span class="keyword">define</span> rs c[u][1]</span><span class="type">int</span> n, k;<span class="type">int</span> h[<span class="number">520</span>];<span class="type">int</span> H[<span class="number">520</span>];<span class="type">int</span> W[<span class="number">520</span>];<span class="type">int</span> c[<span class="number">520</span>][<span class="number">2</span>];Z f[<span class="number">520</span>][<span class="number">520</span>];Z g[<span class="number">520</span>][<span class="number">520</span>];<span class="type">int</span> rt;<span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (l &gt; r)        <span class="keyword">return</span> <span class="number">0</span>;    <span class="type">int</span> u = <span class="built_in">min_element</span>(h + l, h + r + <span class="number">1</span>) - h;    ls = <span class="built_in">build</span>(l, u - <span class="number">1</span>);    rs = <span class="built_in">build</span>(u + <span class="number">1</span>, r);    H[ls] = h[ls] - h[u];    H[rs] = h[rs] - h[u];    W[u] = r - l + <span class="number">1</span>;    <span class="keyword">return</span> u;&#125;<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span><span class="function"></span>&#123;    f[u][<span class="number">0</span>] = g[u][<span class="number">0</span>] = <span class="number">1</span>;    <span class="keyword">if</span> (!u)        <span class="keyword">return</span>;    <span class="built_in">dfs</span>(ls), <span class="built_in">dfs</span>(rs);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)            g[u][i] += f[ls][j] * f[rs][i - j];    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)            f[u][i] += <span class="built_in">C</span>(H[u], i - j) * <span class="built_in">C</span>(W[u] - j, i - j) * fac[i - j] * g[u][j];&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    fac[<span class="number">0</span>] = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)        fac[i] = fac[i - <span class="number">1</span>] * i;    inv[N] = fac[N].<span class="built_in">pow</span>(PPP - <span class="number">2</span>);    <span class="keyword">for</span> (<span class="type">int</span> i = N; i &gt;= <span class="number">1</span>; i--)        inv[i - <span class="number">1</span>] = inv[i] * i;    <span class="built_in">read</span>(n, k);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">read</span>(h[i]);    rt = <span class="built_in">build</span>(<span class="number">1</span>, n);    H[rt] = h[rt];    <span class="built_in">dfs</span>(rt);    cout &lt;&lt; f[rt][k] &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF913E Logical Expression</title>
      <link href="/archives/CF913E/"/>
      <url>/archives/CF913E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定 $x&#x3D;(00001111)_2,y&#x3D;(00110011)_2,z&#x3D;(01010101)_2$。</p><p>你有二元运算符『与』和『或』，以及一元运算符『取反』。</p><p>与：表示二进制下按位与，字符是 <code>&amp;</code>。</p><p>或：表示二进制下按位或，字符是 <code>|</code>。</p><p>取反：表示二进制下按位取反，字符是 <code>!</code>。</p><p>优先级从大到小排列是：取反，与，或。</p><p>给出 $n(1\leq n\leq 10^4)$ 个询问，每次给出长度为 $8$ 的二进制串，求其在使用 $x,y,z$ 和以上三种操作后得到该二进制串的最优答案。</p><p>对于『最优答案』的解释：优先取长度小的，长度一样优先取字典序小的。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>首先，$n\leq 10^4$ 的数据范围是假的，只有 $256$ 个输入串。</p><p>二进制串改成十进制数状压也是显然的。</p><p>考虑设计 $f_i$ 表示凑到 $i$ 的『最优答案』。</p><p>但是因为优先级会有很多括号的事情，所以加入一位 $f_{i,k}$ 表示凑到 $i$ 当前优先级为 $k$ 得到的『最优答案』。</p><p>转移十分显然，这里从自己转移到别人比较方便，分两大类：</p><ol><li>一元运算符</li></ol><p>那么就是给自己前面加上 <code>!</code> 即可。</p><ol start="2"><li>二元运算符</li></ol><p>转移暴力枚举 $i,j\in [0,256)$，之后枚举 $i$ 和 $j$ 的优先级，再枚举两个二元运算符进行转移。</p><p>关于实现，这里不推荐大家写若干循环，我直接手动循环展开转移的。不然优先级加括号要判挺多东西。</p><p>但是，这个做法还有个问题。你转移一次不一定是对的啊。</p><p>然后你会发现，你一共 $255$ 个值的状态，其实状态很少，多跑几轮总能转移结束。那么你就类似图论最短路多跑几次，直到所有的“松弛操作”都没有进行再结束。</p><p>也就是说，状态设计成 $f_{r,i,k}$ 表示第 $r$ 轮转移凑到 $i$ 当前优先级为 $k$ 得到的『最优答案』。</p><p>实现的时候注意优先级问题要加括号！取『最优答案』的时候要注意不要从空串开始转移。关于转移次数，我转移了 $6$ 轮就过了。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://codeforces.com/contest/913/submission/254456293">CF submission 254456293</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> a[] = &#123;<span class="number">0b00001111</span>, <span class="number">0b00110011</span>, <span class="number">0b01010101</span>&#125;;<span class="type">const</span> <span class="type">char</span> ch[] = &#123;<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;;<span class="type">const</span> <span class="type">char</span> op[] = &#123;<span class="string">&#x27;|&#x27;</span>, <span class="string">&#x27;&amp;&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;; <span class="comment">// 低 ~ 高，单值 和 括号 也算 2 级，高级 外面可以套 低级</span><span class="type">const</span> <span class="type">int</span> R = <span class="number">6</span>;<span class="type">const</span> <span class="type">int</span> n = <span class="number">1</span> &lt;&lt; <span class="number">8</span>;<span class="function">string <span class="title">Min</span><span class="params">(string &amp;a, string &amp;b)</span> </span>&#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() ^ b.<span class="built_in">size</span>() ? (a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>() ? a : b) : (a &lt; b ? a : b); &#125;<span class="function"><span class="type">void</span> <span class="title">chkmn</span><span class="params">(string &amp;a, string b)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (a.<span class="built_in">empty</span>())        a = b;    <span class="keyword">else</span>        a = <span class="built_in">Min</span>(a, b);&#125;<span class="function"><span class="type">int</span> <span class="title">StB</span><span class="params">(string &amp;s)</span></span><span class="function"></span>&#123;    <span class="type">int</span> ret = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">char</span> c : s)        ret = ret &lt;&lt; <span class="number">1</span> | c ^ <span class="string">&#x27;0&#x27;</span>;    <span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">int</span> <span class="title">inv</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="number">0b11111111</span> ^ x; &#125;string f[R + <span class="number">1</span>][n][<span class="number">3</span>];string ans[n];<span class="type">int</span> t;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    string s;    cin &gt;&gt; s;    cout &lt;&lt; ans[<span class="built_in">StB</span>(s)] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)        f[<span class="number">0</span>][a[i]][<span class="number">2</span>] = ch[i];    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; R; r++)    &#123;        <span class="comment">// 单值修改</span>        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)        &#123;            <span class="comment">// 继承原始</span>            <span class="keyword">if</span> (!f[r][i][<span class="number">0</span>].<span class="built_in">empty</span>())                <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i][<span class="number">0</span>], f[r][i][<span class="number">0</span>]);            <span class="keyword">if</span> (!f[r][i][<span class="number">1</span>].<span class="built_in">empty</span>())                <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i][<span class="number">1</span>], f[r][i][<span class="number">1</span>]);            <span class="keyword">if</span> (!f[r][i][<span class="number">2</span>].<span class="built_in">empty</span>())                <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i][<span class="number">2</span>], f[r][i][<span class="number">2</span>]);            <span class="comment">// 取反</span>            <span class="keyword">if</span> (!f[r][i][<span class="number">0</span>].<span class="built_in">empty</span>())                <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][<span class="built_in">inv</span>(i)][<span class="number">2</span>], <span class="string">&quot;!(&quot;</span> + f[r][i][<span class="number">0</span>] + <span class="string">&quot;)&quot;</span>);            <span class="keyword">if</span> (!f[r][i][<span class="number">1</span>].<span class="built_in">empty</span>())                <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][<span class="built_in">inv</span>(i)][<span class="number">2</span>], <span class="string">&quot;!(&quot;</span> + f[r][i][<span class="number">1</span>] + <span class="string">&quot;)&quot;</span>);            <span class="keyword">if</span> (!f[r][i][<span class="number">2</span>].<span class="built_in">empty</span>())                <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][<span class="built_in">inv</span>(i)][<span class="number">2</span>], <span class="string">&quot;!&quot;</span> + f[r][i][<span class="number">2</span>]);        &#125;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)        &#123;            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)            &#123;                <span class="comment">// 0 | 0</span>                <span class="keyword">if</span> (!f[r][i][<span class="number">0</span>].<span class="built_in">empty</span>() &amp;&amp; !f[r][j][<span class="number">0</span>].<span class="built_in">empty</span>())                    <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i | j][<span class="number">0</span>], f[r][i][<span class="number">0</span>] + <span class="string">&quot;|&quot;</span> + f[r][j][<span class="number">0</span>]);                <span class="comment">// 0 | 1</span>                <span class="keyword">if</span> (!f[r][i][<span class="number">0</span>].<span class="built_in">empty</span>() &amp;&amp; !f[r][j][<span class="number">1</span>].<span class="built_in">empty</span>())                    <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i | j][<span class="number">0</span>], f[r][i][<span class="number">0</span>] + <span class="string">&quot;|&quot;</span> + f[r][j][<span class="number">1</span>]);                <span class="comment">// 0 | 2</span>                <span class="keyword">if</span> (!f[r][i][<span class="number">0</span>].<span class="built_in">empty</span>() &amp;&amp; !f[r][j][<span class="number">2</span>].<span class="built_in">empty</span>())                    <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i | j][<span class="number">0</span>], f[r][i][<span class="number">0</span>] + <span class="string">&quot;|&quot;</span> + f[r][j][<span class="number">2</span>]);                <span class="comment">// 0 &amp; 0</span>                <span class="keyword">if</span> (!f[r][i][<span class="number">0</span>].<span class="built_in">empty</span>() &amp;&amp; !f[r][j][<span class="number">0</span>].<span class="built_in">empty</span>())                    <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i &amp; j][<span class="number">1</span>], <span class="string">&quot;(&quot;</span> + f[r][i][<span class="number">0</span>] + <span class="string">&quot;)&amp;(&quot;</span> + f[r][j][<span class="number">0</span>] + <span class="string">&quot;)&quot;</span>);                <span class="comment">// 0 &amp; 1</span>                <span class="keyword">if</span> (!f[r][i][<span class="number">0</span>].<span class="built_in">empty</span>() &amp;&amp; !f[r][j][<span class="number">1</span>].<span class="built_in">empty</span>())                    <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i &amp; j][<span class="number">1</span>], <span class="string">&quot;(&quot;</span> + f[r][i][<span class="number">0</span>] + <span class="string">&quot;)&amp;&quot;</span> + f[r][j][<span class="number">1</span>]);                <span class="comment">// 0 &amp; 2</span>                <span class="keyword">if</span> (!f[r][i][<span class="number">0</span>].<span class="built_in">empty</span>() &amp;&amp; !f[r][j][<span class="number">2</span>].<span class="built_in">empty</span>())                    <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i &amp; j][<span class="number">1</span>], <span class="string">&quot;(&quot;</span> + f[r][i][<span class="number">0</span>] + <span class="string">&quot;)&amp;&quot;</span> + f[r][j][<span class="number">2</span>]);                <span class="comment">// 1 | 0</span>                <span class="keyword">if</span> (!f[r][i][<span class="number">1</span>].<span class="built_in">empty</span>() &amp;&amp; !f[r][j][<span class="number">0</span>].<span class="built_in">empty</span>())                    <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i | j][<span class="number">0</span>], f[r][i][<span class="number">1</span>] + <span class="string">&quot;|&quot;</span> + f[r][j][<span class="number">0</span>]);                <span class="comment">// 1 | 1</span>                <span class="keyword">if</span> (!f[r][i][<span class="number">1</span>].<span class="built_in">empty</span>() &amp;&amp; !f[r][j][<span class="number">1</span>].<span class="built_in">empty</span>())                    <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i | j][<span class="number">0</span>], f[r][i][<span class="number">1</span>] + <span class="string">&quot;|&quot;</span> + f[r][j][<span class="number">1</span>]);                <span class="comment">// 1 | 2</span>                <span class="keyword">if</span> (!f[r][i][<span class="number">1</span>].<span class="built_in">empty</span>() &amp;&amp; !f[r][j][<span class="number">2</span>].<span class="built_in">empty</span>())                    <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i | j][<span class="number">0</span>], f[r][i][<span class="number">1</span>] + <span class="string">&quot;|&quot;</span> + f[r][j][<span class="number">2</span>]);                <span class="comment">// 1 &amp; 0</span>                <span class="keyword">if</span> (!f[r][i][<span class="number">1</span>].<span class="built_in">empty</span>() &amp;&amp; !f[r][j][<span class="number">0</span>].<span class="built_in">empty</span>())                    <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i &amp; j][<span class="number">1</span>], f[r][i][<span class="number">1</span>] + <span class="string">&quot;&amp;(&quot;</span> + f[r][j][<span class="number">0</span>] + <span class="string">&quot;)&quot;</span>);                <span class="comment">// 1 &amp; 1</span>                <span class="keyword">if</span> (!f[r][i][<span class="number">1</span>].<span class="built_in">empty</span>() &amp;&amp; !f[r][j][<span class="number">1</span>].<span class="built_in">empty</span>())                    <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i &amp; j][<span class="number">1</span>], f[r][i][<span class="number">1</span>] + <span class="string">&quot;&amp;&quot;</span> + f[r][j][<span class="number">1</span>]);                <span class="comment">// 1 &amp; 2</span>                <span class="keyword">if</span> (!f[r][i][<span class="number">1</span>].<span class="built_in">empty</span>() &amp;&amp; !f[r][j][<span class="number">2</span>].<span class="built_in">empty</span>())                    <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i &amp; j][<span class="number">1</span>], f[r][i][<span class="number">1</span>] + <span class="string">&quot;&amp;&quot;</span> + f[r][j][<span class="number">2</span>]);                <span class="comment">// 2 | 0</span>                <span class="keyword">if</span> (!f[r][i][<span class="number">2</span>].<span class="built_in">empty</span>() &amp;&amp; !f[r][j][<span class="number">0</span>].<span class="built_in">empty</span>())                    <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i | j][<span class="number">0</span>], f[r][i][<span class="number">2</span>] + <span class="string">&quot;|&quot;</span> + f[r][j][<span class="number">0</span>]);                <span class="comment">// 2 | 1</span>                <span class="keyword">if</span> (!f[r][i][<span class="number">2</span>].<span class="built_in">empty</span>() &amp;&amp; !f[r][j][<span class="number">1</span>].<span class="built_in">empty</span>())                    <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i | j][<span class="number">0</span>], f[r][i][<span class="number">2</span>] + <span class="string">&quot;|&quot;</span> + f[r][j][<span class="number">1</span>]);                <span class="comment">// 2 | 2</span>                <span class="keyword">if</span> (!f[r][i][<span class="number">2</span>].<span class="built_in">empty</span>() &amp;&amp; !f[r][j][<span class="number">2</span>].<span class="built_in">empty</span>())                    <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i | j][<span class="number">0</span>], f[r][i][<span class="number">2</span>] + <span class="string">&quot;|&quot;</span> + f[r][j][<span class="number">2</span>]);                <span class="comment">// 2 &amp; 0</span>                <span class="keyword">if</span> (!f[r][i][<span class="number">2</span>].<span class="built_in">empty</span>() &amp;&amp; !f[r][j][<span class="number">0</span>].<span class="built_in">empty</span>())                    <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i &amp; j][<span class="number">1</span>], f[r][i][<span class="number">2</span>] + <span class="string">&quot;&amp;(&quot;</span> + f[r][j][<span class="number">0</span>] + <span class="string">&quot;)&quot;</span>);                <span class="comment">// 2 &amp; 1</span>                <span class="keyword">if</span> (!f[r][i][<span class="number">2</span>].<span class="built_in">empty</span>() &amp;&amp; !f[r][j][<span class="number">1</span>].<span class="built_in">empty</span>())                    <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i &amp; j][<span class="number">1</span>], f[r][i][<span class="number">2</span>] + <span class="string">&quot;&amp;&quot;</span> + f[r][j][<span class="number">1</span>]);                <span class="comment">// 2 &amp; 2</span>                <span class="keyword">if</span> (!f[r][i][<span class="number">2</span>].<span class="built_in">empty</span>() &amp;&amp; !f[r][j][<span class="number">2</span>].<span class="built_in">empty</span>())                    <span class="built_in">chkmn</span>(f[r + <span class="number">1</span>][i &amp; j][<span class="number">1</span>], f[r][i][<span class="number">2</span>] + <span class="string">&quot;&amp;&quot;</span> + f[r][j][<span class="number">2</span>]);            &#125;        &#125;        <span class="comment">// cerr &lt;&lt; r &lt;&lt; endl;</span>        <span class="comment">// for (int i = 0; i &lt; n; i++)</span>        <span class="comment">//     for (int j = 0; j &lt; 3; j++)</span>        <span class="comment">//         cerr &lt;&lt; f[r][i][j] &lt;&lt; &quot; \n&quot;[j == 2];</span>        <span class="comment">// cerr &lt;&lt; endl;</span>    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)            <span class="built_in">chkmn</span>(ans[i], f[R][i][j]);    <span class="type">int</span> t;    cin &gt;&gt; t;    <span class="keyword">while</span> (t--)        <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC346 EFG 简单题解</title>
      <link href="/archives/ABC346/"/>
      <url>/archives/ABC346/</url>
      
        <content type="html"><![CDATA[<h1 id="E-Paint"><a href="#E-Paint" class="headerlink" title="E - Paint"></a>E - Paint</h1><p>我都见到这题三次了。</p><p>考虑正难则反，操作逆序。</p><p>此时你先涂的颜色<strong>后面不能更改了</strong>。</p><p>但是显然的你可以知道现在有多少行多少列被涂过了。</p><p>那么你把剩下的加进答案就好了。</p><p>然后这题有个很逆天的 corner case 是一开始全是颜色 $0$。如果这个 corner case 判错了也会寄的。</p><pre><code class="highlight cpp"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="type">int</span> h, w, q;<span class="keyword">struct</span> <span class="title class_">Query</span>&#123;    <span class="type">int</span> op, data, col;&#125; Q[<span class="number">200020</span>];ll cnt[<span class="number">200020</span>];<span class="type">int</span> r, c;<span class="type">bool</span> R[<span class="number">200020</span>];<span class="type">bool</span> C[<span class="number">200020</span>];set&lt;<span class="type">int</span>&gt; s;ll sum;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(h, w, q);    r = h, c = w;    sum = <span class="number">1LL</span> * h * w;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)        <span class="built_in">read</span>(Q[i].op, Q[i].data, Q[i].col);    <span class="built_in">reverse</span>(Q + <span class="number">1</span>, Q + q + <span class="number">1</span>);    s.<span class="built_in">insert</span>(<span class="number">0</span>);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)    &#123;        <span class="keyword">auto</span> [op, d, col] = Q[i];        <span class="keyword">if</span> (op &amp; <span class="number">1</span>) <span class="comment">// coloring row</span>        &#123;            <span class="keyword">if</span> (R[d] || !c)                <span class="keyword">continue</span>;            R[d] = <span class="number">1</span>;            cnt[col] += c;            <span class="keyword">if</span> (col)                sum -= c;            r--;            s.<span class="built_in">insert</span>(col);        &#125;        <span class="keyword">else</span>        &#123;            <span class="keyword">if</span> (C[d] || !r)                <span class="keyword">continue</span>;            C[d] = <span class="number">1</span>;            cnt[col] += r;            <span class="keyword">if</span> (col)                sum -= r;            c--;            s.<span class="built_in">insert</span>(col);        &#125;    &#125;    <span class="keyword">if</span> (!sum)        s.<span class="built_in">erase</span>(<span class="number">0</span>);    cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;    <span class="keyword">for</span> (<span class="type">int</span> i : s)        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (!i ? sum : cnt[i]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="F-SSttrriinngg-in-StringString"><a href="#F-SSttrriinngg-in-StringString" class="headerlink" title="F - SSttrriinngg in StringString"></a>F - SSttrriinngg in StringString</h1><p>首先，最大化答案，一眼二分答案。</p><p>然后考虑 check。这个 check 我只能说是大家都会口胡吧。</p><p>你就考虑你现在指针跑到哪里了，已经过了几轮。整轮能跳的显然要 $\mathcal O(1)$ 维护过了几轮。</p><p>然后不满一轮的判断也是很简单的，但是要注意不满一轮也可能要新开一轮的。这个大家实现的时候自己对着样例调一下就行。</p><p>另外如果样例 3 挂了调不出来可以拍一下 $N&#x3D;5,|S|,|T|\leq 5,\alpha \leq 3$ 的点，其中 $\alpha$ 表示字符集大小。其实不需要几组就能拍出小 hack 的，我拍了一个小数据很快就调过去了。</p><pre><code class="highlight cpp"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">typedef</span> __int128 LL;<span class="type">int</span> n, m;ll k;string s, t;<span class="type">int</span> pre[<span class="number">26</span>][<span class="number">100020</span>];<span class="type">int</span> pos[<span class="number">26</span>][<span class="number">100020</span>];<span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll x)</span></span><span class="function"></span>&#123;    <span class="type">int</span> p = <span class="number">0</span>;    ll round = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)    &#123;        <span class="keyword">if</span> (round &gt; k)            <span class="keyword">return</span> <span class="number">0</span>;        <span class="type">char</span> c = t[i];        ll need = x;        <span class="keyword">if</span> (pre[c - <span class="string">&#x27;a&#x27;</span>][n] - pre[c - <span class="string">&#x27;a&#x27;</span>][p] &gt;= need)        &#123;            <span class="type">int</span> preHave = pre[c - <span class="string">&#x27;a&#x27;</span>][p];            <span class="type">int</span> newPos = pos[c - <span class="string">&#x27;a&#x27;</span>][preHave + need];            p = newPos;            <span class="keyword">continue</span>;        &#125;        need -= pre[c - <span class="string">&#x27;a&#x27;</span>][n] - pre[c - <span class="string">&#x27;a&#x27;</span>][p];        ll can_per_round = pre[c - <span class="string">&#x27;a&#x27;</span>][n];        <span class="keyword">if</span> (!can_per_round)            <span class="keyword">return</span> !need &amp;&amp; round &lt;= k;        ll need_round = need / can_per_round;        round += need_round;        need -= can_per_round * need_round;        <span class="keyword">if</span> (need)            round++, p = pos[c - <span class="string">&#x27;a&#x27;</span>][need];        <span class="keyword">else</span>            p = pos[c - <span class="string">&#x27;a&#x27;</span>][can_per_round];    &#125;    <span class="keyword">return</span> round &lt;= k;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; k &gt;&gt; s &gt;&gt; t;    n = s.<span class="built_in">size</span>(), m = t.<span class="built_in">size</span>();    s = <span class="string">&#x27; &#x27;</span> + s, t = <span class="string">&#x27; &#x27;</span> + t;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)            pre[j][i] = pre[j][i - <span class="number">1</span>];        pos[s[i] - <span class="string">&#x27;a&#x27;</span>][++pre[s[i] - <span class="string">&#x27;a&#x27;</span>][i]] = i;    &#125;    ll L = <span class="number">0</span>, R = <span class="number">1e18</span>, ans = <span class="number">0</span>;    <span class="keyword">while</span> (L &lt;= R)    &#123;        ll mid = L + R &gt;&gt; <span class="number">1</span>;        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))            L = (ans = mid) + <span class="number">1</span>;        <span class="keyword">else</span>            R = mid - <span class="number">1</span>;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p>另外这题根据实现的不同可能有的方法会炸 long long，自己注意一下。但是我的写法是不会的。<del>尽管我写了个 typedef。</del></p><h1 id="G-Alone"><a href="#G-Alone" class="headerlink" title="G - Alone"></a>G - Alone</h1><p>考虑到你的序列长 $[\tt T,{\color{red}{x}},T,T,T,{\color{red}{x}},T,T,T,T,{\color{red}{x}},T,T,T,{\color{red}{x}},T,T,T]$ 这样子。</p><p>其中 $\tt\color{red}x$ 表示某个颜色相同的数，$\tt T$ 表示其他数。</p><p>那么你对于 $[\tt T_1,T_2,T_3,{\color{red}{x_4}},T_5,T_6,T_7]$ 这样的一个序列（下标表示在序列中的位置），你如果想要得到一组合法的 $[L,R]$ 就需要满足 $L\in [1,3],R\in [5,7]$，也就是要分布在这个 $x$ 的两侧。</p><p>但是这个会导致计算重复的 $[L,R]$。不是很好处理。</p><p>考虑把数对 $(L,R)$ 映射到平面直角坐标系上，$x$ 轴表示左端点，$y$ 轴表示右端点，那么你的每个 $(L,R)$ 都会成为平面上第一象限的一个点。</p><p>而你的 $L$ 和 $R$ 都是有取值范围的，每个 $x$ 贡献的所有 $L$ 和 $R$ 对应点会组成一个矩形。若干个 $x$ 就组成若干矩形，但是有交。</p><p>那么题目就变成了平面直角坐标系中若干矩形求面积并，这是扫描线板子。</p><pre><code class="highlight cpp"><span class="type">int</span> n, w, h;<span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;    <span class="type">int</span> x, yd, yu, c;&#125;;vector&lt;Seg&gt; a;vector&lt;<span class="type">int</span>&gt; v;<span class="keyword">struct</span> <span class="title class_">SegTree</span>&#123;    <span class="keyword">struct</span> <span class="title class_">node</span>    &#123;        <span class="type">int</span> len, lzy;    &#125; t[<span class="number">200020</span> &lt;&lt; <span class="number">2</span>];<span class="meta">#<span class="keyword">define</span> ls id &lt;&lt; 1</span><span class="meta">#<span class="keyword">define</span> rs id &lt;&lt; 1 | 1</span>    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; t[id].len = (t[id].lzy ? v[r] - v[l - <span class="number">1</span>] : (l == r ? <span class="number">0</span> : t[ls].len + t[rs].len)); &#125;    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> id = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = n)</span></span><span class="function">    </span>&#123;        <span class="keyword">if</span> (l == r)            <span class="keyword">return</span> t[id].len = t[id].lzy = <span class="number">0</span>, <span class="built_in">void</span>();        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;        <span class="built_in">build</span>(ls, l, mid);        <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);    &#125;    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> k, <span class="type">int</span> id = <span class="number">1</span>, <span class="type">int</span> l = <span class="number">1</span>, <span class="type">int</span> r = n)</span></span><span class="function">    </span>&#123;        <span class="keyword">if</span> (r &lt; ql || l &gt; qr)            <span class="keyword">return</span>;        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)            <span class="keyword">return</span> t[id].lzy += k, <span class="built_in">push_up</span>(id, l, r);        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;        <span class="built_in">add</span>(ql, qr, k, ls, l, mid);        <span class="built_in">add</span>(ql, qr, k, rs, mid + <span class="number">1</span>, r);        <span class="built_in">push_up</span>(id, l, r);    &#125;&#125; T;<span class="function"><span class="type">int</span> <span class="title">Q</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), x) - v.<span class="built_in">begin</span>() + <span class="number">1</span>; &#125;<span class="type">int</span> arr[<span class="number">200020</span>];<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> xl, <span class="type">int</span> yd, <span class="type">int</span> xr, <span class="type">int</span> yu)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (xl &gt; xr || yd &gt; yu)        <span class="keyword">return</span>;    v.<span class="built_in">push_back</span>(yd), v.<span class="built_in">push_back</span>(yu);    a.<span class="built_in">push_back</span>(&#123;xl, yd, yu, <span class="number">1</span>&#125;);    a.<span class="built_in">push_back</span>(&#123;xr, yd, yu, <span class="number">-1</span>&#125;);&#125;vector&lt;<span class="type">int</span>&gt; col[<span class="number">200020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(n);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        col[i].<span class="built_in">push_back</span>(<span class="number">0</span>);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">read</span>(arr[i]), col[arr[i]].<span class="built_in">push_back</span>(i);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        col[i].<span class="built_in">push_back</span>(n + <span class="number">1</span>);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j + <span class="number">1</span> &lt; col[i].<span class="built_in">size</span>(); j++)            <span class="built_in">add</span>(col[i][j - <span class="number">1</span>] + <span class="number">1</span>, col[i][j] - <span class="number">1</span>, col[i][j] + <span class="number">1</span>, col[i][j + <span class="number">1</span>] - <span class="number">1</span>);    &#125;    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());    v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()), v.<span class="built_in">end</span>());    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [&amp;](Seg a, Seg b)         &#123; <span class="keyword">return</span> a.x ^ b.x ? a.x &lt; b.x : a.c &gt; b.c; &#125;);    n = v.<span class="built_in">size</span>() - <span class="number">1</span>;    T.<span class="built_in">build</span>();    ll ans = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; a.<span class="built_in">size</span>(); i++)    &#123;        <span class="keyword">auto</span> [x, yd, yu, c] = a[i];        T.<span class="built_in">add</span>(<span class="built_in">Q</span>(yd), <span class="built_in">Q</span>(yu) - <span class="number">1</span>, c);        ans += <span class="number">1LL</span> * T.t[<span class="number">1</span>].len * (a[i + <span class="number">1</span>].x - x);    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF178F3 Representative Sampling</title>
      <link href="/archives/CF178F3/"/>
      <url>/archives/CF178F3/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定 $n(n\leq 2000)$ 个串，选定 $k$ 个串，求出最大两两 LCP。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>首先把给定串按字典序排序，保证相邻 LCP 最大。</p><p>考虑 dp，$f_{l,r,x}$ 表示选择 $[l,r]$ 中有 $x$ 个串的最大两两 LCP。</p><p>类似分治，转移的时候枚举相邻 LCP 最小的点 $m$，一定是在 $m$ 断开最优。转移枚举左右段分选几个串，加上串的个数乘上 $\operatorname{lcp}(s_m,s_{m+1})$。这个 $\operatorname{lcp}$ 需要预处理。</p><p>时间复杂度 $\mathcal O(n^2)$。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">max</span>(x, y); &#125;<span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;<span class="type">int</span> n, k;<span class="type">int</span> lcp[<span class="number">2020</span>];string s[<span class="number">2020</span>];<span class="function">vi <span class="title">solve</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (l == r)        <span class="keyword">return</span> <span class="built_in">vi</span>(<span class="number">2</span>, <span class="number">0</span>);    <span class="type">int</span> m = <span class="built_in">min_element</span>(lcp + l, lcp + r) - lcp;    vi L = <span class="built_in">solve</span>(l, m);    vi R = <span class="built_in">solve</span>(m + <span class="number">1</span>, r);    <span class="function">vi <span class="title">f</span><span class="params">(r - l + <span class="number">2</span>, <span class="number">0</span>)</span></span>;    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; L.<span class="built_in">size</span>(); l++)        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; R.<span class="built_in">size</span>(); r++)            <span class="built_in">chkmx</span>(f[l + r], L[l] + R[r] + lcp[m] * l * r);    <span class="keyword">return</span> f;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n &gt;&gt; k;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        cin &gt;&gt; s[i];    <span class="built_in">sort</span>(s + <span class="number">1</span>, s + n + <span class="number">1</span>);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="type">int</span> len = <span class="number">0</span>;        <span class="keyword">while</span> (len &lt; <span class="built_in">min</span>(s[i].<span class="built_in">size</span>(), s[i + <span class="number">1</span>].<span class="built_in">size</span>()) &amp;&amp; s[i][len] == s[i + <span class="number">1</span>][len])            len++;        lcp[i] = len;    &#125;    cout &lt;&lt; <span class="built_in">solve</span>(<span class="number">1</span>, n)[k] &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] AGC026B rng_10s</title>
      <link href="/archives/AGC026B/"/>
      <url>/archives/AGC026B/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定 $a,b,c,d$，重复执行 $a\gets a-b$。但是操作完后如果 $a\leq c$ 将会执行 $a\gets a+d$，问是否可以保证 $a\gt 0$ 的情况喜爱无限次执行。</p><p>多测，$1\leq t\leq 300,1\leq a,b,c,d\leq 10^{18}$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>特殊情况是 $a\lt b$ 表示第一天买完了，$d\lt b$ 表示你加的没有要的多，都是不合法的情况。</p><p>那么我们判掉之后就成了 $a\geq b\operatorname{and} d\geq b$。</p><p>设买了 $x$ 次，加了 $y$ 次，此时我们就是在找是否有解满足 $c\lt a-bx+dy\lt b$，表示我们现在可以到 $\gt c$ 但是加不到 $\geq b$。如果存在就说明可以被买完。</p><p>又因为 $bx-dy&#x3D;k\times \gcd(b,d)$，所以就是在问是否存在这样的 $k$ 使得 $c\lt a-k\times \gcd(a,b)\lt b$，移项得到 $a-b\lt k\times \gcd(a,b)\lt a-c$。</p><p>这个是很好判断的，那么就做完了。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    ll a, b, c, d;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;    <span class="keyword">if</span> (<span class="built_in">min</span>(a, d) &lt; b)        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>), <span class="built_in">void</span>();    ll g = __gcd(b, d);    <span class="built_in">puts</span>((a - c - <span class="number">1</span>) / g &lt;= (a - b) / g ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> t;    cin &gt;&gt; t;    <span class="keyword">while</span> (t--)        <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1017C The Phone Number</title>
      <link href="/archives/CF1017C/"/>
      <url>/archives/CF1017C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给出 $n(1\leq n\leq 2\times 10^5$，构造一个排列使得 $\operatorname{len(LIS)+len(LDS)}$ 最小。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>样例提示我们分块操作，设分了 $x$ 块，每块块长为 $\frac{n}{x}$。我们这里为了方便书写先只讨论整除的情况，不整除是一样的。</p><p>那么我们就是最小化 $x+\frac{n}{x}$，显然 $x&#x3D;\sqrt n$ 最优。</p><p>那么就很好构造了，参考样例从大到小分组即可。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n;    <span class="type">int</span> m = <span class="built_in">sqrt</span>(n);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (n + m - <span class="number">1</span>) / m; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = n - i * m + <span class="number">1</span>; j &lt;= n - (i - <span class="number">1</span>) * m; j++)            <span class="keyword">if</span> (j &gt; <span class="number">0</span>)                cout &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>;    &#125;    cout &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] SP18637 LAWRENCE - Lawrence of Arabia</title>
      <link href="/archives/SP18637/"/>
      <url>/archives/SP18637/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>有一个长度为 $n(n\leq 500)$ 的序列，你可以砍 $m(0\leq m\lt n)$ 刀将其分为 $m+1$ 段，令每一段 $[l,r]$ 的贡献为 $\sum\limits_{i&#x3D;l}^r \sum\limits_{j&#x3D;i+1}^r a_i\times a_j$，一个序列的答案是每一段的贡献之和，求最小的答案。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>设 $f_{i,j}$ 表示前 $i$ 个位置割 $j$ 刀的最小答案。</p><p>转移是很显然的，枚举上一次断在哪里，$f_{i,j}\gets \min\limits_{k&#x3D;0}^{i-1}f_{k,j-1}+calc(k+1,i)$。其中 $calc(l,r)$ 是 $[l,r]$ 的贡献。</p><p>不考虑 $calc$，转移是 $n^3$ 的，可以通过。但是这个 $calc$ 我们无法快速计算。</p><p>但是我们发现这个 $calc$ 被调用了 $n^3$ 次却至多只有 $n^2$ 个答案，所以我们考虑预处理 $calc(l,r)$ 记为 $g_{l,r}$。</p><p>$calc$ 有一个显然的 $\mathcal O(n^2)$ 降为 $\mathcal O(n)$ 的做法。根据乘法分配律，我们只关心这个数乘了多大的数，不关心具体乘了谁，记录前缀和，快速得到一个区间内的 $\sum a_i$ 即可 $\mathcal O(n)$ 求出单个 $calc$。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">min</span>(x, y); &#125;<span class="type">int</span> n, m;<span class="type">int</span> a[<span class="number">520</span>];<span class="type">int</span> f[<span class="number">520</span>][<span class="number">520</span>];<span class="type">int</span> g[<span class="number">520</span>][<span class="number">520</span>];<span class="type">int</span> pre[<span class="number">520</span>];<span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span><span class="function"></span>&#123;    <span class="type">int</span> ret = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++)        ret += a[i] * (pre[r] - pre[i]);    <span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));    cin &gt;&gt; n &gt;&gt; m;    m++;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        cin &gt;&gt; a[i], pre[i] = pre[i - <span class="number">1</span>] + a[i];    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)        <span class="keyword">for</span> (<span class="type">int</span> r = l; r &lt;= n; r++)            g[l][r] = <span class="built_in">calc</span>(l, r);    <span class="built_in">memset</span>(f[<span class="number">0</span>], <span class="number">0</span>, <span class="built_in">sizeof</span>(f[<span class="number">0</span>]));    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">min</span>(i, m); j++)            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++)                <span class="built_in">chkmn</span>(f[i][j], f[k][j - <span class="number">1</span>] + g[k + <span class="number">1</span>][i]);    cout &lt;&lt; f[n][m] &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1511D Min Cost String</title>
      <link href="/archives/CF1511D/"/>
      <url>/archives/CF1511D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>定义字符串的费用是 $(i,j)$ 的个数满足 $1\leq i\lt j\leq n,s_i&#x3D;s_j,s_{i+1}&#x3D;s_{j+1}$。</p><p>给定 $n\leq 2\times 10^5$ 和字符集大小 $k(k\leq 26)$，用字母表前 $k$ 个小写字母组成的长度为 $n$ 的字符串中，找任意一种费用最小的字符串。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>字符集大小为 $k$ 的长度为 $2$ 的本质不同的字符串有 $k^2$ 个。对于 $n\leq k^2+1$，我们都可以构造费用为 $0$ 的解。</p><p>我们对于 $n\leq k^2+1$ 的，构造一组找一下规律：$\tt{[a,ab,ac,ad][b,bc,bd][c,cd]a}$。</p><p>我们不是所有 $k^2$ 个字符串都能放进去，因为可能会导致两个小字符串首尾相接出现重复。</p><p>这个例子启发我们，每一组都形如上面，先放自己，然后依次遍历字符集填充，可以构造费用为 $0$ 的解。感性理解一下，我们这里例子保证了单个 $k^2+1$ 长度的费用为 $0$，我们重复几次就很平均，所以看上去是对的。</p><p>严格证明一下，设这 $k^2$ 个字符串的出现次数分别为 $a_1,a_2,\cdots a_{k^2}$，那么我们的费用是 $\sum\limits_{i&#x3D;1}^{k^2} \binom{a_i}{2}&#x3D;\sum\frac{a_i(a_i-1)}{2}&#x3D;\sum\frac{a_i^2-a_i}{2}&#x3D;\frac{\sum a_i^2-a_i}{2}&#x3D;\frac{\sum a_i^2}{2}-\frac{\sum a_i}{2}&#x3D;\frac{\sum a_i^2}{2}-\frac{n-1}{2}$。</p><p>要是的上面这个式子最小，即最小化 $\sum a_i^2$。你贪心考虑，这个式子最小就是 $a_i$ 全部均摊的情况。那么我们上面给的这个费用为 $0$ 的构造就很平均。所以重复若干次即可。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n, k;string s;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n &gt;&gt; k;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)    &#123;        s += <span class="built_in">char</span>(i + <span class="string">&#x27;a&#x27;</span>);        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; k; j++)            s += <span class="built_in">char</span>(i + <span class="string">&#x27;a&#x27;</span>), s += <span class="built_in">char</span>(j + <span class="string">&#x27;a&#x27;</span>);    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)        cout &lt;&lt; s[i % s.<span class="built_in">size</span>()];    cout &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF868D Huge Strings</title>
      <link href="/archives/CF868D/"/>
      <url>/archives/CF868D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定 $n(n\leq 100)$ 个字符串 $s_i$，满足 $\sum |s_i|\leq 100$，再给出 $m(m\leq 100)$ 个新串，给定 $x,y$，新串为 $s_x+s_y$。对于这 $m$ 个串，找到最大的 $k$，使得所有长度为 $k$ 的 01 串均被其包含。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>设子串长度是 $L$，因为 $\sum |s_i|\leq 100$，因此长度为 $L$ 的互不相同的子串仅在原 $n$ 个串中也只会有 $100$ 个。$m\leq 100$，每次连接最多产生 $L-1$ 个本质不同的长度为 $L$ 的子串，所以长度为 $L$ 的不同子串最多只有 $(L-1)\times 100+100&#x3D;100L$ 个。然而要满足包含所有长度为 $L$ 的子串，必要条件是 $100L\geq 2^{L}$。解得 $L\leq 9$，也就是说，我们不可能构造答案为 $10$ 的数据。</p><p>那么知道这个结论之后就很好做了。我们判断是否合法只需要暴力匹配。但是我们合并之后的字符串会很长，我们发现中间很大一部分是没有用的，我们前后保留 $900$ 个字符即可。</p><p>但这 $900$ 个字符只是我们认为的『可能得到的更优答案』，这样又导致我们可能答案产生在没有被我们保留的部分中，产生在了我们删除的部分之中。设我们每次拼接 $s_x,s_y$，这两个串的答案是 $ans_x,ans_y$，我们删除的部分答案只可能有 $\max{ans_x,ans_y}$。因此我们答案取 $\max{ans_x,ans_y,k}$ 即可。其中 $k$ 是我们合并之后的答案。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">max</span>(x, y); &#125;<span class="type">int</span> n, m;string s[<span class="number">520</span>];<span class="type">int</span> ans[<span class="number">520</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        cin &gt;&gt; s[i];    cin &gt;&gt; m;    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= n + m; i++)    &#123;        <span class="type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        s[i] = s[x] + s[y];        ans[i] = <span class="built_in">max</span>(ans[x], ans[y]);        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">9</span>; k++)        &#123;            <span class="type">bool</span> ok = <span class="number">1</span>;            <span class="keyword">for</span> (<span class="type">int</span> S = <span class="number">0</span>; S &lt; <span class="number">1</span> &lt;&lt; k; S++)            &#123;                string t = <span class="string">&quot;&quot;</span>;                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)                    t += <span class="built_in">char</span>(<span class="string">&#x27;0&#x27;</span> + (S &gt;&gt; j &amp; <span class="number">1</span>));                <span class="keyword">if</span> (s[i].<span class="built_in">find</span>(t) == string::npos)                    ok = <span class="number">0</span>;            &#125;            <span class="keyword">if</span> (!ok)            &#123;                <span class="built_in">chkmx</span>(ans[i], k - <span class="number">1</span>);                <span class="keyword">break</span>;            &#125;        &#125;        <span class="keyword">if</span> (s[i].<span class="built_in">size</span>() &gt; <span class="number">1800</span>)            s[i] = s[i].<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">900</span>) + <span class="string">&#x27;-&#x27;</span> + s[i].<span class="built_in">substr</span>(s[i].<span class="built_in">size</span>() - <span class="number">900</span>);        cout &lt;&lt; ans[i] &lt;&lt; endl;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1929F Sasha and the Wedding Binary Search Tree</title>
      <link href="/archives/CF1929F/"/>
      <url>/archives/CF1929F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定 $n$ 个点的 BST（二叉搜索树），目前点权为 $-1$ 的节点可以染色 $[1,C]$，问可能的 BST 个数。答案对 $998,244,353$ 取模。</p><p>多测，$1\leq t\leq 10^5,1\leq \sum n\leq 5\times 10^5,1\leq C\leq 10^9$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>BST 的一个性质是中序遍历点权单调不降。</p><p>中序遍历的顺序之后，我们只需要对于相邻两对不为 $-1$ 的数（我们定为 $L$ 和 $R$）直接的 $-1$ 填充即可。填充只能填充 $[L,R]$ 的数。</p><p>那么这个问题转化为对于长度为 $k$ 的序列，求填充 $[L,R]$ 且单调不降的方案数。观察到我们只需要知道可以选的个数，不需要知道具体选什么，所以答案只与 $len&#x3D;R-L+1$ 有关。也就是用 $len$ 个数填充长度为 $k$ 的序列且单调不降的方案数。</p><p>这是经典组合数题，答案是 $\binom{len+(k-1)}{k}$。我的考虑方式和别的题解不太一样，你考虑对于只能单调上升的答案是 $\binom{len}{k}$，那么你加入 $k-1$ 个决策，表示 $\forall i\in[2,k]$，第 $i$ 个位置和第 $i-1$ 个位置填一样颜色。</p><p>实现需要支持多次查询 $\binom{n}{i}$，但是 $\sum i\leq n$ 所以直接暴力做就行。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>modint 部分已经省略。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> p = <span class="number">998244353</span>;<span class="keyword">using</span> Z = mod_int&lt;p&gt;;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="type">int</span> n;ll c;<span class="keyword">struct</span> <span class="title class_">node</span>&#123;    <span class="type">int</span> l, r;    ll val;&#125; a[<span class="number">500020</span>];vector&lt;<span class="type">int</span>&gt; v;<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (~a[u].l)        <span class="built_in">dfs</span>(a[u].l);    v.<span class="built_in">push_back</span>(u);    <span class="keyword">if</span> (~a[u].r)        <span class="built_in">dfs</span>(a[u].r);&#125;<span class="function">Z <span class="title">C</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i)</span> <span class="comment">// n 选 i 方案数</span></span><span class="function"></span>&#123;    Z ret = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)        ret *= n - j + <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)        ret /= j;    <span class="keyword">return</span> ret;&#125;<span class="function">Z <span class="title">F</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> L, <span class="type">int</span> R)</span> <span class="comment">// n 个数升序，且都在 [L,R] 的方案数</span></span><span class="function"></span>&#123;    <span class="type">int</span> len = R - L + <span class="number">1</span>;    <span class="comment">// 等价于 C(n + len - 1 , n)</span>    <span class="keyword">return</span> <span class="built_in">C</span>(n + len - <span class="number">1</span>, n);&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(n, c);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">read</span>(a[i].l, a[i].r, a[i].val);    v.<span class="built_in">clear</span>();    <span class="built_in">dfs</span>(<span class="number">1</span>);    <span class="type">int</span> minus = <span class="number">0</span>, l = <span class="number">1</span>;    Z ans = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i : v)    &#123;        <span class="keyword">if</span> (~a[i].val)        &#123;            ans *= <span class="built_in">F</span>(minus, l, a[i].val);            minus = <span class="number">0</span>;            l = a[i].val;        &#125;        <span class="keyword">else</span>            minus++;    &#125;    ans *= <span class="built_in">F</span>(minus, l, c);    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> t;    <span class="built_in">read</span>(t);    <span class="keyword">while</span> (t--)        <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1929E Sasha and the Happy Tree Cutting</title>
      <link href="/archives/CF1929E/"/>
      <url>/archives/CF1929E/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如何评价我场上 LCA 没清空 fa 数组没有 AK。</p><h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定 $n$ 个点的一棵树，以及 $k$ 组点 $(u,v)$，表示 $u\to v$ 的简单路径包含特殊边。问至少多少边为特殊边。</p><p>多测，$1\leq t\leq 10^4,\sum n\leq10^5,\sum 2^k\leq 2^{20}$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>$k$ 很小，考虑状压。$S_i$ 为一个 mask 表示第 $i$ 条边可能出现哪几条特殊边，也就是被哪几个路径包含。</p><p>设计 dp 状态 $f_{mask}$ 表示『包含集合 $mask$ 至少需要多少条边』。</p><p>直接转移是 $\mathcal O(2^k\times n)$ 的，无法通过。</p><p>发现 $k$ 条边至多 $2k$ 个点，直接建虚树大小为 $\mathcal O(k)$。<del>所以我们建立虚树转移 dp。</del></p><p>我们直接对于 $S_i$ 进行去重，得到的集合大小只有 $\mathcal O(k)$ 了。现在复杂度为 $\mathcal O(2^k\times k)$，可以通过。</p><p>状压部分的染色，$u\to v$ 的简单路径就是 $u\to \operatorname{lca}(u,v)$ 加上 $v\to \operatorname{lca}(u,v)$，因此暴力跳 $fa$ 数组即可。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">min</span>(x, y); &#125;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;pii E[<span class="number">100020</span>];<span class="type">int</span> n, m;vector&lt;<span class="type">int</span>&gt; a[<span class="number">100020</span>];<span class="type">int</span> dep[<span class="number">100020</span>];<span class="type">int</span> fa[<span class="number">100020</span>][<span class="number">20</span>];<span class="type">int</span> S[<span class="number">100020</span>]; <span class="comment">// mask</span><span class="type">int</span> f[<span class="number">1</span> &lt;&lt; <span class="number">20</span>];map&lt;pii, <span class="type">int</span>&gt; mp;<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> p)</span></span><span class="function"></span>&#123;    dep[u] = dep[p] + <span class="number">1</span>;    fa[u][<span class="number">0</span>] = p;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; <span class="number">1</span> &lt;&lt; i &lt;= dep[u]; i++)        fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];    <span class="keyword">for</span> (<span class="type">int</span> v : a[u])        <span class="keyword">if</span> (v ^ p)            <span class="built_in">dfs</span>(v, u);&#125;<span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (dep[x] &lt; dep[y])        <span class="built_in">swap</span>(x, y);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)        <span class="keyword">if</span> (dep[fa[x][i]] &gt;= dep[y])            x = fa[x][i];    <span class="keyword">if</span> (x == y)        <span class="keyword">return</span> x;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)        <span class="keyword">if</span> (fa[x][i] ^ fa[y][i])            x = fa[x][i], y = fa[y][i];    <span class="keyword">return</span> fa[x][<span class="number">0</span>];&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(n);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        a[i].<span class="built_in">clear</span>(), S[i] = dep[i] = <span class="number">0</span>;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++)            fa[i][j] = <span class="number">0</span>;    &#125;    mp.<span class="built_in">clear</span>();    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)    &#123;        <span class="type">int</span> u, v;        <span class="built_in">read</span>(u, v);        E[i] = &#123;u, v&#125;;        a[u].<span class="built_in">push_back</span>(v);        a[v].<span class="built_in">push_back</span>(u);        mp[&#123;u, v&#125;] = mp[&#123;v, u&#125;] = i;    &#125;    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);    <span class="built_in">read</span>(m);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)    &#123;        <span class="type">int</span> cnt = <span class="number">1</span> &lt;&lt; i;        <span class="type">int</span> u, v;        <span class="built_in">read</span>(u, v);        <span class="type">int</span> lca = <span class="built_in">LCA</span>(u, v);        <span class="keyword">for</span> (<span class="type">int</span> j = u; j != lca; j = fa[j][<span class="number">0</span>])            S[mp[&#123;j, fa[j][<span class="number">0</span>]&#125;]] |= cnt;        <span class="keyword">for</span> (<span class="type">int</span> j = v; j != lca; j = fa[j][<span class="number">0</span>])            S[mp[&#123;j, fa[j][<span class="number">0</span>]&#125;]] |= cnt;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++)        f[i] = inf;    set&lt;<span class="type">int</span>&gt; s;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)        s.<span class="built_in">insert</span>(S[i]);    <span class="keyword">for</span> (<span class="type">int</span> i : s)        f[i] = <span class="number">1</span>;    <span class="comment">// for (int i : s)</span>    <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span>    <span class="comment">// cout &lt;&lt; endl;</span>    f[<span class="number">0</span>] = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++)        <span class="keyword">for</span> (<span class="type">int</span> j : s)            <span class="built_in">chkmn</span>(f[i | j], f[i] + <span class="number">1</span>);    cout &lt;&lt; f[(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> t;    cin &gt;&gt; t;    <span class="keyword">while</span> (t--)        <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF710D Two Arithmetic Progressions</title>
      <link href="/archives/CF710D/"/>
      <url>/archives/CF710D/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是今天粉兔杯每日一题，也是根分日报例题，补一下。</p><p><a href="https://www.luogu.com.cn/blog/Amateur-threshold/pu-li-mei-xue-qian-tan-gen-hao-fen-zhi">暴力美学——浅谈根号分治 - paulzrm 的博客 - 洛谷博客</a></p><h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给出两个等差数列，求在 $[L,R]$ 之间的交集大小。</p><p>等差数列形式为 $ak+b$。</p><p>$1\leq a_1,a_2\leq 2\times 10^9,-2\times 10^9 \leq b_1,b_2,L,R \leq 2\times 10^9,L \le R$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>观察到 $a$ 大，等差数列在 $[L,R]$ 之间的项数就很少。反之亦然。</p><p>所以考虑根号分治。显然阈值 $B&#x3D;\sqrt{2\times 10^9}\approx44722$。</p><p>为了方便，另 $a_1\geq a_2$。</p><ul><li>$a_1\leq B$</li></ul><p>循环节长度为 $\operatorname{lcm}(a_1,a_2)$ 很显然，那么我们找到第一个重复出现的数即可。</p><p>又因为循环节长度为 $\operatorname{lcm}(a_1,a_2)$，所以我们枚举前 $\dfrac{\operatorname{lcm}}{a_1}$ 个在 $a_1k+b_1$ 中的数即可找到第一个重复的数。我一开始实现的时候保守了枚举了 $a_2$ 个，但是我们令 $a_1\geq a_2$，所以其实范围是差不多的。</p><p>知道重复的数 $x$ 之后，答案就是 $\lceil\dfrac{R-x+1}{\operatorname{lcm}}\rceil$。</p><ul><li>$a_1\gt B$</li></ul><p>这是很简单的，因为公差大，所以项数不多，直接枚举 $a_1k+b_1$，判断是否在 $a_2k+b_2$ 中即可。</p><hr><p>实现的时候注意一下开始的位置应该是 $\max{b_1,b_2,L}$。然后自己微调一下变成等差数列中的某个数就行。</p><p>开始循环的位置是 <code>ll start = (max(&#123;b1, b2, L&#125;) - b1 + a1 - 1) / a1 * a1 + b1;</code>。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>$15\ \tt{ms}$ 是目前 CF 最优解了。正解是 exgcd。</p><p><a href="https://codeforces.com/contest/710/submission/247832379">CF submission 247832379</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="type">const</span> <span class="type">int</span> B = <span class="number">44722</span>;ll a1, b1, a2, b2;ll L, R;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; a1 &gt;&gt; b1 &gt;&gt; a2 &gt;&gt; b2 &gt;&gt; L &gt;&gt; R;    <span class="keyword">if</span> (a1 &lt;= a2)        <span class="built_in">swap</span>(a1, a2), <span class="built_in">swap</span>(b1, b2);    ll start = (<span class="built_in">max</span>(&#123;b1, b2, L&#125;) - b1 + a1 - <span class="number">1</span>) / a1 * a1 + b1;    <span class="keyword">if</span> (a1 &lt;= B)    &#123;        ll Lcm = a1 / __gcd(a1, a2) * a2;        <span class="keyword">for</span> (ll i = start, j = <span class="number">1</span>; i &lt;= R &amp;&amp; j &lt;= Lcm / a1 + <span class="number">5</span>; i += a1, j++)        &#123;            <span class="keyword">if</span> ((i - b2) % a2)                <span class="keyword">continue</span>;            <span class="keyword">return</span> cout &lt;&lt; ((R - i + <span class="number">1</span>) + (Lcm - <span class="number">1</span>)) / Lcm &lt;&lt; endl, <span class="number">0</span>;        &#125;        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;    &#125;    <span class="keyword">else</span>    &#123;        <span class="type">int</span> ans = <span class="number">0</span>;        <span class="keyword">for</span> (ll i = start; i &lt;= R; i += a1)            ans += !((i - b2) % a2);        cout &lt;&lt; ans &lt;&lt; endl;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1926F Vlad and Avoiding X</title>
      <link href="/archives/CF1926F/"/>
      <url>/archives/CF1926F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定 $7\times 7$ 的黑白网格，问至少改多少点才能使得不出现大小为 $3\times 3$ 的<strong>黑色</strong> $\tt X$ 形。定义改一个点指改变这个点的颜色，黑变成白，白变成黑。</p><p>多测，$1\leq t\leq 200$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>显然只需要黑色改白色。</p><p>一个不是很显然的结论是 $ans\leq 8$。</p><p>你考虑对于网格进行红绿染色（其实就是黑白染色，但是和题意重合了）。就是 $(1,1)$ 红色，$(1,2)$ 和 $(2,1)$ 绿色这样子交叉递推。显然红色与绿色的部分是可以分开计算的。</p><p>然后我们瞪眼法发现一个 $ans&#x3D;8$ 的通解：染色 $(3,3),(3,4),(3,5),(4,3),(4,5),(5,3),(5,4),(5,5)$。这也就告诉我们，$ans$ 上界为 $8$。其中红绿两部分各 $4$ 个。</p><p>但是这不一定能构造最优解。<del>因为我在 test 2 的 case 16 WA 了。</del></p><p>但是这启发我们，因为答案很小，每个部分也都很少，我们可以直接暴力枚举具体是哪 $4$ 个格子被染白了。</p><p>时间复杂度是 $\mathcal O(\binom{25}{4}\times 25+\binom{24}{4}\times 24)$ 的。后面加的 $\times 25$ 之类的是用来 check 是否为合法的方案的。<del>时间复杂度能这么写吗我不知道啊。</del></p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>写的很丑。</p><p><a href="https://codeforces.com/contest/1926/submission/247566445">CF submission 247566445</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">min</span>(x, y); &#125;<span class="type">const</span> <span class="type">int</span> n = <span class="number">7</span>;<span class="type">const</span> <span class="type">int</span> m = <span class="number">9</span>;<span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;<span class="type">const</span> <span class="type">int</span> dy[] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;<span class="type">char</span> mp[<span class="number">10</span>][<span class="number">10</span>];vector&lt;pii&gt; v[<span class="number">2</span>];<span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> mp[x - <span class="number">1</span>][y - <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; mp[x - <span class="number">1</span>][y + <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; mp[x + <span class="number">1</span>][y - <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; mp[x + <span class="number">1</span>][y + <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span>; &#125;<span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(pii a, <span class="type">char</span> to)</span> </span>&#123; mp[a.first][a.second] = to; &#125;<span class="function"><span class="type">int</span> <span class="title">siz</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span><span class="function"></span>&#123;    set&lt;<span class="type">int</span>&gt; s;    s.<span class="built_in">insert</span>(a);    s.<span class="built_in">insert</span>(b);    s.<span class="built_in">insert</span>(c);    s.<span class="built_in">insert</span>(d);    <span class="keyword">return</span> s.<span class="built_in">size</span>();&#125;<span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(vector&lt;pii&gt; &amp;v)</span></span><span class="function"></span>&#123;    <span class="type">bool</span> need = <span class="number">0</span>;    <span class="keyword">for</span> (pii p : v)    &#123;        <span class="type">int</span> x = p.first;        <span class="type">int</span> y = p.second;        <span class="keyword">if</span> (mp[x][y] == <span class="string">&#x27;B&#x27;</span>)            <span class="keyword">if</span> (<span class="built_in">ok</span>(x, y))                need = <span class="number">1</span>;    &#125;    <span class="keyword">if</span> (!need)        <span class="keyword">return</span> <span class="number">0</span>;    <span class="type">int</span> ret = <span class="number">8</span>;    <span class="keyword">for</span> (<span class="type">int</span> p1 = <span class="number">0</span>; p1 &lt; v.<span class="built_in">size</span>(); p1++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> p2 = p1; p2 &lt; v.<span class="built_in">size</span>(); p2++)        &#123;            <span class="keyword">for</span> (<span class="type">int</span> p3 = p2; p3 &lt; v.<span class="built_in">size</span>(); p3++)            &#123;                <span class="keyword">for</span> (<span class="type">int</span> p4 = p3; p4 &lt; v.<span class="built_in">size</span>(); p4++)                &#123;                    need = <span class="number">1</span>;                    <span class="built_in">change</span>(v[p1], <span class="string">&#x27;W&#x27;</span>), <span class="built_in">change</span>(v[p2], <span class="string">&#x27;W&#x27;</span>), <span class="built_in">change</span>(v[p3], <span class="string">&#x27;W&#x27;</span>), <span class="built_in">change</span>(v[p4], <span class="string">&#x27;W&#x27;</span>);                    <span class="keyword">for</span> (pii p : v)                    &#123;                        <span class="type">int</span> x = p.first;                        <span class="type">int</span> y = p.second;                        <span class="keyword">if</span> (mp[x][y] == <span class="string">&#x27;B&#x27;</span>)                            <span class="keyword">if</span> (<span class="built_in">ok</span>(x, y))                                need = <span class="number">0</span>;                    &#125;                    <span class="keyword">if</span> (need)                        <span class="built_in">chkmn</span>(ret, <span class="built_in">siz</span>(p1, p2, p3, p4));                    <span class="built_in">change</span>(v[p1], <span class="string">&#x27;B&#x27;</span>), <span class="built_in">change</span>(v[p2], <span class="string">&#x27;B&#x27;</span>), <span class="built_in">change</span>(v[p3], <span class="string">&#x27;B&#x27;</span>), <span class="built_in">change</span>(v[p4], <span class="string">&#x27;B&#x27;</span>);                &#125;            &#125;        &#125;    &#125;    <span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    v[<span class="number">0</span>].<span class="built_in">clear</span>(), v[<span class="number">1</span>].<span class="built_in">clear</span>();    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)            cin &gt;&gt; mp[i][j];    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)            <span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;B&#x27;</span>)                v[(i &amp; <span class="number">1</span>) ^ (j &amp; <span class="number">1</span>)].<span class="built_in">push_back</span>(&#123;i, j&#125;);    &#125;    cout &lt;&lt; <span class="built_in">calc</span>(v[<span class="number">0</span>]) + <span class="built_in">calc</span>(v[<span class="number">1</span>]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> t;    cin &gt;&gt; t;    <span class="keyword">while</span> (t--)        <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF995E Number Clicker</title>
      <link href="/archives/CF1129B/"/>
      <url>/archives/CF1129B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在『江莉XCPC民间算法交流枢纽』有群友扔了这题，还挺有趣的。（这里是专有名词中英文之间不加括号没事的吧？）</p><h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定 $u,v,p$，保证 $p$ 是质数，有 $3$ 种操作：</p><ol><li>$u\gets u+1$</li><li>$u\gets u-1$</li><li>$u\gets u^{p-2}$</li></ol><p>以上操作过后均对 $p$ 取模。</p><p>求一种不超过 $200$ 次操作使得 $u&#x3D;v$ 的操作方案。</p><p>$0\leq u,v\lt p,3\leq p\leq 10^9+9$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>$200$ 直接搜就算有很多操作重复也是会炸的。考虑直接双向搜索，从 $u,v$ <strong>同时</strong>开搜。</p><p><del>你怎么知道我没睡醒两边各搜 100 个 TLE on 3。</del></p><p>为啥这样子时间复杂度是正确的？$u\gets u^{p-2}$ 其实就相当于随机选位置跳了，几乎一点关系没有。根据生日悖论，大概搜 $\mathcal O(\sqrt p)$ 次就能搜到，这样子跳到重复的概率其实是非常高的。</p><p>搜的时候记录一下前驱后驱，$v$ 搜碰到通过 $u$ 搜到的位置就可以停下输出了。我每个点都是不到 $40$ 次操作。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="type">int</span> x, y, p;<span class="type">int</span> pos;<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(ll x, <span class="type">int</span> y)</span></span><span class="function"></span>&#123;    ll ret = <span class="number">1</span>;    <span class="keyword">for</span> (; y &gt; <span class="number">0</span>; y &gt;&gt;= <span class="number">1</span>)    &#123;        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)            (ret *= x) %= p;        (x *= x) %= p;    &#125;    <span class="keyword">return</span> ret;&#125;<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">inv</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">qpow</span>(x, p - <span class="number">2</span>); &#125;map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; frt;map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; bck;map&lt;<span class="type">int</span>, pii&gt; pre;map&lt;<span class="type">int</span>, pii&gt; suf;queue&lt;pii&gt; q1;queue&lt;pii&gt; q2;<span class="type">bool</span> ok;<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> op)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (op == <span class="number">1</span>)        <span class="keyword">return</span> (x + <span class="number">1</span>) % p;    <span class="keyword">if</span> (op == <span class="number">2</span>)        <span class="keyword">return</span> (x + p - <span class="number">1</span>) % p;    <span class="keyword">return</span> <span class="built_in">inv</span>(x);&#125;<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">in</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &lt;= x &amp;&amp; x &lt; p; &#125;<span class="function"><span class="type">void</span> <span class="title">out_pre</span><span class="params">(<span class="type">int</span> x)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (!pre[x].first)        <span class="keyword">return</span>;    <span class="built_in">out_pre</span>(pre[x].second);    cout &lt;&lt; pre[x].first &lt;&lt; <span class="string">&quot; &quot;</span>;&#125;<span class="function"><span class="type">void</span> <span class="title">out_suf</span><span class="params">(<span class="type">int</span> x)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (!suf[x].first)        <span class="keyword">return</span>;    cout &lt;&lt; (suf[x].first == <span class="number">3</span> ? <span class="number">3</span> : <span class="number">3</span> - suf[x].first) &lt;&lt; <span class="string">&quot; &quot;</span>;    <span class="built_in">out_suf</span>(suf[x].second);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; x &gt;&gt; y &gt;&gt; p;    pre[x] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;    suf[y] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;    q<span class="number">1.</span><span class="built_in">push</span>(&#123;x, frt[x] = <span class="number">0</span>&#125;);    q<span class="number">2.</span><span class="built_in">push</span>(&#123;y, bck[y] = <span class="number">0</span>&#125;);    <span class="keyword">while</span> (!ok &amp;&amp; !q<span class="number">1.</span><span class="built_in">empty</span>() &amp;&amp; !q<span class="number">2.</span><span class="built_in">empty</span>())    &#123;        <span class="type">int</span> u = q<span class="number">1.f</span>ront().first, v = q<span class="number">2.f</span>ront().first;        <span class="type">int</span> du = q<span class="number">1.f</span>ront().second, dv = q<span class="number">2.f</span>ront().second;        <span class="comment">// cout &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; endl;</span>        q<span class="number">1.</span><span class="built_in">pop</span>(), q<span class="number">2.</span><span class="built_in">pop</span>();        <span class="keyword">for</span> (<span class="type">int</span> op = <span class="number">1</span>; op &lt;= <span class="number">3</span>; op++)        &#123;            <span class="type">int</span> tx = <span class="built_in">F</span>(u, op);            <span class="keyword">if</span> (frt.<span class="built_in">count</span>(tx))                <span class="keyword">continue</span>;            pre[tx] = &#123;op, u&#125;;            q<span class="number">1.</span><span class="built_in">push</span>(&#123;tx, frt[tx] = du + <span class="number">1</span>&#125;);        &#125;        <span class="keyword">for</span> (<span class="type">int</span> op = <span class="number">1</span>; op &lt;= <span class="number">3</span>; op++)        &#123;            <span class="type">int</span> ty = <span class="built_in">F</span>(v, op);            <span class="keyword">if</span> (bck.<span class="built_in">count</span>(ty))                <span class="keyword">continue</span>;            suf[ty] = &#123;op, v&#125;;            q<span class="number">2.</span><span class="built_in">push</span>(&#123;ty, bck[ty] = dv + <span class="number">1</span>&#125;);            <span class="keyword">if</span> (frt.<span class="built_in">count</span>(ty))            &#123;                ok = <span class="number">1</span>, pos = ty;                <span class="keyword">break</span>;            &#125;        &#125;    &#125;    cout &lt;&lt; frt[pos] + bck[pos] &lt;&lt; endl;    <span class="built_in">out_pre</span>(pos);    <span class="built_in">out_suf</span>(pos);    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC339F Product Equality</title>
      <link href="/archives/ABC339F/"/>
      <url>/archives/ABC339F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>$n$ 个大数 $a_i$，找三元组 $(i,j,k)$ 个数满足 $1\leq i,j,k\leq n$ 且 $a_i\times a_j&#x3D;a_k$。</p><p>$n\leq 1000,a_i\leq \color{red}{10^{1000}}$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>显然可以直接 FFT 高精度乘法。然后喜提 TLE，因为这个 $a_i$ 位数很长并且要跑很多轮乘法。</p><p>我们集中注意力，注意到满足 $a_i\times a_j&#x3D;a_k$ 的必要条件是对于任意模数 $p$ 存在 $(a_i\bmod p)\times(a_j\bmod p)\equiv a_k \pmod p$。</p><p>所以我们多写几个模数判一下就好。高精度取模低精度可以一位一位扫过去。</p><p>时间复杂度是 $\mathcal O(n^2\log n)$，如果手写个 hash 可以做到 $\mathcal O(n^2)$。</p><p>本人组了 $8$ 个自己生日、同学生日和【数据删除】生日以及一些众所周知的大质数。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://atcoder.jp/contests/abc339/submissions/49960822">AT submission 49960822</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="type">const</span> <span class="type">int</span> P[] = &#123;<span class="number">20091119</span>,                 <span class="number">11190119</span>,                 <span class="number">20102009</span>,                 <span class="number">998244353</span>,                 <span class="number">19260817</span>,                 <span class="number">1000000007</span>,                 <span class="number">998244853</span>,                 <span class="number">1145141</span>&#125;;map&lt;vector&lt;ll&gt;, <span class="type">int</span>&gt; mp;<span class="function">vector&lt;ll&gt; <span class="title">f</span><span class="params">(string &amp;s)</span></span><span class="function"></span>&#123;    vector&lt;ll&gt; p;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)        p.<span class="built_in">push_back</span>(<span class="number">0</span>);    <span class="keyword">for</span> (<span class="type">char</span> c : s)    &#123;        <span class="type">int</span> d = c ^ <span class="string">&#x27;0&#x27;</span>;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)            p[i] = (p[i] * <span class="number">10</span> + d) % P[i];    &#125;    <span class="keyword">return</span> p;&#125;<span class="type">int</span> n;<span class="type">int</span> ans;string s[<span class="number">1020</span>];vector&lt;ll&gt; v[<span class="number">1020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        cin &gt;&gt; s[i];        <span class="comment">// vector&lt;ll&gt; a ;</span>        v[i] = <span class="built_in">f</span>(s[i]);        mp[v[i]]++;        <span class="comment">// for (int j : v[i])</span>        <span class="comment">//     cout &lt;&lt; j &lt;&lt; &quot; &quot;;</span>        <span class="comment">// cout &lt;&lt; endl;</span>    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)        &#123;            vector&lt;ll&gt; a = v[i];            vector&lt;ll&gt; b = v[j];            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)                a[k] = a[k] * b[k] % P[k];            <span class="comment">// for (int i : a)</span>            <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span>            <span class="comment">// cout &lt;&lt; endl;</span>            ans += mp[a];        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[笔记] 莫队 学习笔记</title>
      <link href="/archives/Mo_s_algorithm/"/>
      <url>/archives/Mo_s_algorithm/</url>
      
        <content type="html"><![CDATA[<p>蒸馍身边一群大神不会普通莫队。</p><p>现在每天半夜不写点根号算法都睡不着。根号算法个个是优雅的算法&#x2F;se</p><h1 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h1><p>处理离线区间询问。</p><p>名字由来是因为是莫涛整理的。</p><h1 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>可以较优复杂度从 $[l\pm1,r\pm1]$ 转到 $[l,r]$。</p><p>当 $n,q$ 同阶时，若转移为 $\mathcal O(1)$，总复杂度即为 $\mathcal O(n\sqrt n)$。同理，转移为 $\mathcal O(log n)$ 复杂度即为 $\mathcal O(n\sqrt n\log n)$。</p><p>$n,q$ 不同阶参考 OI Wiki 的复杂度分析。</p><p><a href="https://oi-wiki.org/misc/mo-algo/#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">https://oi-wiki.org/misc/mo-algo/#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90</a></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>对于询问的排序，一般是对 $L$ 分块，先按块排序，每个块内再按 $R$ 排序。一般这样即可，但是更好的写法可以继续奇偶性优化少掉不同块内 $R$ 从 $n$ 再次回到 $1$ 的过程。</p><p>以下为排序代码，其中 $fa_i$ 表示 $i$ 在那一块。</p><pre><code class="highlight cpp"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (fa[a.L] != fa[b.L])        <span class="keyword">return</span> a.L &lt; b.L;    <span class="keyword">if</span> (fa[a.L] &amp; <span class="number">1</span>)        <span class="keyword">return</span> a.R &gt; b.R;    <span class="keyword">return</span> a.R &lt; b.R;&#125;</code></pre><p>也就是说，不进行奇偶性优化的莫队，询问排序后长这样：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ddbq2clq.png"></p><p>而进行了奇偶性优化的话：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/jo4d8k7b.png"></p><p>这样子就可以让 $R$ 更加连贯。</p><p>图中红线表示分块的界线，黑线表示区间询问范围。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="highlight cpp"><span class="type">int</span> L = <span class="number">1</span>, R = <span class="number">0</span>;<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;    <span class="keyword">while</span> (L &gt; Query[i].L)        <span class="built_in">add</span>(--L);    <span class="keyword">while</span> (R &lt; Query[i].R)        <span class="built_in">add</span>(++R);    <span class="keyword">while</span> (L &lt; Query[i].L)        <span class="built_in">del</span>(L++);    <span class="keyword">while</span> (R &gt; Query[i].R)        <span class="built_in">del</span>(R--);    ans[Query[i].id] = ANS;&#125;</code></pre><p>其中 $add(x)$ 和 $del(x)$ 分别表示添加第 $x$ 个位置和删除第 $x$ 个位置进行的操作。</p><p>当然，有的题 $L$ 和 $R$ 的添加删除是不一样的。</p><p>这是个循环位置的顺序，参考 <a href="https://oi-wiki.org/misc/mo-algo/#%E8%BF%87%E7%A8%8B">https://oi-wiki.org/misc/mo-algo/#%E8%BF%87%E7%A8%8B</a> 关于四个循环位置的讨论。一般来说你只要保证先扩张后缩减是不会有问题的。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="P1972-SDOI2009-HH的项链"><a href="#P1972-SDOI2009-HH的项链" class="headerlink" title="P1972 [SDOI2009] HH的项链"></a><a href="https://www.luogu.com.cn/problem/P1972">P1972 [SDOI2009] HH的项链</a></h3><p>我们将此题作为莫队模板进行讲解。</p><p>可是这题莫队标签都没有！那是因为大家不会卡常。</p><p>记录颜色数，即为记录 $h_i$ 表示 $i$ 在序列中出现的次数，新出现加一种颜色，被删完少一种颜色。</p><p>那么我们很快就能码好：</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> fa[<span class="number">1000020</span>];<span class="type">int</span> a[<span class="number">1000020</span>];<span class="type">int</span> ans[<span class="number">1000020</span>];<span class="type">int</span> h[<span class="number">1000020</span>];<span class="type">int</span> n, len, ANS, q;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="keyword">register</span> <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">register</span> <span class="type">int</span> x = <span class="number">0</span>;    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>)        c = <span class="built_in">getchar</span>();    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>), c = <span class="built_in">getchar</span>();    <span class="keyword">return</span> x;&#125;<span class="keyword">struct</span> <span class="title class_">node</span>&#123;    <span class="type">int</span> L, R, id;&#125; Query[<span class="number">1000020</span>];<span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (fa[a.L] != fa[b.L])        <span class="keyword">return</span> a.L &lt; b.L;    <span class="keyword">if</span> (fa[a.L] &amp; <span class="number">1</span>)        <span class="keyword">return</span> a.R &gt; b.R;    <span class="keyword">return</span> a.R &lt; b.R;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    n = <span class="built_in">read</span>();    len = <span class="built_in">sqrt</span>(n);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        a[i] = <span class="built_in">read</span>();        fa[i] = (i + len - <span class="number">1</span>) / len;    &#125;    q = <span class="built_in">read</span>();    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)    &#123;        <span class="type">int</span> L, R;        L = <span class="built_in">read</span>();        R = <span class="built_in">read</span>();        Query[i] = &#123;L, R, i&#125;;    &#125;    <span class="built_in">sort</span>(Query + <span class="number">1</span>, Query + q + <span class="number">1</span>, cmp);    <span class="type">int</span> L = <span class="number">1</span>, R = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)    &#123;        <span class="keyword">while</span> (L &gt; Query[i].L)            ANS += (++h[a[--L]] == <span class="number">1</span>);        <span class="keyword">while</span> (R &lt; Query[i].R)            ANS += (++h[a[++R]] == <span class="number">1</span>);        <span class="keyword">while</span> (L &lt; Query[i].L)            ANS -= (--h[a[L++]] == <span class="number">0</span>);        <span class="keyword">while</span> (R &gt; Query[i].R)            ANS -= (--h[a[R--]] == <span class="number">0</span>);        ans[Query[i].id] = ANS;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)    &#123;        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p>诶，T 了！本题莫队真的过不去吗？</p><p>我的评价是我这题不关同步的 cin 都过了。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> fa[<span class="number">1000020</span>];<span class="type">int</span> a[<span class="number">1000020</span>];<span class="type">int</span> ans[<span class="number">1000020</span>];<span class="type">int</span> pre[<span class="number">1000020</span>];<span class="type">int</span> nxt[<span class="number">1000020</span>];<span class="type">int</span> p[<span class="number">1000020</span>];<span class="type">int</span> n, len, ANS, q;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="keyword">register</span> <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">register</span> <span class="type">int</span> x = <span class="number">0</span>;    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>)        c = <span class="built_in">getchar</span>();    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>), c = <span class="built_in">getchar</span>();    <span class="keyword">return</span> x;&#125;<span class="keyword">struct</span> <span class="title class_">node</span>&#123;    <span class="type">int</span> L, R, id;&#125; Query[<span class="number">1000020</span>];<span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (fa[a.L] != fa[b.L])        <span class="keyword">return</span> a.L &lt; b.L;    <span class="keyword">if</span> (fa[a.L] &amp; <span class="number">1</span>)        <span class="keyword">return</span> a.R &gt; b.R;    <span class="keyword">return</span> a.R &lt; b.R;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    n = <span class="built_in">read</span>();    len = <span class="built_in">sqrt</span>(n);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        a[i] = <span class="built_in">read</span>();        fa[i] = (i + len - <span class="number">1</span>) / len;        nxt[i] = n + <span class="number">1</span>;        pre[i] = p[a[i]];        nxt[pre[i]] = i;        p[a[i]] = i;    &#125;    q = <span class="built_in">read</span>();    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)    &#123;        <span class="type">int</span> L, R;        L = <span class="built_in">read</span>();        R = <span class="built_in">read</span>();        Query[i] = &#123;L, R, i&#125;;    &#125;    <span class="built_in">sort</span>(Query + <span class="number">1</span>, Query + q + <span class="number">1</span>, cmp);    <span class="type">int</span> L = <span class="number">1</span>, R = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)    &#123;        <span class="keyword">while</span> (L &gt; Query[i].L)            ANS += (nxt[--L] &gt; R);        <span class="keyword">while</span> (R &lt; Query[i].R)            ANS += (pre[++R] &lt; L);        <span class="keyword">while</span> (L &lt; Query[i].L)            ANS -= (nxt[L++] &gt; R);        <span class="keyword">while</span> (R &gt; Query[i].R)            ANS -= (pre[R--] &lt; L);        ans[Query[i].id] = ANS;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)    &#123;        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p>为什么这样可过呢，我们发现，观察一个数在序列中是否是只出现一次，只需要看同一颜色的数，是否已经出现过了。有点废话文学，但是『只需要看同一颜色的数，是否已经出现过了』就是记录这个数上一次出现的位置和下一次出现的位置。</p><p>所以，我们考虑记录 $pre_i$ 和 $nxt_i$ 表示 $a_i$ 上一次或下一次出现的位置用来辅助区间转移。</p><p>这样子就可以做到莫队过程访址连续，真正的 $\mathcal O(n\sqrt n)$。</p><h3 id="P1494-国家集训队-小-Z-的袜子"><a href="#P1494-国家集训队-小-Z-的袜子" class="headerlink" title="P1494 [国家集训队] 小 Z 的袜子"></a><a href="https://www.luogu.com.cn/problem/P1494">P1494 [国家集训队] 小 Z 的袜子</a></h3><p>记录每个区间此时颜色数量，那么颜色数量 $-1$ 即为此时这个颜色能配成多少对。答案分母显然是 $\dbinom{R-L+1}{2}$。分子即为所有颜色能配成多少对。</p><h3 id="P2709-小-B-的询问"><a href="#P2709-小-B-的询问" class="headerlink" title="P2709 小 B 的询问"></a><a href="https://www.luogu.com.cn/problem/P2709">P2709 小 B 的询问</a></h3><p>也是区间数颜色。每种颜色个数平方一下即可。</p><h3 id="P3901-数列找不同"><a href="#P3901-数列找不同" class="headerlink" title="P3901 数列找不同"></a><a href="https://www.luogu.com.cn/problem/P3901">P3901 数列找不同</a></h3><p>判断区间颜色数是否 $&#x3D;R-L+1$。</p><h3 id="CF351D-Jeff-and-Removing-Periods"><a href="#CF351D-Jeff-and-Removing-Periods" class="headerlink" title="CF351D Jeff and Removing Periods"></a><a href="https://codeforces.com/problemset/problem/351/D">CF351D Jeff and Removing Periods</a></h3><p>为了方便描述，我们约定数值相同的数为同一颜色的数。</p><p>有 $n$ 个数，我们定义一次操作为：选择若干个同颜色数，使得他们在序列中的位置为一个等差数列。删除它们。</p><p>操作完之后可以重排整个序列。</p><p>有 $q$ 个询问，每次询问给定 $[l,r]$，求至少几次操作能全部删除 $[l,r]$。</p><p>询问互不影响。</p><p>$1\leq n,q,a_i\leq 10^5$</p><p><a href="http://blog.cyx2009.top/archives/250/">http://blog.cyx2009.top/archives/250/</a> 查看。</p><p>或洛谷题解区最高赞题解。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/2i6hvf8d.png"></p><h3 id="ABC293G-Triple-Index"><a href="#ABC293G-Triple-Index" class="headerlink" title="ABC293G Triple Index"></a><a href="https://atcoder.jp/contests/abc293/tasks/abc293_g">ABC293G Triple Index</a></h3><p>给定长度为 $N$ 的数列 $a_1,a_2,\cdots,a_N$。</p><p>$q$ 组询问，每组询问给定 $l,r$ 且 $1\le l\le r \le n$，问存在多少个三元组 $(i,j,k)$，使得 $l\le i &lt; j&lt;k\le r$ 且 $a_i&#x3D;a_j&#x3D;a_k$。</p><p>考虑增加颜色和删除颜色贡献，设当前位置的颜色是 $x$，共显示 $\pm \dfrac{(h_x-1)(h_x-2)}{2}$。其中 $h_i$ 表示颜色 $i$ 的个数。</p><h3 id="TENKA1-2014-FINAL-D"><a href="#TENKA1-2014-FINAL-D" class="headerlink" title="TENKA1_2014_FINAL D"></a><a href="https://atcoder.jp/contests/tenka1-2014-final/tasks/tenka1_2014_final_d">TENKA1_2014_FINAL D</a></h3><p>$m$ 组询问，每次给定 $n,k$，求 $\sum\limits_{i&#x3D;0}^k \binom{n}{i}$。</p><p>$1 \le n, m, k \le 10^5$。</p><p>很好数学，爱来自莫队。</p><p>$\dbinom{n}{k-1}\to\dbinom{n}{k},ans\gets ans+\dbinom{n}{k}$</p><p>$\dbinom{n}{k+1}\to\dbinom{n}{k},ans\gets ans-\dbinom{n}{k+1}$</p><p>$\dbinom{n-1}{k}\to\dbinom{n}{k},ans\gets 2ans-\dbinom{n-1}{k}$</p><p>$\dbinom{n+1}{k}\to\dbinom{n}{k},ans\gets \dfrac{ans+\dbinom{n}{k}}{2}$</p><p>改变 $k$ 是显然的，改变 $n$ 用帕斯卡法则拆一下即可得到 $\dbinom{n-1}{k}\to\dbinom{n}{k}$ 的答案变化，另一个同理。</p><h3 id="SP-DQUERY-D-query"><a href="#SP-DQUERY-D-query" class="headerlink" title="SP DQUERY - D-query"></a><a href="https://www.spoj.com/problems/DQUERY/">SP DQUERY - D-query</a></h3><p>给出一个长度为 $n$ 的数列，$a_1,a_2,\dots,a_n$ ，有 $q$ 个询问，每个询问给出数对$(i,j)$，需要你给出 $a_{i},a_{i+1},\dots ,a_{j}$ 这一段中有多少不同的数字。</p><p>也是区间数颜色。</p>]]></content>
      
      
      <categories>
          
          <category> StudyNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF351D Jeff and Removing Periods</title>
      <link href="/archives/CF351D/"/>
      <url>/archives/CF351D/</url>
      
        <content type="html"><![CDATA[<h1 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h1><p>和等差数列过不去了。碰上等差数列就要调 1h。</p><h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>为了方便描述，我们约定数值相同的数为同一颜色的数。</p><p>有 $n$ 个数，我们定义一次操作为：选择若干个同颜色数，使得他们在序列中的位置为一个等差数列。删除它们。</p><p>操作完之后可以重排整个序列。</p><p>有 $q$ 个询问，每次询问给定 $[l,r]$，求至少几次操作能全部删除 $[l,r]$。</p><p>询问互不影响。</p><p>$1\leq n,q,a_i\leq 10^5$</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>与翻译类似，约定数值相同的数为同一颜色的数。</p><p>看起来就长了一眼莫队样子。</p><p>分析一下，发现操作一次之后，通过重排是可以调整使得之后每次都能删除某一种相同数。</p><p>但是，如果我们第一次操作就可以删除某一种相同数，换言之，<strong>如果原区间本身就包含一个颜色使得位置为等差数列</strong>，答案即为区间颜色数。反之，答案为区间颜色数 $+1$。</p><p>区间颜色数是很好维护的，我们用一个桶记录每个数出现几次即可。</p><p>另外介绍一种小常数写法，我们记录 $pre_i$ 与 $nxt_i$ 表示与 $a_i$ 颜色相同的数上一次或下一次出现在什么位置，这能做到访址连续跑得更快。</p><pre><code class="highlight cpp"><span class="comment">// while(L&gt;Query[i].L)ANS+=(++h[a[--L]]==1);</span><span class="comment">// while(R&lt;Query[i].R)ANS+=(++h[a[++R]]==1);  </span><span class="comment">// while(L&lt;Query[i].L)ANS-=(--h[a[L++]]==0);</span><span class="comment">// while(R&gt;Query[i].R)ANS-=(--h[a[R--]]==0);</span><span class="keyword">while</span>(L&gt;Query[i].L)ANS+=(nxt[--L]&gt;R);<span class="keyword">while</span>(R&lt;Query[i].R)ANS+=(pre[++R]&lt;L);  <span class="keyword">while</span>(L&lt;Query[i].L)ANS-=(nxt[L++]&gt;R);<span class="keyword">while</span>(R&gt;Query[i].R)ANS-=(pre[R--]&lt;L);</code></pre><p>注释即为正常桶记录写法，非注释即为这种访址连续的写法。</p><p>然后我们考虑如何判断『原区间本身就包含一个颜色使得位置为等差数列』，为了莫队方便把信息传递到下个区间，我们改成『维护区间内有多少颜色使得位置为等差数列』。</p><p>这个有一个很显然的单次修改查询 $\mathcal O(\log n)$ 的做法为，维护若干 multiset，每次暴力插入删除当前点的贡献，然后判断最大值与最小值是否相等。附一个到此步 TLE on 23 的码：<a href="https://codeforces.com/contest/351/submission/243942020">CF submission 243942020</a>。</p><p>然后考虑优化，我们现在把要维护的问题转化为：</p><blockquote><p>有 $n$ 个类别，每次操作在一个类别里加入或删除一个数，每次判断这个类别是否只有 $1$ 种数。</p></blockquote><p>然后，我们考虑一个人类智慧做法：</p><p>维护 $3$ 个信息，类别中数的个数 $cnt_i$，类别中数的和 $sum_{0,i}$，类别中数的平方和 $sum_{1,i}$。</p><p>有这三个信息我们就可以判断是否类别中均为一个数了。</p><p><del>你怎么知道这是我深夜在 U 群问怎么做这个问题然后 skip2004 告诉我的解法。</del></p><p>然后我们把之前 TLE on 23 的码改一改就可以了！</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://codeforces.com/contest/351/submission/243951477">CF submission 243951477</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="type">int</span> fa[<span class="number">100020</span>];<span class="type">int</span> a[<span class="number">100020</span>];<span class="type">int</span> ans[<span class="number">100020</span>];<span class="type">int</span> pre[<span class="number">100020</span>];<span class="type">int</span> nxt[<span class="number">100020</span>];<span class="type">int</span> p[<span class="number">100020</span>];ll sum[<span class="number">2</span>][<span class="number">100020</span>];<span class="type">int</span> cnt[<span class="number">100020</span>];multiset&lt;<span class="type">int</span>&gt; s[<span class="number">100020</span>];<span class="type">int</span> n, len, ANS, q, tot;<span class="keyword">struct</span> <span class="title class_">node</span>&#123;    <span class="type">int</span> L, R, id;&#125; Query[<span class="number">1000020</span>];<span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (fa[a.L] != fa[b.L])        <span class="keyword">return</span> a.L &lt; b.L;    <span class="keyword">if</span> (fa[a.L] &amp; <span class="number">1</span>)        <span class="keyword">return</span> a.R &gt; b.R;    <span class="keyword">return</span> a.R &lt; b.R;&#125;<span class="function">ll <span class="title">sq</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1LL</span> * x * x; &#125;<span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> !cnt[x] ? <span class="number">1</span> : !(sum[<span class="number">0</span>][x] % cnt[x]) &amp;&amp; !(sum[<span class="number">1</span>][x] % cnt[x]) &amp;&amp; <span class="built_in">sq</span>(sum[<span class="number">0</span>][x] / cnt[x]) * cnt[x] == sum[<span class="number">1</span>][x]; &#125;<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">bool</span> ff)</span></span><span class="function"></span>&#123;    <span class="type">bool</span> f = <span class="number">0</span>;    <span class="keyword">if</span> (ff &amp; <span class="number">1</span>)    &#123;        <span class="keyword">if</span> (<span class="built_in">same</span>(a[x]))            f = <span class="number">1</span>;        cnt[a[x]]++;        sum[<span class="number">0</span>][a[x]] += x - pre[x];        sum[<span class="number">1</span>][a[x]] += <span class="built_in">sq</span>(x - pre[x]);        <span class="keyword">if</span> (!<span class="built_in">same</span>(a[x]) &amp;&amp; f)            tot--;    &#125;    <span class="keyword">else</span>    &#123;        <span class="keyword">if</span> (<span class="built_in">same</span>(a[x]))            f = <span class="number">1</span>;        cnt[a[x]]++;        sum[<span class="number">0</span>][a[x]] += nxt[x] - x;        sum[<span class="number">1</span>][a[x]] += <span class="built_in">sq</span>(nxt[x] - x);        <span class="keyword">if</span> (!<span class="built_in">same</span>(a[x]) &amp;&amp; f)            tot--;    &#125;&#125;<span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x, <span class="type">bool</span> ff)</span></span><span class="function"></span>&#123;    <span class="type">bool</span> f = <span class="number">0</span>;    <span class="keyword">if</span> (ff &amp; <span class="number">1</span>)    &#123;        <span class="keyword">if</span> (!<span class="built_in">same</span>(a[x]))            f = <span class="number">1</span>;        cnt[a[x]]--;        sum[<span class="number">0</span>][a[x]] -= x - pre[x];        sum[<span class="number">1</span>][a[x]] -= <span class="built_in">sq</span>(x - pre[x]);        <span class="keyword">if</span> (<span class="built_in">same</span>(a[x]) &amp;&amp; f)            tot++;    &#125;    <span class="keyword">else</span>    &#123;        <span class="keyword">if</span> (!<span class="built_in">same</span>(a[x]))            f = <span class="number">1</span>;        cnt[a[x]]--;        sum[<span class="number">0</span>][a[x]] -= nxt[x] - x;        sum[<span class="number">1</span>][a[x]] -= <span class="built_in">sq</span>(nxt[x] - x);        <span class="keyword">if</span> (<span class="built_in">same</span>(a[x]) &amp;&amp; f)            tot++;    &#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(n);    len = <span class="built_in">sqrt</span>(n);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="built_in">read</span>(a[i]);        fa[i] = (i + len - <span class="number">1</span>) / len;        nxt[i] = n + <span class="number">1</span>;        pre[i] = p[a[i]];        nxt[pre[i]] = i;        p[a[i]] = i;    &#125;    <span class="built_in">read</span>(q);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)    &#123;        <span class="type">int</span> L, R;        <span class="built_in">read</span>(L, R);        Query[i] = &#123;L, R, i&#125;;    &#125;    <span class="built_in">sort</span>(Query + <span class="number">1</span>, Query + q + <span class="number">1</span>, cmp);    <span class="type">int</span> L = <span class="number">1</span>, R = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)    &#123;        <span class="keyword">while</span> (L &gt; Query[i].L)        &#123;            L--;            <span class="keyword">if</span> (nxt[L] &gt; R)                ANS++, tot++;            <span class="keyword">else</span>                <span class="built_in">add</span>(L, <span class="number">0</span>);        &#125;        <span class="keyword">while</span> (R &lt; Query[i].R)        &#123;            R++;            <span class="keyword">if</span> (pre[R] &lt; L)                ANS++, tot++;            <span class="keyword">else</span>                <span class="built_in">add</span>(R, <span class="number">1</span>);        &#125;        <span class="keyword">while</span> (L &lt; Query[i].L)        &#123;            <span class="keyword">if</span> (nxt[L] &gt; R)                ANS--, tot--;            <span class="keyword">else</span>                <span class="built_in">del</span>(L, <span class="number">0</span>);            L++;        &#125;        <span class="keyword">while</span> (R &gt; Query[i].R)        &#123;            <span class="keyword">if</span> (pre[R] &lt; L)                ANS--, tot--;            <span class="keyword">else</span>                <span class="built_in">del</span>(R, <span class="number">1</span>);            R--;        &#125;        ans[Query[i].id] = ANS + <span class="number">1</span> - (tot &gt; <span class="number">0</span>);    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[闲话] 20240119 鲜花</title>
      <link href="/archives/20240119_essay/"/>
      <url>/archives/20240119_essay/</url>
      
        <content type="html"><![CDATA[<p>今天是 gmx 生日。我昨晚在书包藏了两块巧克力，下午第四节课下课跑去送了。</p><p>她好像看起来很开心&#x2F;se</p><p>但她估计不知道我是咋知道她生日的，我甚至没有她的联系方式（<del>但我打算期末考完加一个</del>），她也没和我说过她生日。其实是我和几个同学（保护一下他们人身安全就不放洛谷号了）机惨教练把教练 U 盘里好东西偷出来找到了一些学生信息和一些 OI 的东西。</p><p>今天很巧的是，我出教室走到她班级门口，她因为今天生日也不上晚自习，正好在她班级门口碰到了。</p><p>然后我俩一起在学校里走出去的。她数学这次竟然模考 86，感觉很有实力，上次从食堂出来聊天她还说开始补数学了，确实数学分抬上来了。但我的语文大抵是废了。废得很彻底。为数不多的成就是会多背一点诗而已。</p><p>她说语文 86 随便上，我：？</p><p>我就说数学 90 随便上，她：？</p><hr><p>下周一二三期末，我现在模考挂分很严重啊！</p><p>语文老师答应我期末考试上 86 给我棒棒糖吃，为了棒棒糖我怎么也要把笔记全背下来！！1</p><p>（下面的加表示老师批错我申诉后获得的分）</p><hr><p>语文（没写作文）：</p><p>45+1&#x2F;60，选择 -5，古诗默写 -1。这 6 分扣得很逆天啊，完全不该扣的，挂分原因是自己考完之后脑子昏昏的改选择，以及忘了一个字到底是啥先跳了打算昨晚整张再背一下说不定就背出来了，然后忘记改了。</p><hr><p>数学（分两次做导致简单卷给了很多时间难卷我没写完）</p><p>89+2&#x2F;100</p><p>2+3 分是我算完之后答句写错了，很逆天。2 分是一个很逆天的题，全校好像不到 10 个写出了结论，最高得分应该是 @<a href="https://www.luogu.com.cn/user/448938">wangchonghao</a> 只扣了 1 分因为证明完了忘记画图。</p><p>我这题是喜提 -2 的，发现我一眼秒了结论证明不太会，感觉说不清，这也不给个数据算一算证一下的，只能口头乱说做法。然后先开的最后一题（这题是倒数第二题）。然后做完最后一题开始证，没写完，喜提结论分。</p><p>最后一题有 3 分是算完之后答句写错了，有 2 分是最后一问漏解了，卷子发下来又是 5min 不到算完了，每次我都是卷子发下来再没讨论做法的情况下就能很快写出来没做出&#x2F;没写全的题，每次都是这样，鉴定为应该考试途中上个厕所清醒一下脑子。</p><p>诶这个最后一问怎么老师讲的这么简单？我的做法除了构造一组全等三角形之外用到的东西都不是八上讲的。</p><hr><p>英语 92&#x2F;100</p><p>阅读短文，回答问题，不超过 4 个单词，我喜提得分 2&#x2F;5，好像昨天晚自习我不在的时候被老师公开处刑了。</p><p>作文 -1 意料之中，选择我是真的不知道 nothing 和 none 的区别啊呜呜呜，这到底咋区分啊，换个情景我就不知道了，呜呜呜。</p><hr><p>政治 80+5&#x2F;100，但是得分折半计算。</p><p>我不多评价。有 2 分是给 4 个序号匹配相应违法行为，我只写了 3 个序号。</p><hr><p>历史 91+2&#x2F;100，但是得分折半计算。</p><p>毛【】【】的革命理论就是“毛【】【】思想”啊？啊？我扯了一堆没扯到 -4。选择我分不清七届二中全会和七大，考完信誓旦旦说七大是河北西柏坡召开的，肯定不选七大。</p><hr><p>物理 95&#x2F;100</p><p>鉴定为我是弱智。选择 -2，我只看光路不看成像位置。填空 -3，有一空我该错，多次实验没写改变物距，有一空图上原来是光线 OB，我看到的明明就是 OE！！！就是 OE！！！</p><p>还有谁家好人上一题填空拉的和下面表格框框一样长，我没看到这一空。</p><hr><p><del>打完入门赛继续写。</del></p><p>我 27 min AK 了。</p><p>天天因为老师批改错误挂分，这学期已经二三十分了诶，常外任课老师我感觉已经很负责了还有这种问题，期末考试换别的学校老师咋办啊？平时每个老师 100 张左右的卷子都能出现这样的问题，期末考试那么多卷子咋办啊？</p><p>希望我 RP 不会低到出现这种挂分情况。</p><hr><p>妈的，我要开始发力了。体育都他妈最后一节课了，难得碰到一次做完准备活动就活动的，给我们灌鸡汤说的贼几把好听，以前男生先拿乒乓场地要挤成 4 人 2 拍轮流打，怎么女生先拿场地就啥玩意儿都不剩了？没球打你吗的，把你脑袋拧下来打？最后一节课都不给放松是吧。</p><p>（我们男女分开上体育课。）</p><p>还有那个学校傻逼跑操，我搞不懂以前七年级绕学校八九年级绕操场内圈外圈有啥不好的，你他妈非要三个年级挤在操场上，屁大点位置转弯还不让减速。诶不是你他妈知道什么是理想状态什么是现实吗？你要每个人都在那个位置慢一下或者快一下是完全不可能的，还几把的一天到晚跑完两三轮发现队伍拉开距离了，你他妈倒是挺会找男生茬的，有本事他妈让男生跑前面你看最后女生掉不掉队？傻逼东西自己不实验就来压力学生尤其男生是吧？</p><p>还有那一个两个的，你们是他妈多虚啊，平时都说我天天生病身体虚，老子跑操偷过最大的懒是去排练升旗仪式，第二大是系了个鞋带然后自己还加速跑回队伍了。你们一个个什么病一天到晚不跑操？还有那个领导，请假的人要排在班级前面让整个班多绕几米是什么勾八规定，你是觉得每个班凸几个凹几个看上去很美观还是他妈自己长大了来撕伞了？</p><p>还有市教研局，你也不是什么好东西，去年数学出题出了个贼牛逼的无解出来，你还自己放出标答是 $[1, 2)$，什么逆天玩意儿，出卷子不会改数据可以不改，审题人不验卷子可以不验，你他妈是连个初中学历的验题人找不到？我操这怎么他妈不给你禁止出题三年啊？今年生物又他妈来个单选题选择错误的 A. 臭氧无色无味 B. 臭氧对人体无害 是什么几把？你他妈也不说根据材料得到错误选项，这算个什么东西，你要是中考文化科目今年再有错题等着他妈被刨祖坟吧。</p><p>这些只是积压了很久的东西，趁着今天写鲜花赶紧发出来，目的是告诉大家，我们吊州是人才辈出的。</p><hr><p>另外，虽然市教研局估计会继续出错题，但还是 RP++。<del>我会用我的实力，用我的排名，告诉大家，今年有多少学生考试。</del></p>]]></content>
      
      
      <categories>
          
          <category> Essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC336 做题笔记</title>
      <link href="/archives/ABC336/"/>
      <url>/archives/ABC336/</url>
      
        <content type="html"><![CDATA[<h1 id="A-Long-Loong"><a href="#A-Long-Loong" class="headerlink" title="A - Long Loong"></a>A - Long Loong</h1><p>模拟。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> x;    cin &gt;&gt; x;    cout &lt;&lt; <span class="string">&quot;L&quot;</span>;    <span class="keyword">while</span> (x--)        cout &lt;&lt; <span class="string">&quot;o&quot;</span>;    cout &lt;&lt; <span class="string">&quot;ng&quot;</span> &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="B-CTZ"><a href="#B-CTZ" class="headerlink" title="B - CTZ"></a>B - CTZ</h1><p>对自带函数的运用。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> x;    cin &gt;&gt; x;    cout &lt;&lt; __builtin_ctz(x) &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="C-Even-Digits"><a href="#C-Even-Digits" class="headerlink" title="C - Even Digits"></a>C - Even Digits</h1><p>转五进制，重载一下每一位具体数字。主播在 CF1811E Living Sequence 中做过类似 trick。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">using</span> <span class="keyword">namespace</span> std;string c = <span class="string">&quot;02468&quot;</span>;<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ll x, ll m)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (x / m)        <span class="built_in">f</span>(x / m, m);    cout &lt;&lt; c[x % m];&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    ll n;    cin &gt;&gt; n;    <span class="built_in">f</span>(n - <span class="number">1</span>, <span class="number">5</span>);    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="D-Pyramid"><a href="#D-Pyramid" class="headerlink" title="D - Pyramid"></a>D - Pyramid</h1><p>扫两遍看一下自己最大能装到多大。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">max</span>(x, y); &#125;<span class="type">int</span> n;<span class="type">int</span> a[<span class="number">200020</span>];<span class="type">int</span> pre[<span class="number">200020</span>];<span class="type">int</span> suf[<span class="number">200020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        cin &gt;&gt; a[i];    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        pre[i] = <span class="built_in">min</span>(pre[i - <span class="number">1</span>] + <span class="number">1</span>, a[i]);    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)        suf[i] = <span class="built_in">min</span>(suf[i + <span class="number">1</span>] + <span class="number">1</span>, a[i]);    <span class="type">int</span> ans = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">chkmx</span>(ans, <span class="built_in">min</span>(pre[i], suf[i]));    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="E-Digit-Sum-Divisible"><a href="#E-Digit-Sum-Divisible" class="headerlink" title="E - Digit Sum Divisible"></a>E - Digit Sum Divisible</h1><p>原题 P4127 [AHOI2009] 同类分布，数位 DP。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;ll f[<span class="number">20</span>][<span class="number">200</span>][<span class="number">200</span>];ll len;ll a[<span class="number">20</span>];ll n;ll p;<span class="function">ll <span class="title">dp</span><span class="params">(ll pos, ll sum, ll st, <span class="type">int</span> lim)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (pos &gt; len &amp;&amp; sum == <span class="number">0</span>)        <span class="keyword">return</span> <span class="number">0</span>;    <span class="keyword">if</span> (pos &gt; len)        <span class="keyword">return</span> st == <span class="number">0</span> &amp;&amp; sum == p ? <span class="number">1</span> : <span class="number">0</span>;    ll &amp;t = f[pos][sum][st];    <span class="keyword">if</span> (!lim &amp;&amp; ~t)        <span class="keyword">return</span> t;    ll ret = <span class="number">0</span>;    ll res = lim ? a[len - pos + <span class="number">1</span>] : <span class="number">9</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= res; i++)        ret += <span class="built_in">dp</span>(pos + <span class="number">1</span>, sum + i, (<span class="number">10LL</span> * st + i) % p, i == res &amp;&amp; lim);    <span class="keyword">return</span> lim ? ret : t = ret;&#125;<span class="function">ll <span class="title">calc</span><span class="params">(ll x)</span></span><span class="function"></span>&#123;    len = <span class="number">0</span>;    <span class="keyword">while</span> (x)        a[++len] = x % <span class="number">10</span>, x /= <span class="number">10</span>;    ll ret = <span class="number">0</span>;    <span class="keyword">for</span> (p = <span class="number">1</span>; p &lt;= <span class="number">9</span> * len; p++)    &#123;        <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));        ret += <span class="built_in">dp</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);    &#125;    <span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n;    cout &lt;&lt; <span class="built_in">calc</span>(n) &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="F-Rotation-Puzzle"><a href="#F-Rotation-Puzzle" class="headerlink" title="F - Rotation Puzzle"></a>F - Rotation Puzzle</h1><p>发现每一次只能选择 $4$ 个位置，直接搜复杂度 $4^{20}$ 显然不可行。考虑折半搜索，从头开始搜 $4^{10}$ 个从尾开始搜 $4^{10}$ 个然后合并起来。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; mtx;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">min</span>(x, y); &#125;mtx a, b;<span class="type">int</span> n, m;<span class="function"><span class="type">void</span> <span class="title">prt</span><span class="params">(mtx &amp;a)</span></span><span class="function"></span>&#123;    <span class="keyword">for</span> (<span class="keyword">auto</span> i : a)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j : i)            cout &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span>;        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    &#125;    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;&#125;<span class="function"><span class="type">void</span> <span class="title">RSZ</span><span class="params">(mtx &amp;a)</span></span><span class="function"></span>&#123;    a.<span class="built_in">resize</span>(n);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)        a[i].<span class="built_in">resize</span>(m);&#125;<span class="function"><span class="type">bool</span> <span class="title">in</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span> &lt;= x &amp;&amp; x &lt; n &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; m; &#125;<span class="function"><span class="type">void</span> <span class="title">RRT</span><span class="params">(mtx &amp;a, <span class="type">int</span> x, <span class="type">int</span> y)</span></span><span class="function"></span>&#123;    mtx b;    <span class="built_in">RSZ</span>(b);    b = a;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)        &#123;            <span class="keyword">if</span> (x &lt;= i &amp;&amp; i &lt;= n + x - <span class="number">2</span> &amp;&amp; y &lt;= j &amp;&amp; j &lt;= m + y - <span class="number">2</span>)                a[i][j] = b[n + x - <span class="number">2</span> - (i - x)][m + y - <span class="number">2</span> - (j - y)];        &#125;    &#125;&#125;map&lt;mtx, <span class="type">int</span>&gt; frt;map&lt;mtx, <span class="type">int</span>&gt; bck;queue&lt;pair&lt;mtx, <span class="type">int</span>&gt;&gt; q; <span class="comment">// &#123;matrix,step&#125;</span><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="built_in">RSZ</span>(a);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)        &#123;            <span class="type">int</span> x;            cin &gt;&gt; x;            a[i][j] = x;        &#125;    &#125;    q.<span class="built_in">push</span>(&#123;a, <span class="number">0</span>&#125;);    frt[a] = <span class="number">0</span>;    <span class="comment">// RRT(a, 0, 0);</span>    <span class="comment">// prt(a);</span>    <span class="comment">// RRT(a, 1, 1);</span>    <span class="comment">// prt(a);</span>    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())    &#123;        mtx u = q.<span class="built_in">front</span>().first;        <span class="type">int</span> stp = q.<span class="built_in">front</span>().second;        q.<span class="built_in">pop</span>();        <span class="keyword">if</span> (stp == <span class="number">10</span>)            <span class="keyword">continue</span>;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)        &#123;            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)            &#123;                mtx v = u;                <span class="built_in">RRT</span>(v, i, j);                <span class="keyword">if</span> (!frt.<span class="built_in">count</span>(v))                    frt[v] = stp + <span class="number">1</span>, q.<span class="built_in">push</span>(&#123;v, stp + <span class="number">1</span>&#125;);            &#125;        &#125;    &#125;    <span class="built_in">RSZ</span>(b);    <span class="type">int</span> tmp = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)            b[i][j] = ++tmp;    q.<span class="built_in">push</span>(&#123;b, <span class="number">0</span>&#125;);    bck[b] = <span class="number">0</span>;    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())    &#123;        mtx u = q.<span class="built_in">front</span>().first;        <span class="type">int</span> stp = q.<span class="built_in">front</span>().second;        q.<span class="built_in">pop</span>();        <span class="keyword">if</span> (stp == <span class="number">10</span>)            <span class="keyword">continue</span>;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)        &#123;            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)            &#123;                mtx v = u;                <span class="built_in">RRT</span>(v, i, j);                <span class="keyword">if</span> (!bck.<span class="built_in">count</span>(v))                    bck[v] = stp + <span class="number">1</span>, q.<span class="built_in">push</span>(&#123;v, stp + <span class="number">1</span>&#125;);            &#125;        &#125;    &#125;    <span class="type">int</span> ans = <span class="number">21</span>;    <span class="keyword">for</span> (<span class="keyword">auto</span> p : frt)    &#123;        mtx M = p.first;        <span class="keyword">if</span> (bck.<span class="built_in">count</span>(M))            <span class="built_in">chkmn</span>(ans, p.second + bck[M]);    &#125;    cout &lt;&lt; (ans == <span class="number">21</span> ? <span class="number">-1</span> : ans) &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] HITACHI2020D Manga Market</title>
      <link href="/archives/HITACHI2020D/"/>
      <url>/archives/HITACHI2020D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>有 $n$ 个节点，每个节点有 $2$ 个参数 $a_i,b_i$。</p><p>你时刻 $0$ 在节点 $0$，在节点间往返需要消耗 $1$ 的单位时间。</p><p>你在时刻 $t$ 到达第 $i$ 个节点时可以等待 $a_i\times t+b_i$ 后获得 $1$ 的收益。</p><p>$T+0.5$ 时刻所有节点都会失效，<strong>包括你所在的节点。</strong></p><p>求你能得到的最大收益，<strong>每个节点不能多次等待，不要求在 $T+0.5$ 时刻之前返回 $0$ 节点。</strong></p><p>$1\leq n\leq 2\times 10^5,0\leq a_i,b_i,T\leq 10^9$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>考虑 exchange argument。</p><p>设目前拥有的访问顺序是最优的，即全部经过且等待之后总时刻最小。</p><p>对于相邻的 $i+1&#x3D;j$，你是时刻 $t$ 到达的，若先等待 $i$ 优于先等待 $j$，需要满足 $1+a_i(t+1)+b_i+1+a_j(t+1+a_i(t+1)+b_i+1)+b_j\lt 1+a_j(t+1)+b_j+1+a_i(t+1+a_j(t+1)+b_j+1)+b_i$。</p><p>化简得 $\frac{a_j}{b_j+1}\lt \frac{a_i}{b_i+1}$。</p><p>也就是说我们按 $\frac{a_i}{b_i+1}$ 的降序排序得到的访问顺序一定是最优的。</p><p>这里的 $a_i&#x3D;0$ 有点特殊，我们单独先拆出来。</p><p>对于 $a_i&#x3D;0$ 的，设我们还有 $t$ 时间剩余，也就是找到尽可能多的 $b_1,b_2,\dots b_k$ ，满足 $(\sum\limits_{i&#x3D;1}^{k}b_i)-k\leq t$。</p><p>这个显然我们是可以排序之后前缀和处理的。</p><p>那么对于 $a_i\neq 0$，既然我们已经钦定了访问顺序的最优策略，就是决定当前点选或不选。</p><p>那么 $f_{i,j}$ 表示前 $i$ 个节点你选择了 $j$ 个<strong>并且都等待了</strong>的最少时间。</p><p>这个直接类似背包转移即可。第一维可以压掉。</p><p>但是这样的转移有个问题，这是 $\mathcal O(n^2)$ 的无法接受。</p><p>发现 $a_i\neq 0$ 的情况，你用的时间是指数级增长的，也就是你最多选择的节点数不超过 $\log_2 T$ 个。</p><p>那么第二维大小就是 $\mathcal O(\log_2 T)$ 的了，转移复杂度 $\mathcal O(n\log_2 T)$ 可以接受。</p><p>然后直接枚举最后选择多少 $a_i\neq 0$ 的，双指针或二分出你能选多少 $a_i&#x3D;0$ 的即可。</p><p><strong>实现中，如果你需要 dp 数组进行初始化，尽量不要 <code>memset</code>，参数不好会炸 <code>long long</code>。</strong></p><h1 id="丑陋代码"><a href="#丑陋代码" class="headerlink" title="丑陋代码"></a>丑陋代码</h1><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">max</span>(x, y); &#125;<span class="type">const</span> <span class="type">int</span> inf = <span class="number">2e9</span>;<span class="type">int</span> n, m;ll T;vector&lt;<span class="type">int</span>&gt; cst;<span class="keyword">struct</span> <span class="title class_">store</span>&#123;    ll a, b;&#125;;vector&lt;store&gt; v;ll f[<span class="number">200020</span>][<span class="number">35</span>];ll pre[<span class="number">200020</span>];<span class="type">int</span> ans;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n &gt;&gt; T;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="type">int</span> a, b;        cin &gt;&gt; a &gt;&gt; b;        <span class="keyword">if</span> (!a)            cst.<span class="built_in">push_back</span>(b);        <span class="keyword">else</span>            v.<span class="built_in">push_back</span>(&#123;a, b&#125;);    &#125;    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [&amp;](store x, store y)         &#123; <span class="keyword">return</span> <span class="number">1.0</span> * x.a / (x.b + <span class="number">1</span>) &gt; <span class="number">1.0</span> * y.a / (y.b + <span class="number">1</span>); &#125;);    <span class="built_in">sort</span>(cst.<span class="built_in">begin</span>(), cst.<span class="built_in">end</span>());    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">int</span>(cst.<span class="built_in">size</span>()); i++)        pre[i] = pre[i - <span class="number">1</span>] + cst[i - <span class="number">1</span>];    <span class="comment">// for (store i : v)</span>    <span class="comment">//     cout &lt;&lt; i.a &lt;&lt; &quot; &quot; &lt;&lt; i.b &lt;&lt; endl;</span>    m = v.<span class="built_in">size</span>();    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">30</span>; j++)            f[i][j] = inf;    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)    &#123;        f[i][<span class="number">0</span>] = <span class="number">0</span>;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">min</span>(<span class="number">30</span>, i); j++)        &#123;            f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span> + v[i - <span class="number">1</span>].a * (f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>) + v[i - <span class="number">1</span>].b);            <span class="comment">// cout &lt;&lt; f[i][j] &lt;&lt; &quot; &quot;;</span>        &#125;        <span class="comment">// cout &lt;&lt; endl;</span>    &#125;    <span class="type">int</span> pos = cst.<span class="built_in">size</span>();    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">min</span>(<span class="number">30</span>, m); i++)    &#123;        ll t = T - f[m][i];        <span class="keyword">if</span> (t &lt; <span class="number">0</span>)            <span class="keyword">continue</span>;        <span class="keyword">while</span> (pre[pos] + pos &gt; t)            pos--;        <span class="built_in">chkmx</span>(ans, pos + i);        <span class="comment">// cout &lt;&lt; f[m][i] &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; pre[pos] &lt;&lt; &quot; &quot; &lt;&lt; pos &lt;&lt; endl;</span>    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[笔记] 费马小定理 证明</title>
      <link href="/archives/Fermat_s_little_theorem_prove/"/>
      <url>/archives/Fermat_s_little_theorem_prove/</url>
      
        <content type="html"><![CDATA[<p>已知 $p\text{ is prime},\gcd(a,p)&#x3D;1$ 证明 $a^p\equiv a\pmod p$。</p><p>考虑一个引理：若 $p$ 是质数，$p\mid\dbinom{p}{i},\forall i\in[1,p-1],i\in \mathbb Z$。</p><p>$$<br>\because \dbinom{p}{i}&#x3D;\dfrac{p!}{i!(p-i)!}\newline<br>又\because p \text{ is prime}\newline<br>\therefore (p-1)!\mid i!(p-i)!\newline<br>\therefore \dbinom{p}{i}&#x3D;p\cdot\dfrac{(p-1)!}{i!(p-i)!}<br>$$</p><p>引理证毕。</p><p>通过这个引理我们能进一步得到一个结论：</p><p>$$<br>p\mid \sum\limits_{i&#x3D;1}^{i&lt;p} \dbinom{p}{i}\newline<br>$$</p><p>这个小结论等会儿会用。</p><p>回归原命题，容易发现 $a&#x3D;1$ 时结论成立。</p><p>当 $a&#x3D;2$ 时</p><p>$$<br>\begin{aligned}<br>a^p<br>&amp;&#x3D;2^p\newline<br>&amp;&#x3D;(1+1)^p\newline<br>&amp;&#x3D;1+\dbinom{p}{1}+\dbinom{p}{2}+\dots+\dbinom{p}{p-1}+1\newline<br>\end{aligned}<br>$$</p><p>$$<br>\therefore 2^p\equiv 2 \pmod p<br>$$</p><p>假设 $a&#x3D;k$ 时成立。</p><p>当 $a&#x3D;k+1$ 时</p><p>$$<br>\begin{aligned}<br>a^p<br>&amp;&#x3D;(k+1)^p\newline<br>&amp;&#x3D;k^p+\dbinom{p}{1}k^{p-1}+\dbinom{p}{2}k^{p-2}+\dots+\dbinom{p}{p-1}k+1\newline<br>\end{aligned}<br>$$</p><p>$$<br>\therefore a^p\equiv k^p+1 \pmod p\newline<br>又\because k^p\equiv k\pmod p\newline<br>\therefore a^p\equiv k+1\pmod p\newline<br>\therefore a^p\equiv a\pmod p<br>$$</p><p>由此可得在正整数域中命题成立。</p><p>证毕。</p><hr><p>上面这个东西就是费马小定理及使用数学归纳法的证明。</p><p><del>教练布置的作业。</del></p><p>然后费马小定理在 OI 中的常见运用是，$a^{p-2}\equiv a\pmod p\to a^{p-1}\equiv 1\pmod p\to a\times a^{p-2}\equiv 1\pmod p$。</p><p>也就是说对于质数 $p$，只要满足 $\gcd(a,p)&#x3D;1$ 那么 $a^{p-2}$ 即为 $a$ 在模 $p$ 意义下的乘法逆元。这样我们就可以单次 $\log$ 使用快速幂计算逆元。</p><p>在欧拉定理中有 $a^{\varphi(n)}\equiv 1\pmod n$。</p><p>其中 $\varphi(n)$ 是 $\sum\limits_{i&#x3D;1}^{i&lt;n}[\gcd(n,i)&#x3D;1]$，即 $[1,n-1]$ 中与 $n$ 互质的数的个数。具体定义是 $n&#x3D;p_1^{a_1}p_2^{a_2}\cdots p_k^{a_k},\varphi(n)&#x3D;p_1^{a_1-1}p_2^{a_2-1}\cdots p_k^{a_k-1}(p_1-1)(p_2-1)\cdots(p_k-1)$。</p><p>费马小定理就是欧拉定理中一个特殊的例子，当 $p$ 为质数时 $\varphi(p)&#x3D;p-1$。</p>]]></content>
      
      
      <categories>
          
          <category> StudyNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 来点 USACO Gold 组人类智慧</title>
      <link href="/archives/USACO23DEC_G/"/>
      <url>/archives/USACO23DEC_G/</url>
      
        <content type="html"><![CDATA[<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>发现 $u\to v$ 的方案数是可以用 $u\to k\to v$ 算出来的，就类似 Floyd 枚举中心点。</p><p>然后就直接枚举 $gap$，$u\to u+gap$ 枚举中间点进行转移。</p><p>但是发现 $1\to 2\to 3\to 5$ 是会统计两次 $1\to {\color{red}2}\to 3\to 5$ 和 $1\to 2\to {\color{red}3}\to 5$ 的。</p><p>设 $g_{u,v}$ 表示是否存在 $u\to v$ 的直接连接路径即可顺利转移。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n;<span class="type">char</span> mp[<span class="number">1020</span>][<span class="number">1020</span>];<span class="type">int</span> f[<span class="number">1020</span>][<span class="number">1020</span>];<span class="type">int</span> g[<span class="number">1020</span>][<span class="number">1020</span>];<span class="type">int</span> ans;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)            mp[i][j] = <span class="string">&#x27;0&#x27;</span>;        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)            cin &gt;&gt; mp[i][j];    &#125;    <span class="comment">// for (int i = 1; i &lt;= n; i++)</span>    <span class="comment">//     for (int j = 1; j &lt;= n; j++)</span>    <span class="comment">//         cout &lt;&lt; mp[i][j] &lt;&lt; &quot; \n&quot;[j == n];</span>    <span class="keyword">for</span> (<span class="type">int</span> gap = <span class="number">1</span>; gap &lt;= n; gap++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u + gap &lt;= n; u++)        &#123;            <span class="type">int</span> v = u + gap;            <span class="comment">// cout &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; endl;</span>            <span class="keyword">for</span> (<span class="type">int</span> k = u + <span class="number">1</span>; k &lt; v; k++)                (f[u][v] += g[u][k] * f[k][v]) %= <span class="number">2</span>;            <span class="comment">// cout &lt;&lt; f[u][v] &lt;&lt; &quot; &quot; &lt;&lt; mp[u][v] &lt;&lt; endl;</span>            <span class="keyword">if</span> ((f[u][v] &amp; <span class="number">1</span>) != (mp[u][v] ^ <span class="string">&#x27;0&#x27;</span>))                (f[u][v] += <span class="number">1</span>) %= <span class="number">2</span>, g[u][v] = <span class="number">1</span>, ans++;            <span class="comment">// cout &lt;&lt; f[u][v] &lt;&lt; endl</span>            <span class="comment">//      &lt;&lt; endl;</span>        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><h2 id="人类智慧"><a href="#人类智慧" class="headerlink" title="人类智慧"></a>人类智慧</h2><p>记忆化搜索，$g_u$ 表示 $u$ 出发的最长路，$f_u$ 表示 $u$ 出发最长路中字典序最小的收益。</p><p>然后发现字典序不是很好转移，考虑第一步一样取答案最小。喜提过了 19 个然后 WA on #20。</p><p>主播赛时到这里就跳了，然后发现</p><p><a href="https://www.luogu.com.cn/blog/679936/au-t2-xian-xing-zuo-fa-post">https://www.luogu.com.cn/blog/679936/au-t2-xian-xing-zuo-fa-post</a></p><p>我们记录两步就行了。</p><p>WA on #20</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">max</span>(x, y); &#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">min</span>(x, y); &#125;<span class="keyword">typedef</span> pair&lt;ll, ll&gt; pii;<span class="type">int</span> n, m;set&lt;pii&gt; e[<span class="number">200020</span>];ll f[<span class="number">200020</span>];ll g[<span class="number">200020</span>];ll len;<span class="function">pii <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> len)</span></span><span class="function"></span>&#123;    ll &amp;t = f[u];    ll &amp;T = g[u];    <span class="keyword">if</span> (~t)        <span class="keyword">return</span> &#123;t, T&#125;;    <span class="keyword">if</span> (e[u].<span class="built_in">empty</span>())        <span class="keyword">return</span> &#123;t = <span class="number">0</span>, T = <span class="number">0</span>&#125;;    ll val = <span class="number">-1</span>;    <span class="keyword">for</span> (pii i : e[u])    &#123;        <span class="built_in">dfs</span>(i.second, len + <span class="number">1</span>);        ll res = i.first + f[i.second];        <span class="keyword">if</span> (g[i.second] + <span class="number">1</span> &gt; T)            val = i.first, t = res, T = g[i.second] + <span class="number">1</span>;        <span class="keyword">else</span> <span class="keyword">if</span> (g[i.second] + <span class="number">1</span> == T &amp;&amp; val == i.first)            <span class="built_in">chkmn</span>(t, res);    &#125;    <span class="keyword">return</span> &#123;t, T&#125;;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(n, m);    <span class="keyword">while</span> (m--)    &#123;        <span class="type">int</span> x, y, z;        <span class="built_in">read</span>(x, y, z);        e[x].<span class="built_in">insert</span>(&#123;z, y&#125;);    &#125;    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        pii res = <span class="built_in">dfs</span>(i, <span class="number">0</span>);        cout &lt;&lt; res.second &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; res.first &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p>AC</p><pre><code class="highlight cpp">别急，等发数据了再发。顺便去你谷加强一下。</code></pre><h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>拓扑。</p><p>等我先学习一下。</p><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><h2 id="在线"><a href="#在线" class="headerlink" title="在线"></a>在线</h2><p>发现按题目说的 $f(y)$ 就是个凹函数。</p><p>容易发现对于整数 $y$ 当 $a\neq b$ 时不存在非极值点的平台，只有在 $a&#x3D;b$ 时存在平台，但此时函数是一条直线。</p><p>整数三分成立，贺板子。</p><p>然后考虑优化 $f(y)$ 的计算，稍微拆一下就知道记录前缀和后缀和即可，二分当前 $y$ 在 $x$ 序列中的位置即可单次 $f(y)$ 做到 $\log n$ 的效率，总过程是 $\log^2$ 的。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="type">int</span> n, q;<span class="type">int</span> x[<span class="number">200020</span>];ll pre[<span class="number">200020</span>];ll suf[<span class="number">200020</span>];ll a, b;<span class="function">ll <span class="title">f</span><span class="params">(ll k)</span></span><span class="function"></span>&#123;    <span class="type">int</span> pos = <span class="built_in">upper_bound</span>(x + <span class="number">1</span>, x + n + <span class="number">1</span>, k) - x - <span class="number">1</span>;    <span class="comment">//[1,pos] [pos+1,n]</span>    <span class="keyword">return</span> a * (k * pos - pre[pos]) + b * (suf[pos + <span class="number">1</span>] - k * (n - pos));&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        cin &gt;&gt; x[i];    <span class="built_in">sort</span>(x + <span class="number">1</span>, x + n + <span class="number">1</span>);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        pre[i] = pre[i - <span class="number">1</span>] + x[i];    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)        suf[i] = suf[i + <span class="number">1</span>] + x[i];    cin &gt;&gt; q;    <span class="keyword">while</span> (q--)    &#123;        cin &gt;&gt; a &gt;&gt; b;        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1e6</span> + <span class="number">1</span>;        <span class="keyword">while</span> (l &lt; r)        &#123;            <span class="type">int</span> ml = l + (r - l) / <span class="number">3</span>;            <span class="type">int</span> mr = r - (r - l) / <span class="number">3</span>;            <span class="comment">// cout &lt;&lt; ml &lt;&lt; &quot; &quot; &lt;&lt; mr &lt;&lt; &quot; &quot; &lt;&lt; f(ml) &lt;&lt; &quot; &quot; &lt;&lt; f(mr) &lt;&lt; endl;</span>            <span class="keyword">if</span> (<span class="built_in">f</span>(ml) &gt; <span class="built_in">f</span>(mr))                l = ml + <span class="number">1</span>;            <span class="keyword">else</span>                r = mr - <span class="number">1</span>;        &#125;        cout &lt;&lt; <span class="built_in">min</span>(<span class="built_in">f</span>(l), <span class="built_in">f</span>(r)) &lt;&lt; endl;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h2 id="离线"><a href="#离线" class="headerlink" title="离线"></a>离线</h2><p>考虑把询问离线下来排个序就行，单 $\log$ 就做完了。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] P3628 [APIO2010] 特别行动队</title>
      <link href="/archives/P3628/"/>
      <url>/archives/P3628/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3628">特别行动队</a></p><p>易得 $\mathcal O(n^2)$ 状态转移方程 $f_i\gets \max\limits_{j&#x3D;0}^{j&lt;i}{f_j+a(s_i-s_j)^2+b(s_i-s_j)+c}$，特殊的，约定 $f_0&#x3D;0$。</p><p>考虑化简式子，</p><p>$$<br>\begin{aligned}<br>f_j+a(s_i-s_j)^2+b(s_i-s_j)+c<br>&amp;&#x3D; f_j+a(s_i^2-2\cdot s_i\cdot s_j+s_j^2)+b\cdot s_i-b\cdot s_j+c \<br>&amp;&#x3D; f_j+a\cdot s_i^2-2a\cdot s_i\cdot s_j+a\cdot s_j^2+b\cdot s_i-b\cdot s_j+c<br>\end{aligned}<br>$$</p><p>设函数 $F(i)$ 由上式只含有 $i$ 的项组成，$G(j)$ 由上式只含有 $j$ 的项组成。</p><p>那么</p><p>$$<br>\begin{aligned}<br>F(i)<br>&amp;&#x3D; a\cdot s_i^2+b\cdot s_i\<br>G(i)<br>&amp;&#x3D; f_j+a\cdot s_j^2-b\cdot s_j<br>\end{aligned}<br>$$</p><p>则上式即为 $F(i)+G(j)+c$，那么转移方程即为 $f_i\gets \max\limits_{j&#x3D;0}^{j&lt;i}{F(i)+G(j)-2a\cdot s_i\cdot s_j+c}$。</p><p>发现 $F(i)+c$ 是共有的，那么便是 $f_i\gets \max\limits_{j&#x3D;0}^{j&lt;i}{G(j)-2a\cdot s_i\cdot s_j}+F(i)+c$。</p><p>约定 $j_1&lt;j_2$，那么当 $j_1$ 转移优于 $j_2$ 即 $G(j_1)+2a\cdot s_i\cdot s_{j_1}&gt;G(j_2)+2a\cdot s_i\cdot s_{j_2}$ 时，则有$(f_{j_1}+a\cdot s_{j_1}^2-b\cdot s_{j_1}-2a\cdot s_i\cdot s_{j_1})-(f_{j_2}+a\cdot s_{j_2}^2-b\cdot s_{j_2}-2a\cdot s_i\cdot s_{j_2})&gt;0$。</p><p>移项得 $s_i&gt;\dfrac{(f_{j_1}+a\cdot s_{j_1}^2-b\cdot s_{j_1})-(f_{j_2}+a\cdot s_{j_2}^2-b\cdot s_{j_2})}{2a(s_{j_1}-s_{j_2})}$。</p><p>题目说了 $a&lt;0,x_i&gt;0$，也就是 $s_{j_1}-s_{j_2}&lt;0$，所以不用变号。</p><p>那么 $j_1$ 到 $j_2$ 的连线我们是可以看做是斜率 $k&#x3D;\dfrac{(f_{j_1}+a\cdot s_{j_1}^2-b\cdot s_{j_1})-(f_{j_2}+a\cdot s_{j_2}^2-b\cdot s_{j_2})}{2a(s_{j_1}-s_{j_2})}$ 的直线。</p><p>然后使用单调队列维护凸壳就可以了。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="type">int</span> n;ll a, b, c;ll s[<span class="number">1000020</span>];ll f[<span class="number">1000020</span>];<span class="type">int</span> q[<span class="number">1000020</span>];ll hd, tl;<span class="function">ll <span class="title">FF</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> f[x] + a * (s[x] * s[x]) - b * s[x]; &#125;<span class="function">ld <span class="title">slope</span><span class="params">(<span class="type">int</span> j1, <span class="type">int</span> j2)</span> </span>&#123; <span class="keyword">return</span> (<span class="number">1.0</span> * <span class="built_in">FF</span>(j1) - <span class="number">1.0</span> * <span class="built_in">FF</span>(j2)) / (<span class="number">2.0</span> * a * (s[j1] - s[j2])); &#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(n, a, b, c);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">read</span>(s[i]), s[i] += s[i - <span class="number">1</span>];    q[hd = tl = <span class="number">1</span>] = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">while</span> (hd &lt; tl &amp;&amp; s[i] &gt; <span class="built_in">slope</span>(q[hd], q[hd + <span class="number">1</span>]))            hd++;        <span class="type">int</span> j = q[hd];        f[i] = f[j] + a * (s[i] - s[j]) * (s[i] - s[j]) + b * (s[i] - s[j]) + c;        <span class="keyword">while</span> (hd &lt; tl &amp;&amp; <span class="built_in">slope</span>(q[tl - <span class="number">1</span>], q[tl]) &gt; <span class="built_in">slope</span>(q[tl], i))            tl--;        q[++tl] = i;    &#125;    cout &lt;&lt; f[n] &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[游记] THUPC 2024 游记</title>
      <link href="/archives/THUPC2024/"/>
      <url>/archives/THUPC2024/</url>
      
        <content type="html"><![CDATA[<h1 id="Day-22"><a href="#Day-22" class="headerlink" title="Day -22"></a>Day -22</h1><p>找的队友跑路了，在 LA 重找。</p><p>找到了 @<a href="https://www.luogu.com.cn/user/661641">Cx114514</a> 和 @<a href="https://www.luogu.com.cn/user/562119">xzy090626</a>。</p><p>由于分别是来自【常州】（我）【无锡】（Cx114514）【徐州】（xzy090626），所以队名是【黑无常，白无常，徐无常】。</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h1><p>约好了要周六上午 vp 一场 gym 里的比赛试试。睡不了懒觉了呜呜呜。</p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>上午 vp 了 CERC 2023，我开场把 E 和 B 两个 shaber 题秒了。</p><p>E 是个简单模拟，处理字符串。B 是细节题，指关注题面不起眼细节。凸多边形所以直接连 $i\to \frac n 2+i$ 就是最优解。</p><p>然后开 D，应该是要二分并且预处理所有答案，但是不会。每次看到这种线段覆盖就很烦。</p><p>开 C，这个题一眼就有一种 dp 的美感，但是 $n\leq 500$，设多维状态和高复杂度转移感觉不太可行，想不出来。</p><p><del>开 Coach Mode 看了一眼是网络流，那没事了，我不配。</del></p><p>然后开 I，$16$ 的限制肯定是 $\log n$ 的查询次数带点奇怪的东西，但是只会查全 $1$ 得到叶子结点。然后不会了。</p><p>摆了摆了，明天 THUPC 继续加油。</p><p>下午开了 USACO Gold 组。不会 T1，看了半小时，中途有一点正解思路出来但是我读入形如的类似邻接矩阵的东西</p><pre><code class="highlight">111010</code></pre><p>使用了 int 读入。然后第一步就挂了，好似。</p><p>然后大概是摆了 1.5h，剩 2h 的时候回去继续开，因为大家公认 Gold 都是 sb 题。</p><p>跳了 T1 重读 T2，发现 T2 也是弱智题，交了一发，怎么挂了这么多点？？？</p><p>哦没开 long long，重交只 WA 了 #20，这是怎么回事呢？</p><p>切完 T1 T3 出去吃了个饭想了一下，我字典序最小盲目取答案最小只在部分情况下是有保障的。<del>吃完饭越改错的越多就不改了。</del></p><p>T3 一眼小学奥数，然后发现这不就是求那个什么的最小值？？？直接使用那个什么就行了，然后中途是可以通过那个什么记录一下就可以单次 $\log$，加在一起单次询问 $\log^2$ 做完了。</p><p>有些东西 USACO 完赛再写吧。</p><p>晚上 ABC，不会 F。半夜 CF，不会 D。</p><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>上午睡到九点多起的，起床之后吃完早饭群里就发公告了。</p><p>是 thupc_275。</p><p>然后吃完早饭就吃中午饭了，中间就半小时，好抽象啊。</p><p>顺便挂个队友的游记 <a href="https://www.luogu.com.cn/blog/JustANoob/thupc2024-chu-sai-you-ji">https://www.luogu.com.cn/blog/JustANoob/thupc2024-chu-sai-you-ji</a>。</p><p>开 M 发现好抽象，一开始以为题目描述的答案是 Genshin。然后没看到 19 个一样思考了好久，甚至观察下来是 AI 会使用形如 seven 的全拼，human 会直接写 7。</p><p>然后随机开题，<del>发现怎么都是不可做题</del>，中途 xzy 过了 M，我后来写了个 C，摆了一会儿。</p><p>根据样例直接猜 K 是看 o 的个数决定答案，但是这为啥范围只有 $5\times 5$ 啊？</p><p>但是 xzy 也说是看 o 个数，我们一致认为是一个必输两个必胜三个必输。</p><p>然后四个交了一个必胜交了一个必输的结论，都 WA 了，说明要分讨。</p><p>后来发现是判断 $1\times 4$ 和 $2\times 2$ 的矩形，但我 $2\times 2$ 的矩形判断方式是 $r_0&#x3D;r_1\land r_2&#x3D;r_3$，没有判断 $c_0&#x3D;c_2$，好似。</p><p>之后就没有贡献了，，，</p><p>xzy 和 mdw 拍了好久，过完 E 发现是过四题的倒数第五，但这时候应该是封榜了。</p><p>赛后就不是倒数第五了，有更晚过题的（）</p>]]></content>
      
      
      <categories>
          
          <category> TravelNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC329F Colored Ball</title>
      <link href="/archives/ABC329F/"/>
      <url>/archives/ABC329F/</url>
      
        <content type="html"><![CDATA[<h1 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h1><p>来点不同的大炮打蚊子的非 STL 的做法。</p><h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>你有 $n$ 个盒子，每个盒子一开始装了一个颜色为 $c_i$ 的球。</p><p>有 $q$ 次询问（操作），每次询问给出一对 $(a,b)$，要把盒子 $a$ 的<strong>所有球</strong>转到盒子 $b$ 里，问此时 $b$ 里有多少<strong>颜色不同</strong>的球。</p><p>$1\leq n,q\leq 2\times 10^5,1\leq a,b,c_i\leq n$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>考虑使用根号分治。</p><p>显然的阈值为 $B&#x3D;\sqrt n\approx 450$。</p><p>对于目前球个数 $\geq B$ 的盒子，我们记录一个桶 $bkt_{i,j}$ 表示<strong>序号（不是编号）为 $i$</strong> 的盒子是否装了 $j$。</p><p>因为这样的盒子数只有 $\leq B$ 个，所以我们需要记录一个序号，设编号为 $i$ 的盒子的序号为 $id_i$。</p><p>然后对于装球个数 $\lt B$ 的盒子，我们记录 $arr_{i,j}$ 表示<strong>编号为 $i$</strong> 的盒子的第 $j$ 个装的是什么。</p><p>大和大在一起，我们可以直接 $O(n)$ 转移。可以证明这样子转移的次数不会超过 $B$ 次。</p><p>小并到大的，直接扫一遍小的往大的里塞。</p><p>大并到小的，和上面同理。但我们无需新开一个 $id$，直接 $id_b\gets id_a$ 继承一下就可以。</p><p>小的和小的在一起，我们需要讨论一下。如果新出来的集合大小是 $\geq B$ 的，我们需要新开一个 $id$。否则直接合并。</p><p>代码和上面一样的。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://atcoder.jp/contests/abc329/submissions/47747560">AT submission 47747560</a></p><p>代码里前半段注释是本题正常的 STL 做法，感兴趣的也可以学习一下。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[游记] NOIP 2023 游记</title>
      <link href="/archives/NOIP2023/"/>
      <url>/archives/NOIP2023/</url>
      
        <content type="html"><![CDATA[<h1 id="Day-7"><a href="#Day-7" class="headerlink" title="Day -7"></a>Day -7</h1><p>JS-0187</p><p>不敢相信自己省排原来这么前。本来以为 200 开外就算好的了。</p><p>晚上打了把 ABC。D 没仔细算直接暴力结果复杂度假的 TLE 一发。然后火速 E 过掉 perf 1 Dan 了。</p><p>开 F。发现 F 就是个沙比并查集啊，一个集合内都是可以构造的，不同集合合并的时候启发式一下就行，至多合并 $n\log n$ 次。觉得很对。但是路径压缩写错了。</p><p>结果吃了 6 发，20:50 能过的拖到了 21:20，还掉分了，豁达。</p><p>豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达</p><h1 id="Day-6"><a href="#Day-6" class="headerlink" title="Day -6"></a>Day -6</h1><p>发生了啥事啊，我不知道啊。</p><h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day -5"></a>Day -5</h1><p>生了一周病，请了一周假。第一天上学。</p><h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day -4"></a>Day -4</h1><p>要考试了&#x2F;ng</p><h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day -3"></a>Day -3</h1><p>期中考试。</p><p>语文选择题有一题很有争议，D 苏轼被贬家人很愉快？？？答案还不是选这个错误？？？</p><p>物理还行，8A 都简单，而且是期中，但是横波纵波算反了&#x2F;ng</p><p>政治提前 5min 写完了。</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h1><p>上午数学。好好好选择第八题有错，算了半天，浪费我时间打乱我节奏是吧。差点没写完&#x2F;fn&#x2F;fn&#x2F;fn</p><p>下午英语，六选四同学们在我停课期间做过，班级同学人均 AK，我错了一个，很难过。</p><p>历史感觉最正常了，但是史料类型七上第一节课讲的实在记不得了，感觉史料要丢几分。选择题出的很好。有一题书上怎么我没找到，我那节课也没上，这下寄了。</p><p>更搞笑的是怎么考完有人给我送整活准考证的？</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/svmlw58x.png"></p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>大家都去秋游了，我去不了，好难过。</p><p>如果秋游和今年秋游一样在 nj 的话我就可以去玩一天然后正好打车去酒店，<del>还剩一趟车票钱。</del></p><p>原来我起床的时候同学们都上车了啊，就我还在被窝里看平板。</p><p>早上打打游戏 duel 几道 800 1000 的简单题，duel 的时候想起来没有用 CCHv2，试图给 NOI Linux 2.0 装 CCHv2。</p><p>然后我配置了一天。</p><p>死因是 nwjs v0.9.0 按字典序看是最大最新的，但其实这是很古老的版本，最新的是 v0.82.0！</p><p>哈哈，好似。</p><p>下午两三点走的，常州北站，G146。<del>我刚和 @<a href="https://www.luogu.com.cn/user/320423">ACaCaca_</a> 说坐火车杀去 bj 就发现我坐的车终点站确实是北京。</del></p><p>上车了，旁边坐的是个漂亮小姐姐。</p><p>下车了，在车站坐出租去宜必思。在北门堵车了，好像出车祸了。</p><p>酒店房间号 8220，宜必思好绕啊，绕了一圈发现就在房间电梯口。</p><p>把东西放了一下就去面 @<a href="https://www.luogu.com.cn/user/580036">Phantom2009</a> 了。好帅诶。</p><p>一起出去跑了一大圈找东西吃，上了一个小吃街，找了一家火锅+米线的神奇组合吃了一顿。顺便买了点奶茶。</p><p>吃饭的时候一直在聊 cz 和 sz 的 OI。还聊了 nj 的大神们。</p><blockquote><p>我：感觉不如 nj 成为 ah 省会然后不占 js 别的地方名额。</p><p>妈：你当心点，这里都是 nj 人。</p></blockquote><p>吃完了就出去买了点早饭，顺便去旁边超市买点面包和饼干明天带着吃。</p><p>回酒店发现酒店提供付费早餐，这很难评。</p><p>回了酒店 @<a href="https://www.luogu.com.cn/user/419487">irris</a> 也到了，去 8263 找了一趟 irris 然后尬聊几分钟转到 Phantom2009 的房间继续尬聊。</p><p>聊到九点左右我就和 irris 一起润了。</p><p>线上三个魔怔哥，线下聊一个多小时天移动距离不超过一米的。</p><p>现实里唯唯诺诺，网络上重拳出击！</p><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>六点半起的。</p><p>酒店里吃了点早饭就润去南航了，七点就到了。</p><p>门口保安让我刷身份证，然后顺着指示牌走。我看指示牌指了一条小路，跑去转了一圈，没人。又转一圈，还是没人。教练说 7：30 到，我以为 8:00 开考，我 7:15 还没看见大队伍很慌啊。然后过了一会儿发现是工作人员没来，看了眼准考证 8:30 开考，乐。</p><p>面基天波老师，天波老师好色&#x2F;se</p><p>考场机子打不开 README，生气。考场晚发了 5min 密码，生气。</p><p>T1 一眼过，现在 CCF 流行签到题放送分题是吧。</p><p>T2 一眼 40 是很好写的，考场上试图冲了 60 和 80 的分，$abs(ans-output)\leq 1$，就很乐。</p><p>然后先开的 T4，做了一下 性质 B 和 前两个点，在想 性质 C 的 dp，就没继续写第三个点往后的非特殊性质数据，现在发现输麻了。</p><p>T3 看了好久读懂了，好奇怪，写了 10 润了。</p><p>所以分数是 $100+[40,60]+10+16$。</p><p>考完发现同学人均 200+，天波老师也是 200，自闭了。</p><p>EasonTao 好像寄了，一直都不高兴。</p><p>中午随便吃了点。</p><p>测了一下云斗 T4 还挂了 8 分，因为 性质 B 如果出现 $[1,2],[3,4]$ 的区间且 $k&#x3D;3$ 很多人都是会一起选择两个区间的。</p><p>唉。</p>]]></content>
      
      
      <categories>
          
          <category> TravelNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] MSOLUTIONS2020F Air Safety</title>
      <link href="/archives/MSOLUTIONS2020F/"/>
      <url>/archives/MSOLUTIONS2020F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>你现在拥有 $n$ 架飞机，每架飞机有一个出发点 $(x_i,y_i)$，每架飞机每秒向指定方向飞 $0.1$ 个单位，问什么时候会发生第一次撞击（撞击指两架飞机坐标完全相同），不会发生输出 <code>SAFE</code>。</p><p>方向：</p><ul><li>$\tt U$ 向上，即向 $y$ 轴正方向运动。</li><li>$\tt R$ 向右，即向 $x$ 轴正方向运动。</li><li>$\tt D$ 向下，即向 $y$ 轴负方向运动。</li><li>$\tt L$ 向左，即向 $x$ 轴负方向运动。</li></ul><p>$1\leq n\leq 2\times 10^5,0\leq x_i,y_i\leq 2\times 10^5$。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>空心黄，五分钟胡完正解实现了一个多小时，终究还是太菜了。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>什么初二一次函数入门题。</p><p>首先，飞机相遇有两种大情况，共线面对面或者垂直。</p><p>面对面还贡献很好处理，我们把每个方向的飞机按 $x$ 储存在 $4\times 2\cdot10^5$ 个 vector 里，枚举 $x$ 找一下即可。</p><p>垂直就要分 $4$ 个小情况了，这里介绍 $2$ 个情况，剩下两个是一模一样只是换个方向。</p><p><strong>但是不要吝啬草稿纸，笔者就是因为发现了 $2$ 种情况非常高兴，剩下 $2$ 种分类错了调试了一个小时。</strong></p><p>我们现在的问题是，如何知道了一个点，找到别的和它垂直的点？</p><p>一个小类情况是 UL 和 RD 两种相遇，以 UL 为例，应该长这样。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/kx0b1dh9.png"></p><p>不难发现，我们知道了一个 $(x,y)$，能很容易发现所有的 $(x+z,y+z)$ 能和它垂直。再分析一下，$y-x&#x3D;(y+z)-(x+z)$，也就是他们的横纵坐标差 $z$ 是相同的。那么我们按 $z$ 开若干 vector 记录即可。实现要注意方向和负数下标。</p><p>另一小类是 RU 和 DL。这里以 DL 为例，应该长这样。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/raxp9zwx.png"></p><p>同样不难发现，我们知道了一个 $(x,y)$，能很容易发现所有的 $(x+z,y-z)$ 能和它垂直。再分析一下，$x+y&#x3D;(x+z)+(y-z)$，也就是他们的横纵坐标之和是相同的。那么我们按横纵坐标之和开若干 vector 记录即可。实现要注意方向。</p><p>我们找点可以双指针跑来优化。因为需要排序，所以时间复杂度 $\mathcal O(n\log n)$，空间复杂度 $\mathcal O(n)$。</p><p>虽然看上去思维难度不高，但写得拉一点还是很恶心的。</p><h1 id="丑陋代码"><a href="#丑陋代码" class="headerlink" title="丑陋代码"></a>丑陋代码</h1><p><a href="https://atcoder.jp/contests/m-solutions2020/submissions/46484503">AT submission 46484503</a></p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1891F A Growing Tree</title>
      <link href="/archives/CF1891F/"/>
      <url>/archives/CF1891F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以此纪念 1:59:14 过的 Div.2 F。</p><h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>有一棵以 $1$ 为根的有根树，一开始只有节点 $1$。</p><p>有 $q(1\leq q\leq 5\times 10^5)$ 个操作：</p><p><code>1 u</code> 表示添加一条 $u\to sz+1$ 的边，其中 $sz$ 为目前树的大小。</p><p><code>2 u w</code> 表示对于以 $u$ 为根的子树，对于所有节点添加 $w(-10^9\leq w\leq 10^9)$ 的权重。</p><p>$q$ 次操作后，输出当前树上每个节点的权重。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>题目不强制在线，我们考虑先离线操作。</p><p>离线之后先按操作建出最终状态的树。此时权重都为 $w$。</p><p>然后套路性的把这棵树按 Euler Tour 压成一段序列。压好之后同一子树内的节点肯定是连续出现的。</p><p>此时 2 操作维护区间加法。操作 1 维护区间清零，因为如果这个点没被建出不会存在以它为根的修改操作，也就是说区间内的数都是一样的，相当于区间加法了。</p><p>所以维护区间加法和单点查询操作即可。可以使用 BIT 或 SGT。代码使用的是 BIT。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://codeforces.com/contest/1891/submission/230573340">CF submission 230573340</a></p><p><strong>读入量巨大，建议使用快读！</strong></p><p>一些东西的用处：</p><p><code>ll cur_tree_sz=1;</code> 当前树大小。</p><p><code>vector&lt;pii&gt; a[2000020];</code> 建树。</p><p><code>ll in[2000020];ll out[2000020];</code> Euler Tour 中的左右端点，即最早最晚的出现次数。</p><p><code>ll times;</code> Euler Tour 的时间（长度）。</p><p><code>ll c[4000020];</code> BIT 数组。<code>change</code> 进行单点修改，<code>query</code> 进行单点查询。区间修改只需要用单点修改差分即可。</p><p>赛时着急写得有点拉，上述没提到的部分东西其实没用。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> T <span class="title">read</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="keyword">register</span> T x = <span class="number">0</span>;    <span class="keyword">register</span> <span class="type">int</span> f = <span class="number">1</span>;    <span class="keyword">register</span> <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);    <span class="keyword">return</span> x * f;&#125;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">typedef</span> pair&lt;ll, ll&gt; pii;<span class="type">int</span> Q;ll cur_tree_sz = <span class="number">1</span>;<span class="keyword">struct</span> <span class="title class_">Query</span>&#123;    ll op, x, y, t;&#125; q[<span class="number">2000020</span>];vector&lt;pii&gt; a[<span class="number">2000020</span>];ll dep[<span class="number">2000020</span>];ll in[<span class="number">2000020</span>];ll out[<span class="number">2000020</span>];ll id[<span class="number">2000020</span>];ll times;<span class="comment">// 树按dfs拍成序列</span><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> d)</span></span><span class="function"></span>&#123;    dep[u] = d;    in[u] = ++times;    id[++times] = u;    <span class="keyword">for</span> (pii p : a[u])    &#123;        ll v = p.first, j = p.second;        <span class="keyword">if</span> (v == fa)            <span class="keyword">continue</span>;        <span class="built_in">dfs</span>(v, u, d + <span class="number">1</span>);    &#125;    out[u] = ++times;&#125;ll c[<span class="number">4000020</span>];<span class="type">const</span> <span class="type">int</span> N = <span class="number">4000000</span>;<span class="function">ll <span class="title">lowbit</span><span class="params">(ll x)</span></span><span class="function"></span>&#123;    <span class="keyword">return</span> x &amp; -x;&#125;<span class="function">ll <span class="title">query</span><span class="params">(ll x)</span></span><span class="function"></span>&#123;    ll ret = <span class="number">0</span>;    <span class="keyword">while</span> (x)    &#123;        ret += c[x];        x -= <span class="built_in">lowbit</span>(x);    &#125;    <span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(ll x, ll y)</span></span><span class="function"></span>&#123;    <span class="keyword">while</span> (x &lt;= N)    &#123;        c[x] += y;        x += <span class="built_in">lowbit</span>(x);    &#125;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cur_tree_sz + <span class="number">10</span>; i++)        dep[i] = id[i] = in[i] = out[i] = <span class="number">0</span>, a[i].<span class="built_in">clear</span>();    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= times + <span class="number">10</span>; i++)        c[i] = <span class="number">0</span>;    cur_tree_sz = <span class="number">1</span>;    times = <span class="number">0</span>;    Q = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)    &#123;        q[i].op = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();        q[i].x = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();        <span class="keyword">if</span> (q[i].op &amp; <span class="number">1</span>)        &#123;            a[q[i].x].<span class="built_in">push_back</span>(&#123;++cur_tree_sz, ++times&#125;);        &#125;        <span class="keyword">else</span>        &#123;            q[i].y = <span class="built_in">read</span>&lt;ll&gt;();        &#125;        q[i].t = i;    &#125;    times = <span class="number">0</span>;    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);    cur_tree_sz = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)    &#123;        <span class="keyword">if</span> (q[i].op &amp; <span class="number">1</span>)        &#123;            cur_tree_sz++;            ll res = <span class="built_in">query</span>(in[cur_tree_sz]);            <span class="built_in">change</span>(in[cur_tree_sz], -res);            <span class="built_in">change</span>(out[cur_tree_sz], res);        &#125;        <span class="keyword">else</span>        &#123;            <span class="built_in">change</span>(in[q[i].x], q[i].y);            <span class="built_in">change</span>(out[q[i].x], -q[i].y);        &#125;    &#125;    <span class="comment">// for (int i = 1; i &lt;= cur_tree_sz; i++)</span>    <span class="comment">//     cout &lt;&lt; id[i] &lt;&lt; &quot; &quot;;</span>    <span class="comment">// cout &lt;&lt; endl;</span>    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cur_tree_sz; i++)        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, <span class="built_in">query</span>(in[i]));    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> t;    cin &gt;&gt; t;    <span class="keyword">while</span> (t--)        <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CSP-J 2023</title>
      <link href="/archives/CSPJ2023/"/>
      <url>/archives/CSPJ2023/</url>
      
        <content type="html"><![CDATA[<h1 id="A-小苹果-apple"><a href="#A-小苹果-apple" class="headerlink" title="A 小苹果 apple"></a>A 小苹果 apple</h1><p>简单题。</p><p>先做询问 2 好像简单，我考场就是这么干的。</p><p>询问 2 就是问你删几次才能使剩下的数个数 $\bmod 3&#x3D;1$。</p><p>你会发现每次是删掉 $\left\lceil\dfrac{1}{3} n\right\rceil$ 个数，$n$ 每次改变。</p><p>然后发现这个复杂度正确，直接莽。</p><p>询问 1 同理，看删几轮删完即可。</p><p><del>代码注释夹带了点考场私货。</del></p><pre><code class="highlight cpp"><span class="comment">/*</span><span class="comment">这段就当考场游记吧</span><span class="comment">8点20把对拍程序和自定义编译命令都调好了，写了个A+B对拍，wa on test 209</span><span class="comment">快读，不打了，听天由命</span><span class="comment"></span><span class="comment">十点半，大样例全过。</span><span class="comment">T4 这么水？我应该没写错吧。欸T1很简单吗，T4一眼秒了T1我一眼不会啊/jk</span><span class="comment">10:45检查完毕开始睡觉</span><span class="comment">11:00发现咖啡效果来了睡不着，那就摆</span><span class="comment">*/</span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;ll n;ll m;ll ans1, ans2 = <span class="number">1</span>;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">freopen</span>(<span class="string">&quot;apple.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);    <span class="built_in">freopen</span>(<span class="string">&quot;apple.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);    cin &gt;&gt; n;    m = n;    <span class="keyword">while</span> (m % <span class="number">3</span> != <span class="number">1</span>)    &#123;        ans2++;        m -= (m + <span class="number">2</span>) / <span class="number">3</span>;    &#125;    <span class="keyword">while</span> (n)    &#123;        ans1++;        n -= (n + <span class="number">2</span>) / <span class="number">3</span>;    &#125;    cout &lt;&lt; ans1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans2 &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="B-公路-road"><a href="#B-公路-road" class="headerlink" title="B 公路 road"></a>B 公路 road</h1><p>简单题。</p><p>考虑贪心。因为油箱无限大，所以你可以有一个虚拟的类似返回加油的过程。</p><p>什么意思呢，就是你现在加油比之前贵就不加了，改成之前的价格加。</p><p>所以就很简单了。</p><p>这个前缀和可能不用，我是怕出现加油有一些剩的可以多跑一点的情况。但也没啥事。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;ll n, d;ll dis[<span class="number">100020</span>];ll a[<span class="number">100020</span>];ll val;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">freopen</span>(<span class="string">&quot;road.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);    <span class="built_in">freopen</span>(<span class="string">&quot;road.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);    cin &gt;&gt; n &gt;&gt; d;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)        cin &gt;&gt; dis[i], dis[i] += dis[i - <span class="number">1</span>];    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        cin &gt;&gt; a[i];        <span class="keyword">if</span> (i &gt; <span class="number">1</span>)            a[i] = <span class="built_in">min</span>(a[i], a[i - <span class="number">1</span>]);    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        dis[i] = (dis[i] + d - <span class="number">1</span>) / d;    <span class="comment">// for (int i = 2; i &lt;= n; i++)</span>    <span class="comment">//     cout &lt;&lt; dis[i] &lt;&lt; &quot; &quot;;</span>    <span class="comment">// cout &lt;&lt; endl;</span>    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)        val += a[i - <span class="number">1</span>] * (dis[i] - dis[i - <span class="number">1</span>]);    cout &lt;&lt; val &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="C-一元二次方程-uqe"><a href="#C-一元二次方程-uqe" class="headerlink" title="C 一元二次方程 uqe"></a>C 一元二次方程 uqe</h1><p>模拟题。</p><p>难点在于分数和平方根的化简。</p><p>做这类模拟题可以分步写，写完一类直接测相对应的数据，效果是很好的。</p><p>我为了防止 long long 使用平方根有奇怪错误还手写了一个，但复杂度是正确的。</p><p><del>这题不会有人超时吧？</del></p><p>先记一个 $dlt&#x3D;b^2-4ac$，直接判断是否 $\lt 0$。</p><p>然后 $sq&#x3D;\left\lfloor\sqrt dlt\right\rfloor$。如果 $sq^2&#x3D;dlt$ 即 $dlt$ 为完全平方数那么就存在有理数解。有理数解还要根据 $2a$ 的正负性分讨一下。</p><p>如果不是完全平方数即存在两个无理数解，先写成 $\frac{p_1}{q_1}+\frac{p_2}{q_2}\sqrt dlt$ 的形式，然后化简。</p><p>平方根化简直接找有没有完全平方因子，有的话提给 $p_2$ 即可。</p><p>码量不算太大。但这题是考场上耗时最久的。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;ll m;ll a, b, c;ll dlt;ll sq;ll p, q;ll p1, q1, p2, q2;<span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(ll &amp;p, ll &amp;q)</span></span><span class="function"></span>&#123;    ll g = __gcd(p, q);    p /= g;    q /= g;&#125;<span class="function"><span class="type">void</span> <span class="title">fprt</span><span class="params">(ll &amp;p, ll &amp;q)</span></span><span class="function"></span>&#123;    <span class="comment">// cout &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; q &lt;&lt; endl;</span>    <span class="keyword">if</span> (p * q &lt; <span class="number">0</span>)        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);    <span class="keyword">if</span> (p &lt; <span class="number">0</span>)        p = -p;    <span class="keyword">if</span> (q &lt; <span class="number">0</span>)        q = -q;    <span class="built_in">F</span>(p, q);&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    sq = <span class="number">0</span>;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;    dlt = b * b - <span class="number">4</span> * a * c;    <span class="keyword">if</span> (dlt &lt; <span class="number">0</span>)        <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>), <span class="built_in">void</span>();    <span class="keyword">while</span> ((sq + <span class="number">1</span>) * (sq + <span class="number">1</span>) &lt;= dlt)        sq++;    <span class="keyword">if</span> (sq * sq == dlt)    &#123;        p = -b + sq;        q = <span class="number">2</span> * a;        <span class="keyword">if</span> (<span class="number">2</span> * a &lt; <span class="number">0</span>)            p = <span class="built_in">min</span>(-b + sq, -b - sq);        <span class="keyword">else</span>            p = <span class="built_in">max</span>(-b + sq, -b - sq);        <span class="built_in">fprt</span>(p, q);        <span class="keyword">if</span> (q == <span class="number">1</span>)            <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, p);        <span class="keyword">else</span>            <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld&quot;</span>, p, q);        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);        <span class="keyword">return</span>;    &#125;    p1 = -b;    q1 = <span class="number">2</span> * a;    p2 = <span class="number">1</span>;    <span class="comment">// cout &lt;&lt; &quot;Debug:&quot; &lt;&lt; sq &lt;&lt; &quot;/&quot; &lt;&lt; dlt &lt;&lt; endl;</span>    <span class="keyword">for</span> (ll d = <span class="number">2</span>; d &lt;= sq; d++)    &#123;        <span class="comment">// cout &lt;&lt; dlt &lt;&lt; &quot; &quot; &lt;&lt; d * d &lt;&lt; &quot; &quot; &lt;&lt; (dlt % (d * d) == 0) &lt;&lt; endl;</span>        <span class="keyword">while</span> (dlt % (d * d) == <span class="number">0</span>)        &#123;            dlt /= d * d;            p2 *= d;        &#125;    &#125;    q2 = <span class="number">2</span> * a;    <span class="built_in">fprt</span>(p1, q1);    <span class="comment">// cout &lt;&lt; &quot;debug:&quot; &lt;&lt; p1 &lt;&lt; &quot;/&quot; &lt;&lt; q1 &lt;&lt; endl;</span>    <span class="keyword">if</span> (q1 == <span class="number">1</span>)    &#123;        <span class="keyword">if</span> (p1 != <span class="number">0</span>)        &#123;            <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, p1);            <span class="built_in">printf</span>(<span class="string">&quot;+&quot;</span>);        &#125;    &#125;    <span class="keyword">else</span>    &#123;        <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld&quot;</span>, p1, q1);        <span class="built_in">printf</span>(<span class="string">&quot;+&quot;</span>);    &#125;    <span class="keyword">if</span> (p2 &lt; <span class="number">0</span>)        p2 = -p2;    <span class="keyword">if</span> (q2 &lt; <span class="number">0</span>)        q2 = -q2;    <span class="built_in">F</span>(p2, q2);    <span class="keyword">if</span> (p2 != <span class="number">1</span>)        <span class="built_in">printf</span>(<span class="string">&quot;%lld*&quot;</span>, p2);    <span class="built_in">printf</span>(<span class="string">&quot;sqrt(%lld)&quot;</span>, dlt);    <span class="keyword">if</span> (q2 != <span class="number">1</span>)        <span class="built_in">printf</span>(<span class="string">&quot;/%lld&quot;</span>, q2);    <span class="comment">// printf(&quot;YES\n&quot;);</span>    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">freopen</span>(<span class="string">&quot;uqe.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);    <span class="built_in">freopen</span>(<span class="string">&quot;uqe.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);    <span class="type">int</span> t;    cin &gt;&gt; t &gt;&gt; m;    <span class="keyword">while</span> (t--)        <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="D-旅游巴士-bus"><a href="#D-旅游巴士-bus" class="headerlink" title="D 旅游巴士 bus"></a>D 旅游巴士 bus</h1><p>T1 和 T2 一眼不会 T4 看完题秒了还有救吗？</p><p>首先，这是可以二分答案的，这个看完题就能想出来。</p><p>为什么可以二分？二分什么？如何二分？</p><p>为什么可以二分？因为开始时间任意，如果你在 $t$ 时刻能过，你拖到 $t+k$ 更能过。因为限制随着时间推移只能更少。</p><p>二分什么？我们会发现从 1 号点开始二分开始时间得到的到达时间不一定是单调上升的。那么我们二分结束时间，建反图即可，这样子就只需要判断答案可行性。</p><p>如何二分？设结束时间为 $pk$，二分 $p$ 即可。</p><p>如何 check 也是个困难点。</p><p>你会发现因为边权是 $1$，所以直接大力 bfs 即可。这时候你就通过了小样例，大样例直接炸掉。</p><p><del>所以我不算一看完题就想出正解。</del></p><p>炸掉怎么办？你考虑进行拆点。这个 $k$ 很小肯定不是出题人少写了几个 $0$，你把每个点 $x$ 拆成 $(x,y)$，表示在 $t\equiv y\pmod{k}$ 时刻你到达了 $x$ 点。</p><p>拆点之后大力 bfs 即可通过。</p><p>因为每次 bfs 新的时间只会更短，所以走过的点不需要重复经过，复杂度有保障。</p><p>时间复杂度 $\mathcal O(nk\log V)$，其中 $V&#x3D;\max{a_i}+m\leq 10^7$。大样例场上跑了 0.8s。</p><p>注意无解输出 $-1$，我是不会说有个小丑玩了一个多小时闲的没事干的时候，题面放的很大，一个字一个字研究题面才发现的。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">typedef</span> pair&lt;ll, <span class="type">int</span>&gt; pli;<span class="type">int</span> n, m;ll k;vector&lt;pli&gt; a[<span class="number">100020</span>];<span class="type">bool</span> vis[<span class="number">100020</span>][<span class="number">120</span>];<span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll et)</span></span><span class="function"></span>&#123;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)            vis[i][j] = <span class="number">0</span>;    queue&lt;pli&gt; q;    q.<span class="built_in">push</span>(&#123;et, n&#125;);    vis[n][et % k] = <span class="number">1</span>;    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())    &#123;        <span class="type">int</span> u = q.<span class="built_in">front</span>().second;        ll t = q.<span class="built_in">front</span>().first;        q.<span class="built_in">pop</span>();        <span class="keyword">if</span> (vis[<span class="number">1</span>][<span class="number">0</span>])            <span class="keyword">return</span> <span class="number">1</span>;        <span class="keyword">for</span> (pli p : a[u])        &#123;            <span class="type">int</span> v = p.second;            ll w = p.first;            <span class="keyword">if</span> (t &gt; w &amp;&amp; !vis[v][(t - <span class="number">1</span>) % k])            &#123;                vis[v][(t - <span class="number">1</span>) % k] = <span class="number">1</span>;                q.<span class="built_in">push</span>(&#123;t - <span class="number">1</span>, v&#125;);            &#125;        &#125;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">freopen</span>(<span class="string">&quot;bus.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);    <span class="built_in">freopen</span>(<span class="string">&quot;bus.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;n, &amp;m, &amp;k);    <span class="keyword">while</span> (m--)    &#123;        <span class="type">int</span> u, v;        ll w;        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;u, &amp;v, &amp;w);        a[v].<span class="built_in">push_back</span>(&#123;w, u&#125;);    &#125;    <span class="comment">//bs end time</span>    ll L = <span class="number">0</span>, R = <span class="number">1e7</span>, mid, ans = <span class="number">-1</span>;    <span class="keyword">while</span> (L &lt;= R)    &#123;        mid = L + R &gt;&gt; <span class="number">1</span>;        <span class="keyword">if</span> (<span class="built_in">check</span>(mid * k))            R = (ans = mid) - <span class="number">1</span>;        <span class="keyword">else</span>            L = mid + <span class="number">1</span>;    &#125;    <span class="keyword">if</span> (ans == <span class="number">-1</span>)        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);    <span class="keyword">else</span>        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans * k);    <span class="comment">// cerr &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; (double)clock() / CLOCKS_PER_SEC &lt;&lt; endl;</span>    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] P2223 [HNOI2001] 软件开发</title>
      <link href="/archives/P2223/"/>
      <url>/archives/P2223/</url>
      
        <content type="html"><![CDATA[<h1 id="多倍经验"><a href="#多倍经验" class="headerlink" title="多倍经验"></a>多倍经验</h1><ul><li><a href="https://www.luogu.com.cn/problem/P1251">P1251 餐巾计划问题</a></li><li><a href="https://www.luogu.com.cn/problem/P2223">P2223 [HNOI2001] 软件开发</a></li><li><a href="https://www.luogu.com.cn/problem/P2917">P2917 [USACO08NOV] Toys G</a></li><li><a href="https://www.luogu.com.cn/problem/P4480">P4480 [BJWC2018] 餐巾计划问题</a></li></ul><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>约定 $p$ 为干净毛巾价格，$m_1,m_2$ 为快消毒慢消毒所需要的天数，$c_1,c_2$ 为快消毒慢消毒一个的代价，$m_1\leq m_2,c_1\geq c_2$，不满足的话自己 swap 一下即可。</p><p>一个显然的性质是我们可以把要用的毛巾一次性买好。考虑如果我们知道了具体要买多少毛巾。设要买 $x$ 条，$f(x)$ 表示买了 $x$ 条毛巾最后的总花费。如果不够用为 $+\infty$。手玩几个找找规律<del>或者是靠小学数学题告诉你的经验</del>可以发现这是个单谷函数，有一个极点。显然我们要找出这个极点并且求出对应的函数值。</p><p>单谷函数，显然是需要三分的。那么这个 $f(x)$ 到底应该怎么算呢？</p><p>先思考，每天可以用的毛巾从哪里来？</p><ol><li>买来的新的没用完。</li><li>快消毒消毒完的。</li><li>慢消毒消毒完的。</li></ol><p>之后会发现优先使用新的毛巾会更优，这个是先用的。</p><p>然后在可以的情况下优先使用较晚慢消毒好的。慢消毒全用完之后用较晚快消毒好的。</p><p>优先使用较晚得到的毛巾，可以尝试让更早的毛巾去慢消毒，最小化代价。</p><p>优先用慢消毒可以尽量减少消费，和上面一个道理，可能能让快消毒毛巾去慢消毒。</p><p>这时很显然这就是贪心的过程，<del>因为这题是洛谷秋令营提高组贪心课后作业。</del></p><p>注意到我们需要从头放，从尾巴取，所以我们实现的时候可以使用双端队列模拟这一贪心过程，即使用 C++ 的 STL 容器 deque。</p><h1 id="丑陋代码"><a href="#丑陋代码" class="headerlink" title="丑陋代码"></a>丑陋代码</h1><p><a href="https://www.luogu.com.cn/record/128375471">Luogu record 128375471</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> upd1(a, b, c)                            \</span><span class="meta">    while (!a.empty() &amp;&amp; a.front().day &lt;= i - c) \</span><span class="meta">    &#123;                                            \</span><span class="meta">        b.push_back(a.front());                  \</span><span class="meta">        a.pop_front();                           \</span><span class="meta">    &#125;</span><span class="meta">#<span class="keyword">define</span> upd2(a, b)                   \</span><span class="meta">    while (cnt &gt; 0 &amp;&amp; !a.empty())    \</span><span class="meta">    &#123;                                \</span><span class="meta">        mn = min(cnt, a.back().cnt); \</span><span class="meta">        ret += mn * b;               \</span><span class="meta">        cnt -= mn;                   \</span><span class="meta">        <span class="keyword">if</span> (!(a.back().cnt -= mn))   \</span><span class="meta">            a.pop_back();            \</span><span class="meta">    &#125;</span><span class="keyword">struct</span> <span class="title class_">info</span>&#123;    <span class="type">int</span> day, cnt;&#125;;<span class="type">int</span> n, m1, m2, c1, c2, p;deque&lt;info&gt; buy;deque&lt;info&gt; fst;deque&lt;info&gt; slw;<span class="type">int</span> a[<span class="number">200020</span>];<span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> k)</span></span><span class="function"></span>&#123;    buy.<span class="built_in">clear</span>();    fst.<span class="built_in">clear</span>();    slw.<span class="built_in">clear</span>();    <span class="type">int</span> ret = k * p;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="built_in">upd1</span>(buy, fst, m1);        <span class="built_in">upd1</span>(fst, slw, m2);        <span class="type">int</span> cnt = a[i];        <span class="type">int</span> mn = <span class="built_in">min</span>(cnt, k);        cnt -= mn;        k -= mn;        <span class="built_in">upd2</span>(slw, c2);        <span class="built_in">upd2</span>(fst, c1);        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>)            <span class="keyword">return</span> INT_MAX;        buy.<span class="built_in">push_back</span>(&#123;i, a[i]&#125;);    &#125;    <span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2 &gt;&gt; c1 &gt;&gt; c2 &gt;&gt; p;    <span class="keyword">if</span> (m1 &gt; m2)        <span class="built_in">swap</span>(m1, m2), <span class="built_in">swap</span>(c1, c2);    <span class="keyword">if</span> (c1 &lt; c2)        m2 = m1, c2 = c1;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        cin &gt;&gt; a[i];    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="built_in">accumulate</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, <span class="number">0</span>);    <span class="keyword">while</span> (l &lt;= r)    &#123;        <span class="type">int</span> ml = l + (r - l) / <span class="number">3</span>;        <span class="type">int</span> mr = r - (r - l) / <span class="number">3</span>;        <span class="type">int</span> vl = <span class="built_in">f</span>(ml), vr = <span class="built_in">f</span>(mr);        <span class="keyword">if</span> (vl &gt;= vr)            l = ml + <span class="number">1</span>;        <span class="keyword">else</span>            r = mr - <span class="number">1</span>;    &#125;    cout &lt;&lt; <span class="built_in">min</span>(<span class="built_in">f</span>(l), <span class="built_in">f</span>(r)) &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] P2917 [USACO08NOV] Toys G</title>
      <link href="/archives/P2917/"/>
      <url>/archives/P2917/</url>
      
        <content type="html"><![CDATA[<h1 id="多倍经验"><a href="#多倍经验" class="headerlink" title="多倍经验"></a>多倍经验</h1><ul><li><a href="https://www.luogu.com.cn/problem/P1251">P1251 餐巾计划问题</a></li><li><a href="https://www.luogu.com.cn/problem/P2223">P2223 [HNOI2001] 软件开发</a></li><li><a href="https://www.luogu.com.cn/problem/P2917">P2917 [USACO08NOV] Toys G</a></li><li><a href="https://www.luogu.com.cn/problem/P4480">P4480 [BJWC2018] 餐巾计划问题</a></li></ul><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>约定 $p$ 为干净玩具价格，$m_1,m_2$ 为快消毒慢消毒所需要的天数，$c_1,c_2$ 为快消毒慢消毒一个的代价，$m_1\leq m_2,c_1\geq c_2$，不满足的话自己 swap 一下即可。</p><p>一个显然的性质是我们可以把要用的玩具一次性买好。考虑如果我们知道了具体要买多少玩具。设要买 $x$ 条，$f(x)$ 表示买了 $x$ 条玩具最后的总花费。如果不够用为 $+\infty$。手玩几个找找规律<del>或者是靠小学数学题告诉你的经验</del>可以发现这是个单谷函数，有一个极点。显然我们要找出这个极点并且求出对应的函数值。</p><p>单谷函数，显然是需要三分的。那么这个 $f(x)$ 到底应该怎么算呢？</p><p>先思考，每天可以用的玩具从哪里来？</p><ol><li>买来的新的没用完。</li><li>快消毒消毒完的。</li><li>慢消毒消毒完的。</li></ol><p>之后会发现优先使用新的玩具会更优，这个是先用的。</p><p>然后在可以的情况下优先使用较晚慢消毒好的。慢消毒全用完之后用较晚快消毒好的。</p><p>优先使用较晚得到的玩具，可以尝试让更早的玩具去慢消毒，最小化代价。</p><p>优先用慢消毒可以尽量减少消费，和上面一个道理，可能能让快消毒玩具去慢消毒。</p><p>这时很显然这就是贪心的过程，<del>因为这题是洛谷秋令营提高组贪心课后作业。</del></p><p>注意到我们需要从头放，从尾巴取，所以我们实现的时候可以使用双端队列模拟这一贪心过程，即使用 C++ 的 STL 容器 deque。</p><h1 id="丑陋代码"><a href="#丑陋代码" class="headerlink" title="丑陋代码"></a>丑陋代码</h1><p><a href="https://www.luogu.com.cn/record/128374807">Luogu record 128374807</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> upd1(a, b, c)                            \</span><span class="meta">    while (!a.empty() &amp;&amp; a.front().day &lt;= i - c) \</span><span class="meta">    &#123;                                            \</span><span class="meta">        b.push_back(a.front());                  \</span><span class="meta">        a.pop_front();                           \</span><span class="meta">    &#125;</span><span class="meta">#<span class="keyword">define</span> upd2(a, b)                   \</span><span class="meta">    while (cnt &gt; 0 &amp;&amp; !a.empty())    \</span><span class="meta">    &#123;                                \</span><span class="meta">        mn = min(cnt, a.back().cnt); \</span><span class="meta">        ret += mn * b;               \</span><span class="meta">        cnt -= mn;                   \</span><span class="meta">        <span class="keyword">if</span> (!(a.back().cnt -= mn))   \</span><span class="meta">            a.pop_back();            \</span><span class="meta">    &#125;</span><span class="keyword">struct</span> <span class="title class_">info</span>&#123;    <span class="type">int</span> day, cnt;&#125;;<span class="type">int</span> n, m1, m2, c1, c2, p;deque&lt;info&gt; buy;deque&lt;info&gt; fst;deque&lt;info&gt; slw;<span class="type">int</span> a[<span class="number">200020</span>];<span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> k)</span></span><span class="function"></span>&#123;    buy.<span class="built_in">clear</span>();    fst.<span class="built_in">clear</span>();    slw.<span class="built_in">clear</span>();    <span class="type">int</span> ret = k * p;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="built_in">upd1</span>(buy, fst, m1);        <span class="built_in">upd1</span>(fst, slw, m2);        <span class="type">int</span> cnt = a[i];        <span class="type">int</span> mn = <span class="built_in">min</span>(cnt, k);        cnt -= mn;        k -= mn;        <span class="built_in">upd2</span>(slw, c2);        <span class="built_in">upd2</span>(fst, c1);        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>)            <span class="keyword">return</span> INT_MAX;        buy.<span class="built_in">push_back</span>(&#123;i, a[i]&#125;);    &#125;    <span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2 &gt;&gt; c1 &gt;&gt; c2 &gt;&gt; p;    <span class="keyword">if</span> (m1 &gt; m2)        <span class="built_in">swap</span>(m1, m2), <span class="built_in">swap</span>(c1, c2);    <span class="keyword">if</span> (c1 &lt; c2)        m2 = m1, c2 = c1;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        cin &gt;&gt; a[i];    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="built_in">accumulate</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, <span class="number">0</span>);    <span class="keyword">while</span> (l &lt;= r)    &#123;        <span class="type">int</span> ml = l + (r - l) / <span class="number">3</span>;        <span class="type">int</span> mr = r - (r - l) / <span class="number">3</span>;        <span class="type">int</span> vl = <span class="built_in">f</span>(ml), vr = <span class="built_in">f</span>(mr);        <span class="keyword">if</span> (vl &gt;= vr)            l = ml + <span class="number">1</span>;        <span class="keyword">else</span>            r = mr - <span class="number">1</span>;    &#125;    cout &lt;&lt; <span class="built_in">min</span>(<span class="built_in">f</span>(l), <span class="built_in">f</span>(r)) &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] P4480 [BJWC2018] 餐巾计划问题</title>
      <link href="/archives/P4480/"/>
      <url>/archives/P4480/</url>
      
        <content type="html"><![CDATA[<h1 id="多倍经验"><a href="#多倍经验" class="headerlink" title="多倍经验"></a>多倍经验</h1><ul><li><a href="https://www.luogu.com.cn/problem/P1251">P1251 餐巾计划问题</a></li><li><a href="https://www.luogu.com.cn/problem/P2223">P2223 [HNOI2001] 软件开发</a></li><li><a href="https://www.luogu.com.cn/problem/P2917">P2917 [USACO08NOV] Toys G</a></li><li><a href="https://www.luogu.com.cn/problem/P4480">P4480 [BJWC2018] 餐巾计划问题</a></li></ul><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>约定 $p$ 为干净餐巾价格，$m_1,m_2$ 为快洗慢洗所需要的天数，$c_1,c_2$ 为快洗慢洗一个的代价，$m_1\leq m_2,c_1\geq c_2$，不满足的话自己 swap 一下即可。</p><p>一个显然的性质是我们可以把要用的餐巾一次性买好。考虑如果我们知道了具体要买多少餐巾。设要买 $x$ 条，$f(x)$ 表示买了 $x$ 条餐巾最后的总花费。如果不够用为 $+\infty$。手玩几个找找规律<del>或者是靠小学数学题告诉你的经验</del>可以发现这是个单谷函数，有一个极点。显然我们要找出这个极点并且求出对应的函数值。</p><p>单谷函数，显然是需要三分的。那么这个 $f(x)$ 到底应该怎么算呢？</p><p>先思考，每天可以用的餐巾从哪里来？</p><ol><li>买来的新的没用完。</li><li>快洗洗完的。</li><li>慢洗洗完的。</li></ol><p>之后会发现优先使用新的餐巾会更优，这个是先用的。</p><p>然后在可以的情况下优先使用较晚慢洗好的。慢洗全用完之后用较晚快洗好的。</p><p>优先使用较晚得到的餐巾，可以尝试让更早的餐巾去慢洗，最小化代价。</p><p>优先用慢洗可以尽量减少消费，和上面一个道理，可能能让快洗的餐巾去慢洗。</p><p>这时很显然这就是贪心的过程，<del>因为这题是洛谷秋令营提高组贪心课后作业。</del></p><p>注意到我们需要从头放，从尾巴取，所以我们实现的时候可以使用双端队列模拟这一贪心过程，即使用 C++ 的 STL 容器 deque。</p><h1 id="丑陋代码"><a href="#丑陋代码" class="headerlink" title="丑陋代码"></a>丑陋代码</h1><p><a href="https://www.luogu.com.cn/record/128374675">Luogu record 128374675</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> upd1(a, b, c)                            \</span><span class="meta">    while (!a.empty() &amp;&amp; a.front().day &lt;= i - c) \</span><span class="meta">    &#123;                                            \</span><span class="meta">        b.push_back(a.front());                  \</span><span class="meta">        a.pop_front();                           \</span><span class="meta">    &#125;</span><span class="meta">#<span class="keyword">define</span> upd2(a, b)                   \</span><span class="meta">    while (cnt &gt; 0 &amp;&amp; !a.empty())    \</span><span class="meta">    &#123;                                \</span><span class="meta">        mn = min(cnt, a.back().cnt); \</span><span class="meta">        ret += mn * b;               \</span><span class="meta">        cnt -= mn;                   \</span><span class="meta">        <span class="keyword">if</span> (!(a.back().cnt -= mn))   \</span><span class="meta">            a.pop_back();            \</span><span class="meta">    &#125;</span><span class="keyword">struct</span> <span class="title class_">info</span>&#123;    <span class="type">int</span> day, cnt;&#125;;<span class="type">int</span> n, m1, m2, c1, c2, p;deque&lt;info&gt; buy;deque&lt;info&gt; fst;deque&lt;info&gt; slw;<span class="type">int</span> a[<span class="number">200020</span>];<span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> k)</span></span><span class="function"></span>&#123;    buy.<span class="built_in">clear</span>();    fst.<span class="built_in">clear</span>();    slw.<span class="built_in">clear</span>();    <span class="type">int</span> ret = k * p;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="built_in">upd1</span>(buy, fst, m1);        <span class="built_in">upd1</span>(fst, slw, m2);        <span class="type">int</span> cnt = a[i];        <span class="type">int</span> mn = <span class="built_in">min</span>(cnt, k);        cnt -= mn;        k -= mn;        <span class="built_in">upd2</span>(slw, c2);        <span class="built_in">upd2</span>(fst, c1);        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>)            <span class="keyword">return</span> INT_MAX;        buy.<span class="built_in">push_back</span>(&#123;i, a[i]&#125;);    &#125;    <span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2 &gt;&gt; c1 &gt;&gt; c2 &gt;&gt; p;    <span class="keyword">if</span> (m1 &gt; m2)        <span class="built_in">swap</span>(m1, m2), <span class="built_in">swap</span>(c1, c2);    <span class="keyword">if</span> (c1 &lt; c2)        m2 = m1, c2 = c1;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        cin &gt;&gt; a[i];    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="built_in">accumulate</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, <span class="number">0</span>);    <span class="keyword">while</span> (l &lt;= r)    &#123;        <span class="type">int</span> ml = l + (r - l) / <span class="number">3</span>;        <span class="type">int</span> mr = r - (r - l) / <span class="number">3</span>;        <span class="type">int</span> vl = <span class="built_in">f</span>(ml), vr = <span class="built_in">f</span>(mr);        <span class="keyword">if</span> (vl &gt;= vr)            l = ml + <span class="number">1</span>;        <span class="keyword">else</span>            r = mr - <span class="number">1</span>;    &#125;    cout &lt;&lt; <span class="built_in">min</span>(<span class="built_in">f</span>(l), <span class="built_in">f</span>(r)) &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] SUMITB2019F Interval Running</title>
      <link href="/archives/SUMITB2019F/"/>
      <url>/archives/SUMITB2019F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>A 和 B 正在赛跑，前 $T_1$ 分钟 A 和 B 速度分别是 $A_1$ 和 $A_2$，之后 $T_2$ 分钟 A 和 B 速度分别是 $A_2$ 和 $B_2$，以此类推，问 A 和 B 会相遇几次。</p><p>相遇无数次输出 <code>infinity</code>。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>什么小学奥数入门题。</p><p>为了方便描述：</p><p>前半段：$S_{a,1}&#x3D;T_1\times A_1,S_{b,1}&#x3D;T_1\times B_1$。</p><p>后半段：$S_{a,2}&#x3D;T_2\times A_2,S_{b,2}&#x3D;T_2\times B_2$。</p><p>全程：$S_a&#x3D;S_{a,1}+S_{a,2},S_b&#x3D;S_{b,1}+S_{b,2}$。</p><p>首先考虑无数次，显然的，A 一个全程与 B 一个全程路程相同即可，即 $S_a&#x3D;S_b$。</p><p>然后我们为了方便描述，强制转换一下，因为本题不用关心前后半程相对顺序与两个人的相对顺序，令 $S_a&gt;S_b$，之后方便我们的描述。</p><p>此时如果 $S_{b,1}\lt S_{a,1}$，那么就不会产生任何相遇，直接特判掉。</p><p>然后再次令 $S_{a,1}\lt S_{b,1},S_{a,2}\gt S_{b,2}$。即让 A 前半程跑不过 B，但是后半程能追上。</p><p>此时就变成了一般情况，A 每个全程比 B 多跑的要去一直填补被 B 甩下的距离，因此所有全程的相遇次数就是 $\left\lfloor\dfrac{S_{b,1}-S_{a,1}}{S_a-S_b}\right\rfloor\times2$。</p><p>然后注意一个细节就是可能半程就把最后一次相遇追上了，所以最后要加上 $[(S_{b,1}-S_{a,1})\bmod (S_a-S_b)\neq 0]$。</p><h1 id="丑陋代码"><a href="#丑陋代码" class="headerlink" title="丑陋代码"></a>丑陋代码</h1><p><a href="https://atcoder.jp/contests/sumitrust2019/submissions/46471947">AT submission 46471947</a></p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ATTENKA12017C 4/N</title>
      <link href="/archives/TENKA12017C/"/>
      <url>/archives/TENKA12017C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>输入一个正整数 $a(2\leq a\leq 3500)$，输出三个数 $h,w,r$，满足 $\dfrac1h+\dfrac1w+\dfrac1r&#x3D;\dfrac4a$，输出任意一种符合的答案。</p><p>保证存在一组 $h,w,r\leq 3500$ 的合法解，但是你不需要一定输出类似的方案，输出中含有 $\geq 3500$ 的方案也是合法的。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>大家都会数学，就我不会，那就来一个不太寻常的大炮打蚊子的做法。</p><p>$\mathcal O(V^3)$ 的做法显然不能接受，我们可以枚举两维，$h$ 和 $w$，然后硬算出 $r$。</p><p>如何算出 $r$？</p><p><a href="https://www.luogu.com.cn/blog/EntropyIncreaser/jian-jie-di-qu-mu-huan-yuan-fen-shuo-fang-fa">前置知识：简洁的取模还原分数方法</a></p><p>我们把 $\dfrac4a,\dfrac1h,\dfrac1w$ 全都取模变成一个整数，如何转换参考 <a href="https://www.luogu.com.cn/problem/P2613">P2613 【模板】有理数取余</a>。</p><p>设得到的三个整数为 $n,P,Q$，得到 $\dfrac1r$ 应该是 $m&#x3D;n-P-Q$。然后我们将 $m$ 还原成分数，判断是否为埃及分数以及最后是否满足 $\dfrac1h+\dfrac1w+\dfrac1r&#x3D;\dfrac4a$ 即可。</p><h1 id="丑陋代码"><a href="#丑陋代码" class="headerlink" title="丑陋代码"></a>丑陋代码</h1><p><a href="https://atcoder.jp/contests/tenka1-2017/submissions/46467770">AT submission 46467770</a></p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20231007 | CSP2023 考前模拟赛 做题笔记</title>
      <link href="/archives/20231007_mock/"/>
      <url>/archives/20231007_mock/</url>
      
        <content type="html"><![CDATA[<h1 id="书"><a href="#书" class="headerlink" title="书"></a>书</h1><p>简单题，但是有个小丑挂掉了。</p><p>对于每个 $[10^x,10^{x+1}-1]$ 的区间，计算 $n$ 覆盖了多大范围。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">freopen</span>(<span class="string">&quot;book.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);    <span class="built_in">freopen</span>(<span class="string">&quot;book.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);    ll n, ans = <span class="number">0</span>;    cin &gt;&gt; n;    ll pw = <span class="number">1</span>, cnt = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)    &#123;        <span class="keyword">if</span> (pw * <span class="number">10</span> - <span class="number">1</span> &lt;= n)            ans += cnt * <span class="number">9</span> * pw;        <span class="keyword">else</span>        &#123;            ans += cnt * (n - pw + <span class="number">1</span>);            <span class="keyword">break</span>;        &#125;        pw *= <span class="number">10</span>;        cnt++;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">[1,9]</span><span class="comment">[10,99]</span><span class="comment">[100,999]</span><span class="comment">...</span><span class="comment">[10**x,10**(x+1)-1]</span><span class="comment">*/</span></code></pre><h1 id="数"><a href="#数" class="headerlink" title="数"></a>数</h1><p>我没记错的话我在 cses.fi 上做过这题。但这题本来就很典，估计很多 OJ 都有。</p><p>设 $f_i$ 表示凑到 $i$ 的最小步数。</p><p>转移 $f_i\gets\min{f_{i-1},f_{i\times 2},f_{i\times 3}}+1$。</p><p>但是有一个小丑以为 CF 打多了误以为多测只要每个 $\mathcal O(n)$ 就能过，喜提 TLE。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> f[<span class="number">1000020</span>];<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n = <span class="number">1000000</span>;    f[f[f[<span class="number">2</span>] = f[<span class="number">3</span>] = <span class="number">1</span>] = <span class="number">0</span>] = <span class="number">1000</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt;= n; i++)    &#123;        <span class="type">int</span> x, y, z;        x = y = z = INT_MAX;        x = f[i - <span class="number">1</span>];        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)            y = f[i / <span class="number">2</span>];        <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)            z = f[i / <span class="number">3</span>];        f[i] = <span class="built_in">min</span>(&#123;x, y, z&#125;) + <span class="number">1</span>;    &#125;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n;    cin &gt;&gt; n;    cout &lt;&lt; f[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">freopen</span>(<span class="string">&quot;number.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);    <span class="built_in">freopen</span>(<span class="string">&quot;number.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);    <span class="built_in">init</span>();    <span class="type">int</span> t;    cin &gt;&gt; t;    <span class="keyword">while</span> (t--)        <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="盒"><a href="#盒" class="headerlink" title="盒"></a>盒</h1><p>一眼 dp，状态很容易设出 $f_{i,0&#x2F;1&#x2F;2}$ 表示第 $i$ 个位置往左不动往右的答案。</p><p>转移需要分讨。</p><ul><li><p>当前有盖子</p><ul><li><p>左边有盖子</p><p>$f_{i,0}\gets f_{i-1,0}+a_{i-1}$</p><p>$f_{i,1}\gets \max{f_{i-1,0},f_{i-1,1}}+a_{i}$</p><p>$f_{i,2}\gets\max{f_{i-1,0},f_{i-1,1},f_{i-1,2}}+a_{i+1}$</p></li><li><p>反之</p><p>$f_{i,0}\gets f_{i-1,0}+a_{i-1}$</p><p>$f_{i,1}\gets f_{i-1,1}+a_{i}$</p><p>$f_{i,2}\gets f_{i-1,1}+a_{i+1}$</p></li></ul></li><li><p>反之</p><p>$f_{i,0}\gets\max{f_{i-1,0},f_{i-1,1}}$</p><p>$f_{i,1}\gets\max{f_{i-1,0},f_{i-1,1},f_{i-1,2}}$</p><p>这里不需要转移 $f_{i,2}$，它本来就没有盖子，无需转移。转移 $f_{i,0}$ 是为了让之后的 $f_{i+1,0}$ 能够转移。</p></li></ul><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;ll f[<span class="number">200020</span>][<span class="number">3</span>];<span class="type">int</span> n;ll a[<span class="number">200020</span>];<span class="type">int</span> b[<span class="number">200020</span>];<span class="comment">//f[i][0/1/2] left,mid,right</span><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">freopen</span>(<span class="string">&quot;box.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);    <span class="built_in">freopen</span>(<span class="string">&quot;box.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);    cin &gt;&gt; n;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, a + i);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b + i);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">if</span> (b[i]) <span class="comment">//有盖子</span>        &#123;            f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + a[i - <span class="number">1</span>];            <span class="keyword">if</span> (b[i - <span class="number">1</span>]) <span class="comment">//左边也有盖子</span>            &#123;                f[i][<span class="number">1</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">1</span>]) + a[i];                f[i][<span class="number">2</span>] = <span class="built_in">max</span>(&#123;f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>]&#125;) + a[i + <span class="number">1</span>];            &#125;            <span class="keyword">else</span>            &#123;                f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">1</span>] + a[i];                f[i][<span class="number">2</span>] = f[i - <span class="number">1</span>][<span class="number">1</span>] + a[i + <span class="number">1</span>];            &#125;        &#125;        <span class="keyword">else</span>        &#123;            f[i][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">1</span>]);            f[i][<span class="number">1</span>] = <span class="built_in">max</span>(&#123;f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>]&#125;);        &#125;    &#125;    cout &lt;&lt; <span class="built_in">max</span>(f[n][<span class="number">0</span>], f[n][<span class="number">1</span>]) &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="和"><a href="#和" class="headerlink" title="和"></a>和</h1><p>很厉害的一道题！</p><p>首先考虑暴力怎么写。我说的不是 $3^n$ 级别的，如果你只想到这一层建议先想出多项式复杂度的代码再看。</p><p>我们的暴力应该是 $\mathcal O(Vn^3)$。</p><p>暴力的写法，应该是 $\mathcal O(n)$ 枚举更改哪个位置，$\mathcal O(V)$ 枚举更改成什么结果，$\mathcal O(n^2)$ 枚举子序列计算。</p><p>考虑优化哪一个。$O(n^2)$ ，枚举子序列大抵是可以优化的，但我不会。</p><p>考虑优化 $O(V)$ 枚举更改值。</p><p>显然的，由于只有 $300$ 个更改方案，<strong>所以能构成的完全平方数不会过多，大约是根号级别的。</strong></p><p>那么就很好优化了，$\mathcal O(n)$ 枚举修改哪个位置，先算出它没有干扰到哪些子序列，这些子序列会产生多少贡献，这个是很好算的。</p><p>然后，我们算出更改这个位置之后的某个子序列上界和下界，这里记作 $L$ 和 $R$。</p><p>$[L,R]$ 之间的完全平方数 $p^2$ 不会过多，我们枚举可行的 $p$。$p$ 的范围应为 $[\left\lceil\sqrt L\right\rceil,\left\lfloor\sqrt R\right\rfloor]$。找完全平方数选择枚举它的因子降低复杂度是一个很典的 trick。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">gmx</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">max</span>(x, y); &#125;<span class="type">int</span> n;<span class="type">int</span> a[<span class="number">320</span>];<span class="type">int</span> s[<span class="number">320</span>];<span class="type">bool</span> sq[<span class="number">100020</span>];ll f[<span class="number">320</span>];ll ans;<span class="function"><span class="type">int</span> <span class="title">S</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> s[r] - s[l - <span class="number">1</span>]; &#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">freopen</span>(<span class="string">&quot;sum.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);    <span class="built_in">freopen</span>(<span class="string">&quot;sum.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);    cin &gt;&gt; n;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        cin &gt;&gt; a[i], s[i] = s[i - <span class="number">1</span>] + a[i];    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">300</span>; i++)        sq[i * i] = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//修改第i个位置</span>    &#123;        <span class="type">int</span> tmp = <span class="number">0</span>;        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)            <span class="keyword">for</span> (<span class="type">int</span> r = l; r &lt;= n; r++)                <span class="keyword">if</span> (i &lt; l || r &lt; i)                    <span class="keyword">if</span> (sq[<span class="built_in">S</span>(l, r)])                        tmp++;        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)        &#123;            <span class="keyword">for</span> (<span class="type">int</span> r = l; r &lt;= n; r++)            &#123;                <span class="keyword">if</span> (i &lt; l || r &lt; i)                    <span class="keyword">continue</span>;                <span class="type">int</span> L = <span class="number">1</span>, R = <span class="number">300</span>;                <span class="type">int</span> sum = <span class="built_in">S</span>(l, r) - a[i];                L += sum;                R += sum;                <span class="comment">// cout &lt;&lt; L &lt;&lt; &quot; &quot; &lt;&lt; R &lt;&lt; endl;</span>                <span class="type">int</span> mayL = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(L)), mayR = <span class="built_in">sqrt</span>(R);                <span class="comment">// cout &lt;&lt; mayL &lt;&lt; &quot; &quot; &lt;&lt; mayR &lt;&lt; endl;</span>                <span class="comment">// cout &lt;&lt; endl;</span>                <span class="keyword">for</span> (<span class="type">int</span> k = mayL; k &lt;= mayR; k++)                    <span class="keyword">if</span> (k * k - sum &lt;= <span class="number">300</span>)                        f[k * k - sum]++;            &#125;        &#125;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">300</span>; i++)            <span class="built_in">gmx</span>(ans, f[i] + tmp);    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[游记] CSP 2023 游记</title>
      <link href="/archives/CSP2023/"/>
      <url>/archives/CSP2023/</url>
      
        <content type="html"><![CDATA[<p>希望今年能靠自己的分数打进 NOIP 吧，去年是靠的常州考点的名额。</p><p>好，noip 应该是进了。</p><h1 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h1><h2 id="Day"><a href="#Day" class="headerlink" title="Day -???"></a>Day -???</h2><p>去机房不能开电脑，难受。</p><p>练初赛，全靠左顾右盼法看@<a href="https://www.luogu.com.cn/user/526163">JwJ_2010</a> 的。退役半年的都比我强，紫砂了。</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p>文化课布置了作文，难受。初赛，没看。</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>上午坐地铁去，好像在常外站看到了个高个子的穿校服的女生，但事实上好像不是去考初赛的。</p><p>地铁上死命看初赛知识点，主定理是在车上看会的。</p><p>到了，在博爱路站下车，看到了@<a href="https://www.luogu.com.cn/user/268980">xiayuhao__2009</a>。走过去竟然要走 800m，啥破地方啊&#x2F;fn</p><p>然后到了考场，这啥初中都没听过啊，门口一条竖着的马路全是人，怎么今年小朋友这么多。</p><p>看到了同校的，怎么都不穿校服？怎么都不穿校服？怎么都不穿校服？传统忘了？传统忘了？传统忘了？</p><p>大家都问我车上看见的学姐去哪了，要检查我的手机相册。</p><p>？</p><p>然后就是正常的互相膜拜。今年不在省常中没有天宁寺拜。</p><p>看到了帅气的@<a href="https://www.luogu.com.cn/user/400269">Shiota_Kaede</a>，好色。</p><p>进考场了。门口破马路真堵。还是学校里面操场宽敞。</p><p>@<a href="https://www.luogu.com.cn/user/400269">Shiota_Kaede</a> 和我姓一样，第二个首字母他是 J 我是 Y 我就润去二考场了？？？人这么多的？？？</p><p>考场里一堆小朋友，<del>好可爱</del>。</p><p>怎么教室墙上有钟离，玩原玩的。</p><p>为什么发卷是一个人一个人发的？</p><p>开考了。</p><p>考试没啥记得的，就记得上厕所说一声就可以直接去，我看着一分钟之内两个人走过我们这里上厕所。这不随便作弊？</p><p>发现 J 很简单啊，但是一对答案就萎了。</p><p>中午和@<a href="https://www.luogu.com.cn/user/268980">xiayuhao__2009</a> 在学校对面吃了顿饭。我一直在看手机看大家讨论答案。</p><p>然后润去买奶茶，发现之前买的一家店不知道是搬了还是我们走错了，寄。</p><p>去买了 coco，坐在那里还是看手机。</p><p>coco 一杯果茶，我点的正常冰放了半杯冰，大家以后记得避坑。</p><p>中午就在 QQ 聊天。</p><p>下午开考前不记得多久了润回了那个偏远初中。</p><p>依旧是看到了@<a href="https://www.luogu.com.cn/user/400269">Shiota_Kaede</a>，还见到了@<a href="https://www.luogu.com.cn/user/233576">ChenLingHan</a>。进去后还看到了@<a href="https://www.luogu.com.cn/user/200429">chufuzhe</a> 和 @<a href="https://www.luogu.com.cn/user/209848">ByGones</a>。还见到了鲲队，但不敢打招呼。</p><p>不同考场规矩还不同的，奇葩。</p><p>S 依旧很简单，但仍然是对完答案就萎了。</p><p>稍微看了下大概错了多少，比预想差一点。估计 60 上下，没仔细算。</p><p>然后一直摆到开学。</p><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><p>学校信息课。教练教了怎么用 NOI Linux。</p><p>妈的我预估 J 最低 75 怎么有人和教练说我 J 只有 70 的，教练还特地问我。</p><h2 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h2><p>怎么还要用 NOI Linux 练习去年做的卷子。哦这套啊想起来了考得很差的。怎么今年一小时阿克不了，难过。</p><h2 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h2><p>出分数线了，听说是特派员周末要下班了，所以周五得发，发完跑路了。</p><p>分数线挺低的。看来机位超多。</p><h1 id="复赛"><a href="#复赛" class="headerlink" title="复赛"></a>复赛</h1><h2 id="Day-15-21"><a href="#Day-15-21" class="headerlink" title="Day [-15,-21]"></a>Day [-15,-21]</h2><p>在 hba 训练。被模拟赛创死。</p><p>但是拍到了很多人的丑照（</p><p>原来大家管互相拍照叫对拍！</p><h2 id="Day-14"><a href="#Day-14" class="headerlink" title="Day -14"></a>Day -14</h2><p>停课力。</p><p>但是国庆作业有一项没看要求，我还要重做&#x2F;ng</p><p>在机房补了前两天学校里的入门组模拟赛，380，死因不看数据范围下意识以为多测保障了 $\sum n\leq 10^6$。</p><h2 id="Day-9"><a href="#Day-9" class="headerlink" title="Day -9"></a>Day -9</h2><p>最近几天都是在机房度过的。但是下周有模考，逃过一劫！</p><h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day -1"></a>Day -1</h2><p>板子大赛。</p><p>写完自己会的发现是 rk.3，晚上看掉 rk.11 了。所以手速在实力的差距面前只是摆设。</p><h2 id="Day-0-1"><a href="#Day-0-1" class="headerlink" title="Day 0"></a>Day 0</h2><p>【省流】J 赢麻了，S 输麻了！</p><h3 id="Morning"><a href="#Morning" class="headerlink" title="Morning"></a>Morning</h3><p>提供一个 J 自己写的题解。</p><p><a href="https://www.luogu.com.cn/blog/cayaxi09/csp-j-2023-ti-xie">https://www.luogu.com.cn/blog/cayaxi09/csp-j-2023-ti-xie</a></p><p>好像去晚了，到的时候已经有考场的人进去了。</p><p>点名批评 @<a href="https://www.luogu.com.cn/user/732869">OrangePayne</a>，2 考场进去的时候带着我进去，<del>还好我走到一半被叫回去了</del>。</p><p>诶为啥密码发的这么晚，又是面对样例和名字猜题意。</p><p>发密码了，但是是 8:30 才发，去年是提前发的啊&#x2F;oh</p><p>开题！</p><p>好好好，T1 不会啊。</p><p>想先打一个拍子，因为往年 T1 都挂了，想了个 $\mathcal O(n {\log_3}^2 n)$ 的做法。</p><p>诶不对可以少一个 $n$ 啊，好好好正解出来了。拍子是什么，不打了。</p><p>开 T2！</p><p>诶 T2 做过强化版原题，是洛谷秋令营例题还是作业来着。</p><p>哦哦原来 T2 是沙比题！会了！还是直接贪！</p><p>开 T3。T3 怎么又是模拟。调调调，过了！</p><p>开 T4！啊怎么这么简单，看错了吗？</p><p>好好好一遍过小样例。大样例炸了！哦会优化了，过了！</p><p>0.8s，有点不太稳，卡个常卡到了 0.7s，应该可以了。CCF 能卡掉这个我和他爆了！</p><p>十点半准时 AK，开始野餐！</p><p>吃了个巧克力，饼干开不动袋子。野餐进行了一分钟后结束了。</p><p>无聊啊，睡觉吧。睡不着，监考还以为我生病了还来问我。我：我全写完了。监考 &amp; 周围同学：？没见过这么拽的。</p><p>哦哦咖啡还是能抵抗睡觉的，好想此时此刻听数学老师的课，就能分分钟入睡了！</p><p>次你 @<a href="https://www.luogu.com.cn/user/744687">Coffee_zzz</a>。</p><p>摆了摆了。去上个厕所吧。</p><p>为什么大家都知道游戏在哪里，我不知道啊&#x2F;ll</p><p>然后就稀里糊涂过了一个小时。最后半小时闲的没事干，题面开的非常大重新读。</p><p>草，读完了发现 T4 忘记判无解了。</p><p>最后 10 分钟火速改掉。</p><p>结束啦。</p><p>怎么收个卷收这么久。fk。</p><h3 id="Noon"><a href="#Noon" class="headerlink" title="Noon"></a>Noon</h3><p>去老地方吃了个饭，吃完火速回 scz 面基。</p><p>@<a href="https://www.luogu.com.cn/user/400269">Shiota_Kaede</a> 还是那么漂亮，JY 小姐姐嘿嘿。</p><p>@<a href="https://www.luogu.com.cn/user/419487">irris</a> 看到 irris 力。</p><p>和 JY 小姐姐还有 irris 合了一张影&#x2F;tiao</p><p>和 @<a href="https://www.luogu.com.cn/user/183722">EasonTao</a> @<a href="https://www.luogu.com.cn/user/398789">Anny1225</a> 也合照了，拜谢未来江苏省队和未来江苏女队。</p><p>在等进考场还看见了好多无锡 OIer。拜谢。</p><h2 id="Afternoon"><a href="#Afternoon" class="headerlink" title="Afternoon"></a>Afternoon</h2><p>进考场！</p><p>还是打了对拍程序，虽然上午下午都没用上。草。</p><p>T1 水啊。</p><p>T2 看了一会儿线性做法会了，但似乎写起来很复杂，算了打了暴力跳了。</p><p>T3 模拟啊，写一写。一写从三点多写到六点。</p><p>。。。</p><p>关键是只过两个小样例，样例 3 RE 了，但没时间查了。</p><p>听天由命吧，希望 CCF 数据不会太强。</p><p>。。。</p><p>T4 没看部分分，输输输。</p><p>预估 $100+50+[0,100]+0$，输麻了。</p><p>EasonTao 出来大喊说是最简单的一届。</p><p>人均 AK，我太菜了。</p><p>说实话去年的我打这个卷子可能都能拿这么多分，一年白训了&#x2F;ll</p><p>别问 S 组怎么写这么少，因为 T3 写了一坤时还挂了根本没有好说的。</p><p>菜死了。还好 J 在小图灵和洛谷测都 AK 了，应该没问题。还好 J AK 了，S 寄得太惨也有个安慰。</p><p>妈的，今年不会蹭不上蓝勾吧。</p><h2 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h2><p>上午发现别的地方出成绩了，急急急，江苏别的地方也发了，急急急。</p><p>负责人在干啥啊？？？建议下次负责人写我，我 24h 在线。</p><p>找教练，教练说没发下来，看来负责人真的在睡觉。</p><p>看到南京也出了，更急了，直接疯狂骚扰教练，要到分数了。</p><p>J 400</p><p>S 155</p><p>都是意料之中。</p><p>怎么人均 300+ 啊，紫砂了。</p><p>@<a href="https://www.luogu.com.cn/user/500200">panrui_CFS</a> 好强，235，我校最高。没记错的话好像从省选打完到现在退役半年了吧，强。</p><p>中午找梦熊要了 AK-Star 奖金。100 CNY，赢！</p><blockquote><p>和 @<a href="https://www.luogu.com.cn/user/183722">EasonTao</a> @<a href="https://www.luogu.com.cn/user/398789">Anny1225</a> 也合照了，拜谢未来江苏省队和未来江苏女队。</p></blockquote><p>前后呼应了属于是，EasonTao 是前年 CSP-J AKer，Anny1225 是去年 CSP-J AKer，我是今年 CSP-J AKer。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ei5whc8g.png"></p>]]></content>
      
      
      <categories>
          
          <category> TravelNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20230818 | CSP2023 考前模拟赛 做题笔记</title>
      <link href="/archives/20230818_mock/"/>
      <url>/archives/20230818_mock/</url>
      
        <content type="html"><![CDATA[<h1 id="赌徒"><a href="#赌徒" class="headerlink" title="赌徒"></a>赌徒</h1><p>数学题，分类讨论。不多说。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">gmx</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">max</span>(x, y); &#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">gmn</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">min</span>(x, y); &#125;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;ll a, b, c;cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<span class="keyword">if</span> (!c)<span class="keyword">return</span> <span class="built_in">puts</span>(!b ? <span class="string">&quot;Ivor&quot;</span> : <span class="string">&quot;Harper&quot;</span>), <span class="built_in">void</span>();<span class="built_in">puts</span>(a + b &lt;= c &amp;&amp; b ^ c &amp;&amp; b || (b % c &amp; <span class="number">1</span>) &amp;&amp; !(c &amp; <span class="number">1</span>) ? <span class="string">&quot;Harper&quot;</span> : <span class="string">&quot;Ivor&quot;</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;gambler.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);<span class="built_in">freopen</span>(<span class="string">&quot;gambler.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);<span class="type">int</span> x;cin &gt;&gt; x;<span class="type">int</span> t;cin &gt;&gt; t;<span class="keyword">while</span> (t--)<span class="built_in">solve</span>();<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="残片"><a href="#残片" class="headerlink" title="残片"></a>残片</h1><p>没改好。</p><pre><code class="highlight cpp"></code></pre><h1 id="护手"><a href="#护手" class="headerlink" title="护手"></a>护手</h1><p>没有强制在线，我只用莫队！！1</p><p>首先你会发现这道题长了一脸莫队的样子，区间询问又是可以离线的。</p><p>然后你直接拍一个莫队上去，会发现 $T&#x3D;0$ 奇数分是很好拿的。因为我们知道 $x \oplus x&#x3D;0,x\oplus 0&#x3D;x$，那么奇数次出现就是区间所有的异或起来。只拿这个分甚至可以维护前缀直接异或直接 $\mathcal O(1)$ 回答问题。</p><p><del>但事实上我考场是凑了半天发现不用判断是第几次出现直接异或就可以的。</del></p><p>然后你考虑偶数的怎么搞，你想，区间里非重复元素的集合减去出现奇数次元素集合不就是出现偶数次元素集合吗！</p><p>所以你维护某个区间去重之后的元素的异或，把偶数当成奇数做，最后和上树的去重元素异或异或一下就好。</p><p>去重元素异或维护很容易，统计每个数出现次数，删去之后全都没了和加上之后是第一次都异或起来。得分 $83\ \text{pts}$。</p><p>怎么回事呢？</p><p>考虑进行卡常。</p><p>我们会发现我们 <strong>不在意每个数具体出现多少次，只在意他前面和后面出现的位置。</strong> 因为我们只需要判断是否在区间内出现过。</p><p>考虑维护 $pre_i$ 表示第 $i$ 个位置上一个与其相等元素位置，$nxt_i$ 表示第 $i$ 个位置下一个与其相等元素位置。</p><p>然后莫队区间移动只需要判断 $pre,nxt,l,r$ 的大小关系了。本地测试最长点耗时 $1.7\ \text{s}$。</p><hr><p>再插一嘴，你要是 $nxt,pre$ 或者是 $83\ \text{pts}$ 做法维护的数字出现次数的数组，用 <code>map/unordered_map</code> 是真的要死。<code>map</code> 稳定 $\log$，<code>unordered_map</code> 均摊常数实则会被卡到线性。</p><p>你复杂度再乘上一个 $\log$ 你卡的过去？？？</p><p>离散化，离散化，离散化！</p><pre><code class="highlight inform7">#include &lt;bits/stdc++.h&gt;using namespace std;#define getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++char buf<span class="comment">[1000000]</span>, *p1 = buf, *p2 = buf;inline int read()&#123;register char c = getchar();register int x = 0;while (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;)c = getchar();while (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48), c = getchar();return x;&#125;int n, Q;int a<span class="comment">[800020]</span>;struct node&#123;int l, r, t, id;&#125; query<span class="comment">[700020]</span>;int ans<span class="comment">[700020]</span>;int b<span class="comment">[800020]</span>;int p<span class="comment">[800020]</span>;int mp<span class="comment">[800020]</span>;int pos<span class="comment">[800020]</span>;int fa<span class="comment">[800020]</span>;int pre<span class="comment">[800020]</span>;int nxt<span class="comment">[800020]</span>;int len;int ANS, X;inline bool cmp(node a, node b) &#123; return pos<span class="comment">[a.l]</span> ^ pos<span class="comment">[b.l]</span> ? pos<span class="comment">[a.l]</span> &lt; pos<span class="comment">[b.l]</span> : pos<span class="comment">[a.l]</span> &amp; 1 ? a.r &gt; b.r  : a.r &lt; b.r; &#125;int main()&#123;freopen(<span class="string">&quot;gauntlet.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);freopen(<span class="string">&quot;gauntlet.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);register int subtask;subtask = read();n = read();Q = read();len = sqrt(n);for (register int i = 1; i &lt;= n; i++)a<span class="comment">[i]</span> = b<span class="comment">[i]</span> = read();sort(b + 1, b + n + 1);register int m = unique(b + 1, b + n + 1) - b;for (register int i = 1; i &lt;= n; i++)&#123;register int j = lower_bound(b + 1, b + m + 1, a<span class="comment">[i]</span>) - b;p<span class="comment">[j]</span> = a<span class="comment">[i]</span>;a<span class="comment">[i]</span> = j;pos<span class="comment">[i]</span> = (i + len - 1) / len;&#125;for (register int i = 1; i &lt;= n; i++)&#123;nxt<span class="comment">[i]</span> = n + 1;pre<span class="comment">[i]</span> = fa<span class="comment">[a<span class="comment">[i]</span>]</span>;nxt<span class="comment">[pre<span class="comment">[i]</span>]</span> = i;fa<span class="comment">[a<span class="comment">[i]</span>]</span> = i;&#125;for (register int i = 1; i &lt;= Q; i++)&#123;int l, r, t;l = read();r = read();t = read();query<span class="comment">[i]</span> = &#123;l, r, t, i&#125;;&#125;sort(query + 1, query + Q + 1, cmp);register int l = 1, r = 0;for (register int i = 1; i &lt;= Q; i++)&#123;while (l &lt; query<span class="comment">[i]</span>.l)&#123;ANS ^= p<span class="comment">[a<span class="comment">[l]</span>]</span>;// del(l++);if (nxt<span class="comment">[l]</span> &gt; r)X ^= p<span class="comment">[a<span class="comment">[l]</span>]</span>;l++;&#125;while (r &gt; query<span class="comment">[i]</span>.r)&#123;ANS ^= p<span class="comment">[a<span class="comment">[r]</span>]</span>;if (pre<span class="comment">[r]</span> &lt; l)X ^= p<span class="comment">[a<span class="comment">[r]</span>]</span>;r--;&#125;while (l &gt; query<span class="comment">[i]</span>.l)&#123;l--;ANS ^= p<span class="comment">[a<span class="comment">[l]</span>]</span>;if (nxt<span class="comment">[l]</span> &gt; r)X ^= p<span class="comment">[a<span class="comment">[l]</span>]</span>;&#125;while (r &lt; query<span class="comment">[i]</span>.r)&#123;r++;ANS ^= p<span class="comment">[a<span class="comment">[r]</span>]</span>;if (pre<span class="comment">[r]</span> &lt; l)X ^= p<span class="comment">[a<span class="comment">[r]</span>]</span>;&#125;if (!query<span class="comment">[i]</span>.t)ans<span class="comment">[query<span class="comment">[i]</span>.id]</span> = ANS;elseans<span class="comment">[query<span class="comment">[i]</span>.id]</span> = ANS ^ X;&#125;for (register int i = 1; i &lt;= Q; i++)printf(<span class="string">&quot;%d\n&quot;</span>, ans<span class="comment">[i]</span>);return 0;&#125;/*inline void add(int i)&#123;mp<span class="comment">[a<span class="comment">[i]</span>]</span>++;ANS ^= p<span class="comment">[a<span class="comment">[i]</span>]</span>;if (mp<span class="comment">[a<span class="comment">[i]</span>]</span> == 1)X ^= p<span class="comment">[a<span class="comment">[i]</span>]</span>;&#125;inline void del(int i)&#123;mp<span class="comment">[a<span class="comment">[i]</span>]</span>--;ANS ^= p<span class="comment">[a<span class="comment">[i]</span>]</span>;if (mp<span class="comment">[a<span class="comment">[i]</span>]</span> == 0)X ^= p<span class="comment">[a<span class="comment">[i]</span>]</span>;&#125;*/</code></pre><h1 id="无量"><a href="#无量" class="headerlink" title="无量"></a>无量</h1><pre><code class="highlight cpp"></code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 常州市程序设计小能手 2023 做题笔记 | CZOI 2023 做题笔记</title>
      <link href="/archives/CZOI2023/"/>
      <url>/archives/CZOI2023/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>初中了没法打小学生比赛了。膜拜小学但是吊打我的巨佬。但是虽然初中仍然能写炸 T1 并且只能口胡到 T2。</p><h1 id="T1-矩形纸片"><a href="#T1-矩形纸片" class="headerlink" title="T1 矩形纸片"></a>T1 矩形纸片</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://czoj.com.cn/p/P1672">http://czoj.com.cn/p/P1672</a></p><p>来源 <a href="http://czoj.com.cn/">CZOJ</a>。</p><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>题面中的 $10^9$ 完全吓唬人用的。</p><p>考虑到 $1\leq a,b,c,d,x,y\leq 1000$，最暴力的方法开个 $2000\times 2000$ 大小的数组存每个位置是否覆盖。</p><p>时间复杂度 $\mathcal O(a\times b+c\times d+2000^2)$。</p><p>或者考虑容斥，用第一个的覆盖面积加上第二个的覆盖面积减去重合面积。特判如果 $(x,y)$ 与第一个纸片没有重合就没有重合面积。</p><hr><p>Solution by @<a href="http://czoj.com.cn/user/6">cyx2009</a></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> a,b,c,d,x,y;    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;x&gt;&gt;y;    cout&lt;&lt;(a*b)+(c*d)-(x&gt;a||y&gt;b?<span class="number">0</span>:<span class="built_in">min</span>(a-x<span class="number">+1</span>,c)*<span class="built_in">min</span>(b-y<span class="number">+1</span>,d))&lt;&lt;endl;       <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><hr><p>Code by @<a href="http://czoj.com.cn/user/6">cyx2009</a></p><h1 id="T2-奶牛农场"><a href="#T2-奶牛农场" class="headerlink" title="T2 奶牛农场"></a>T2 奶牛农场</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://czoj.com.cn/p/P1673">http://czoj.com.cn/p/P1673</a></p><p>来源 <a href="http://czoj.com.cn/">CZOJ</a>。</p><h2 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h2><p>考虑贪心，对于每个为 $0$ 的位置只设置比前面高 $1$，尽可能的让后面的位置选的高度数量更多。</p><hr><p>Solution by @<a href="http://czoj.com.cn/user/6">cyx2009</a></p><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n;<span class="type">int</span> ans[<span class="number">100020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin&gt;&gt;n;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        cin&gt;&gt;ans[i];        <span class="keyword">if</span>(ans[i]==<span class="number">0</span>)ans[i]=ans[i<span class="number">-1</span>]<span class="number">+1</span>;    &#125;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        <span class="keyword">if</span>(ans[i]&lt;=ans[i<span class="number">-1</span>]||ans[i]&gt;<span class="number">1000000000</span>||ans[i]&lt;=<span class="number">0</span>)        &#123;            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);            <span class="keyword">return</span> <span class="number">0</span>;        &#125;    &#125;    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;    &#125;    cout&lt;&lt;endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><hr><p>Code by @<a href="http://czoj.com.cn/user/6">cyx2009</a></p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC162D RGB Triplets</title>
      <link href="/archives/ABC162D/"/>
      <url>/archives/ABC162D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><blockquote><p>有一个长度为 $n$，且只由 $\tt R,\tt G,\tt B$ 组成的字符串 $s$，求有多少个三元组 $(i,j,k)$ 满足：</p><ul><li>$1\leq i&lt;j&lt;k\leq n$。</li><li>$s_i\neq s_j,s_j\neq s_k,s_i\neq s_k$。</li><li>$j-i\neq k-j$。</li></ul><p>$1\leq n \leq 4,000$。</p></blockquote><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>暴力枚举 $i,j,k$，但是 $\mathcal O(n^3)$ 超时。</p><p>考虑优化，我们枚举 $i,k$，可以通过前缀和预处理出这一段中 $s_j\neq s_i,s_j\neq s_k$ 的个数。</p><p>然后考虑性质 $j-i\neq k-j$，不难发现对于每一对 $(i,k)$，最多只有 $1$ 个 $j$ 使得 $j-i&#x3D;k-j$，而且这个 $j&#x3D;\frac{i+k}{2}$。</p><p>那么我们特判这一个特殊的 $j$ 即可。</p><p>时间复杂度 $\mathcal O(n^2)$，可以通过。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;R&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="keyword">if</span>(c==<span class="string">&#x27;G&#x27;</span>)<span class="keyword">return</span> <span class="number">1</span>;<span class="keyword">return</span> <span class="number">2</span>;&#125;<span class="type">int</span> h[<span class="number">3</span>][<span class="number">4020</span>];<span class="type">int</span> n;string s;<span class="type">long</span> <span class="type">long</span> ans;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin&gt;&gt;n&gt;&gt;s;    s=<span class="string">&#x27; &#x27;</span>+s;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)h[j][i]=h[j][i<span class="number">-1</span>];        h[<span class="built_in">id</span>(s[i])][i]++;    &#125;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        <span class="keyword">for</span>(<span class="type">int</span> k=i<span class="number">+1</span>;k&lt;=n;k++)        &#123;            <span class="keyword">if</span>(s[i]==s[k])<span class="keyword">continue</span>;            <span class="type">int</span> x=<span class="number">3</span>-<span class="built_in">id</span>(s[i])-<span class="built_in">id</span>(s[k]);            <span class="type">int</span> tmp=h[x][k]-h[x][i<span class="number">-1</span>];            ans+=tmp;            <span class="keyword">if</span>(!(k+i&amp;<span class="number">1</span>)&amp;&amp;<span class="built_in">id</span>(s[k+i&gt;&gt;<span class="number">1</span>])==x)ans--;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1829 做题笔记</title>
      <link href="/archives/CF1829/"/>
      <url>/archives/CF1829/</url>
      
        <content type="html"><![CDATA[<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABE0AAACICAIAAACdl4JiAAAgAElEQVR4Ae2dC3RV1bnvZ3jIFhMeQppIYh4GEXmVYiHCgaRRLGPQNo1m9JLKsIn13J6OVg+1p9ci9cTd1CJ6ztVL9XT0tscDOd544nUEI+1hDGpqboIHDLSUgiAgkBATSEp4JuLmmfvNOddca661136Sx97Jfw0GWWs+vjnnb+2drG99j5nQ29vb2trKcIAACIAACIAACIAACIAACIBA/BPIyMigRYwKtJAxY8aMHTv2pptuGjVq1MiRIwM1QzkIgMDwJEDvR+QvkeG5fKx6KBHAhzkW7ibuQvC7AD7B+aBWJzAcPi3XxHH58mWfz3fx4kV9+fq5i55Duo1HHKNHjx4xYoTeGucgAAIgAAIgAAIgAAIgAAIgMIgESEOhg4wxpLaQbeazzz67cuUK6T6OKTn1HOqTmJhIag7ZcBISEhytcQkCIAACIAACIAACIAACIAACg0hAKin0P1llSGchbae7u9vfsOM010hLDqlHUHIG8eZhaBAAARAAARAAARAAARAAgeAESGEhPYdMOqTC+Ld00XPIpOPfDiUgAAIgAAIgAAIgAAIgAAIgEIMEyLDjPyunSkOWHP9GKAEBEAABEAABEAABEAABEACB2CTgaqdx6jkIy4nNm4dZgQAIgAAIgAAIgAAIgAAIuBJw1XOc1htXo4+rOBSCAAiAAAiAAAiAAAiAAAiAwKATIFON/xyc9hz/FigBARAAARAAARAAARAAARAAgfgiAD0nvu4XZgsCIDBkCXT8RzHljaGj+D86huwisTAQGCYE2t4wvs8/2zFMVoxlgkAMEoCeE4M3pS+mZP6GpYcm/ZfsBz8Xz1EJP/+gL0aBDBAYzgTUt0n/ipm6il6442fyawcFZjh/XMJau/X5MT4y9KP4jbaw+g7PRiYxvB0Ynh8ArBoEghOAnhOcz5CoLf9n/JkcEjcSi4gxAunZD8kZlb+nXth2vPf2JmOW+5qVUaajeZ8se6h4SWqQNaR+s6ZXHDXfNJopBQlPukGwDZmqHfQW6raH6fPzUNUn8oPQe/IN+ohtWrnB+Hz17efB1BDw2utGP0Pmi0X9reKNCkV/EACBPiAAPacPIMa8iE0rf/iGeuSK+cligiAQLwTS7yv+hpzr7mbjjXtz81tq9m/VvOco/EbxfemqFj9BwE5gx88WPSNKHnrjXx5WnxOh+m5/zt4SVyAAAiAAAmESgJ4TJqi4bVbxHP8b+dbK1wI4qpmv9CwviYSfq5fTfNXaG8SON/6bamW8teIvIOXh5zOgNRYt8Mowbj9DmHggAqnZs2XVJkPPaWvebbX1K5ydbZhplMMbfWvUF1B86bRyxvg3aFG5IX/l7eJb9N+sFxaqo/EFdHOTIyuQ+hqar5nNF8+qX4Im05o7zgaagGn0Y/PUx0RNYeFP/nFhkM+D85PA72yo3+E/20G/2IXtiA/yzEL5abD1UqMPiZ/qm2V86vXPvKrSvoyCoP0vpg3yz35u/OGTckjC7SsNM275IgOlvTtTo1Ct39/KIUEYiwCBWCUAPSdW70yfzeu+x7jnA3vmJesJySm7YrvhJNF7soq/n35mkf3PpGi/aeXt32cv9fZ+UsXFGb/N37uvV3pWsE0P32ZpMvxZ6raVbynvix1c1aI/pfj9Lkjiv6FDYOEDxqv23cJJrWNbDX/cqdi+vYKvURaytmb5DPTcA/S0ajvoW2M+a9oq+EXqw/+3V8qxHJn+78NCU+LaC3V86I2T4psr3vfTV1J/euMS6DtLX0N+Zhzqgey5HeobL7/Oqh4/B4+AqTMLrcPUS60JBfk88I+cuqPBf4dbn4eF/2j86qYR1OfhJ84PqDV6HJ/xV3ULn1GIBJ+3Vt7m9zeOvozfZ/9CGOWX7pmFlrMoKTnye2qAeoBJy5sB5d6fGH8W6VrdiJ/cqxGj7+a79KfS7W+l1gqnIAAC/UEAek5/UI0tmanf/FEQkw73i+AvC+WR+vAP5XPbM+85Xkdxl/Ea7k2Rnj1Ptv1G1cle/ncxdUkx13zMpzp6D/1D8XKr4keG98W9jwn1iW16+70O2Rf/g8DQIHDvffILs+lIMy2o+QjXaB6amp09lX8n5Ad+x7uGO1K2ckYyl64UFXoEiuARs+M/vi+0l+d+ZITxLJTvMpjlKSdHUC8aSLw0CLwkZ/LcfeZDWPrDNYbuZE4KJ4NDYOGj4hWSHFyZBej1v/X+KMC8IvkdTh8FcVi/8wMIHTLFH/xcGEUfqnpU/pkL+DeOvowyLk69vNhUs038vWp74/s8aIqxb1Q9Jr846lsfLiRSfgRw82/lM+/qPhPhikE7EACBKAhAz4kCWtx1MR6DApp0dFcWeu8lDuNVdCRrlY96rO29GvkK2fpTrV4ivtXMHwZxgMDQIZCdLUN0eNaBHe9xNzOebMB4oOEfeOWP1GfBOWaqA7K7GocyCilPuRB4jY4hH6BDiEF13xIgndOwqNvkcqcyF/OOrQ3ro9/hdqFD4Uq9ZSDbpvq2RPo3TtljH3rwPmFNHQpYsAYQGD4EoOcMi3ud+s1/4RaVt1Z+/6Xd9gUL933hW2y8WhY+ZvY2EV6pvwqmBV+9QqSfEby0jnBUNAeBQSGQet+DwpxJtpQPZHDOPG63McyelJ9AZSYwg3NudJpKIHvO9FUyv2I2bxnnQKkPv6RZDMyojJDP0E45uO4/Atw5TR1a+gEroZ//0P3wO9x/kHgtUW8ZtBR2Cm+vmdUw+OI69Ji74E1RCwIgEHsEoOfE3j3plxkZxvpNb8lIATWGaXup2B7mL33VM/BPM9lu4CaoAYEhQyDVcOTc1PyuiMP5RnY2X9vC+yro/001G96Trxb8g3OiJaAsSFH05xYDFWJndkfeeRNFbJ0s/EmvqeqQwhxgcv3xOzzAUHFYbEU9xeHkMWUQAIE+IAA9pw8gxocIFSRjm62yvVBEga38Ri7MAJ5g7yBvZAD0BYFYIqCc9Z8p5z6fpnOLEaJT/ox4taCFxNzo3M1HN/8guvBES21HxVuH1wet+psAmWWCpDsTRkLXKfTH73DXgeKzUH4N+RsHGWwT+SrMoBrDMTtyCegBAiAwiASg5wwi/AEe2oy/1MZVj2gqQ0DHG0akstYm4tOFPzGc355ZpCWA4klvtMuIpaIDCMQoAZuBxUwKrOw8YtKGkSfiBZgh0frr/IX/aLzm11NCicS1VoYot5F4FngtJke59PRZ4JDbmCiLgICIm9LcCM0ddZ7bYXj8unwebuB3uPkEH0U0ZgTLGtSmhs82KTrOjKD6dyHoFM1tskzL5wfvGWGsZj+zjbU7sFmHExAAgcEkAD1nMOkP9NguJp2FP5GJZXmeTTq+zx6U6aNubGqUZ1MG1BpiuWhKemO+6r4x6egNAjFFQIXo8Ek9ZCVVUw+gvDTqCOZ7f3JS5oWXO5wYbwrIo0nmqLVHV4ehsaidUugbybOD8Kg85FuLiU+Tip6y0reI3ZNEnmIr7Mrl83ADv8PJsifeSZEOwH9H+6VajgkwYU9CrUIshf4zviwi5EntbWDU8ZDU8E2sZkZv9XV7lxl/Jq2gO2oj3j6oP3naC4WwF4CGIAAC/UAggby1W1tbTckZGRnmOU5AAARAIBAB+r2BXxeB4KA8vgjgwxwL9ytu7gJlt1PJe/osrjWMGxA3fMJYC5r0N4Fh+2mhhZts5SMK7DkmEJyAAAiAAAiAAAiAgI0A7ROqp/besUFsEMfMDaxsjXEBAiAQUwRGxdRsMBkQAAEQAAEQAAEQiC0C5E/Id8dSh9r6U13jJwiAQIwSgJ4TozcG0wIBEAABEAABEBh0AqnfrOn95qDPAhMAARCIhgD81qKhhj4gAAIgAAIgAAIgAAIgAAKxTAB6TizfHcwNBEAABEAABEAABEAABEAgGgLQc6Khhj4gAAIgAAIgAAIgAAIgAAKxTAB6TizfHcwNBEAABEAABEAABEAABEAgGgLQc6Khhj4gAAIgAAIgAAIgAAIgAAKxTAB6TizfHcwNBEAABEAABEAABEAABEAgGgIJvb29+u6h0chAHxAAARAAARAAARAAARAAARCIDQIZGRk0Eef+OSkpKbExPcwCBEAgpgl0dnbi10VM3yFMLmwC+DCHjaofG+IuBIdLfLoTO4K3QS0ISAJJPanD8w80fU0cnwH4rTmA4BIEQAAEQAAEQAAEQAAEQCDuCUDPiftbiAWAAAiAAAiAAAiAAAiAAAg4CEDPcQDBJQiAAAiAAAiAAAiAAAiAQNwTgJ4T97cQCwABEAABEAABEAABEAABEHAQgJ7jAIJLEAABEAABEAABEAABEACBuCcAPSfubyEWAAIgAAIgAAIgAAIgAAIg4CAAPccBBJcgAAIgAAIgAAIgAAIgAAJxTwB6TtzfQiwABEAABEAABEAABEAABEDAQQB6jgMILkEABEAABEAABEAABPwIdB55bXbjlr1+5SgIkwAAhgmq75qN6jtRkAQCIAACIAACIAACIBArBM5t2bn+xz59NvOr8pbP0QuiPu/Z9Q+7t7Apq/7n1AmRy2j+343//uqEb+2bkx153yHTg0M4HCXAIQOhvxcCPae/CUM+CIAACIAACIAACAwWAc/yugXzU8Toe/f+dGXjyRfmPbY8cbBmg3FBYCAJwG9tIGljLBAAARAAARAAARAYJAJz5nzrcdb242PNfTB+4vz/mfdsVMYcGjz77/KeHd7GnD64AxARBgHYc8KAhCYgAAIgAAIgAAIgEP8EJt7uYczX1cmyU5jhN/UUq1l6oo2W9vi0Z/8ulS+RwkhkCb8I6F1mc7sSXW6rmpdcuXvL73k39mXhkcUtSOfENUvX7EjCoc6j/NY6tsw+TFamYnZAedlpNijGnN53UrIUypx958s5OBzqxDQC+exFw0FbF5+IQmdjwiuEd980BZaXGAdv+Sqdn1g/+wQvMhYl2kuAvNTGgRfgiJAA9JwIgaE5CIAACIAACIAACAwNAr8/sZ5Ugn15VoyNUgkeE2E8/HF89l6lkIRY866VB5bXkZGHmnH1gz/B0+P7vjlcOBd7YNc9yoPOT1Lbj3fXvDDv2X3coY4PunTvZM3go6koXBNY/w9MjwvS+3LBpRO2rDzzcSczvPVI4I5zNJNFQQKTIuKgEKlIp44t/9BDypzF0G91/gVk0foWc8TnqJCnfUbIEyl42zsZkz6H/iJQEgYB+K2FAQlNQAAEQAAEQAAEQCD+CZz9xMe+fOud5qOzzTZCy+vYsvIcGV7UEzw5mE2bz859FF6OtflVphqTevfjpo1CUJvzufnMt/dPPYEQ6tae7IWkMnCjkzwmLF9gzoexxDvv97DfXzyrCdL78mIx1pbaDqNJ55H3XmXp96cG00Mi4eCnNaUuj9Z/T1sEmdE69v6ezS+18jrYF25ri4swCUDPCRMUmoEACIAACIAACIBAHBMg+wD5SulP0s7F7P3rLuaZc4+epSAx+cvsZFtA/cQpoc+ufaeUnsNFkglldqP8J3zbLC3IbcDURS942Kt/lWFI5/50po1NuC+i1AtBOXDfP7L//G+lR7nNIJqylMTbGNu1cucufeHRCEIfiwD81iwWOAMBEAABEAABEACBoUXAt2Vp4xZjSRTvkWd6cwVYpt5eNZlGeo6u/KjygfhphKyYrmsiXCfEwBPuuTWdnXhvS89jy3u2U2btxzMiT2AdkAOZWb71CUXXHP7pq4fFPPoqiiZ1eV3PyaUnrPulwn5CrBbVgQlAzwnMBjUgAAIgAAIgAAIgEN8EIn0Kj7R9P9PZe4wSG5hKTriDpUy97/ET//6HjnPpF8lCtbxI5FcIt7NsF4wDzxf3d7IZj0TaYo8mimwcvXXK1Mf2TZUFQp07/NrtiUgCrhOK9Bx+a5ESQ3sQAAEQAAEQAAEQGIoEQkXRDNKaPclmQFHYM+BBPuRdRtneHs8IZcLyExoBh9TlVVY0kXBps8UO+YkOt2DC8hnLv8zaPhl4j8FwZxgX7aDnxMVtwiRBAARAAARAAARAoL8J8MgWSl+2RUs8QIYF/bK/Z+CU71A59u5VuaedDZ3Xc+4gPYGO+QujMOYE40Dp4HQgIi2BkdphQjql7TbTNjiSRDsnKJQinhfOOCg39z8cOaeujLQE0UzeFIETBr81fAhAAARAAARAAARAAAQ4AQo+efYe2j+n8acWD9pCx7oY8DMetfLa0t0//bEY+fFpq17wrZfnIaaSOHkatQiaTjqwhCAcyFL07ysbd5l99Vxtc+asemHneqOWPN/mLWe7VXCU2cE4MeJ8ZPQUF5I6h+02ttMRTSL21nOOgGuW0Nvb29raapJISYncNGh2xgkIgMCwIdDZ2YlfF8Pmbg/xheLDHAs3GHch+F0gPt2JfZ3gK/iQcV9rbCE6DONbknpSh+cfaPqamB/bjIwMOoc9xwSCExAAARAAARAAARAYCgQunrvyT0t2DIWVRLWGZ/flndvSuotN+JZIJ00JqaMSExOdFj92+/0/iDxdXEzMffAnMcz1nKZ1nvw9lcerV4Rlxep8sySztJbftOKNx6tKwuoz+Ld4sGYQGduBmaW8g0Vh3/GBmZUcpWmtJ7+CeRt9qxcM5LAYCwRAAARAYAgSGDthND3rD8GFhbukDj2d9PBGES6yIdkuPvMQtFeXePSjpLq9/+/OznWZpWzjUR8/YlXJoWdlx1HypmXC639GEY6wc502W9tNJIVEq7JO/ZfDl7y2KayB26tXldaSImGqtW6jrHPKEh82/3HDGjFII7F2XWzuGl9DOfPm+U0giBBUgQAIgAAIgAAIuBBIXb6PUj9HkYHARRaK4pdA/Ok5/Lk2p2xuo9A3xH/HK1lZjmfdzv69C011XlZcVJDWv6P0hXRvg8mm0VtbmhmuGtAXY4cvg+sYeXsMvdHnc9zElBXV5iKMk0YvCZ+bbbeitVe/XBHmmJ3VT5XVFm981GktKTLnQAM1lHvzPR5d/QhTemTNSHfK8/p3yV3T4GXel2NZNfWfNEpAAARAAARAAARAICYJxJues3Odv28PfyY+ujFrAPjOdDxlD8CQNzbEgtVkImAV9U4bxY1J7YvenfWba1n5kyVKb0xZsX5jMfPWBZppZ/V60jM1LUXagnLKhB9hGDPauaGshnlXhfA2JKOKTyiHlqqTVkIql2kCCmOkkE2ExlXu9bo0zH20sqi2dEMgCi49UBSbBHZu2+zZbPxbubtLTfLwWl64LdqXMhF1l43NaWx905yFmg1+ggAIgAAIgMCQJhBfeo7fw655b9JKSqz39J3VKy1PJ6edx+bzlu81JagT3fXLfNilQtKvWAW96+eHKdO1sZBE0SncLGB6RqkutrmRJOuJ1jYxrZzE2fy7wnbTUity/Aw4ZzEBNU/RiY9ruZPxjiurO7V5mnyMIbQqj8eFrWMmbH9zp7MowLW/lrJgtbDzHCftKJxDmOM0NSlIH6EcasqGcSt5D3EjbIgYM7AEEWivalqbWcY2Hl9TYC82rlIWFxUxb320z8GuMlE40ARIyck7aw1a07ZdU3Ws8n48O7zNs/mg3dR5qXT75oGeRj+uEKJBAARAAARAICSBuNJz2utra1hRYYHddcmxRnoqzSybqVy3Gr3ePEst4c+pNp83chPSD66E5O/feFx6Sh3dyEoz5aO8jJ3g6QdElYgUD9jYlEg+Y6vYeilMdBFzo2dcWcS9pPY0y8gi+8SE95RSdagqz0tRJepo8IavHrDO5v2UNSEry5hT6Dmbk3c/qSnLfEotSdg9rId++xJocV53EbI0paCwiJE0U9PjmkzRxtJc104RaCmu/SWHsM1xuUu9jKlbowtcUEAVNqOTcJwLaSYyZZDem1/hbQgS35VWUBTMrmVKwknsEjhcx5WcMZWLCn2FhUfTx9BFzalW+U2/sVlPW1NIMpdY73RcxXXtXnmQz6A4fRFNQPxbVMlnwWraPoIK7coMhSAAAiAAAkORQFzpOeIGOCM07Hel882XKcKhYY16XF6w+nhlkYrtFuag8oZA+aw631xVVqM9g6aVrCcnos317jYH+Vz+ovKDIu8m/ty/Ss+I4MjrZcxNe8bNXVMtHLea1uV5qbE5MRmnIV/q+z3i567WJNhX77wSKyraaE4yjDk7RTiu9URz4qF/j2GSCcHWIYYupbch2S4MG1kea/BJGn5tI9Ql/PpTQUsLOa0tVZ8KtxZ+ZbUtLg+m3K9M9wPsfL+2lnkLQjx3KtlGKovVQeeRkj1TtcfPeCZwaXMrdxRLm7eMaxrL5ikXTX1NdteybYd5HWkp5Nu2dbf6+HW9uZX7nq3llU6/Nd07TjTgAtpbT9XQj4nTq+ZN5tf8mLzinvRirnqF0pFkc/wPAiAAAiAAAkOBQPzpOUGpy6iPAv05MiV7rvFuXpiDAj/sBuhb09LiNqRLWoK0rCLm+nAs+7vINwTvrPeyoqLFKdo4WVnFZFDgGlZWjrB7hJlSjItQmoPHk7m56LimPEQ+Z21GAU5rj7bwmhBs3Tpz+09tkchfx4OI+LQtHzm9Q1Ola/4AvcnAndv9ygLfU/8ZkVMf12bXmyFJ/k1kCb/jEZjsAolB+aARmLZ0Ih+b3NWUfuI6FVJg7K5lZw9yXWVyRiHZXi6del+G03S1br5ExqH0Ur6tt+1weMdVHJS6EGv/lDqw8hR7h8nzqgqXrTAVH5skXMQeAe4ua1nL+2Z+3J7vdDbuG8mQAgIgMNwJXLt2fXtT8z+u3fqVhzfOX7Luu3//H3X1B69cuTboXOJPz1EGhLDRhVA/7HJUBA4F4fAjz+vuv2TvZFylSY3K3fzj2kMrrKWUcdqRSUHzUoUgu4fIJWCYPfSAGa27fmrkWyNDFjmGrQqevOuG5qwPGum5NGEZD/08+p/7udWWPVXtxCeMOaGcFSMdPZz2RVluL+CZ9CtbL+bJtbuAvnaOMbjlp7yhT/MZOEbAZcwQWLDE8BOjGZH64dnsmgNg8opl0qmM/98oVKP9PaTcTF6czBUdaQ6Sxpni5Aznp7Fr93rNO843nfev6CQ9qav5og1E++6tZkaEADOxtcdFAAJGsCXFKNobqCBM5Wlsr43yir/8shmKA8ZVmgPQmyPzcH0vJn5fqRdqXOfRD3+dSq1LtHIItIViUgPn2vXZ8v6O7uaccQICIDBUCPzxz58cP3V5fFrarVNSuz+9svdg5+8bjuzY1TLo64srPUc8YgZ0JAvEsr2llgV4ZvXvUq4Ce1Q0DKXaCvkC3hDT3rzHP/Gx/xDuJbbsxsbgyvtOqAGyTCgDOc4/Kq4ipYLkcKVztryhOTuFRXDtMq5wCfOznnFjDvM+Gd5GrhFMIGhTF8OX1T6lZJWX1dTWtzNhaIok1bhNi873Msazfvu9tW05WsvCDiWy5oWzWCIgdJhF5ComD8oBEDDHmvQ90/MWpM3LJgunCOnpev8Ut+YUZvgZYs58KpzTsg0TzbQl3DtuCdlwJmePjSUSQ24uNWUbbDFOwqjbx6uUbsCWYwKpDTyuT/4R0AJHzWG5XsFdf9Wh/naYDejE9vuKdB4tUpSSTFIgq27qISXH2i+OXkLR7y5NV6G3NqzSjDOV6fh1a3xTvTlbmtHRjUXU3U8/1OeGcxAAgXgnsPdAx87dbYePnupoO/Vp96cn28/+6c9tu/eeJDvP4C4trvQcZgSv2//MCIDt1dX8b49oYE+j3Cm1D3obGsJ24dI3yL3hoeriYddqE0KhCiyfB7rU1r7veEtoCdbOclfzbWTcQuS1RuZp7hpKR0aWIkMvCjHnEHxMqW4nUfV1mOb4873jkMacykd1R0RHk/AuLT/A0O1l7vIgGaiN+1VdXxEyK4Y1Go9Hsh2ksjIKyqIyMy5LtBapI6x+OItfAtxVrNBnaDsXm6UfmrUcGXiztfluy56jKoXnG7muHZZOa8mL/dQc1dLlZ9otPOeAsO3wWiNAqNAyMbn0QVGYBLxe2sxXmnNlDx70yAv78nAYimWAYqOK65OBo1r2edJJhBakGrhPhXQPLbE+BZTqcZ4yyaQVjNq0obRWc7IVf3cqXjajT+m3mW6aFgGl+p+w3NU+bTJiwszvHZb7NFEKAiAQhwSuX+9t/eTsH3d+3NSw5+O9h69cunrlakJH17XWjitXr/b29g7mkuJLz+HB6+TE5f/myZNT1iIwpqx4ksz9+eabJx75Xes1/kLIzUnMVAFkuOfv1M3D6Gt77dS0znZptmVswaNchTD9rMKIvvCX37RWvgOTE8vUPQfoT5e8pBd1enlQU4M2PeM0peTFjTzWX64ixJy5MmCZy0SeN3+JAUpCsHX2Sit5spxbM6ylGTsjaX8d5QvIvjHm8OB+a2nO2VjX3FXDnhPCqrPOcgv45Mvok6YZmrg/fR+8s+SPOJGmTLBmhrMYIMBzOmuJBCYnuieWOPxRKTfVSB3G6Wy2IIX80C6VHmwjo015tlsOg1tv4cais83GrjjaoGkZyaLqoEcmNhBI2nf/iQ+H40YJFJRuLLLecBmGF3uSeKdLmGYnEb8lzD9PYi78d449NJH7uOp7Uvu9QbOCTrkEqZOEehnk5wjnAsJURfzt7WG4fxuxmi5ymcs7LLdmKAMBNwKn//PbubP+eZ9bVVRlf9wwa9Lq/zwRVV90CkCA9JyLFz7tbP6k/dCxi+e6R3jGjUya0js27cqICdcH2ZzD4kzPIcLciUsY7umpUh6ZpXPJXq9eitObpOMb96toFpGRWVVxNel4JVORMKvYi/ydunZQX1/DTEp2bB75ewKmsU4pqdIa55SRHV9/xaWJNU/F3JglP3+/4fXEX/Yf3bgnzxzXQ4uSWbzICEN6nXnwtNf6ezhTdqATkQiOZ3Dmqk7wOVNtg5fnehZHXQE5MwSS6l8eiq2zB7+PwlnCWFreno1HzZsoGgvNpyiQMcdwRueBTGpfo2DufMKW5XA4kVOyRUbJz1Ko+8hy6VmHepdbjiXO5UV7HVkCt2hHQb/+JE12E1QAACAASURBVDAthb/dv9SWY+wTKpINGPqMNq5UVIxm251KiBTCm09cSs5o/sfkeat4SA7fFYerVTKRtAzjITuSCNdhZw+akTk5bULL8Z+Gv2SUBCXA3adryyqbeCOH4cXqp3zMyFxrczMT3rk2jwOZy8TaMZkxXqJHJFouCaZ8XevgOglturXB/Bvh0JpkJ/6CLNjvK27tsXYg8NOsQnhDcCWKFeVkmRO0nbi9w7I1wAUIxAQBoVB9e6vT8h4Tc4v1SYwaNWLcuJvGjh09ctSoUTcnjZl4+83J0yZmTE++PcPjGZmQMJjzTyB7UmtrqzmFlBQ965dZjBMQiHcC9JJVbNAZkZY40Ium1735e0IrzAM9LdfxOjs78evClQwVkk+aprqMST9q5JWmxNCk9kxsFHvgUIYApX6kH72HPbW9rcZqyYzaidNF1I0cyNadivSUa7RbjpZI2m8OPKk08q1JjP7/h/NhJsOLeA+yOpfbuum9THV2pSefgmLW5Kr4GZs5Wo0ifvPQlm4yZoYs/znaSzFhNqft0cyXcYw3oESUVlyoi3BdiDS8U2SpiskR7Sng05JANh/6xcL0UdTk5E+xNHJUM17ViUvmL8GrjaIJEAukjCy2EXm9mAn9JK3PlYwmQ5yGcxecfYbTNfHpTuwYTiuWayX1Y/mPZ/zrhz+a3TdrJ3vOskMv7Fv3lSl9Iy82pST1pA7wH+iN/2f7WzV/2vfRKTZ6/JiUGbekZk+bNvkrf5NYer9nIBHR18QcLiMjg85Hmdc4AYEhTYC78NXmlG1YVWI9UsTYgpvWkiOlt2Fgky7EGIMhMh2eh2CFy1poo89pa1Q5j5yZpy4YqyqcV2VdibgarVbU2LpTyYIlhT6ti/000BzsrXAVOQHuAJxZ+371XIp4aXQPHlSP+KZw2iUgl79E5C67ZfkUCbOC770m/JA3PqptwMWzBVBiRgooDe8Q1h5b1kceLVORTxanEqX58K3baOszbRSb7PbqVaW1tAv2+qh+84hd2ijU0CVjPjfa808799bLd9eRbBPBBQiAQPwSmDF9yp13dRw7efkyGz/CM/6mxKTM22+edvvgaxnx57cWvx8CzHyQCYhwWEdw1yBPSRtePhipWDKtAqcgAAKxRYAnleEResU2FcWYIxlb6LHeSjhGyWBss7d8aF2S5otsAfYdjfmGWm6H3DJbxOo4qnmkpbYHl9MRztZamIYop2WDZuh2k8k7+XumSUMQC5Ex35nGwDYBXMQJgb/8c+6sSca/X//RnLQRPKPVbviLWUknPBhGddRcwnj7b2/9S81qVRs6YMZ9iBNbf2DK5yf20dm+X2u1P6g5rU/NOJczFPE/claG35oM4/mjJd/eXSzcEL76B9/O1Wu7xLo0Si7DDr2iO6d+bmpO8vjxY0eOHj3qptE3j7qUeevVqamDr2UM/gyG3s3GimKWAI+DokzhUb227O9FyezhMWtr6u/lQz4IxBEBkVRGS1+mTV2mwg/mqcXNQcxb1ySD8bRcJuSISIEutm1zSLA964AYyRk/E2R/aiOISG2bo02UTk0lx+FXpsf/yB7+mQkokIg78tWSkmO6zNmlO66CTtLRFpcxRoAUgJXPf7fqdNOH9G9fxYFltsd69vzfNn1JVJ1uqnr6VyuVPsMf95cxoxdVzSj/kqri63unfAP7H1zg6ab/92v249kOFcWOIMAQvNHXK/6fnNjpLS983RqdcRXobw/8eoscgqbNmv2SD3Aftl/9/damAE5x9T/+JXtGrZp9Z7lSXUh9Eq50xrgrZ7xjn+2wvBo/7ubJ48ckjull1y+PGXk58dInySO7bk0cfBbQcwb/HmAGIAACIAACcUWAJ60J+FaiOCsr2GLkHgP5pCQ48qy4Zwvw0zpsmQl4mnuuNWkDtrTUWCnvndnbzHZSySF/NoeSQw389wlwalaGksMz4yvvOFOw/4l0rnPfedm/NUpijcCJrRueZ3+/9dHPy4lNWfbMrwvqvrPZsts8/a/f+aIx6c8/XLH0nfomrlDs2/SdeqsXY1qVaPz1imeKJ8lukxcWLGWH2vzUEEMo/dCH+NJ32Tsn2mXdlGX/69+Wqbz7k77yPavqL2+U12lDMGrpiPBRSo45eWs446zgheeU8ClffODr7MBxbhHqqqn6BftulSVtStrXbV0nF68j5SqwWFvjIXNx7tzFrnNXP7s8euSIkSN9f+3ubDv5SWdXV8+gL3DwPecGHQEmAAIgAAIgAAJ9QoC7pVXU1r9YIjeYblorckLaXde4OYg2PKA8aYt5zI5xcDc2iub3C/iRIT156wqkQiLCaSgeRrXjOdy8pfnrlkq9i7IC6GF+POu0t7FaG0aMZio5mruamgf95DIzS1dVL5bJDJrW5VG6tgZzy2xH3gKtozil1AiUrtPUf2T8j9bd2R7XMU7gxIk6VvCAFrU/OfMuJtSSz2uFxiKmTJnB6tu5xnLiAGN1y3J/YVtdwQO2y764ILvN7PI6S9J3xenpNhp+xhSlAlnV8qz9jdWznmcv7GuKIhtBe3M9+3pB2DF0zqGH2HVPj+/I0b/u+ODYh4dOH26//ulNU8ZOnDBi9Kju812/e6/94KHOmXdNWpibOW3q58aNu3lQ1g49Z1CwY1AQAAEQAIGhSGDB6uOVJZk5njKxOG8j7XNAmR4dhwihmamnk2bS8LLe7emJnFobmCff45VSzMRo8pK742ZTCjhVzU00PMkBP4QjXINfBgLhMsf4fgM1ZaKd8Z8pme8TwKxV2J3TRC5sxjdA85Taehsp18jElJfvqbCquNknJr2FrSnirF8IFPR3WjNyjfsStxo1/a8vigVwE004K6n/xfO82Y+f2ZprmYPC6Yg2NgInTp4/8HHXvsNntta1HG+/eDkh6aYJE24ecfOV6+zStTEtnd0nOroPH+/+6NiFJbnpC+ffnpVpWPBsUvr5AnpOPwOGeBAAARAAgfgnwNWJFe7LUInFjFpnyypfiaOf3A54lTLJ8FqZLWC90/CiOjqGUMXq5wLuRqcurJ/CEa5BH0bWOWdo9bDOArfh+7CV6LkBrU7yTDj1OQsH4VrPemeqcHIeehWVOGpDzZWn0q4tdO6YZwQs2TtHKNneOUaupkxZyn7FTTTKetN1/BBjd6WrS9s0//jHX7CCF6hKGHbe3XH6K8o5zdasby5ON/1nve7SpkmdlD6DsQMnuthsN5OOVMAozOZvv/TPUwIE52jC7Kdp2QWMjEXD/rh69frBI11129vaL4z+5PzN1zy30NY5CSNuunL5OktI6B3hGTE2+cpVX8uZi83/dfrUmUu33DImbcqE0aNHDjA5xOcMMPCBGO7UbysfueMV579X8L0cCPgYYwgToF1xxKacmzev3H1UnG9908jNM4RXjaX1OQGeq8CRq23nhrIauxvbjY8q8rl57dnbblxqvEgQmgxt3SOOoxtZaWbJm+bGGpTXTlVRvaj1rNVjnIKukt+sQA00sWLk2Ex7E2j27uVTlj36NPvFMpUn4MTW575Tv/TXhUa4jq3Pvl8v+xV7eqVwBpv9EA/jMWP3qR3lKFNCbL2ivjCVGSlBjK6EiXCg8ufMHGvk3iaSqql6+jn7O/sqlj7/t7Oc5VoTt1MeTfSOJbmr5p9+bM9DMEzyrV28eOloa/e+Y5+dv3LL+PQ7JuVMm5g1NTE1/aZxk0Yl3jpm4pSbJ2eMmZQ15tbsm27NbukafaztswsXPnMj2r9lsOf0L9/Bk57+9LEH6XVGRMeBV155/tCcl17NT46oGxqDwHAg0L77T6WXYmqhtG1o51Kx5WhMTQuTCU5AppOuLLCZbrhBJni3yGvTSqr9LEmRS4nPHlLHa1T7k/JNBWozSzc0rZAlZHHSrFyitra0vmlNrlbqsnBXi41LuyFX9PkfNVWx3JWTfiVXRn5itiB7UhWEGxivfdra0JOH42eSI5kWokO1fQrn8z/a8sK3l39pUrmQ+t2qrd9lpt8aJR7Yx34we/ms7xhD0rSdgxttaP6UTe5RZ22ga7vkpb/+1xe+Xv9uoMZDt7zn08snT1355OS18SOvZ83N7k24yXcp4fIV1ktL7mXXrrKrl69d/uzapYuXL/X0XP7Mc/bi6HMXPps0aaBTsEHPGbqfQawMBECgzwkUpy+qmkeOEGTb6XPZkQjs2r1ye1sNm7g0kk5oGwsEhrP6MWD8RYK4Ii3YyUzPnasV2qezp7mdWbWUTSHP6/A6U758tPNp/h575yF/RarOhz8KsEpNt3G2+OKjH7rpD1ya3pQ0h9OmgqJX0Pmkr/xb01f0Mi7TvHbWalXkO+cm1tbd3kaflaOZYxo2yft+/R0243tW5AlX8OypR8zpDqWTM2d6zndfuXJt5JXLV0eMvpmc1UZevz5mJEsQi7xO+aWvjbyeOPKyL6HzXNvly77TZ3pPnerJyR7oF+nQc4bSpy6MtXQ0/HTR3qya+1nxH4z8JE/e//oT3PBD3m7Pv0w/9/7wjr1ckCpnf377keI2XkLHctPac6ru8erKu+5/KWvXD1ddoJqlNU+UfkG0Mf/raKjcNaP0a/SZPlD32+Sl/AQHCMQngZ3bNued5VOvadte0zaxsfBu+zrItHLQCryeON23ZBo1aN+9NaftEpuYXnmxTdqCyqcXrplmNiY5S1SMOClO25W9SC83G/MBDS3LUHKo4Gze5s2a6mVKYGIg3oUd3uY5eNaaw8TpR29pDntWQgL+A4E4I2BLvS3nztNze1soG7GLniMzK3izXaoiXbjXTBfBKCGEezq7SGWifawRIAe8zen/ZiTaNtJMfzHWJtnv8xk9OmHczVeTRvV8dpadPXXxplvGJoyQsTfcopOQkDBiFOvtvX79ytWr3R1jmS9x1KRRo6QS1O9z0weAnqPTGErnbc/f8YptPabeQqkeiw89fewJkSnnQOUdf/hpVvKzX0tO/lrp0y1OvzVSfn64ahw1li5w5Nj2w8eZ5dj28h9+ub7k9WMBFZiWVdWPtJAexdrpZKupI9nmhQsQiHcCpKJoSg6t5uzBtYenreGajjjOtplpqSoObq44qMpJS9l2WGhEupJDtaS9bBMqkE3JoQrSsmYmFq651ZRgnjhb0kD7e6TpSbRRcyi+hTo38yJVQqcBZiU64j8QiD8CLUdrGZvrP+89zZ1sgc1hkLeR8TblBTantQCpHfxlmiXK2iMLuM0ns6Yl2I6xZk+cxB+BX5lefIz20jmtNheKv4VEP+PJkxLvmTXxs88+az/DEnrPJlyj/AOjr/Um9JKaQ1pOAhuZQD+vjr+pOyVnZNqEmxfMGX9bSlL040XbE3pOtORivV+w+JylNWbozoz5T/6hruUUY666yoEtqy4srSk143xmfGPO1EUtf+nIX5oq1v/k/aQgBSSRmv/ssRlk9nnk8TkvHXtiPulId7SUbi81+gbshgoQiD0CC5YUHhXGGdN4InQFOdHJK5YVrlBzlpaf/T2UoIDc2+Qh7TNKFZHWHmlmudjDXzAf/ohbcsakH102j94oCyvQ2fW7u6rm6d2VMP5zXtUixoTfmrQIUeyQsCYpQ5AQXtP20ap5pr1oTOWiZSvEjNp362IDz0ofEOcgMFQJiN2BmLfB3PCnbxaau7rR683z1u9cnatstn0jOLakON3GYmt2/TWb4blqJ81Jk8Yt//Ks/L/JOXnyzP6DJ1s7O053s+4roy5dI9+1ETeNvH7L6Ou3Jl1Pyxr1+Vmzb7998i23eLj2M+AH9JwBRx5HA3acamHsSPEr2g5cNPtxfxPBEpKXvvrE58ko9Ery60888fritx9Z9PaUyBMkRDAgmoLAYBEwfducE5iYIh50bs0Zw9glVp4iDD233lLMzsqsTe09F3mXS205m5WHKJluPj1TxaYtnXiw4ix3ThMylRrjHIC1f8ozJJRPV1rNtLsrm8mH7WzdYWY8Y41JXmyqXbJ7qFn5DYKCWCbA04vtdzhK8fTHZTMbfGsY2Ra87rOnnUnlZqBk1uARKVarcupos3BYVQHObGH6g+q1lZVT5DrHudkOYw63utCGrRuPqowFrt2iK6R9hJjX3YIUnUD0AoEYIzBiREJS0lj6N21aeoxNzZoO9ByLBc7cCIy7MQuMCONh5LE2gydze5lLM61DbsOhDATij4D0OiODSaFvMguo7RjrGpPj4nUWcM1kR6I0XEqmHo0TsIt7xdhEshQFPiKbVWA5qIlJAtqGNu3VJTllcxt9q+1GBpGFmR73fSXG54QrAB6n4hRscSqPc7XQjbiKlbmSDVaAikvWAb/MBIyZSo7S9IKtL/K69ubhlqsgckboAQL9TgD75/Q74jgeIDU5i134r13k1RbVQTkP7uC5Cl5/NXnLHSLy5xic1qIiiU4xTcDwOpMGk65mYZuJaMJpiWN5e/JbKyz0mf9EJgMph2s7VD59Il3WnGolVzc2OXGmrBP/p91CpiIKs9m2UxbKKVE2NjNGSGuMUxCwEyA7TH6FZtjhtVw1aii0t+NXpBt41hkfM72WdqSh3TYfVQaglJIXNxbV1Nbzz+pgHDzrQC3POqAOv8wEUsmh7W76R8mhcaVmtdhhQVITwk8QAIEBIQB7zoBgjpNBkrPGsZfPaME6M5avp3Rq1ZXpZi41ss+8P+VVM7wnxMKy1peIAJ4DaZSuIEgkTwgxqAaBWCYgPdDsXmeRzddwM7P5rfGEabfK5NE2YcXJGZplxrTwZJe3US4E08ONdylOv9v+zt4mBxcgYBAQ2cbKG5Qlx+KSu6LEughxlpVVzLyb6ztXlBjP9fwpf+6T2mc1hIC+rU4rebK8LD9vXYFPOKS1V68qrS2qXK/UMFPJCeyu5pZXOugcSWa9MRy1I7sZOQG6UQ0qZMhVfvzB62+fMFZ1172PfH2KWmH3vtfe3WOlh56S/9S9Gaou1E/Z17+LLtO/1lXqiYYXP2APPpR/p1Z7+uDm1w6ctwrCFGV1wFlMEYCeE1O3ow8nEyzfWqBhkr+2vHRrtZGoTeRnoyRsr6dTXmktRIfKA/V3lKfml35NFs1Yapw4WuASBIYAgcnzXkw/VUP5o+kgm8w97CnKEHCq9UUrD0HIRVImg0XMyittZoWeV1WYONOesVrs3kMCZegOlywjedYU3prjIiHk0Ggw7Am0tNSwosKsG+PADTi1OWWZNWV8z5nF9fSU723UN+O8MfGR985d42tg5HvnlV1tO+HsrBelWg5o2ShUSJItAKk000N5FK0wJNL0bAJpRN+K4W3M4UpO99zHHprNt5bhGsXm7Q8ULkrisE+3N7MZhU9NHy/It76ziWrDVHVa39EVJNGfC+TKCVv8wCNSvioO/vP89v2tjDn0q/OHPtHlRDS34MPFca3YkuSItQBnpisRmGBUO3cZ0ftae5Mw254llmQtVkLf1ETLGGy1De+MEsD1trbSjTaOlJTh/bVUHPATBEAgOIHOzk78ugiOCLXxQiDyD7MI8a+x1kfP9LaIF0dMv/U0bHXxPxMhLlqx47FbhNZQvmTboSQHzUOgzBjU0z8+x7/ENoDjgltCmGOxRhNhJCkuInc1MUlyCQtsLXFIFZeR3wU3KUO3jPh0J3bEz/qEdWWyZcM5v/3dze8nBVBmuBZ0frHSggIvUgqZu7h7j00UH6v57tDdTcFCTre8zHDYc8xG8sTQ1h4Q2pqjLnYvk3pS+/APNG0x8ku23MyvK7QaS9Xhl4fUxiFcOblgxXUbezZKnyBj30W5Z6M/O76RydYsuXOJ2NSEKTl8B5S68FQd+pqYkjMyuA4Le44JZIicfPvuX165dC3GF1Pxzors2Z+L8UlieiAAAiDgTqC9vpZtPO5TPlpcq/HsITuGen/fVMetGUrzEUH5npBbqVCIi6YbcPXDJROAJtZ9ahGXpmXPZSxoWjDp5aUJzlNWEsbUfHgbIsAtGFXUki8537PHSuam9cbp8CDQfeY0G3+3sN6IBY+/6/bx739y/jRj3LxjP05f0PzEeJXUQ5wayMcfbH6fzX3s3oxD79pyPHy8f8/ppLl3WWPZpTNukzmUNPcxS1cZv4gsP8oK5Ghtu+ze13iC3XVvfCk5thX0xQW59jyryZmxOJ29fOFEB5tBW4x0NLz1Mu0Un2/sMfKFxaXLqyvfOrBUbLt44K29R5bP+d4XZOfkpY+lVxbvqvvGDLf9ReRGJlIOP5+6vkQ1m1Fac6guYEdtZm6n0HPcqMRz2b999L14nj7mDgIgAAIxTyCtpJo/zatjweqGcm++Fp1CTlOaDUX4dNWUhdpKhUL/tU5pJesra2tLW1qqWD97WYjQmqMtLOA4Wro2kaPMxZ7DPcGKNlox9yklVQ0tNfm173eWKN1PwcLP4UFAqC7jkx26R/eZMy56DrmKnWfBFBWOjDzT3j5Bmg+pHE6l6FQ3m5R0pnbT66REycMWC6QKI/ppRBaRdvTQI/6KWUSi4qKxdBLTbCbCokI7KJrh2eYyTtW91saevN9QQk6eOULbjdxm1iZ/ftk4tvWUiPQ+deIQY3clW9ssfuGupewP7ScZk3swmp0YO/XbXXXk1SY1IrGpSVa61Y+JjpQWa2nkkd7It6ZhxikIgAAIgAAIREegpqUlaEduMzEPMgF5PCVvaiVmlTppOep0UlM1Lj/5jjHOCYjAm5wsl9a2opSCwiJW8XK1lp1M1je9WR1sfroQv/xmeiXOQSAYgdMHG97vZnfN1G0m3N7ylJ4e4ESDCL+xJQxQQs+TnnO6+9aih6gL//fYjPGHPnj9HZX/gCJwvk7lljFH9Qv68857hbR7GalPrx10aFZBe8Zn5RcefL2GrDR/qPyzmP+f3/7hKnIbsys5pAvd8cojd2xhzzxh+p6dartA2ypOcegtW3hGK1Je2rewqVmauiJkt7SJSnGu/hPGnMeUUUiV9slP6Dl9ghFCQAAEQAAEhi0BnlWZFWdlBQDQ+T4PWfHbpDJAa1m8c11+BXmFOUNcvHmkH8mjRNdMUlY8SbtS5q9tMoU2rc2nkifDMKekrFi/sbi2LEcXSH5onny5Pa0pMchJWkER5VvLW2cOH/7oQaSiahgQ4ArM+UkzCq1UbC6Lbn3ng9a77jVyGLjUk43o9gzT6jJpev7iJHZICz137RJWYdLsohnjTx/Y83FYreO70RcefGn9uLriyro/N/y0uG1pjd9GIKQLHXvi9WPL2XOvPPJ4g7+yEvXypTFnueHeRtae/G88yeqK3z5gSvzzIfuG9WZF6BP4rYVmhBYgAAIgAAIgEIhA55svexmlLCsI4GDWtKGU1BxvgZ7mewHtT7PaVaDKRkCxOrofG2PkLOcrMbvwZjmeFisKiLzLjmetzPR4VBNKUWBGEKmyAD/JzcxXsmqdJ8dTZrZwZEEwy91PuITsmVZ+M56ILNzR3SWiNL4JTBpHudS4peVOh+uaviyefqCVlJzHjMRrep3znEw0L+pl3Q0vbqLIGcpVzb3juvSqPj0PayF9OuLgCZNJdyuL91JsTKmpdTjnk7z0mTn/tWjvlj/nB27j7BPsuqPhl6vIQc5mzJnxxBNPs1eM9L/U+cn0pYy1BJMSsA56TkA0qAABEAABEACBEATE3iz0WL8+gOVEWDZcLDOBxFJsj28NVQqLSmBlI3dNg7ci31vXtHqBGdUj1BU9cMh/DLuyZKsPrHppzXisjnZpO1UztxXiYrgSSLp1EmslPYcpPefMufNsytw7FQ+5TU14Sg53PFP96KcjdRvXc97/pPX0dN3zTWt+Y6fugUY3JjPmex9pIWuN09/MmjXfRJ5x97MvJCenj2NM5SSwWsiz5LTlrC64KMbsuQosEaTqvP6EuqS8bS9f+Jv5gaekGvr/hN+aP5M4Kdl5xOP5SPdbiJN5Y5ogAAIgMFQIGLmevQ1VKveafWXSOENbqajca/bqYFe5qxu9rmEzqlNuQTlj+/WgH1WDnyAw+ASSZudNYYf27zNyA5xooA1D7xKJfmluUskha0wASw5pMq+/uKkhTG+xO2fOndS9p1ZF0YiAn4wHrY1HKd/a6y++q2YSHA2lqNbHNdzqLPUseO84rz312y2VW9Kf3j5n6st/+OlvAzum6XkCbrt1KrvAUwuo41TLBfbkXTP4ZfKUuxg7xHMSGAfvOM6mrsh0baEic4QulPV5RxSQkhr8J+w5wfk4a5vWfphf4WnwTTVfoMkWnW9+lLl57PGqTEYnpWzj0bv995Z2yorPa77SUAsMp03Eqye9Ls/nbZwV+eNCxEOhAwiAAAiEJmAqOQE2ijGVHDPfdGiZzha1LZQeIM1ZKq47m/e7lqMQBGKDAIXyP/jB669tMnJAaznQRII1egK2u6KFZ9txW1vS7MceGv/Ops0vGgEdzoTUfn30/XPOv72Jdj8fb+zek5Rxd9IeUWJ00qbtJ2ZoFRi5Bx6kbNHfW9/yw1Vb6ubLEB2+7037Y2ZOggOVi7Rs0TyWZu/zrzUsf1U4nv357ed5mmmh5jA24xtzploebqfqnhMdNXUlkDFHJyu266H9Q22ObXqD4OfYJzQ4H79a96ftjnWerj2V6dUrJvh1cBScq17ZVjZzsm+Ndp8dTcK85DO50u8K1cCM4rLkvgPlIhxFfUAAm/r1AUSIiA0C0XyYpZKjtun0X4dUctT2Mv71oUs63ywRL5WqA7w1M7asuQElKvQcBrJFNHdhIOc32GMRn7jaJ3SweQ3v8SPeJ1TklaawHPtmoKSxcPVG5pi2iGrpp2WhUEWMemcqarFV6BFZSZmjpTokL0UV0wY1RNAPvZffcFYzvzP6mphl2CfURBHJyYLJG4vbyuo6Vi/QFJWdPV42cuPikEpOJAOhLQiAQLwRaFo7hnJkFVVen1s6wismv/HopRI2uiRnRC1dFl8/XnVFhaqPWucZKdvYy0dWrxxVViM603/l13xrrsoLKVxV9Db4LnOrcrsQTpJXJWTmJchaPii3AMghA7LtNQAAD8RJREFUVEtmSFa1ShJ+RkHgxpUcvrWol/zZLC2FSuoKfGuUr4AM+ylvMJUcUpzql+p7j+ZTOrWGAEFBUawJXUAABIYvAZ5LzbZ6PTyG9gl9/Wu2WseF3thRRcnTnj2W7yyU19FVucsKWAq/tYBoAlRMKCg8yUp7mtYw9eeINdX5WHFSgXQt0A0g7cdLcrrnNqZnrW8TDy6eX5b7vkdPMDVdngqeHKSIm4AYWXhqCy1bkHD6Gm24xgkJ/AnJOFxc5lSV9tMYdzLL6/LK4nLLgiTkX7Naa1XcK29/0vFVVzLzfNSg6GUPe5KflOV8WMY7iNH1BfJCbsvy8hN+iBVNYHobed44tjavWy7EaCPaCz9AcSb+M6ua1gpiOqjF5wVMy29N76v5sxmGoAbWRU+c4ggMrf34uvfHr+ZWuI7qNz0loc1x1lRxBgKBCNSWCq1GVJfljCkz29WMWFU4snoFffs0JYdqa0ZkstFCBbIrOVRVMbIkp5e6dL7JNSjtSMhfO8pUgbgEUzWiL+xTowsshUrrhNM+IiDzRLOassyaMl2k0ltEmmnKsJbn8erVpJYE8HDjrRYUePPyPdpdJmk+TY2hHXJsApHQzMYWFyAAAuES+Kipfe03N4XbOpba3ffwrEefK4hoRtBzIsLFG6csHlvEuut3slwjSWhHPX+DOz4lgCRv3smNR2f5jBw458bud/itnQvQTxUXJ1HYjxDOn+DzVx5Xl6pBgJ/evJ4G36zVvJarIiU5HtOtzlQnGNeIbFWspjuT3Op8Uw2p9wT1jhMKFatM90kNgS4ruV7kd1wrW8+O+2ZVUwXv0rYue4IZZmOpKFwjMqpy16RvdIBqt+3TZQuU4jI/LNH9Biu66htniZxFjLcMDG1PaZvnKM9u1EInm8+HydZvgSgAAY2AtNtISwtX/q9KRYV8kGqPcpNL55vCkqNsNcJQM2LDKmZ+KfxNLikrLvlWqCF23uQh083+BDLPm792vI2XeHdZVZPQUmVVqW742WcEUlZUW7fDRSpPSiZ+97rUGUUuyc1C9Ao1aOCxUAMCIAACGoG7c9NoJxytYCifIt9a5Hc3bTzfEK2uw+jJndY8TwY2BXgbbyAnQVpmtaHk0GgTSlZ5WM2VlvCm7G00kyWkPlo5snbzeem0mLLiblPhYWmZT5bTs5emnJBaFXbsUFNld21x0npz7TRb974jN74oVTUKqOUjmvRy11j2GcZ9Atme5lCKHy2//fjLfAc9tcC0zPW0wNIuc4s6Vj7ZfGTMXRoYGk3YRwpVl2flpUd9sxpmdmcihV14ny60CkKgqPA6Vz/SeueKRkWLufk0JbvX7NJyVJxWjPR4xtA/aajZ0zySsWsFhbyKrECyyplQkdQY6qL800yBjPUae7MsuO7VSnEKAiAAAiAAAsOZAPScKO4+ua6NZBU98qmaO62VJ+ZGISbMLmSs8Hzokf+EO1mY/fRmKdmjdQWJXNcMgR5KH6c3jOj8HM/2M3OM+UY5zM5ZOSPZ/ktS6aIuZG9Rk5HefWGIab9Sy0ZmaTmI+ALZlWZKTBTxMaGkatbxwouZaztI6fI1ji7LOWLpSxFLQwcQcBDozdY+qI46/0tut/FdOl5p1HCFZy23upPfGmk4Jc3XqNbXaKlMRrvi3izjzP9HgvpeJLRovm3+7VACAiAAAiAAAkOMAPScaG6ocF3zvfwmWR6405p3aWo0UsLowxUSHuEzy+cT/xo9YXQK3oSc3z7MLKX4H0NmA+3AMGgHOdSJiCBjMulkzxnwQwChnOBrUrnGxVPYKTPRgE8FAw4TAlk5YqHkt0ZKi/on4nYMAFLb8R29XkQFFSOa2KgNpbxKmoY6m418A0brUD94YmI6dhqpEUI1Rz0IgAAIgAAIDBEC0HOiupHS3Ys8wYTTmuExEpWkoJ3O1W++prtgBW0crFJkShidRU3az9fWaB5fwTqFrJuQPZN2qbMsMyE7iAZiUdIKJPPUmS5t4fXnrdJGF7FrxtOb6NXZfIWx0RG9OOf9uK1MhEtVjdlgaFw34GQoZoL/QCAkgZQV17zUSPmtaS5qlJ/A8FjjhTJLW/n1XNabJV4BSH82ivMJ7zB6efOETBdvt/DEoBUIgAAIgAAIxCcB6DlR3jcR9dHN85JF5rTmrxvwEjN4hp68V5WaydAcjTvWRee3tvMIOad5V4kImbQxFDNgxcCIqmAI/DQKvXFuaVJRTfcqbtcSB6kNa1XYkt5OO+9882RZzciNpcICZhcuqsymjrWb5eJEBvnkKQczAa2ocnIU3oNzKYmCiCnKohMrFMo+HK5AoI8JXF3tE6qOEqsSD1D5VZtVk1Ia8LzS10peFLYd0X7jUdGmZkR9CEfNayVV1ihFlddsktXQ+AkCIAACIAACQ5UA8q1Fe2cXJHqZz0uZQyN0WstdM9nr6cqs+ZAGlnnPeG6xlW2ZHl5C+akbeEg9P6XDVkVpnRs93jxZE/p/b96HXtXKymnGUlfT3ho5bZ7SNl5ZPrmh3Jevmrn85CH+H2UaovwSNFMc/1GeP82QRjQaM12EsGsqMzVVjrT2NqXujZRjzZgnKSobi7tqVX8nqMWqQvykWJoG9mG+hMbH1fIZ2BoGvUjLXL1CNkgtMU6CtkclCAQlkLvmkszyJ1pxpcVKurXgsk/L98GYvdYSy5WTkirr2jhLu1Ktd7fa2MudYu2jrLjqItlvKBSAAAiAAAiAwNAgkNDb29va2mouJiUl0qhysytOYoYAz7PMo3rMnGODOTN9L53BnAfG7mMC2Ly8j4FC3OARwId58NhbI+MuWCzczohPd2IIjwm3figbjgSSelKH5/M8fU3M+52RkUHnsOeYQMI6SUzcf/Vqb1hNB6kRZSzQR6ZUZvrlAJ/H1GQiWvt7792xaNHYiLqgMQiAAAiAAAiAAAiAQOwQgJ4T2b3o6aHQ+3g6HJrG4E49piYzuCgwOgiAAAiAAAiAAAiAQL8SgJ7Tr3gHSTjf/nKQhvYfdsFUe1iCfwuUgAAIgAAIgAAIxAOBU4ffq20fu6Tg3ul9NduTH/zmIOtLgX01sRuQIyhd5AImzvnvc7n7FI5BIgA9Z5DAY1gQAAEQAAEQAAEQGCwC1rO4mkHa9K8uv01dxPTP89t3bNuvXugmpS0pmTY+hubb8+Ef2tnM+V9dlBhoUrE9/0Czjsty6DlxedswaRAAARAAARAAARCIjoB8zp68pOA+0yzD1Z7OVnZb7BsfWrfU720nO8lCMdWeD6t3batmfavq8CEuRKs+nTrx127P5+4MqOQMwPyj+1QMyV7YP2dI3lYsCgRAAARAAARAAARcCfR80upjadNtvmfJ0+6LDw+rkyfa2diZU5U+ljjr/rSx3ac/OeW60sEoPH3xIrt5XHKgoWN+/oEmHp/lsOfE533DrEEABEAABEAABECgnwjoXm3ujmHckNIyzubqZjeD8MCbLmN6nqyihbOsR3+9ireYbK1CVLmPKBslJSaxrtYT5xcpX7VQeoU2DS1ahi/w9OesWVnLIWPXXr4Lc/u234jNmAO587kiosJtZ6nz3t/U72Wkj82/z+m9Fun8LTQ4i4IA9JwooKELCIAACIAACIAACMQpgcTbMzwt+w/+7jed7lHy4gnejDAh7WXbby76tZRCNFe3U4ePtLPJS4T6ISRQuoKvSr+4g3t+V7uDSaXCLpwxkYcgApDcgPPXWq6EcC3izhOkV5ADnjLvOAQJrUkpKtxb7zc7Lli6jaOxcTl+0cI550L5rdlXYSEis9iSi7/b9pldr9MHimj+ekecR0MAfmvRUEMfEAABEAABEAABEIhTAvQov2Smh7GzZHb4nfFvj7lnfOuu9otJafcoQ0TG8umT2dkj23scix2/KEsvP//xaep1t1BsuATdL2761Kwk318/5hIcwh0yGbvt3v9e8NXgeQWSk/j2dkketn/X72rbL7KJU8woI7u489tbuijjmUquMH7RbJpGy66T9lbRXDlWEQiRu+iw5+/eHaWREIA9JxJaaAsCIAACIAACIAAC8U+AVJ2vLlLLIHvLNtJ5pK2j58IFxsYlaRnMhKvVuW7GHLH1t01JO7jXcCHjMT9jM6aIXkJCN9mLDqoB+E+x97a/cL1JOOfcRHPRymbG/c3UzJ3dz5/zsaRJ2kISx41j7EL3eXabVujsFca1/yoCIfIXFsH8/TujJFIC0HMiJYb2IAACIAACIAACIDCECEyf+9VJfGOcntOMWVE0oReYMT/tSC3PATD+9JGW7olzlAmIerqFplCx0ygUegxHi4OdXcyTZWUzS5xVMr3nNwe5sSjZoYY5esbGZbzPPzYohj8L+K2FzwotQQAEQAAEQAAEQCDeCZz8YEsQ3y3T6GEus7unm42dkGReWyfJUz4nPMFaj51laSkqSIZLuEh2HqudeSaEm1dRnEwaO5b5uD4WxjF+god1X9Sm4W+HCUOKS5NIEDm6RzJ/R1dcRkEAek4U0NAFBEAABEAABEAABOKWQDs5lVkBOTwZAAW6qOgastKM7W7/kwrIad1CadMmTtVsNdqyE2fNncjaD+5t92TNt/YYlRK2adoU5QD4QHixZdzB28tzkiOEa/J4WoL631Uf1pQTvZbMTaRZsa5t1uSDTE9GEO1V0zi/fV9Lt5onD5IxQoZoAFFlDeSnIFlV8iwSRPa+kczf3hNX0RBI6O3tbW01Y89YSkpKNGLQBwRAYJgR6OzsxK+LYXbPh+xy8WGOhVuLuxD8LhCf7sSO4G0iqRVplCniRh1ONzORT+yirNWzPKtEatreOyKnmd7GkCnKlXxG+QDM/XlEOJCsmbxkOtt2kC0pUAIDSbME0ZnYalOVuAytqvhPfRraHKhGW+PYmdM/13pQS5Ot8VHp2nSh/FzrzvQ58NUFybfGu0Yyf94+0iOpJ3V4/oGmr4nJKiOD2xeh55hAcAICIBABATyURAALTWObAD7MsXB/cBeC3wXi06d6TvDRUBvfBKDn0P2Teg781uL7o4zZgwAIgAAIgAAIgAAIgAAI+BOAnuPPBCUgAAIgAAIgAAIgAAIgAALxTQB6TnzfP8weBEAABEAABEAABEAABEDAnwD0HH8mKAEBEAABEAABEAABEAABEIhvAtBz4vv+YfYgAAIgAAIgAAIgAAIgAAL+BKDn+DNBCQiAAAiAAAiAAAiAAAiAQHwTgJ4T3/cPswcBEAABEAABEAABEAABEPAnAD3HnwlKQAAEQAAEQAAEQAAEQAAE4puAc5/Q+F4NZg8CIAACIAACIAACIAACIDC8Cch9Qkc5IMhSRyEuQQAEQMBBoLW1Fb8uHExwGacE8GGOhRuHuxD8LoBPcD6o1QkM208LLVznQOfwW3MAwSUIgAAIgAAIgAAIgAAIgEDcE/j/ZImPxiPNrcIAAAAASUVORK5CYII="></p><h1 id="A-Love-Story"><a href="#A-Love-Story" class="headerlink" title="A.Love Story"></a>A.<a href="https://codeforces.com/contest/1829/problem/A">Love Story</a></h1><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><blockquote><p>给出一个长度为 $10$ 的字符串，一位一位看问它与 <code>codeforces</code> 差了多少字符。</p><p>$t$ 组数据，$1\leq t\leq 1000$。</p></blockquote><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>按照题意模拟，扫描一遍给出字符串，判断第 $i$ 位与 <code>codeforces</code> 的第 $i$ 位是否相同即可。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> string t=<span class="string">&quot;codeforces&quot;</span>;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    string s;    <span class="type">int</span> ans=<span class="number">0</span>;    cin&gt;&gt;s;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)    &#123;        <span class="keyword">if</span>(s[i]!=t[i])        &#123;            ans++;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> t;cin&gt;&gt;t;<span class="keyword">while</span>(t--)    <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="B-Blank-Space"><a href="#B-Blank-Space" class="headerlink" title="B.Blank Space"></a>B.<a href="https://codeforces.com/contest/1829/problem/B">Blank Space</a></h1><h2 id="题目翻译-1"><a href="#题目翻译-1" class="headerlink" title="题目翻译"></a>题目翻译</h2><blockquote><p>给出一个长度为 $n$ 的序列 $a$，问最长连续 $0$ 有多长。</p><p>$1\leq n\leq 100,0\leq a_i\leq 1$。</p><p>$t$ 组数据，$1\leq t\leq 1000$。</p></blockquote><h2 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h2><p>我们遇到一个 $0$，便把长度加上 $1$。如果当前位不是 $0$，说明已经有了一段连续 $0$ 了，计算答案 $ans&#x3D;\max{ans,len}$。</p><p>注意循环结束也要计算一遍，防止最后一个是 $0$ 的情况不会统计长度。</p><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n;    cin&gt;&gt;n;    <span class="type">int</span> len=<span class="number">0</span>,ans=<span class="number">0</span>;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        <span class="type">int</span> x;        cin&gt;&gt;x;        <span class="keyword">if</span>(x!=<span class="number">0</span>)        &#123;            ans=<span class="built_in">max</span>(ans,len);            len=<span class="number">0</span>;        &#125;        <span class="keyword">else</span>        &#123;            len++;        &#125;    &#125;    ans=<span class="built_in">max</span>(ans,len);    cout&lt;&lt;ans&lt;&lt;endl;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> t;cin&gt;&gt;t;<span class="keyword">while</span>(t--)    <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="C-Mr-Perfectly-Fine"><a href="#C-Mr-Perfectly-Fine" class="headerlink" title="C.Mr. Perfectly Fine"></a>C.<a href="https://codeforces.com/contest/1829/problem/C">Mr. Perfectly Fine</a></h1><h2 id="题目翻译-2"><a href="#题目翻译-2" class="headerlink" title="题目翻译"></a>题目翻译</h2><blockquote><p>有 $n$ 本书，每本书耗时 $a_i$。有一个长度为 $2$ 的字符串 $skill$，$skill_j$ 为 $\tt{1&#x2F;0}$ 时表示是否获得了第 $j$ 种技能。问最少耗时多久才能学习所有技能。无解输出 $-1$。</p><p>$n\leq 2\times 10^5,1\leq a_i\leq 2\times 10^5$。</p><p>$t$ 组数据，$1\leq t \leq 1000,\sum_{tt&#x3D;1}^t n\leq 2\times 10^5$。</p></blockquote><h2 id="题目思路-2"><a href="#题目思路-2" class="headerlink" title="题目思路"></a>题目思路</h2><p>我们分两种情况讨论，第一种是看两本书学习两个技能，第二种是看一本书学习所有技能。对于两种情况，答案取最小值。</p><h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n;    cin&gt;&gt;n;    <span class="type">int</span> m1,m2,m12;    m1=m2=m12=(<span class="number">1</span>&lt;&lt;<span class="number">29</span>);    <span class="keyword">while</span>(n--)    &#123;        <span class="type">int</span> x;        string s;        cin&gt;&gt;x&gt;&gt;s;        <span class="keyword">if</span>(s==<span class="string">&quot;11&quot;</span>)        &#123;            m12=<span class="built_in">min</span>(m12,x);        &#125;        <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">&quot;10&quot;</span>)        &#123;            m1=<span class="built_in">min</span>(m1,x);        &#125;        <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">&quot;01&quot;</span>)        &#123;            m2=<span class="built_in">min</span>(m2,x);        &#125;    &#125;    cout&lt;&lt;(<span class="built_in">min</span>(m1+m2,m12)==(<span class="number">1</span>&lt;&lt;<span class="number">29</span>)?<span class="number">-1</span>:<span class="built_in">min</span>(m1+m2,m12))&lt;&lt;endl;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> t;cin&gt;&gt;t;<span class="keyword">while</span>(t--)    <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="D-Gold-Rush"><a href="#D-Gold-Rush" class="headerlink" title="D.Gold Rush"></a>D.<a href="https://codeforces.com/contest/1829/problem/D">Gold Rush</a></h1><h2 id="题目翻译-3"><a href="#题目翻译-3" class="headerlink" title="题目翻译"></a>题目翻译</h2><blockquote><p>有一堆含有 $n$ 个石子的石子堆，你每次可以选择大小为 $k$ 的一堆，将其分成 $\frac{k}{3}$ 与 $\frac{2\times k}{3}$ 两堆，问是否可以得到大小为 $m$ 的堆。</p><p>$1\leq n,m\leq 10^7$。</p><p>$t$ 组数据，$t\leq 1000$。</p></blockquote><h2 id="题目思路-3"><a href="#题目思路-3" class="headerlink" title="题目思路"></a>题目思路</h2><p>我们通过阅读题面，因为这个 $n$ 是要分成三份然后一堆一份一堆两份，显然可以得到 $n,m$ 只有可以表示为 $n&#x3D;3^i\times p,m&#x3D;2^j\times p(0\leq j\leq i,p\geq 0)$ 时，我们才可以分出来。</p><p>考虑到 $n,m$ 都很小，我们枚举这个 $i,j$，判断是否可行即可。</p><h2 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n,m,tmp3=<span class="number">1</span>,tmp2;    cin&gt;&gt;n&gt;&gt;m;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">15</span>;i++)    &#123;        tmp2=<span class="number">1</span>;        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)        &#123;            <span class="keyword">if</span>(n%tmp3==<span class="number">0</span>&amp;&amp;n/tmp3*tmp2==m)            &#123;                <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);                <span class="keyword">return</span>;            &#125;            tmp2*=<span class="number">2</span>;        &#125;        tmp3*=<span class="number">3</span>;    &#125;    <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> t;cin&gt;&gt;t;<span class="keyword">while</span>(t--)    <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="E-The-Lakes"><a href="#E-The-Lakes" class="headerlink" title="E.The Lakes"></a>E.<a href="https://codeforces.com/contest/1829/problem/E">The Lakes</a></h1><h2 id="题目翻译-4"><a href="#题目翻译-4" class="headerlink" title="题目翻译"></a>题目翻译</h2><blockquote><p>你有一个 $n\times m$ 的矩阵，其中有水坑，水坑的大小为 $a_{i,j}$。若 $a_{i,j}&#x3D;0$ 则不是水坑。问最大的连续水坑大小是多少。</p><p>$1\leq n,m\leq 1000,0\leq a_{i,j}\leq 1000$。</p><p>$t$ 组数据，$1\leq t \leq 1000,\sum_{tt&#x3D;1}^t n\times m\leq 10^6$。</p></blockquote><h2 id="题目思路-4"><a href="#题目思路-4" class="headerlink" title="题目思路"></a>题目思路</h2><p>典型的四方向连通块，使用搜索，深搜广搜均可。</p><p>记录每个水坑是否走过避免回头路。</p><p>注意开始遍历的时候要判断当前位置是否为 $0$。</p><pre><code class="highlight basic"><span class="number">1</span><span class="symbol">2 </span><span class="number">2</span><span class="symbol">0 </span><span class="number">1</span><span class="symbol">1 </span><span class="number">0</span></code></pre><p>如果不判断的话会从 $(1,1)$ 开始找到 $(1,2)$ 和 $(2,1)$，但其实这两个点不连通。</p><h2 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n,m;<span class="type">bool</span> vis[<span class="number">1020</span>][<span class="number">1020</span>];<span class="type">int</span> a[<span class="number">1020</span>][<span class="number">1020</span>];<span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;<span class="type">int</span> dy[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><span class="function"></span>&#123;    <span class="keyword">return</span> x&gt;=<span class="number">1</span>&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&lt;=m&amp;&amp;!vis[x][y]&amp;&amp;a[x][y]&gt;<span class="number">0</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><span class="function"></span>&#123;    vis[x][y]=<span class="number">1</span>;    <span class="type">int</span> ans=a[x][y];    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)    &#123;        <span class="keyword">if</span>(<span class="built_in">judge</span>(x+dx[i],y+dy[i]))        &#123;            ans+=<span class="built_in">dfs</span>(x+dx[i],y+dy[i]);        &#125;    &#125;    <span class="keyword">return</span> ans;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    cin&gt;&gt;n&gt;&gt;m;    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)        &#123;            cin&gt;&gt;a[i][j];        &#125;    &#125;    <span class="type">int</span> ans=<span class="number">0</span>;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)        &#123;            <span class="keyword">if</span>(!vis[i][j]&amp;&amp;a[i][j])            &#123;                ans=<span class="built_in">max</span>(ans,<span class="built_in">dfs</span>(i,j));            &#125;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> t;cin&gt;&gt;t;<span class="keyword">while</span>(t--)    <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="F-Forever-Winter"><a href="#F-Forever-Winter" class="headerlink" title="F.Forever Winter"></a>F.<a href="https://codeforces.com/contest/1829/problem/F">Forever Winter</a></h1><h2 id="题目翻译-5"><a href="#题目翻译-5" class="headerlink" title="题目翻译"></a>题目翻译</h2><blockquote><p>我们定义大小 $(x,y)$ 的雪花图表示有一个节点 $u$ 连向 $x$ 个节点，这 $x$ 个节点又分别连向不同于 $u$ 的 $y$ 个节点。给定一张 $n$ 节点 $m$ 条边的雪花图，问这张雪花图的大小是什么。</p><p>例如 <img src="https://cdn.luogu.com.cn/upload/vjudge_pic/CF1829F/8093abf53ab9afd4293f2937f4849e3ca604a47a.png"> 就是大小为 $(5,3)$ 的雪花图。</p><p>$1\leq n\leq 200,1\leq m\leq \min(\frac{n\times (n-1)}{2},1000)$。</p></blockquote><h2 id="题目思路-5"><a href="#题目思路-5" class="headerlink" title="题目思路"></a>题目思路</h2><p>因为给出的图一定是雪花图，所以我们只需枚举它的大小。然后我们观察样例可得，我们需要有一个度数为 $x$ 的点以及 $x$ 个度数为 $y+1$ 的点（因为连到了 $x$ 个点，每个点还会往中心连一次）。</p><p>但仅仅这些还不够，我们需要判断这个 $(x,y)$ 是否满足有 $n$ 个点，即 $x\times y+1&#x3D;n$。</p><h2 id="完整代码-5"><a href="#完整代码-5" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> deg[<span class="number">220</span>];<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">memset</span>(deg,<span class="number">0</span>,<span class="built_in">sizeof</span>(deg));    <span class="type">int</span> n,m;    cin&gt;&gt;n&gt;&gt;m;    <span class="keyword">while</span>(m--)    &#123;        <span class="type">int</span> u,v;        cin&gt;&gt;u&gt;&gt;v;        deg[u]++;deg[v]++;    &#125;    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=<span class="number">200</span>;x++)    &#123;        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;=<span class="number">200</span>;y++)        &#123;            <span class="keyword">if</span>(x*(y<span class="number">+1</span>)<span class="number">+1</span>!=n)<span class="keyword">continue</span>;            <span class="type">int</span> sx=<span class="number">0</span>,sy1=<span class="number">0</span>;            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)            &#123;                <span class="keyword">if</span>(deg[i]==x&amp;&amp;!sx)&#123;sx=<span class="number">1</span>;<span class="keyword">continue</span>;&#125;                <span class="keyword">if</span>(deg[i]==y<span class="number">+1</span>)&#123;sy1++;&#125;            &#125;            <span class="keyword">if</span>(sx==<span class="number">1</span>&amp;&amp;sy1==x)            &#123;                cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;endl;                <span class="keyword">return</span>;            &#125;        &#125;    &#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> t;cin&gt;&gt;t;<span class="keyword">while</span>(t--)    <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="G-Hits-Different"><a href="#G-Hits-Different" class="headerlink" title="G.Hits Different"></a>G.<a href="https://codeforces.com/contest/1829/problem/G">Hits Different</a></h1><h2 id="题目翻译-6"><a href="#题目翻译-6" class="headerlink" title="题目翻译"></a>题目翻译</h2><blockquote><p>你有一个罐子搭成的金字塔，如图<img src="https://espresso.codeforces.com/3f72320a7f225babc9b2b244a719e59e9e8f028d.png">。第 $i$ 个罐子代表数 $i^2$，现在打掉第 $i$ 个罐子，问掉落罐子的数之和为多少。</p><p>$1\leq n\leq 10^6$。</p><p>$t$ 组数据，$1\leq t\leq 1000$。</p></blockquote><h2 id="题目思路-6"><a href="#题目思路-6" class="headerlink" title="题目思路"></a>题目思路</h2><p>观察可得，打掉第 $x$ 行第 $y$ 列的罐子，那么第 $x$ 行第 $y-1$ 和第 $x$ 行第 $y$ 列的罐子都会倒塌，然后逐个往上。</p><p>我们做一个预处理，只需找出 $n$ 罐子的位置，一个个往上递推，用前缀和优化记录某一行某一段的和即可。</p><h2 id="完整代码-6"><a href="#完整代码-6" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> x,l,r;<span class="type">long</span> <span class="type">long</span> a[<span class="number">2020</span>][<span class="number">2020</span>],cnt;<span class="type">long</span> <span class="type">long</span> s[<span class="number">2020</span>][<span class="number">2020</span>];pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;fa[<span class="number">3000020</span>];<span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span>(l&lt;<span class="number">1</span>)l=<span class="number">1</span>;    <span class="keyword">if</span>(r&gt;i)r=i;    <span class="keyword">return</span> s[i][r]-s[i][l<span class="number">-1</span>];&#125;<span class="function"><span class="type">void</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> n)</span></span><span class="function"></span>&#123;    x=fa[n].first;    l=r=fa[n].second;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n;    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;    cin&gt;&gt;n;    <span class="built_in">Get</span>(n);    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)    &#123;        ans+=<span class="built_in">Sum</span>(x,l,r);        l--;        x--;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2000</span>;i++)    &#123;        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)        &#123;            a[i][j]=++cnt;            s[i][j]=s[i][j<span class="number">-1</span>]+a[i][j]*a[i][j];            fa[cnt]=<span class="built_in">make_pair</span>(i,j);        &#125;    &#125;    <span class="type">int</span> t;cin&gt;&gt;t;<span class="keyword">while</span>(t--)    <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="H-Don-t-Blame-Me"><a href="#H-Don-t-Blame-Me" class="headerlink" title="H.Don&#39;t Blame Me"></a>H.<a href="https://codeforces.com/contest/1829/problem/H">Don&#39;t Blame Me</a></h1><h2 id="题目翻译-7"><a href="#题目翻译-7" class="headerlink" title="题目翻译"></a>题目翻译</h2><blockquote><p>你有一个长度为 $n$ 的数组 $a$，问有多少子序列使得选中数字按位与结果中含有 $k$ 个 $1$，答案对 $10^9+7$ 取模。</p><p>$1\leq n\leq 2\times 10^5,0\leq k\leq 6,0\leq a_i\leq 63$。</p><p>$t$ 组数据，$1\leq t\leq 10^4$。</p></blockquote><h2 id="题目思路-7"><a href="#题目思路-7" class="headerlink" title="题目思路"></a>题目思路</h2><p>这题非常像背包，但是背包的转移是 <code>f[j]=max(f[j],f[j+w[i]]+value[i]);</code>，这题只不过是把所谓体积的转移从加法改成按位与。</p><p>这题 dp 的初值也很有意思，赛时因为最开始的初值赋错导致痛失 AK。</p><p>初值应该写成 <code>f[63]=1</code>，假设先放上一个 $(111111)_2$ 去做按位与。因为 $0$ 按位与答案一定是 $0$，后面就没意义了。</p><p>但是这样有个问题，当 $k&#x3D;6$ 因为加了一个额外的 $(111111)_2$，所以会选择空集。$k&#x3D;6$ 我们最后答案减一即可。</p><h2 id="完整代码-7"><a href="#完整代码-7" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> p=<span class="number">1000000007</span>;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n,m;    <span class="type">long</span> <span class="type">long</span> ANS=<span class="number">0</span>;    cin&gt;&gt;n&gt;&gt;m;    <span class="type">int</span> a[n<span class="number">+1</span>];    <span class="type">long</span> <span class="type">long</span> f[<span class="number">64</span>]=&#123;&#125;,ans[<span class="number">64</span>]=&#123;&#125;;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        cin&gt;&gt;a[i];    &#125;    ans[<span class="number">63</span>]=<span class="number">1</span>;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">64</span>;j++)        &#123;            f[a[i]&amp;j]=(f[a[i]&amp;j]+ans[j])%p;        &#125;        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">64</span>;j++)        &#123;            ans[j]+=f[j];            f[j]=<span class="number">0</span>;        &#125;    &#125;      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)    &#123;        <span class="keyword">if</span>(__builtin_popcount(i)==m)        &#123;            ANS=(ANS+ans[i])%p;        &#125;    &#125;    cout&lt;&lt;ANS-(m==<span class="number">6</span>)&lt;&lt;endl;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> t;cin&gt;&gt;t;<span class="keyword">while</span>(t--)    <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1817A Almost Increasing Subsequence</title>
      <link href="/archives/CF1817A/"/>
      <url>/archives/CF1817A/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><blockquote><p>我们定义“几乎递增”序列表示这个序列没有 $3$ 个连续的元素 $x,y,z$ 使得 $x\ge y\ge z$。</p><p>现在有一个长度为 $n$ 的序列，有 $q$ 次询问，每次问一个区间 $[l,r]$，你回答 $[l,r]$ 中最长的“几乎递增”子序列长度。</p><p>一行 $2$ 个正整数 $n,q$ 表示长度和查询个数。</p><p>$q$ 行每行 $1$ 个整数，表示最长的“几乎递增”子序列长度。</p><p>$1\leq n,q\leq 2\times 10^5,a_i\leq 10^9$。</p></blockquote><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>这里讲一下莫队算法。</p><p>因为莫队算法是基于分块的，也就是说每个询问，莫队算法的时间复杂度为 $\mathcal O(\sqrt n)$，总时间复杂度 $\mathcal O(q\sqrt n)$，可以接受。</p><p>很显然，这题在进行莫队的时候，我们只需对于新进的数字判断一下三个数关系即可实现莫队精华部分。</p><p>接着我们按照莫队常规操作记录编号输出即可。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span>usingnamespacestd;<span class="meta">#<span class="keyword">define</span> getchar() p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>],*p1=buf,*p2=buf;<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span><span class="function"></span>&#123;    registerchar c=<span class="built_in">getchar</span>();registerint x=<span class="number">0</span>;    <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)c=<span class="built_in">getchar</span>();<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=<span class="built_in">getchar</span>();    <span class="keyword">return</span> x;&#125;<span class="type">int</span> len,n,q;<span class="type">int</span> a[<span class="number">200020</span>];<span class="type">int</span> ans[<span class="number">200020</span>];<span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> l,r,id;&#125;b[<span class="number">2000020</span>];<span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span><span class="function"></span>&#123;    <span class="type">int</span> fx=(x.l<span class="number">-1</span>)/len,fy=(y.l<span class="number">-1</span>)/len;    <span class="keyword">if</span>(fx^fy)<span class="keyword">return</span> fx&lt;fy;    <span class="keyword">if</span>(fx&amp;<span class="number">1</span>)<span class="keyword">return</span> x.r&gt;y.r;    <span class="keyword">return</span> x.r&lt;y.r;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    n=<span class="built_in">read</span>();q=<span class="built_in">read</span>();    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        a[i]=<span class="built_in">read</span>();    &#125;    len=<span class="built_in">sqrt</span>(n);    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)    &#123;        <span class="type">int</span> l,r;        l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();        b[i]=&#123;l,r,i&#125;;    &#125;    <span class="built_in">sort</span>(b<span class="number">+1</span>,b+q<span class="number">+1</span>,cmp);    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>,ANS=<span class="number">0</span>;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;<span class="keyword">while</span>(r&lt;b[i].r)&#123;r++;ANS++;<span class="keyword">if</span>(r-l<span class="number">+1</span>&lt;<span class="number">3</span>)<span class="keyword">continue</span>;<span class="keyword">if</span>(a[r<span class="number">-2</span>]&gt;=a[r<span class="number">-1</span>]&amp;&amp;a[r<span class="number">-1</span>]&gt;=a[r])ANS--;&#125;<span class="keyword">while</span>(r&gt;b[i].r)&#123;<span class="keyword">if</span>(r-l<span class="number">+1</span>&lt;<span class="number">3</span>)&#123;r--;ANS--;<span class="keyword">continue</span>;&#125;<span class="keyword">if</span>(a[r<span class="number">-2</span>]&lt;a[r<span class="number">-1</span>]||a[r<span class="number">-1</span>]&lt;a[r])ANS--;r--;&#125;<span class="keyword">while</span>(l&lt;b[i].l)&#123;<span class="keyword">if</span>(r-l<span class="number">+1</span>&lt;<span class="number">3</span>)&#123;l++;ANS--;<span class="keyword">continue</span>;&#125;<span class="keyword">if</span>(a[l]&lt;a[l<span class="number">+1</span>]||a[l<span class="number">+1</span>]&lt;a[l<span class="number">+2</span>])ANS--;l++;&#125;<span class="keyword">while</span>(l&gt;b[i].l)&#123;l--;ANS++;<span class="keyword">if</span>(r-l<span class="number">+1</span>&lt;<span class="number">3</span>)<span class="keyword">continue</span>;<span class="keyword">if</span>(a[l]&gt;=a[l<span class="number">+1</span>]&amp;&amp;a[l<span class="number">+1</span>]&gt;=a[l<span class="number">+2</span>])ANS--;&#125;ans[b[i].id]=ANS;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)    &#123;        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);    &#125;    return0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC171E Red Scarf</title>
      <link href="/archives/ABC171E/"/>
      <url>/archives/ABC171E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><blockquote><p>给出有 $n$ 个数的序列 $b$，还原序列 $a$，使 $a_i$ 为除 $b_i$ 以外所有数的异或和。<br>$2\leq n\leq 2\times 10^6,0\leq a_i\leq 10^9$。<br>$n\equiv0\pmod{2}$。</p></blockquote><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>前置知识：异或的归零律、恒等律与自反 $a\oplus a&#x3D;0,a\oplus 0&#x3D;a,a\oplus b\oplus a&#x3D;b$。</p><p>观察题意可得我们求出的 $a_i$ 即为 $b_1\oplus b_2\oplus \dots \oplus b_n$ 再去除一个 $b_i$。</p><p>设 $b_1\oplus b_2\oplus \dots \oplus b_n&#x3D;k$。</p><p>我们根据异或的自反可得：</p><p>$$<br>\begin{aligned}k\oplus b_i&amp;&#x3D;b_1\oplus b_2\oplus \dots \oplus b_n\oplus b_i\&amp;&#x3D;b_1\oplus b_2\oplus\dots\oplus b_{i-1}\oplus b_{i+1}\oplus b_{i+2}\oplus \dots \oplus b_n\end{aligned}<br>$$</p><p>于是我们得到了想求的 $a$ 数组。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n,k;<span class="type">int</span> a[<span class="number">200020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin&gt;&gt;n;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        cin&gt;&gt;a[i];        k^=a[i];    &#125;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        cout&lt;&lt;(k^a[i])&lt;&lt;<span class="string">&quot; \n&quot;</span>[i==n];    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] UVA291 The House Of Santa Claus</title>
      <link href="/archives/UVA291/"/>
      <url>/archives/UVA291/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><blockquote><p>一张无向图。<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMkAAADBCAIAAADq9wM/AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAgAElEQVR4nO2deVRT1/bHMzAkTGEQCPM8g8zihMxIZUZmUERQirXtq3b1Veub7LC6rH1qfc+iVkEIEEgQNKCAIIooFpWCCjLIDAGNIjJlvvf3x1nl57NWEIHchPv5w7VcK9x7cu83e5+zz977YGEYxqCgLAI4UQ8ARWJBtTVXYBgWCoUQBIl6IGIDqq05AUEQh8Pp6+ubmpoS9VjEBlRbc4LP5zc3N+fm5j558kTUYxEbUG3NCSaTefv27YmJCXTpM3ekRD0ApAPD8MTERENDA4FA0NbWFvVwxAnUbs0Cm82ur6/v7e318/OTlZXFYrGiHpHYgGrrbUAQxGQyW1pavLy8lJSU0EXiO4Fq60+BYXhsbKy2tlZeXt7S0pLH4wFtdXV1TU5OohOvWUHnW29jeHi4vr7ewMDg4sWLbDa7ra1NUVGxr68vNTVVXl5e1KNDOlj09zcXYBh++vQplUr19/fH4XCGhoaysrKiHhTSQX3inOByuX19fQMDA93d3bq6utLS0qIekRiAamtOMJnM+/fvGxkZ9ff3P378WCAQiHpEYgDqE+cEBEGvPigcDocGI2YF1RbKYoH6RJTFAtUWymKBagtlsUC19W5MT0+jM9Q5gmprTsAwDEFQaWnpv/71r/r6eg6HgypsVtB14izAMMxms3t7e7u6um7fvs3hcOTl5S0sLPT09MzMzFasWCElJYXGI94Iqq23IRQKR0dHr127VlBQoKenl5aWZmFhMTo6eunSpYqKCh0dnYiIiJUrVxKJRFGPFImg2vpThEJhX18fnU6vra319/ePjo5WV1fH4/HAkrW0tBw7dgyCoOTk5DVr1igoKIh6vIgD1dYbgGF4cnKyoaHhzJkzQqEwLS1t/fr1MjIyr34GgqBnz57R6fSqqqo1a9ZERkbq6OiAfUbURQJQbf0PYM7+/PnzS5culZWV2djYxMXFmZiY4PH4PyoGgiCQlZqTk0MgEKKiotzc3BQUFFBtAVBt/T9AWJ2dnSdOnBgfH/fx8fnggw9UVVWxWOyfyQWGYT6f397eTqFQ2trawsLCYmNjQeozqjBUWxgMBgPDMJhF1dXVZWRkaGlpJSYm2tvby8nJzSoRoMinT59WVFTQaDQvL6+IiAgdHR0ZGZllLi9UWxgMBiMUCru7u+l0+o0bNzw9PePi4shk8jsFF4A0Ozs7jx49ymazY2JiPD09lZWVl7O8UG1h+Hz+b7/9dubMmenp6ZCQEC8vL1VVVRxuPlFloVDY1dVVUlLS0NCwYcOGyMhIMpk8v0tJAMtaW6DaoqKiIj8/39LSMioqysbGhkAgvI+xAevHy5cvX716lUwmx8fH29jYSEktx7qE5astgUDQ0dFx7ty59vZ2X1/fxMREEom0IC4MzN5aWlpycnIGBwf9/PzCw8MX6uJixHLU1osXLx4+fNjW1jY9PY3H462trd3c3Ba8bgeCoP7+/traWiaTSSQSyWSyg4ODiYnJ8rFhy0tbEAS9ePEiNzf32rVrFhYWW7ZssbCwwOPxi3rTqampysrKoqIiaWnplJQUZ2fnZbJHtFy0BcMwh8NpaWkpKyu7f/9+SEhIYGDgvOfs7wqfz+/t7T158mRbW1t8fLyHh4eGhobEb3JLvrbA7Gd8fLy8vLykpERdXT09Pd3U1PS1PZwlgM1mMxgMKpVqZmYWHR1ta2sr2TEwCdcWDMMCgYDJZBYXF1+9etXHxyc8PFxPTw8jil0/EAO7ffs2g8FgsVhJSUmrV6+Wl5eX1CC+xGoLfC8ej3f//v0TJ05wOJzk5ORVq1YpKiou9gTrLUAQJBAInjx5UlZWdv78eT8/v/j4eBADkzx5Say2hELhs2fPioqKqqurbWxsUlJSdHR03rjlLBLYbHZ5eXlhYaGiouKOHTtsbW0lb4Ivmdri8XhtbW10Or2pqSk4ODgkJERdXR1R8XEYhrlcbltbW0FBQV9fX1BQ0MaNG8G+uKiHtmBIoLb4fP7ly5dpNBoej09NTbWzs1NSUkLmOxMIBMPDwxcuXKisrLS2tt65c6exsbGoB7VgSJS2wFQmLy+vtrZ29erVoaGhVlZWCJ/KwDA8PT1dW1vLYDDYbHZycrKrq+t77jshBMnRFpfLvXfvHo1GY7FY4eHhnp6eKioqiPKDb0EgEPT09FCp1AcPHvj7+/v6+urr64vL4P8MsdcWBEFjY2O3b99ubGwkkUhkMtnMzMzS0pJAIIh6aO8GBEEsFqu5uZnFYg0MDMjKynp6elpbW4tvoy8x1hY4qKKrq6u4uLi+vv6DDz4IDQ3V0NAQYYjh/ZmZ4584cWJ6ejouLs7d3V1RUVEcXaRYaguE2qemphoaGqhU6suXL3fs2OHl5SUx28AwDI+MjOTk5NTX169evToqKkpPT0/s9ojEUltgzn716tWLFy86OjpGR0fr6+tLS0uL16N/O6CvfW1tLYVC0dTUjI6Otre3B0F8UQ9troiftoRCYUdHx6lTp7q6usLCwkJDQ1VUVMATF6PnPivgvQiFwkePHlGp1K6uruDg4LCwMCKRKC5zfLHR1owfrKurO3XqlI6OTkpKipWVFdjulSRVvQr41qOjo2VlZbm5uU5OTlu3bjU1NRWLQkix0RYEQV1dXWVlZTdv3nRycoqLi9PV1ZWYCdbbAYWQzc3NmZmZEASFh4dv2LBBQUEB4QZMPLTF5/MfPnyYkZHB4/GCgoK8vb1JJBLCn+zCAhI6enp6GAzGnTt37Ozs0tPTZyYDyATp2oJh+OXLlxUVFRQKxcHBISIiAsSukPxMF4+Z3ie5ubkmJiZJSUmWlpaIXcQgWlugXIJCoXR3d7u7u0dHR69YsQKZz3Ep4fF4LS0tWVlZw8PDoaGhmzZtQmYhJEK1Bbp91NfXUygUAoGwefPm1atXk0gkUY8LKUAQ9PjxYwaDcePGjQ0bNoSEhBgaGiJt9ok4bYFWH6Wlpffu3TM1NV21apWOjo6WlhZiLb+ogCBofHx8cHDw8ePHNTU1GAwmIiJi9erVyNkjQpC2QIjh/v37RUVFQ0NDERERmzZtEq9ooUgADQcoFMqjR4/8/f39/Py0tbWRcCoMUrQFypErKysrKysVFBR27txpZ2cn1juDS8zExERpaSmDwdDU1ExMTLSzs1v6YpPXQIS2hEIhyLuqqqry9/ePiIgwNDQU9aDED9AMLC8vb3JycufOnatXryYSiSK0+qLUFgg6czic1tbWrKyssbGxhISEtWvXKioqLqvY1UIBCj2YTGZJSUlZWVlISEhISIgIqwREpi3Qtmp0dLSwsLC8vHzlypXbt283MDBATrmEmAJBEI/Hu3bt2qlTpxQVFdPS0pydnYF/XOIHKzJtgdhVXl5ea2traGior68vmUxGJ1gLAgzDIAZGo9Ha29ujoqJ8fX3V1NSW2BuIRlsCgeDGjRv//e9/SSRSSkqKvb09mBmgFmuhAImTT548KS4urqmpsbW1BW5hKcewpNoCm2IjIyMFBQWVlZXe3t6xsbHgC6OqWgyAAWtoaMjOzoYgKCEhwcXFZcmyWJdUW2w2++7du4WFhS9fvgQd+sSoXEJ84fF4IIXk9u3bPj4+gYGBurq6S/DYl0hbz58/r6urA+USRkZGFhYWRkZGkldJjFjAsunRo0e9vb29vb1EItHb2xs0O1m8my66tng8Xnt7O41Ga2pqCgwMDA0NBSXOqBNceoCLfPz48S+//DIyMrJ582YfH5/Fy1ZaRG2Bqs4bN24UFhbCMBwdHe3j4yPyYDEKBoMZHh7Oy8urq6tzdXVdvGqDxdKWUChksViXLl0qLi62t7ePjY21tLRE2kb9sgU0Ea6trS0tLZWSktqyZQtYqi+sAZtdW2A1y+VyYRjGYrHArsrIyLxxF3mmgqC7u/vs2bN3795NSEgICgpasg59KHNHIBD09fX99NNPLBZrxj++FgmaaTXFZrOFQqGsrCyBQJhjfHtO2urq6qLT6WNjY+CiQqHQ19d3w4YNf9xshyBoamrq1q1bP/74I9jVMjAwQM0VYgG5J+Xl5VQqNTk5+aOPPtLW1n41gg1iRg8ePOjp6WGxWFgs1sXFBWTrz3rx2d86DMM9PT2tra2KiopEIlFGRsbDw8PV1fWNioFheGho6Pjx43V1debm5mVlZcDavdMXRlkyYBjG4/FTU1NYLDYzM9PExCQ2NlZRUXHmA9PT0wwG48mTJxEREUKh8OzZs99++62ioqK7u/usF5+TRXn58uWGDRt8fX2BzSQQCOA4pDd+eHp6enx83MbGRlpaeuPGjebm5qg3RCzAbl24cKGrq0tGRubJkydsNvtVbUlLS6urq+vr65ubm+Px+ICAgOrq6q6uroXRFri9kZERmUzGYrFSUlJviSAAD6urqxsXF1dTU1NRUaGsrOzr6yumHQ0kG4FA0Nvbm5+fPzIysm/fvv7+fgKB8NocSVZW1t/fH4fDycjI8Hi8iYkJQ0PDOe4dza4tNpsN7vrgwQMQdjM1NTU2Nn5jNAFM9gUCgZ2d3cqVKxkMRk5OTm9vb3BwsLGxsdh1NJBUQHjo3r17+fn5fD7/008/dXV1zc7O5nA4r30Sh8MpKCiwWKz79+8/efKkqakpKirK2dl5LneZXVsQBKmoqIyNjfX39/f09Ny6dUteXn7fvn3W1tZ/5uyEQiEOh9PR0UlMTNTT0ysqKurs7IyPj1+7di0Scm1RRkdHS0tLq6qqdHV1k5KSjIyMZGVlgcV649r/8ePHZWVlPB4PVOFOT08rKSnNepfZtSUvL5+YmIjFYvF4PJfLtbe3/+GHH4qLi01MTN64aTOziMViscrKygEBAS4uLo8fP7558yadTt+wYYO3tze6jbj0zBwjWlJS0t/fv379+n379mlqas68ize6FLAUs7e3NzMzw2AwTCbzp59+amlp+eKLL2b1jLNrSyAQPHr0SE9PT1dXV1ZWVkpKisPhzN21ycrK6ujo6OjoODk5ZWVlUSiUxsbGpKQkU1NTNDaxZICioGvXrjEYDCwWC85vn8vPG+xzKygo6OrqYrFYLpcLerT+0Xv+kdmvPjExQaPR6uvrnz9/3tPTc/XqVSKRuH79+nf1boqKilu2bElNTWWxWD/99NPdu3enp6eRkK0v8QiFQiaTSaFQMjMzTU1NP//889WrV8/Rb4ASj+vXr4+Ojg4NDVVXV3d0dKxatUpTU3PWv53dcoCIfENDw/j4eH9/P5vN3rt3r5ub2zysDnCRRkZGZ86cOXz48ObNm319fdFS6UWFz+d3d3dnZ2e3trbGxMT4+fm9UwIqBEHS0tLNzc1CoXBgYKCjoyMsLGzLli1zqUOeXR9kMnn//v0sFmt6etrd3V1NTY1EIs07+VhaWtra2vrAgQNUKvX06dNNTU07d+7U09MTi6Y/YgSoc5mcnKyuri4pKSESiV9++aWzs/O7liOoqaklJyc/e/ZMIBC4urrKyclpamrOsR/H7NrC4XArVqxQU1MD/33/Lmo4HE5FRQV0fs/MzDx06FBCQoKDg4OCggKqrYVCKBSOjIyUlpbSaDRfX9+EhARQ8POu18HhcCQS6dVV4dxTz2fX1mK05AOxuDVr1mhra2dkZHz77bebN2+Ojo5WUlJC14/vCbBYnZ2dZ8+e7e3tTU9Pf5+WUu/z9kW2UgMhfmNj471791ZWVl68eHFoaGjbtm16enpoGdm8AbkC165dO3LkiJWV1Z49exwcHEA79KV/pKKMAgDrqqWlFRsba2VllZGRceDAgdjYWHd3d2VlZREOTEwRCoX9/f2lpaXl5eVhYWERERFaWloiLMtDRIRJVlbW0dFxz549dDo9Ozu7q6srJiZGS0tL1OMSJwQCwa+//lpYWDgxMZGUlBQQECDyPVxEaAuDwUhLS1tZWaWlpVVXV5eWljKZzB07dpiYmKDTr7kwOTlZU1NDpVLV1NS2b9/u6Oi44Ee7zwOkaAuDweDxeDKZHBcXFxUV1dzcfPLkyadPn4aHh/v5+cnJyaGVsX9EIBD09/dnZGT09fX5+Pj88MMP6urqyJmtIkhbGAwG7Fri8XgXFxdtbW06nZ6TkzMyMuLn54fAvngiBCQ+NTU10en0kZGRpKQkDw8PJNiqV0Ho2wJpFNu2bdPW1i4uLu7t7Y2JibGzs0PTKDAYDAzDz58/ZzAYVVVVenp6X331lYWFBQILqJA7mwFpFGFhYX/961/ZbPbBgwevXr364sULoVC4bHchQS7DwMDAuXPnCgoK/Pz89uzZY2Njg0BhYRBrt2aQlpZeuXLlV199lZmZeezYMQ8Pj7CwsOWZZgj84J07d86fPz82NnbgwIH57eouGcgdGQAISEND4+OPPzY2NmYwGENDQ1u3brW1tX1Lzr7kAZJkQNM2ExOT9PR0CwsLhJenI9cnzgBWiHJyciEhIXv27JGWlv773/9eWVk5NTW1HJwjqA8dGho6ceJEYWHhxo0bP/vsM1DhgmRhYZBvt2bAYrGysrL29vYGBgbFxcVnzpxpbGzcsmWLxLcanJycvHr16rlz52RkZA4ePAgMNkYcckbERluY3w2YiopKZGSkpqYmjUb7+uuvExMT161bJ6ktcVgs1vnz5y9fvmxjYxMfH29hYYHkCdZriM1AZ8BisUpKSl5eXmQyubi4+NixY0wmMzg4GJnnjswboVDY0tKSnZ09PDwcGxu7YcMGTU1N8erZKX7awmAwYPrl6OhoZGRUXFxcXV09PDwcFhamqakpLy8v1ktICII4HM7U1FRjY2NRUZGMjExaWpqbmxs4JlLUo3s3xFJbmN8j+GpqaqmpqYmJiXfu3Dl06BAGg9m8efP69evnUuGEQEAx6vnz52/cuOHj43PgwIGlafC3SIirtl6FQCCAZGsqlUqlUkdGRoKCgtTV1cXrh87lcltbW8+dO8dkMsPDwyMiIsQ90UgStAWwtLT8+OOPy8vL8/Lynjx5Eh0dLS5LSBAUvXXrFoVCkZOT27Nnz8qVKyVgdSI52sLhcOrq6rGxsebm5idPnvz66683b97s5eUlJyeHWLcCYleDg4MXLlyora11cHD45JNPJOYoP8nRFkBaWtrFxUVJSamoqOjs2bODg4NhYWEaGhoIXGGB82bu379fUFDw4sWLmJgYf39/iREWRvK0hcFgcDichYVFenp6TU0NhUJhMpnJycn6+vqI8o/AD165ciUzM9PIyGjXrl22trYgsV1ikEBtAQGpqqoGBwcbGhpmZWXt379/x44dbm5uIs8xhH+HxWKdOXOmvr7e09MzLi4OxK6QI/0FQQK1hfldXrKysg4ODl9++WVRUdHhw4dDQkICAwPnV6a3gLDZ7Hv37mVmZgoEgt27d69Zs0ZSz12TTG3NICUlpaWlFRcXp6GhwWAwHj16lJyc7OjoKKrxTE1NXbx4sbi4WFtbOz093dDQUIKzOSRcW5jf14+hoaF6enpUKvWbb75JTU11d3dfytOKgR98+vRpZmbm3bt3/f39g4KCtLS0JNJczSD52gICkpOTW7dunamp6YULFy5cuNDX12dra2tgYEAmkxc7T3pqaqq7u7u/v//WrVtTU1MfffTRmjVrJCB8NSuSr60ZsFgsmUxOS0sbHR29cuVKRkaGsrJyfHy8o6PjIr1pCIJYLFZlZWVRUZGtrW1UVJStra0YJTK8J8vle76KqqpqaGioqalpbm7uqVOnNm3a5Ovrq6qqurB34fP5bW1tFy5caGhoCAoKCggIEPkyYolZjtrCYDAEAsHR0dHAwCA/P//06dOtra3JyckLdbQzaE508+bNs2fPEgiE3bt3e3l5iXV2xvxYptrCYDA4HA5UIVtYWFAolCNHjkRFRTk4OIAY2LwvKxAIwEFGZWVlNjY2CQkJy7b75nL8zjNgsVh5eXkvLy8tLa1z5859//33UVFRwcHB8+soBJqft7a25ufn9/b2BgUFBQcHL/0p0chhWWsLICUlZW1t/dlnn5WUlOTl5Q0ODm7ZsgUczD5HWYAQw/T0dHNz85EjRxQVFdPT011dXZfDYvAtoNrCYLFYHA6npaWVmprq5uZ29OjRgwcPhoeHr127Fpwx8/Y/B+ZqaGjo0qVLJSUloEmfRO7hvCvL1Fy/BpCXjIyMg4PDV199paam9vPPP9NotImJiVn/FvjBw4cPX79+fevWrWlpaaDr1TIXFga1W68CWhmamZnt2rWrsrKysrJyYGBg69atxsbGf+Ycp6amampq8vPzSSQS8IPvuRSQJFBtvQ4ej9fT00tISLCysvrll1/27duXmpq6fv3617rEQBDU19dHpVJv3rzp4eEB/CDy61GXElRbrwPEQSQS3dzcSCRSbW3tnTt3hoaGNDU1nZ2dyWQym81+9OhRT09PX18fn89PS0tbu3btTB9rlBlQbf0pUlJStra21tbWo6OjFRUVmZmZz549CwgIuHXrVkFBgaam5rZt2xDbQwYJoNqaBdBePyIiwsjIqKio6N69e/39/evWrYuKigItpUU9QOSCrhPnhKysrIWFxYsXL8rKyvB4vK+vr8RnyLw/6NOZHaFQ2NfXl5mZqaWldejQIVVV1VOnTl2/fn1qagqCIFGPDrmg2noboE9fd3f3v//977q6uoCAgJCQkM8++4xEIh06dKioqGh0dFQoFIp6mAgFnW/9KRAEjY6O1tbW5uXlkUikb7/91sLCAo/HW1pa/u1vf6uqqjp58uSDBw8SExNtbGyWYZrDrKDaegNgf3BgYCA/P7+xsdHFxSUhIUFbWxuEr0Cnk8DAQHV19YKCgqNHj0ZFRc20SUYVNgOqrTcAQVBLS8upU6devny5bdu2tWvXvnaIFYjgu7i4qKur02i0jIyM7u7umJgYdXV1EQ4baaDa+h9gGAZtRUtLS01NTdPT001MTP6sFEdaWtrExOTDDz+0s7Oj0Wjt7e1bt251cnJantlafwR9ChjM77kM/f39XV1dg4ODjx8/3rx5s4eHx9vPFAL+UVVVNSAgQF9fv6ysLCsri8Viqaurm5iYoOe9o9rCYDAYoVB448YNGo3G4/GioqKio6MVFBTm/ufS0tL29vY2NjZMJjMvL6+5udnR0TE6OlpfX385y2tZawu0eR4bG6uqqsrNzTU3Nwdb1PPbxpGSktLX19+xY8eVK1fodPrTp0+Tk5PNzc2X7RJyWWuLy+U+fPjw/Pnzzc3NwcHB0dHR71/to6amFhkZaW5unp2d/f333/v5+fn7+2tqai5DeS1TbYE2Mrdv36bT6Vwu99NPP/Xy8lqoIlgpKSknJycymZyfn89gMEAS2BIU2SKN5TgbEAqFLBartLT0+PHjKioqn3/++QIKawYtLa3t27fHxMQ8fPjwxx9/bGpq4nA4y+GwhRmWl90C68HOzk4KhdLa2hoZGRkYGKisrLwYM24sFksikUJCQhwcHI4dO/bNN99ERkYGBASoqaktk7Mgl4u2QKidzWZfv36dSqUqKCh88cUXLi4u0tLSi/eaQQ6+sbHx/v37S0pKcnJyurq64uLiTExMlkNC/XLxiaCdWk5OzpkzZ0xMTHbv3u3q6rqowpoBh8NpamomJibu2bOnq6vr8OHDjY2NXC5X4v2j5NstGIYhCHr69Ol33303NDQUHR3t7++vpKS0lJYDh8MpKCh4eXnp6OhkZWXt3bs3NTU1MjKSSCRKcABMwrUFw/DLly+vX7+ekZFhYWGxf/9+UbUVBWdd2dra7t+//9q1a/n5+e3t7YmJiWZmZpK6fpRYbYFz4erq6iYnJ8fGxmJiYvz8/DQ0NES72YfFYtXU1DZt2mRoaFhVVcVgMFRVVS0sLJycnN5pJ0AskExt8fn8hw8f5ubmgoOuIyIiVFVVkeN9iESik5OTjY1NR0dHcXFxRUWFv79/RETEihUrRD20hUTStAXOR62oqCgrK1NUVDxw4ADYw0HaogyLxRIIBNC7sLi4uLi4uL29PSYmxsHBYWlWGEuARGkLnBNOp9Obmprc3NyCg4ONjIyQ/J5wOByJRIqPj9fT0wPn9UVGRnp4eCxSyG2JkRxt8Xi83377jUqlPn36NC4uzsPDQ1xOI5ORkfHw8NDX16dSqWfPnmWxWAEBAWJ9AhlA7LUFokTj4+MgsV1NTe3zzz8Xu5JUKSkpEHUrLS2l0+mdnZ3bt283NjYG/hHJpvctiLe2wB4Ok8ksKCiorKwE03YxTcrD4XDKyspxcXF2dnY///zzP/7xj4SEhHXr1qmoqIhpha0YawuCIB6P19TUlJeX9+LFiz179nh4eMjJyYl6XPMHHDhqa2u7b9++vLw8KpXa2dkZGRmpp6cnjl1MxFVbIEmmsrIyJyfHxsYmKSnJ1tYWgevBdwXIS09P78MPP6yurs7LyxseHk5LSzMyMhK7HEOx1BaPx+vr6ysoKKivr09KSvLz8wN1OOL16P8M0GhORUUlJCTE1tb22LFjn3766fbt2729vcXL3Yuftthsdm1tbU5ODp/P3717t6enp+S1FZ0568rc3Hz//v00Go1Op7e1tW3duhX4R1EPcE6IjbZgGB4ZGbl06VJfXx+ZTA4PD7exsTE0NJSwMwdfA4/H6+rqbt++ff369W1tbYWFhRgMZu3ata6urshfCIuBtsDBu729vSdPnuzs7PTz84uNjSWRSGK6enpXgH9ctWqVo6NjR0dHfn7+0aNHg4KCwsPDFRQUkGzDkK4tGIZfvHhRX19fUlKioKDw+eefu7i4SLateiNYLFZGRsba2vrjjz8uKSmhUqkdHR3gcG7ErmAQrS0YhoeGhoqLi2tqapycnOLj4/X19Zdz1TJIM0xISDA0NKRSqcePH4+NjV27di0yf2zIfU98Pr+3tzczM7OlpSU4ODg4OFhDQwOZP9ClBIvFKioq+vr6ksnkrKys06dPT05Ouru7z+8sj0UFidoCzYlu3ryZn59PJBK//vpra2vr5ZBgPnfweLy9vf1330Y2N3sAAAYZSURBVH1XWFh44sSJpqamsLAwCwsLRPlHZGkLTNtHR0fpdHpVVZWdnV1KSspyOxpuLsw0k46JiTEwMMjKyjp69OjWrVvd3NwIBAJC5IUgbYEmfe3t7RQKhclkxsfHu7u7r1ixAmmmHlEQCIR169YpKSkVFxcfP368r68vODgYISk6iNAWyGWYmJioqqqiUCja2tp79+6d6cuAkF8hAgFPBnQ6MTQ0LC8vLygoaGtrS0lJMTIyAvIS4dNDhLYgCBocHKTRaLdu3XJ3dw8PD0fba88d0GhOTU0tIiLCwMAgOzv74MGDycnJTk5Oos1gE722+Hz+vXv3KBTK+Ph4YmKiu7u7qqoqKqx5QCAQVq1apaGhUVZW9p///Mfb2zssLAwc1ieS8YhGW8AJTk5OVlZWMhgMGxubsLAwc3NzDQ2NP2vShzIrIL5qamqakpLi6+vb0tJy7NgxIpEYFxdnZma29Hv5otGWUChsa2ujUCgPHz4ETRlWrFiBSmpBwOFwSkpKdnZ2VlZW9vb2GRkZ//znPyMjI0EaxVI+5KXWFsi7AontXC53165d3t7eyAwriztSUlJWVlaffPIJlUotKSkZGBgIDw/X0dFZslLbJdUW2By8fPkylUq1tLRMSUmxs7OT1KpihGBkZJSWllZXV0ej0fr7+xMTE+3s7JYmh2KJtAWaMnR0dDAYjNu3b/v5+UVFRYEDB5dmAMsWcNZVYGCgoaFhRkbGsWPHNm7cGBgY+FpX88VgKbQFQdDk5GRzc/O5c+d4PF5aWpqXlxfy048kCRADO3DgQHZ2No1GGxkZCQ0NNTQ0XNSdtMXVFuh69fz580uXLl28eNHKyiomJgZsey3qfVH+CBaL1dbW3rVrl7Ozc25ubl9fX0JCgr29/eItzBdRW8APDg4Onjx5sr29PTQ0dNOmTYjqy7DcAK0MPT09NTQ0srOz//73v+/evdvHx2eRtiAXS1swDE9PT9+9e/f06dMyMjJ/+ctfXF1dkbONujyZScNfuXLll19+WVlZmZGR8fDhw9jYWD09vQXvNbfA2gLjk5KSGhgYKC8vv379upmZGchlk5gWGhIADodTV1ePiIjQ0tI6c+bMwMBAVFQUl8vF/P4GF4SFt1swDD979uzIkSMcDicmJsbb21tZWVkgEAgEggW/F8p74uLioqKikpWV9cMPP2AwmPXr1y/g7x+7sJYQgqBnz56VlZX19vbi8XgZGRl0doVYwKsHOXMCgYBEIq1fv34B+yousLYwGAwEQVwud6ZXLOoHkQ94U7KysgQCYQFtwcJrCwUFIPocGxSkAYJHwOjMHHU7j+ug2kL5f0BaOYvFamxs7OnpEQqFzs7Ojo6O8vLy81DYAjhXPp/P5XLR4+YlAKFQ2NjYSKPRpqensVjso0ePvv/++8rKSjabPY+rzdNugc0cHo83NTXV2dnJ4XAcHR1JJNL8roaCEDgcTkNDQ1dX1/bt2wkEQmdnJ2hl6OrqSiQS39Vuzd8n8vn8O3fu5OXlVVdX+/r6mpqaotoSd+Tk5Ly8vGxtbRUUFLBYrK6urrOzc0dHx/T09DyuNn9t4XA4GxubgwcPDgwMsNlsdL0pAeBwOGtraxiGcTgc6Pf58uVLeXn5+XWhmv98S0pKSllZWU1NTVZWFhWWxIDH40HHDaFQODAw0NnZ6e7uPr9k6HnaLXCnV/9FkRiAxWKxWFVVVZ6enpGRkfLy8vO4zsLEIFB5SRLT09M3btzo6enx8fFZuXLl+Pj42NiYsrLyu9aiLUyAH/WJEsPk5GRNTU1dXR3IOG9ubqbT6b/++us8Ug3e124JBAI0siUxcLnc+/fv5+bmcrlcDodz5cqViYmJkZGR9PT0eRTQvld8SygUTk5OcjgceXl5NpvN4/HQJC2xBoIgIpEYGRkJ9nywWKxQKFRSUnJ1dV06bWEwGB6P19vbe+/evbGxMTabXV1d7eHhYWJiIisrO+9roogWIpHo6Ojo6Oi4IFebZx4EDMMcDofJZA4PDz979gyDwaioqBgaGuro6CznnpEorzJ/bYHd8v+5FhaL9ghBmQHN30JZLNCEY5TFAtUWymLxf2qmqPtqtbD7AAAAAElFTkSuQmCC">，由 $5$ 个点 $8$ 条边组成。请问如何才能从点 $1$ 出发<strong>不遗漏不重复</strong>走完所有边。</p></blockquote><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>简单的一笔画问题。通过一笔画我们不难想到七桥问题，作为尝试，我们都知道一张图内拥有 $0$ 或 $2$ 个奇点时才可被一笔画。</p><p>显然这张图上，奇点是 $1$ 和 $2$。因为题目说了从 $1$ 开始，所以起点为 $1$。</p><p>我们考虑对这张图进行搜索，枚举之后每一步走哪一条边，打上边是否走过的标记即可。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>这题没有输入，可直接打表。具体的答案在程序最后的注释。</p><pre><code class="highlight prolog">#include&lt;bits/stdc++.h&gt;using namespace std;bool vis[<span class="number">10</span>][<span class="number">10</span>];int fa[<span class="number">10</span>][<span class="number">10</span>];int ans[<span class="number">10</span>];void dfs(int u,int dep)&#123;    if(dep&gt;<span class="number">8</span>)    &#123;        for(int i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)        &#123;            cout&lt;&lt;ans[i];        &#125;        cout&lt;&lt;endl;        return;    &#125;    for(int i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)    &#123;        if(fa[u][i]&amp;&amp;!vis[u][i])        &#123;            ans[dep+<span class="number">1</span>]=i;            vis[u][i]=vis[i][u]=<span class="number">1</span>;            dfs(i,dep+<span class="number">1</span>);            vis[u][i]=vis[i][u]=<span class="number">0</span>;        &#125;    &#125;&#125;int main()&#123;    fa[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;fa[<span class="number">1</span>][<span class="number">3</span>]=<span class="number">2</span>;fa[<span class="number">1</span>][<span class="number">5</span>]=<span class="number">3</span>;    fa[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">4</span>;fa[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">5</span>;fa[<span class="number">2</span>][<span class="number">5</span>]=<span class="number">6</span>;    fa[<span class="number">3</span>][<span class="number">1</span>]=<span class="number">7</span>;fa[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">8</span>;fa[<span class="number">3</span>][<span class="number">4</span>]=<span class="number">9</span>;fa[<span class="number">3</span>][<span class="number">5</span>]=<span class="number">10</span>;    fa[<span class="number">4</span>][<span class="number">3</span>]=<span class="number">11</span>;fa[<span class="number">4</span>][<span class="number">5</span>]=<span class="number">12</span>;    fa[<span class="number">5</span>][<span class="number">1</span>]=<span class="number">13</span>;fa[<span class="number">5</span>][<span class="number">2</span>]=<span class="number">14</span>;fa[<span class="number">5</span>][<span class="number">3</span>]=<span class="number">15</span>;fa[<span class="number">5</span>][<span class="number">4</span>]=<span class="number">16</span>;    ans[<span class="number">1</span>]=<span class="number">1</span>;    dfs(<span class="number">1</span>,<span class="number">1</span>);    return <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">123153452</span><span class="comment">123154352</span><span class="comment">123451352</span><span class="comment">123453152</span><span class="comment">123513452</span><span class="comment">123543152</span><span class="comment">125134532</span><span class="comment">125135432</span><span class="comment">125315432</span><span class="comment">125345132</span><span class="comment">125431532</span><span class="comment">125435132</span><span class="comment">132153452</span><span class="comment">132154352</span><span class="comment">132534512</span><span class="comment">132543512</span><span class="comment">134512352</span><span class="comment">134512532</span><span class="comment">134521532</span><span class="comment">134523512</span><span class="comment">134532152</span><span class="comment">134532512</span><span class="comment">135123452</span><span class="comment">135125432</span><span class="comment">135215432</span><span class="comment">135234512</span><span class="comment">135432152</span><span class="comment">135432512</span><span class="comment">152134532</span><span class="comment">152135432</span><span class="comment">152345312</span><span class="comment">152354312</span><span class="comment">153123452</span><span class="comment">153125432</span><span class="comment">153213452</span><span class="comment">153254312</span><span class="comment">153452132</span><span class="comment">153452312</span><span class="comment">154312352</span><span class="comment">154312532</span><span class="comment">154321352</span><span class="comment">154325312</span><span class="comment">154352132</span><span class="comment">154352312</span><span class="comment">*/</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF616D Longest k-Good Segment</title>
      <link href="/archives/CF616D/"/>
      <url>/archives/CF616D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><blockquote><p>有一个长度为 $n$ 的序列 $a$，找出最长的 $[l,r]$ 使得 $a_l,a_{l+1},a_{l+2},\dots a_{r-1},a_r$ 不重复的数字个数 $\leq k$。<br>$1\leq k \leq n\leq 5\times 10^5,a_i\leq 10^6$</p></blockquote><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>分析一下复杂度，$n$ 的级别显然告诉我们要做到 $n^2$ 以下。</p><p>观察到固定左端点 $l$，随着 $r$ 往右推，不重复数字的个数也是单调不降的。考虑双指针。</p><p>我们先让 $r$ 往右挪动，每一步检查一下当前的不重复数字个数，如果不满足题意那么挪动左端点 $l$ 把不重复的数字个数控制在 $k$ 以内。</p><p>时间复杂度 $\mathcal O(n)$。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n,k;<span class="type">int</span> a[<span class="number">500020</span>];<span class="type">int</span> cnt[<span class="number">1000020</span>],sum;<span class="type">int</span> ansl=<span class="number">1</span>,ansr;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin&gt;&gt;n&gt;&gt;k;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        cin&gt;&gt;a[i];    &#125;    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;    <span class="keyword">while</span>(r&lt;n)    &#123;        sum+=((++cnt[a[++r]])==<span class="number">1</span>);        <span class="keyword">while</span>(sum&gt;k)sum-=(!(--cnt[a[l++]]));        <span class="keyword">if</span>(r-l<span class="number">+1</span>&gt;ansr-ansl<span class="number">+1</span>)ansr=r,ansl=l;    &#125;    cout&lt;&lt;ansl&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ansr&lt;&lt;endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20230427 | VP 往年区赛</title>
      <link href="/archives/20230427_mock/"/>
      <url>/archives/20230427_mock/</url>
      
        <content type="html"><![CDATA[<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAVMAAABiCAIAAABieKefAAAgAElEQVR4Ae19CXQc1bnmreqq3ld1t7ZWS7IlWbaRtzYYOazCBEPALAFBAkbzkklOzpA5gZi85PkMM8m8eTN+553gOOdkHF5OeG+i50wmCCYP9IbVCztmsQzG2MZYtuXWvve+VFfV/Leql+ruklDLsgHr3tOn+9bd71f3+///LlVNiaKIiCMIEAQWGQL0Iusv6S5BgCCAESDMJ+OAILAYESDMX4x3nfSZIECYT8YAQWAxIkCYvxjvOukzQYAwn4wBgsBiRIAwfzHeddJnggBhPhkDBIHFiABh/mK866TPBAHCfDIGCAKLEQHC/MV410mfCQKE+WQMEAQWIwKE+YvxrpM+EwQI88kYIAgsRgQI8xfjXSd9JggQ5pMxQBBYjAgQ5i/Gu076TBAgzCdjgCCwGBEgzF+Md530mSBAmE/GAEFgMSJAmL8Y7zrpM0GAMJ+MAYLAYkSAMH8x3nXSZ4IAYT4ZAwSBxYgAYf5ivOukzwQBwnwyBggCixEBZmE7Df/VNR3kDh85MnD22NGeNwMjJ6N8rG7Jcper0VO3bK1vw5L6Oo2GiJuFRZ2URhAoGQFqof5XL5lMvvLqm6+//HQitDcyfIZhUzVm2mwR9SYxEkCjg2gYvqc0Oqtp440/vPc7P6yv9ZTcWJKBIEAQWCAEFoD5HJd654OPup/5p4HjTy8pG21ZicqdCPR6hEepOEoksZ+LoFQKpZJo9CzVcxidnqY3/9WPfvTXj7ldZQvUEVIMQYAgUAIC58v86UCwu/vfXnx6V62l52vr+VCCPnpSNzHNUBQN1oTRIFTZEzUejqZQKIDJHw5Q8TAVGhWOn0bDqPo///J/3v7NO0to76xJOY4D0yMluVkTkkiCwKWJAE3TGo1GKznwz9LJ82L+1OTkM091vvHcr9Y0+DWs6dhZC60tdztry1zlVos+lUgEIrHBvrPj030mQ6CxIqzViFycisRQMoCSIXFqBH0yiL712C9/uO3HmllbOUsHslGxWCyRSAD5BUHgeT4bTjwEgcWDAAUql6YZhgHu6/V6lmVn6vv8mR8MBv716f+976m/d5vHQlRtTb1vdcvKy2o9tVVmrVmLKArxScQJodHpg6dGPjz+yaH33qe5/gYnp9VRfApFg4IQQ+FpdGSAvvPRv/vJ3/xsdhE1UwcgHIwLUPXhcFim/SwpSRRBYJEgAJrfYDAYjUaQAqpdnifzQbu+un/vE7/8L1RysHHN5b4N11+/obHSzqAoKPQkEniU4JGQQCKPWApZdQmOOnjw+F+ef+vTTz6uLwuV2xCHUDyCxBiKhdCHk7rv/+3u7373OyCxVFs5eyDQPhgMAu0XarVy9upILEHgK4GATH6LxaJKq3ky/8SJ44/9zU/PHX/v2w/ceevd31hWrkVjUxgOGp2bnByfCiUDSSQmZIBoPV9hYetqK4Ynw7v/8Orr+99dVhYoK0MpHnFRRPFodBINa+t+/afnV8HyYIkOJvXRaDQSiUA+wvwSwSPJL2UEgPBg7ZvNZjD7i/up+cUvflEcOktIPB4/fPjDl196ce/efVdfffVVraupVFjLxU1Wy3g8+f7Rvrc/HOgdocdT5pGEaThu7A+yR3sDZ/0jiWCgoca0ckXN6Hjy8IlhC53SaZAoYP5bTWh0IHBuKnbdphthfjJL7cVRoPChScD/4igSQhAgCAD/VZlfms4Hi/ov//rc0Y8/drtdlZVVtbWe6Ymxjw+9XV2WWnd54weHevsnDS3rNnqXNDrsNhoW9BHikqnRsfFB/+kP33xhvWtk8w2rB0ZCu37/0mdHP2kuR7QGccBZEUUn0SDj+B9/3Ovz+Uq6W6DtYYZPlvRKAo0kXiQIAO1BlTqdzuL+qs/+i9PJIfv27T/Uc/iWzTe2tLS4XC4RoXA45qquP/7h27//X3vLqho3b7n7shXNOm3eimJttSvU4LXYyvY+/Y/lhz7dsLHp9ptafn12ZHh6vNqBBAGXbbGjaN/Uvn2vtrSs0uZnn6kxcjhZyZ8dHxK7mBGA+S8oRfgunurPtuNXAFl/f//+fXvvu/ee666/3ulyQSzodIvZsH7tqjWXX41MdeuvvH7NqpVp2kNVksOFwE4DRa1cscx3wz0fno3Hh8d8S93XXtEUEZhYPF1JikZ6AR159/VgYDodRH4IAgSBC4ZACcx/5pmna2rr161dI8pqWtEmmGyvXbuuedkyPpXCAgYM/ayDzTqaZrUsLNs3r1gxljCfOjVcZtH6WqpYrSUYQYy0nC+KyGlFU/1HI/GMMFCUT7wEAYLAwiIwV+YDn4PT0xs2XC5XL2++DQ74n9j9myeffBKm2kuXLDl6/MQj237y3HPdsWhUToATQ05JUrAaDUtTcaQNxJOUBtW4ra4KVxjipaRwkMdlQUJwcHwqDAb8wnaSlEYQIAgUIDDXeT7w12ixupxOmNtn3aFD7//qV487nFXf/8EP1qxueeXPLz3z1J/7+wfWr19fW2uUk0F6Hh+qg08qxSUpWNMD7c9xNSZ6XYNt/yADx3riYdQ/iZIcGmcSFgODExBHELi0EAD9lwhNRgPjrMFstJdrGJZPhNJnXkAT0jpRY4C9rlhgjIuFDVan3uoE2/nCYTBX5kMLJLOdhg4Isj2PkNNZUVnpMZtMZTYzo9GsWLG8vKLyyiuugMMDsoCAxCAyYI0ByA8e0P/pnvCCSct4q8oMGuMnp4Mpq+6q65YtrXI999rhg+/31NXVF6wRyrlg6w7akFs+uHCokJIJAguKADAgFg6MfvwmFxph9Ea7y+1wsCgxKfJxCgkiokVgPmMLBIXgxHgqHmXM5RWrrjVY7HAaZ0EbkitszswXxYmxIXB1dXWY+4IAAunyK6743e+fBEqPj0/09fVt3nzTpk03wJq/yWTMbrCDJ8mlEvFYPBaDJUGRg4N9opBCooY22YznOK3ZW/mTjitX1tgj0fjNbbf9wx/+m8HivOe2TcDwXDMlHxwchEDAAg4kZpcRCtKQS4LAlxCBRDw62nfi1P7OygpdODIdjA+XrYRnWAVaa6RoRhQ4Ph4RETNwDPH6StZk7xuOU9byysbVRpPlAnVnzsxHyGi2vf3Wa62trXByBsHDAMA/hmlqaoKWRcPvH+n3N0suCU/t8gKY+BCeAlnHAfFToUg0Fk0Eo5yDjS11aFAigXRsOMk5HKYHv7X+mrXVzx848caR4Zbl1T9r0+3e23nPbTdIWwd5vQa2w3E9KBK2KHU6HdQ+ywMJeTnJBUHgC0WA4cOO1Knl3pDLMhaxaHnTKvd1V2r0VtBjoDhhYAt8SoiHquh36fCAWdvv0OotfC/DL4XdswvU8Dkzn6IeuP+Bv/uvjx0/fqK5eVk0FuNZLWhlWNUHEeB0V77x1ruI0Xtr63AfECXCQznA/FQqkUzGElwyHrPZ7d3P/aVON1m1ZIU4HRG4FJ3gv/f1phtqLUwweus67y1tjf9p92s1uiqfeXhgZKKm0l3QZ3gCAQqUn8mDemW1T5YDC1Ail182BMTpkxr/S5axl5wra8xVSwTWKrImxlZGaWDDK23Ywok6Wmdq+No18CoLDRc0DZ1Jjj1FaQNizWbKvuxC9Giup3ehiSaTSaQ0u3/z+Jq16ysrKkHfMhpGy7Knzg11dnbqEv3nzpzgGFvD0kaei8MTs8DScDyZiEU1Wn15RcVTz3SffPl337t5mZFlxVQqnuCikWRNudWuY/zjEUoQDHb90Gg0EIq6jIx22S3lLkdBh2WYsBkhPZwDnAeHlw+IIwh8WREQpo7RQ6+wwUMWp8lQ3UzbqvV2t9FqwTvfcHY18wE/hOhMJo3BLGp0LFi1TEIMD4pcVNCYKUP5vPsHS2PA3KyIyZZT2uldmGnvfWXvb5944rJVa+qbWqDQ0ZHBgTNHV3u1d92zCbx/+D+vCcal6zde6ypzyqd3gZkj45PvvfmaafrtR+9c5q5wiKMBWMMUBZ5m8IJdNM7934N9a2odl9WXTQaiBpP+2Xd6v/HzFx02FTsHqA46H2x+IH+2D8RDEPgyIgCLYbFxdPpPbPADiqGSpiZ4jjyVEnRGvc0NG2IuWgPkT+t8kAECL0wMjQfGJuORGKzp2xx6beQzMSVy1vVo6f20wYWo+Sz1w6TY7XYXM3/O1r4ELUiilSuXr6o3LdGeTPQNQphHz9xzW9OKVU3wfG5VvafhB1/vfumN8Q//NM1apD7Bap7IRSautga/fdd6MGj48SkKHsnBZ/UpIYU37g0WI6/RfOyfLqt3VNU4o/7ez6JlZrNJ9V6CqIDHD0CagOaHb3CqyUggQeALR0DgYrz/Ve3oG6zDMo1q3nv+3emhMZgIa/XamqbajVuusTjMMM+X2ynyQng6cuiVt/tPnuMSSaC4vcq14cZ1drafH32D01aj+ltprTop5tfT0nQ+vPbmhRdfGTv5wg8eugeFwng/AiYqoQh+LB8cPJavZZDNiILTIhzChdfuCQkxlaQsWlHHopEpPsWNTYdHpqZtZl2502gU0WQwHkIoxIkvvNOLKObWdRX73jkmbnzs4f/wYLGUyvYQ5hHwQD5M9Qn5s5gQz5cKATi6kpru077zU2tVVVCw9p6eONfrv769zWw3nTl6+tzJc+4a9/pN6/XG9JOpiVjy0L6eoTPDtc21TWubYqHoa8+8WuGtaFjitGsiwaHB5MZ/YOz1DJtOP/fOLoDOB5rF49GB3o/WeMxoahpNhdL78/KRO6x+RfzCzZEoGPMUzYqsBvEgGBgxkkDBKBJSUVo44p/6bGCCi8Uaa8quv7yON+q7Xz2upTWtDWVnJ4V/efm4Yc19jzzYPgvtoc/QGZvNFggEZPLPHQWSkiBwcRCgoyPsuf06SqNlXCbKUlOpdTvKXHa71q6rv6zW6jQBXTTywXWpQbSGKvc4XdVOZ5XTajcbKHbt2tUMy5j1Fi0y6OlR4dx+WnsbstUsVPtLmDnAatrZPn9k/LP1LQ0IXqYHT9QBr4H20Al4zh7v0YM/hUN4eD0OvJMnieB9eBAIDqYoDGPSaK5qdt1747Jr1tf1jkXeOjZiNbJ3ri8bOH78+TM225pvbtj6tz/a9jOb2fC53YNdfTgvBJb/hTvqoGjDgUc8ni2dfkWI5IVgldDCVOR6sSEAU1E+OMT43zJqKzWcyZjUVuhtdTUeLSjEFG+1GzwN5VV1To0G+AIvsMEf8FfWOb1N5TaHgeJSTIryVldX2p0mwaCJGw1sJdv/Nh8chIIXCswSmA+Hb998+50qq8BWePonA+dCkTgwH/hvAKmkRXoGaSkEb9tgRaSFb/CzyMgieB0IQ8V5cTSFjk1FXzwy+NunDscEceMV3onhqYnJmLdM0+yiqpuvvvKWrd+85z44DgilzsXB5gK8Zmx+W/r+zi3FnFUNhJb4O3d2ofZtHd65tEqRZqbyFEkUXkjteeSAIuDzvThLcTc+P1/JKXBFRTVdOLk3ByggySw9TwODBXYO03RgqZ2fRzYuHk4Fh9jAgJaz0SGKDXLGBDIwLJWEt9QlNZRgMDFmu46mQFly8gf8EALhEAtpqGTKwDDGmMgGknSYhnKYUD8XHICSS23/TOlLWOED7Rqe8G+otUY47uVXDx359OzGtU3lFW6j3Ww2ak2sRkcJGoSVP8cLSTjBk+DiiVAsHApNhkZHA2eGAp/6x08PjEdi/GWXVdzUXF4pCGY9KyZEBOsDqRAtpuZG+Vxf4EgPMB+fLCrReTu2NXhat6CD3Vk+H3ikdTtq31Nc0IHHt/f4duxuK46ZPQTyoQZcHgzArV2qadv3DOwqLFeR2rdjR8P27QVZfTuyjT7V04MatmUEEgzR1u09qvUo8qjGf16gt6P7INrS2vqIV7W9O33ZJqVLmqUt6RSlNwnKfAjtTt8wlRtY3Im2XQN7kGfrlnTz2rbt6Nra6unKAqjaysKGzQNkIToqhgZoSk/Dy+bgbVEMjQw0SnEw+cUfAW/hFbc2HQJrZ7z0SYloBCbUFGVkKTj+qmOESD+KjiKTbca8pUSUwHyYXdfU1NBoSifC+3PZva8fOnK4x2q1M1o9UN9hMVr0LIKjiGDYi3wyFpqKJMcmQ3wiKqQSvEjxfBLW+Q0U31Dn8FVbLLxgdpsR2AZJnYXVDI75k/EoQoV7+KX0paS0bbsO7tjS+viBDol6MAa2dqnxMK3w96QFhIKW6dq6Wj3bcxXnijjwyNZeGGJtwMtTEJ+LyCTGRWX8yl8YrgO7JHGx09fW0THQARfQii2tPdsKaOf394IpkpUcQM+BDmVJ6Xwgt9pxM0p3Rczo2eqR5RDuTrq8tl17nvW0enqKhFghhRT1Q993Ki7BWwxspioZu0Ys1vIEs3wD86V3fpn4CqOZDvV62wAhL8D+UGdbVuLnt7K4YfMBWcNNImGErjSjctiZ1mOeg23NCPiblnajZt+SwslgfQyhequUV0SVFDPm0PLjIpS8QK4E5kON17RtfveP+6/Q0q0bmi9vafr4oyN2rRAMiFOjVB+8eAvRVgrVsFwtlbQnkxpBE+E0A4wOTvo69BSjNYAx0D+Z2Li6prbaIUQSIAgQDft7+hVV+lOjH0yOjVZXV53/i/dnR6ZgNOfGF0LZca3gKVb47Xu6Mb3wqPAdlGiZrkIOyQ6iXMVYkADvd+X41qWsKJuwXfIpmoRT4bHYdmBnV/s2Rf5sFsmj4Emm3PwRrChXJSK/sJmv1GRJLnV2ZpJWrY/ckS+ZerbnCcVcRslX8NK1tLyTE2FAFHIOLj1b4S7kF48QtkTa/F6vAg1lJT256hUYKEQBylfnyrzYryi2RJDhzZQaKkjbtIlUKDkxysfx2RO8GQ8zX4NIwQurZlb5sEoOMwAUo1A8vUSm0bNap4G26mg+KKS+CGsfWl9fv+Rg+eXi1GS13XTrTa2f9Q0HkqFatwGOHkd5uopKbaLDjUzMJAhaEQm0GEbimzz6fzzYOrzAif7heFNT5c2tjXBYmQfagxM4gdbXNlYuGzzV9c//WPPzv3c67Tj8grriQaSoThp26WtQ3F0wamTeY6NgRi4qCoAh07q9YQ/oXxixeADjuOIq8cCSc8kEUw73A49sR3K1ynJzfoknigxQVoEOlawEPEsptMNzhSykT8mnTLmz1K3S3kyugl/cSSx7ByThWxAJ5PeCcPXKVpIiEufqas/vOq5TOSuBNNmbm83a6PNlBBbUCVJ+XiBTIoeJqxUig0OitpF2lVPwTC6XDAeHDFa31miCCTEXj6SScZ0Zm8zgSYSnwcPqTTTDJqORaHDM7KjSsFoRtgejo9zIZ7pqnorFoeRsW8/TU5rOh8q+9f2fvv/0f79ifcWmDfUjE9f9oWv/6aFQRZnJw/K308EWKg6aHGbu0EBWFMqQsIXmh0T2zYhuZCy81ON6+J51dW6zAJt8GQfPKmndVTbm9APfvf9i0D5T7xx+saWHMiMBkxeLgM9zIC2QpJ6y9MXKcTadX1giXlGcReFnkoPG8vka8ZXUzrwXl/o7H4IpPxgr2WWMTK4Sf2Xm5Wfytbejri5pRWGmuU5+hs+5wjKwYDEDcmT0LM6ch55vx1/au+6SVzRmkC5eb0NhnQfAlkLYCsEyWJo7qFgR2IzInzHND2TQ2/hYbhL+ZErX3KRb+jWNyQpP3SdOvGdZuspQVgnP4aamRvjgJFu9VG9xxMNT0YHTrLVM56iAZ3iFyZEEOuJcvgGe5OcjwfjpdxKfvqurhn+vgb2Awn7N+7pk5kNNLbc8fOzt36xssN23ucVkoJ/pfudT/8hqc2KlK2ljxSg8bQiGDUKg9sExnAAv2z2TZDf5Gr9368q1y8uF6SBIB9ixl0/gUSZqdKzM8d3frlh7Lc7wJXKZcYCHJtqTWRDIX0ZTjn08qNpA/anYCFJUXtekQvNC0hf+A8AqeebRvmcP2pplhcyFzGA/8GwXarhDmk+oW62+HY/ORVKpNSE/TNl2SZv6Hu3eJWlDsILau7YqDHNlxqzIVAZm/QprX7JgshGyR5IGma4WxMElLH9IVk2xwChOK4e0tXWgto42MAZ2dj7aXUjwmXLND2QezrCA4hNTjJ2hjTrW4dZVeDXRoGbCr/MsMbg8oPA5g543GvU1S+ElHCg4EU0ltXa33u0Btc8bjExoDKK0RmtixJ806hg7Lg3+tUZATN7LbWdq9xzC58N8g8m85Kr/eOTVX6+uN9x9Y8uy2rIX9x0Jnjnz/PSQORFnOKSROJ+Q5jNJh5mv82zzNW2+aYmdpV5+/USZkV3XUC7CDgescpqYcIoONN2/asPX59DaBUqSp0LUypTn3+mYzFqddJkRBmq5FGF4mgAqV2aemimct/aUl9Hz7B1gZsrTTDkVTBcURmc6sWLlCXt9Dc/iybCiJLBWchNdafHgfPV/XuHSRYNXsjmKI+YIU3FGCMmZACqyQ00Y5DKky8N7Iqin5xQq6nGuXUWZFG3Jirp5gswz1iQy8/GgvtKTDA5z0+PAfEX5JXghLx8c1lca+fhAglpOM9YSMs+adD7MhwINRnPjdQ9/sO/JZfbglWs9TXX20ZH1faeGzvSNBUfHYRqD0xhot8ezotG9sd7ldJsmzww+sf9YaDr87WubYFsDDvTTZl2EsUXqH2xuXD1rIxc6Mntn1QqWSJaNgCtprQ7P2ec8bZZ4ny4CFydbptky8zzyUM6k2vqsch0rbcznpc9c5MxQvFDla9+9q2NXZrldlhSFE91MzpJ/CwWlTxKM2NAodpmOFMeoh+QxWc4Mhk57V96UXD1rNjRtM+DcGfPD39mF1JqXXqaFSRDeGugtWgyQWtBwR8ZWmifISU1ZkipPhQI275LIkU8Z52rUvC7b3JI83Pg5buyEbY02cDwQtbi1mjJTSflnTjxP5kOBRpP58tsffvGZf6Z79m5YWb5iqWtJg/NKDi9eyGa8RivCwwkGMTZ0bOpPrx3/5KR/WY3rwbuWl+k0gpjSuGx+bolu2W3VtU0zN2/hY3JSXyobRH/BIFMmwGt1MIBAecIIHRjAcnuWoS0LFKxMenfsaN8ub/Ypi8v1BieSVwMgTG7DwR0PwcDdheBcIF6IQqDI08Z8LlvOB+cJYS1K2pRUWKS5+IXyZZqPu50nSjLq0L8zr6pM+rxANZslP4GMqgwy9vvaH52nkpTLxRP9Lj+AVFCKEitvx+4dXa3KHT5pdURxdGO+ILMmJ2X18uPwArskip/jg+dS4QDeqCvRQS7IixLnaNoAf0+rs3oZk8p/ZpRYajr5/JkvF3Dz3d+Jx7/15ktPf/S7f6owi54yk92sg525SJwbDUTOjsMKplhmNk5HuQdvWrm8uQo2KEWWCcTKk7XfqF162fwaPf9cmQHcdiA9kIt3o4GHYG/LB2zUZqBQuYrNgAuWlAyMLYjuQLA6P1cHtYCS8XdK6dvuaN+684C/w5tdv1MtBnRW98Ad+Iwajs7MK1STnl9gWkY9KpUCFz0yNngxwtcOtj6wQ3YZaNMWdsFlJpXKL64BY5ZZP8XGRI9yppLOo4K6HHOgs7Oxo8Cwx4v0xeY+Jr4CK5n7mfNJkpjH9y4rLeYLMry9Kmn3RhivZWpKa0mJ0VPRMx/rG1ardH7WIMgFebXWSGI6CaXp7V6teWGO8UC10lrcrNV/bqReb7jxjgfv//lTho0/fj3S0nW26s9nKrsHaw4m16GWf//SqYplTu2Pfnqvr7mOGk30fGo+HPDZN/11+cWnPWhXfByv4FgLNvt8XTuzp/LbHt3RuzV35jPTfRjJyqOgmeCiX6Cx4lienAsyFji8agdGNHaFh1CB+j1dBzrx+h3esprNQV17sOU926xgtvxziAOuKFYKJWzwEWOZ+EXng3ItVkmQ7q8CCfmwMhavSsykawhSOqmb6s2FqdV24HiBw0q/Fyt9pZOInzXlcQyYKHiNUmoTntUp25HOOQ+Q4Vly0Vgzbb8xPDxm8rIofjz4wb/BKzhhhqtszix+SAnpIRfkNXm14WF4vvVG0eSFkmfJVVLU+er8bGVVFe6777oDPrKpnw0vM1Hu1U1jvBF5NtpWVfrKqrJRF9sjn7+XjuPlDYmshZrRU917erJnPnEYtvgz5j4UUkK700X7/XDgREnjtCZVyIhcoUCvna1wZhcrJ0kfZqIy+1w55YcXFNp37OiF3ariM3SZbIW/Uo/gvIFq5fmJc/uLacAkLflQZ2eDdL4JepQDMm/ej0UsFAW2S06D5pqdX8kcrqQ1TGxhFDpYA9yKTbDMxDwXj5V+l1R/5q52nMrX+Om0kBDJW5QqRgJOMy+QteZyR+PNiXefhbfH6Sw8P/nJ6At/FKqVYyDX1mKfEI9Beh31ic4yyUfhkVSDY81mKLM45bxDFoz52RYUPGD7YMdfZaO+WI+k8NPn77FKKLrRsp7aDXfHKx/tfQr1/hgmt/IEX9H4wiWvdFTejoAiub/z8Ydg/1tt/1iRStWL9V9u3S4/CYxoyUruaIM1bLCYC8/Q5afOXuFeKg/9ZiOKPZAUFT6wALJsN56IFx40UpITc8W3AytT2F2AlLBqcV4ufedUaQPFK0RY5s6AMHi03bddoj6uGowRmMTnmfrZFRss07uhbCxl8eHkPAk1T5DhCVyWsVSOVfw7NPVnu3nK6NZyfXtTYw3CklXIJc3QZkZECEykPnqd1vUa60KID05NOcbK73OZK6HMmTOVHLPwzC+5CRcrA2ZRti5QrL7WjBLNhsIgSOuojB1wr9qgzRsbcmasWLCWU3Pejl3d0ul7tchsWEZnStNNmTcej0pN6Qw4GZzzS4/6vL5li1T14PXqQjqrJpRs4W7oGGxq4ASQC3MvXXEGJxCh29M4wsEhSKDkCqx3AJ8ym4tFcONSVXuYZ+rgVLkbg68kJ0kwaFNH7vQu5nDOxkDb2rdvhTXQO6QVE/+BnT1IWpnIUh6qVhoLaSkLdUuLJ7hhaL4g4xbSjF5f1zb92YAYecNhHLNURsXBRIqwNhQAAAPaSURBVOyjbio8rSlXlWIoOTkaG/VHe9+wsMcsldNiKjIddQT0V+lr2zTs5z+6LgMzx+/S3skzx0IvZrKQ5C5mjXOqC4/d7OJ9JgcWDzKLpLGcOWCXDW7fc9AHhn7OEi9igFySdMCnYEtCismWBFeqlJI0m1rOTBM/7xfXkLfGX5BBtd8FaRbo0t/5yIG2XQqmF5ebxgMkQgbr4jQzh0Bf1KCaA8iKMkfPHUV9z9njrzvd8VSEjo05KMtapnJ1SmePRzm7t1lvdsSCE4H+k/B+HiY5nRo+IoY+NLinGJMwPqYL6K+j6m5317YoiizNO9M7eQjzS8ORpCYIlIrA+NDpaO8L1ZN7jC7K6DRzY6lgbzIesqQ0XmNVA6MzwqH92Hiflh/QW0LWBi3rZqIT4ei4OOh4wNj4DVfV0lJrVKYnzFeiQfwEgYuHAPyjZCISCA0f50/9i5PrMemirMXEWs00axQFBj+HiwSk4eEF21wwzIUikYRxgvVpGh+0VK7QmWzwn1Ln09aZmH9ehZ5Pg0hegsAiQQCoCya9xrtWsNnhZXYTE8eYyGeOqF/H99P4nTz4NbYizcZp55S4MmVs0ntXOlxNtLWe1RkXcBuvAG3C/AJAyCVBYOERAALrDGZkaBGMtaJtORU5x/Mj8eSkwMNfRcI+OKVhdIK2jKErNKZanc1jsFgXvhH5JRLm5+NBrggCFxIBk8UKH4RWQCXw8ngBPtL/6lEMA38UqbuQVReUTZhfAAi5JAhcJARgBg7uIlVWVM2CHQYsKpkEEAQIAl9eBAjzv7z3hrSMIHDhEPjKMx8OC1+49c8LhzspmSBwERCQ2VFwoF6u9yvPfPgXgC9wsnQRbh6pgiAwbwRAKc7Ejq8886Fj8/ubnXmjSTISBL4qCADz4d9oVFt7KTBfp9MB+VVNGtU+k0CCwGJAAMxhoD3896RqZ7/yzAfCQ/dMJhMof0J+1XtMAhchAvjskE5ngJdhzvAyj6/8EzvZmxqB886JBD4dIblsOPEQBBYPAqD8wMnaHmg/k6kPgFw6zIfOcBwH5IdvcIvnZpOeEgSyCICGB9qDtgcjfyZtLye+pJif7T/xEAQIArMj8JWf58/ePRJLECAIqCJAmK8KCwkkCFziCBDmX+I3mHSPIKCKAGG+KiwkkCBwiSNAmH+J32DSPYKAKgKE+aqwkECCwCWOAGH+JX6DSfcIAqoIEOarwkICCQKXOAKE+Zf4DSbdIwioIkCYrwoLCSQIXOIIEOZf4jeYdI8goIoAYb4qLCSQIHCJI0CYf4nfYNI9goAqAoT5qrCQQILAJY7A/weG0rvSViCDkgAAAABJRU5ErkJggg=="></p><p>考场 $225\ \tt{pts}$，</p><p>考完改了 $10$ 个字节 $335\ \tt{pts}$，</p><p>回家改了 $2$ 个字节 $400\ \tt{pts}$。</p><p>水平没长进挂分的水平进步不小。</p><h1 id="D-三角形个数-count"><a href="#D-三角形个数-count" class="headerlink" title="D.三角形个数 count"></a>D.三角形个数 count</h1><p>很显然 $\mathcal O(n^2)$ 枚举两个角度会超时。</p><p>考虑到题目隐藏数据范围 $a_i\leq 180$，我们实际只要开桶记录每个度数出现次数，然后枚举三角形角度得到每个度数出现次数，相乘即可。</p><p>考场的 $j$ 和 $k$ 变量忘记 $+1$，$-80\ \tt{pts}$。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n;<span class="type">long</span> <span class="type">long</span> h[<span class="number">200</span>];<span class="type">long</span> <span class="type">long</span> cnt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> x;cin&gt;&gt;x;h[x]++;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">180</span>;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;<span class="number">180</span>;j++)&#123;<span class="keyword">for</span>(<span class="type">int</span> k=j<span class="number">+1</span>;k&lt;<span class="number">180</span>;k++)&#123;<span class="keyword">if</span>(i+j+k!=<span class="number">180</span>)<span class="keyword">continue</span>;cnt+=h[i]*h[j]*h[k];&#125;&#125;&#125;cout&lt;&lt;cnt&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">5</span><span class="comment">20 20 30 130 14</span><span class="comment">*/</span></code></pre><h1 id="E-牛队-cow"><a href="#E-牛队-cow" class="headerlink" title="E.牛队 cow"></a>E.牛队 cow</h1><p>考虑到这头牛能网友看到的牛的高度具单调递减，具有单调性。</p><p>直接单调栈维护，一旦即将进入的高度比栈顶高就连续排出元素最后插入进栈。</p><p>看到的牛高度是<strong>严格小于</strong>当前牛的高度。</p><p>考场没有发现是严格小于，写的小于等于，$-65\ \tt{pts}$。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;stack&lt;<span class="type">int</span>&gt;s;<span class="type">int</span> n;<span class="type">int</span> a[<span class="number">1000020</span>];<span class="type">long</span> <span class="type">long</span> ans;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(s.<span class="built_in">empty</span>()||s.<span class="built_in">top</span>()&gt;a[i])&#123;<span class="comment">//cout&lt;&lt;&quot;insert:&quot;&lt;&lt;a[i]&lt;&lt;endl;</span>s.<span class="built_in">push</span>(a[i]);&#125;<span class="keyword">else</span>&#123;<span class="comment">//ans+=1LL*s.size()*(s.size()-1)/2;</span><span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;s.<span class="built_in">top</span>()&lt;=a[i])&#123;ans+=s.<span class="built_in">size</span>()<span class="number">-1</span>;s.<span class="built_in">pop</span>();&#125;<span class="comment">//cout&lt;&lt;&quot;insert:&quot;&lt;&lt;a[i]&lt;&lt;endl;</span>s.<span class="built_in">push</span>(a[i]);&#125;&#125;ans+=<span class="number">1LL</span>*s.<span class="built_in">size</span>()*(s.<span class="built_in">size</span>()<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">// for(int i=1;i&lt;=n;i++)</span><span class="comment">// &#123;</span><span class="comment">// for(int j=i+1;j&lt;=n;j++)</span><span class="comment">// &#123;</span><span class="comment">// if(a[j]&gt;=a[i])break;</span><span class="comment">// ans++;</span><span class="comment">// &#125;</span><span class="comment">// &#125;</span><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">5</span><span class="comment">3 2 4 1 5</span><span class="comment"></span><span class="comment">5</span><span class="comment">1 4 2 3 5</span><span class="comment"></span><span class="comment">10</span><span class="comment">6 7 10 3 4 8 1 2 5 9</span><span class="comment"></span><span class="comment">*/</span></code></pre><h1 id="F-机房分组-team"><a href="#F-机房分组-team" class="headerlink" title="F.机房分组 team"></a>F.机房分组 team</h1><p>求最值，考虑穷举贪心二分答案。</p><p>这题显然有贪心性质，每次插到最小但是能容纳下这个同学的列去。</p><p>建议的证明就是，其他列的可能可以给比你大的人坐，为了每一列坐得多你不能抢别人位置。</p><p>不知道为啥这个代码稀里糊涂的跑过去了，应该是可以二分得到最小位置继续优化的。</p><p>考场的 $top$ 变量第一次调用没有 <code>++top</code>，$- 20\ \tt{pts}$。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> top,n;<span class="type">int</span> a[<span class="number">200020</span>];vector&lt;<span class="type">int</span>&gt;b[<span class="number">200020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;<span class="comment">//for(int i=1;i&lt;=n;i++)</span><span class="comment">//&#123;</span><span class="comment">//if(!top||a[i]&gt;f[top])</span><span class="comment">//&#123;</span><span class="comment">//f[++top]=a[i];</span><span class="comment">//&#125;</span><span class="comment">//else</span><span class="comment">//&#123;</span><span class="comment">//int p=lower_bound(f+1,f+top+1,a[i])-f;</span><span class="comment">//f[p]=a[i];</span><span class="comment">//&#125;</span><span class="comment">//&#125;</span>b[++top].<span class="built_in">push_back</span>(a[<span class="number">1</span>]);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;<span class="type">int</span> minn=INT_MAX,p=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=top;j++)&#123;<span class="keyword">if</span>(a[i]&lt;=b[j][<span class="built_in">int</span>(b[j].<span class="built_in">size</span>())<span class="number">-1</span>]&amp;&amp;b[j][<span class="built_in">int</span>(b[j].<span class="built_in">size</span>())<span class="number">-1</span>]&lt;minn)&#123;minn=b[j][<span class="built_in">int</span>(b[j].<span class="built_in">size</span>())<span class="number">-1</span>];p=j;&#125;&#125;<span class="keyword">if</span>(!p)&#123;b[++top].<span class="built_in">push_back</span>(a[i]);&#125;<span class="keyword">else</span>&#123;b[p].<span class="built_in">push_back</span>(a[i]);&#125;&#125;cout&lt;&lt;top&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">7</span><span class="comment">6 3 6 1 2 4 5</span><span class="comment"></span><span class="comment"></span><span class="comment">8</span><span class="comment">389 207 155 300 299 170 158 65</span><span class="comment">*/</span></code></pre><h1 id="G-买铅笔-pencil"><a href="#G-买铅笔-pencil" class="headerlink" title="G.买铅笔 pencil"></a>G.买铅笔 pencil</h1><p>完全背包板子。</p><p>但是，完全背包是求能装下的最大价值，这里是求超过的最小价值。</p><p>那么显然，除了最大最小需要改变，观察到 $a_i,b_i\leq 100$，我们只需上限调到 $n+100$ 即可，然后在 $[n,n+100]$ 的范围内找最小花费，保险一点右端点可以写成 $n+200$。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">long</span> <span class="type">long</span> f[<span class="number">4000500</span>];<span class="type">int</span> n;<span class="type">int</span> x,y;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));cin&gt;&gt;n;f[<span class="number">0</span>]=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;cin&gt;&gt;x&gt;&gt;y;<span class="keyword">for</span>(<span class="type">int</span> j=x;j&lt;=n<span class="number">+200</span>;j++)&#123;f[j]=<span class="built_in">min</span>(f[j],f[j-x]+y);&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> j=n;j&lt;=n<span class="number">+200</span>;j++)&#123;f[n]=<span class="built_in">min</span>(f[n],f[j]);&#125;cout&lt;&lt;f[n]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">57</span><span class="comment">2 2</span><span class="comment">50 30</span><span class="comment">30 27</span><span class="comment">*/</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF776C Molly&#39;s Chemicals</title>
      <link href="/archives/CF776C/"/>
      <url>/archives/CF776C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>给定长度为 $n$ 的序列 $a$，求有多少组 $(l,r)$ 满足 $\sum\limits_{i&#x3D;l}^ra_i&#x3D;k^i$。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>首先考虑，枚举 $l$ 和 $r$，判断 $\sum\limits_{i&#x3D;l}^r$ 是否为 $k$ 的倍数。但是显然这种做法复杂度为 $n^2$ 无法通过。</p><p>设 $s$ 为 $a$ 的前缀和数组，我们注意到，我们查找 $s_r-s_{l-1}&#x3D;k^i$，其实等价于找 $s$ 中是否有 $s_r-k^i$ 这个元素，那么我们只需枚举一个端点以及一个 $k$ 的次幂。</p><p>显然在这个题中，除去 $k&#x3D;\pm1$，上述的 $i$ 最多只需枚举至 $\log_2 (10^9\times 10^5)\approx 60$ 次。</p><p>因此，总的时间复杂度为 $\mathcal O(n\log V)$。其中 $V&#x3D;10^9\times 10^5$。对于 C++ 选手，如果你用 map 来判断 $s_r-k^i$ 是否存在还需乘上一个 $\log_2 n$。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n;ll st[<span class="number">100</span>];<span class="type">int</span> top;ll pw=<span class="number">1</span>;ll k,ans;ll a[<span class="number">100020</span>];ll s[<span class="number">100020</span>];map&lt;ll,<span class="type">int</span>&gt;mp;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin&gt;&gt;n&gt;&gt;k;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        cin&gt;&gt;a[i];        s[i]=a[i]+s[i<span class="number">-1</span>];    &#125;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;i++)    &#123;        <span class="keyword">if</span>(<span class="built_in">abs</span>(pw)&gt;<span class="number">1e14</span>)<span class="keyword">break</span>;        st[++top]=pw;        pw*=k;    &#125;    mp[<span class="number">0</span>]=<span class="number">1</span>;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        <span class="keyword">if</span>(k==<span class="number">1</span>)ans+=mp[s[i]<span class="number">-1</span>];        <span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">-1</span>)ans+=mp[s[i]<span class="number">-1</span>]+mp[s[i]<span class="number">+1</span>];        <span class="keyword">else</span>         &#123;            <span class="keyword">for</span>(<span class="type">int</span> _=<span class="number">1</span>;_&lt;=top;_++)            &#123;                ans+=mp[s[i]-st[_]];            &#125;        &#125;        mp[s[i]]++;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC159E Dividing Chocolate</title>
      <link href="/archives/ABC159E/"/>
      <url>/archives/ABC159E/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>有一个 $H\times W$ 的矩阵，切若干次，使得每一块中 $1$ 个数 $\leq k$，只能一切到底，问最少用几刀。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>直接暴力枚举每一行每一列绝对不行，复杂度 $\mathcal O(2^{H+W})$。</p><p>我们发现 $H$ 很小，我们可以枚举 $H$ 在哪里切割，复杂度 $\mathcal O(2^H)$。其实最多只有 $H-1$ 刀，为了方便描述，统一用 $H$。</p><p>接着，我们对于 $W$ 考虑贪心，每一块有尽量多的 $1$，最后肯定花费最小，也是可以证明的。</p><p>综上所述，我们枚举 $2^H$ 种方案，接着扫一遍 $W$ 确定切割次数。</p><p>时间复杂度 $\mathcal O(2^H\times W\times H)$，可以通过此题。</p><p>但是还不完美，如果 $H\leq 15,W\leq 10^6$，明显是会炸掉的。</p><p>我们扫 $W$ 时，这里 $1$ 个数肯定是单调不增的，可以考虑进行二分或者倍增来找。这一段的时间复杂度一下子变成了 $\mathcal O(\log W)$，总时间复杂度 $\mathcal O(2^H\times \log W\times H)$。</p><p>但上述做法在面对全是 $1$ 时，每次只能前进一步，实际上会退化成 $\mathcal O(W)$。其余数据效果比最初做法时间上较佳。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>代码很长，不贴了，发个链接。</p><p><a href="https://atcoder.jp/contests/abc159/submissions/38882298">Code 1</a></p><p><a href="https://atcoder.jp/contests/abc159/submissions/38882293">Code 2</a></p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC251D At Most 3 (Contestant ver.)</title>
      <link href="/archives/ABC251D/"/>
      <url>/archives/ABC251D/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>给出 $w$，问造一个数组，满足选三个正好是等于所有 $\leqslant w$ 的。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>这个 $w$ 最多 $7$ 位，但 $&lt;w$ 只有 $6$ 位。</p><p>我们把这个数设为 $\overline{abcdef}$，然后分成 $\overline{ab}$、$\overline{cd}$、$\overline{ef}$。</p><p>每个都有 $99$ 种可能，加上 $10^6$，一共 $298$ 个。</p><h3 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;cout&lt;&lt;<span class="number">298</span>&lt;&lt;endl;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">99</span>;i++)&#123;cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">99</span>;i++)&#123;cout&lt;&lt;i*<span class="number">100</span>&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">99</span>;i++)&#123;cout&lt;&lt;i*<span class="number">100</span>*<span class="number">100</span>&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;cout&lt;&lt;<span class="number">1000000</span>&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC257E Addition and Multiplication 2</title>
      <link href="/archives/ABC257E/"/>
      <url>/archives/ABC257E/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>有 $9$ 种数字，$1,2,\dots9$。</p><p>数字 $i$ 可以花 $c_i$ 的价格购买，你有 $n$ 元。</p><p>最后输出你购买的数字拼成的最大值。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>我们考虑，先让位数最大。</p><p>然后，再最大化最高位、次高位、次次高位，一直往下。</p><p>最大位数，即为用 $n$ 除以最便宜的价钱。</p><p>然后，你可能会有剩余的钱。</p><p>剩余的，我们开始置换。</p><p>从 $9$ 开始枚举，能换就换，并输出你置换的数字。</p><p>这样最大化了较高位，还保证位数没有变少。</p><p>具体可以品味下代码。</p><h3 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h3><pre><code class="highlight cpp"><span class="type">int</span> c[<span class="number">20</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n, mnc = INT_MAX, maxn;    cin &gt;&gt; n;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)    &#123;        cin &gt;&gt; c[i];        <span class="keyword">if</span> (c[i] &lt;= mnc)        &#123;            mnc = c[i];            maxn = i;        &#125;    &#125;    <span class="type">int</span> cnt = n / mnc;    <span class="type">int</span> x = <span class="number">0</span>, cnt2 = <span class="number">0</span>;    <span class="type">int</span> s = n - cnt * mnc;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">1</span>; i--)    &#123;        <span class="keyword">if</span> (i &gt; maxn)        &#123;            <span class="keyword">if</span> (c[i] - mnc &lt;= s)            &#123;                cnt2 = s / (c[i] - mnc);                cnt -= cnt2;                s%=c[i] - mnc;                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt2; j++)                &#123;                    cout &lt;&lt; i;                &#125;            &#125;        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)    &#123;        cout &lt;&lt; maxn;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC247E Max Min</title>
      <link href="/archives/ABC247E/"/>
      <url>/archives/ABC247E/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>输入一个长度为 $n$ 个数字，还有 $X$ 和 $Y$。<br>问数组中有几个区间最大值是 $X$ 且最小值是 $Y$。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>所有数字分为 $a_i&gt;Y$，$a_i&#x3D;Y$，$a_i&lt;X$，$a_i&#x3D;X$，$X&lt;a_i&lt;Y$ 五种情况。<br>$&gt;Y$ 和 $&lt;X$ 的位置一定不能选。<br>选一个区间，包含至少一个 $&#x3D;Y$，包含至少一个 $&#x3D;X$，问有多少种方案。<br>问以每个位置作为结尾，有多少个方案。<br>对于每个位置，找自己之前的最近的 $X$ 是多少，最近的 $Y$ 是多少，至多选多少个数字没有 $&gt;Y$ 和 $&lt;X$ 的情况。</p><h3 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,x,y,maxxid=<span class="number">0</span>,minnid=<span class="number">0</span>,la=<span class="number">1</span>;<span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> z;cin&gt;&gt;z;<span class="keyword">if</span>(z==x)&#123;maxxid=i;&#125;<span class="keyword">if</span>(z==y)&#123;minnid=i;&#125;<span class="keyword">if</span>(z&gt;x||z&lt;y)&#123;maxxid=<span class="number">0</span>;minnid=<span class="number">0</span>;la=i<span class="number">+1</span>;&#125;<span class="keyword">if</span>(maxxid!=<span class="number">0</span>&amp;&amp;minnid!=<span class="number">0</span>)&#123;ans+=<span class="built_in">min</span>(maxxid,minnid)-la<span class="number">+1</span>;&#125;&#125;cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC260D Draw Your Cards</title>
      <link href="/archives/ABC260D/"/>
      <url>/archives/ABC260D/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>依次摸 $n$ 张卡片，第 $i$ 个卡片上写的 $p_i$，$p_i$ 是 $1$ 到 $n$ 的一个排列。</p><p>维护一些牌堆，如果 $p_i$ 大于所有堆顶的牌，那么新开一堆只有 $p_i$。</p><p>否则在所有堆顶的牌，找到大于 $p_i$ 最小的一张，把 $p_i$ 放到这个堆的堆顶。</p><p>如果这一堆有恰好 $K$ 张牌，把这 $K$ 个牌的数字都标记上当前的时间 $i$，并把这堆删掉。</p><p>最后输出每个数字被标记的时间，如果没有被标记过就是 $-1$。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>如果我们真的模拟题意去开栈，肯定会 boom 的。</p><p>观察题意可得，所有操作只考虑牌堆顶，且卡片只要进入牌堆就不会变动。</p><p>因此我们只需维护牌堆顶即可。但这样时间复杂度仍然很高，我们可以把牌堆顶存入一个 set，每次查询即为 $\mathcal O(\log n)$ 了。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">200005</span>];<span class="type">int</span> fa[<span class="number">200005</span>],id,c[<span class="number">200005</span>],d[<span class="number">200005</span>];<span class="type">bool</span> f[<span class="number">200005</span>];<span class="type">int</span> ans[<span class="number">200005</span>];set&lt;<span class="type">int</span>&gt;s;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];<span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>||a[i]&gt;*s.<span class="built_in">rbegin</span>())&#123;s.<span class="built_in">insert</span>(a[i]);id++;fa[a[i]]=id;c[id]=a[i];d[id]++;<span class="keyword">if</span>(d[id]==k)&#123;f[id]=<span class="number">1</span>;ans[id]=i;s.<span class="built_in">erase</span>(a[i]);&#125;&#125;<span class="keyword">else</span>&#123;<span class="keyword">auto</span> it=s.<span class="built_in">upper_bound</span>(a[i]);<span class="type">int</span> x=fa[*it];<span class="keyword">if</span>(f[x]==<span class="number">1</span>)&#123;<span class="keyword">continue</span>;&#125;c[x]=a[i];d[x]++;fa[a[i]]=x;s.<span class="built_in">erase</span>(it);s.<span class="built_in">insert</span>(a[i]);<span class="keyword">if</span>(d[x]==k)&#123;f[x]=<span class="number">1</span>;ans[x]=i;s.<span class="built_in">erase</span>(a[i]);&#125;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cout&lt;&lt;(ans[fa[i]]==<span class="number">0</span>?<span class="number">-1</span>:ans[fa[i]])&lt;&lt;endl;&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC232E Rook Path</title>
      <link href="/archives/ABC232E/"/>
      <url>/archives/ABC232E/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>有一个 $H\times W$ 的国际象棋棋盘，求一个<strong>车</strong>从 $(x_1,y_1)$ 走到 $(x_2,y_2)$ 正好用 $K$ 步的方案数。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>首先看到题，很显然是动态规划。$f_{k,i,j}$ 表示走到 $(i,j)$ 正好 $k$ 步的方案。但时间复杂度过高，考虑进行优化。</p><p>我们可以不记录具体走到哪个点位，我们只需知道当前在不在起点即可。于是就有 $f_{k,0&#x2F;1&#x2F;2&#x2F;3}$ 表示第 $k$ 步时，当前位置为 $(x_1,y_1),(x_1,非y_1),(非x_1,y_1),(非x_1,非y_1)$。</p><p>我们在运用一些排列组合的基本知识，便能得到以下转移方程：</p><p>$$<br>f_{k,0} &#x3D; f_{k-1,1} \times (W-1) + f_{k,2} \times (H-1)<br>$$</p><p>$$<br>f_{k,1} &#x3D; f_{k-1,1} \times (W-2) + f_{k,0} + f_{k,3} \times (H-1)<br>$$</p><p>$$<br>f_{k,2} &#x3D; f_{k-1,2} \times (H-2) + f_{k,0} + f_{k,3} \times (W-1)<br>$$</p><p>$$<br>f_{k,3} &#x3D; f_{k-1,3} \times (H+W-4) + f_{k,2} + f_{k,1}<br>$$</p><p>接着，我们再循环过程中是可以压掉第一维 $k$ 的，那么我们只需记录 $4$ 个变量即可。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>远古时期代码，码风有点不好请见谅。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="meta">#<span class="keyword">define</span> ll long long</span><span class="meta">#<span class="keyword">define</span> p 998244353</span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">long</span> <span class="type">long</span> a,b,c,d;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;ll h,w,k,xx1,xx2,yy1,yy2;cin&gt;&gt;h&gt;&gt;w&gt;&gt;k&gt;&gt;xx1&gt;&gt;yy1&gt;&gt;xx2&gt;&gt;yy2;a=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;ll a1,b1,c1,d1;a1=b*(w<span class="number">-1</span>)+c*(h<span class="number">-1</span>);b1=b*(w<span class="number">-2</span>)+a+d*(h<span class="number">-1</span>);c1=c*(h<span class="number">-2</span>)+a+d*(w<span class="number">-1</span>);d1=d*(h+w<span class="number">-4</span>)+b+c;a1%=p;b1%=p;c1%=p;d1%=p;a=a1;b=b1;c=c1;d=d1;&#125;<span class="keyword">if</span>(xx2==xx1&amp;&amp;yy2==yy1)cout&lt;&lt;a%p;<span class="keyword">else</span> <span class="keyword">if</span>(xx2==xx1)cout&lt;&lt;b%p;<span class="keyword">else</span> <span class="keyword">if</span>(yy2==yy1)cout&lt;&lt;c%p;<span class="keyword">else</span> cout&lt;&lt;d%p;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC252F Bread</title>
      <link href="/archives/ABC252F/"/>
      <url>/archives/ABC252F/</url>
      
        <content type="html"><![CDATA[<h3 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h3><p>原题 <a href="https://www.luogu.com.cn/problem/P1334">P1334 瑞瑞的木板</a>。刚好不久前做过，赛时直接贺了自己的代码过掉的。</p><h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>为方便和瑞瑞的木板联系起来，下文翻译不采用原题中的“面包”而是使用“木板”。</p><p>有一根长度为 $L$ 的木板，切成 $n$ 根小木板。第 $i$ 根小木板的长度为 $l_i$，每次切下长度为 $x$ 的小木板需要耗费 $x$ 的体力。允许有剩余，也就是说不保证 $L&#x3D;\sum_{i&#x3D;1}^n l_i$。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>本题与瑞瑞的木板唯一区别，即不保证 $L&#x3D;\sum_{i&#x3D;1}^n l_i$。为了方便我们贺代码，我们可以自己加一块长度为 $L-\sum_{i&#x3D;1}^n l_i$ 的木板。这时耗费体力肯定不变。</p><p>那么这题就完美的变成了瑞瑞的木板。接下来，我们按照合并果子的贪心思想，每次切最小的即可。详细的贪心证明可以去看 <a href="https://www.luogu.com.cn/problem/P1090">P1090 合并果子</a> 的题解。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;multiset&lt;<span class="type">long</span> <span class="type">long</span>&gt;s;<span class="type">long</span> <span class="type">long</span> n,l,ss=<span class="number">0</span>;cin&gt;&gt;n&gt;&gt;l;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">long</span> <span class="type">long</span> x;cin&gt;&gt;x;s.<span class="built_in">insert</span>(x);ss+=x;&#125;<span class="keyword">if</span>(l-ss!=<span class="number">0</span>)s.<span class="built_in">insert</span>(l-ss);<span class="comment">//插入新的小木板</span><span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;<span class="keyword">while</span>(s.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;<span class="type">long</span> <span class="type">long</span> x=*s.<span class="built_in">begin</span>();s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());<span class="type">long</span> <span class="type">long</span> y=*s.<span class="built_in">begin</span>();s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());s.<span class="built_in">insert</span>(x+y);sum+=x+y;&#125;cout&lt;&lt;sum&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1742G Orray</title>
      <link href="/archives/CF1742G/"/>
      <url>/archives/CF1742G/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>我们定义前缀或的意思是 $or_i&#x3D;or_{i-1} \operatorname{or} a_i$。</p><p>重排数组 $a$，使得它的前缀或数组的字典序最大。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>通过观察和思考可得，第一位一定放 $\max\limits_{1\leq i\leq n}{a_i}$ 才能让第一位最大，接着保证字典序最大。</p><p>那么我们考虑，对于之后每一位的答案，我们都去和前面的进行比较，看看哪一个才是这一位该放的最大的答案。这一点是很容易想到的。</p><p>那么这只是 $\mathcal O(n^2)$，很显然是会超时的。</p><p>我们考虑到，一个 <code>int</code> 类型只有 $32$ 位，那么我们只要知道这 $32$ 位能不能放上 $1$ 即可。</p><p>也就是说，如果这 $32$ 位都决策完了，我们不用继续找，后面没用过的可以直接输出。</p><p>所以我们只要判断当前操作下来的答案，和上一步操作的答案是否相同，若相同即可结束。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;vector&lt;<span class="type">int</span>&gt;ans;<span class="type">int</span> n,maxx=<span class="number">-1</span>,id;cin&gt;&gt;n;<span class="type">int</span> a[n<span class="number">+1</span>];<span class="type">int</span> tmp[n<span class="number">+1</span>];<span class="type">bool</span> f[n<span class="number">+1</span>]=&#123;&#125;;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];tmp[i]=a[i];<span class="keyword">if</span>(a[i]&gt;maxx)&#123;maxx=a[i];id=i;&#125;&#125;f[id]=<span class="number">1</span>;ans.<span class="built_in">push_back</span>(maxx);<span class="type">int</span> last=maxx;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;tmp[j]|=maxx;&#125;last=maxx;maxx=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="keyword">if</span>(!f[j])&#123;<span class="keyword">if</span>(tmp[j]&gt;maxx)&#123;maxx=tmp[j];id=j;&#125;&#125;&#125;f[id]=<span class="number">1</span>;ans.<span class="built_in">push_back</span>(a[id]);<span class="keyword">if</span>(maxx==last)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="keyword">if</span>(!f[j])&#123;ans.<span class="built_in">push_back</span>(a[j]);&#125;&#125;<span class="keyword">break</span>;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i:ans)&#123;cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;cout&lt;&lt;endl;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> t;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);<span class="keyword">while</span>(t--)&#123;<span class="built_in">solve</span>();&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p><a href="https://codeforces.com/contest/1742/submission/186537251">链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1744C Traffic Light</title>
      <link href="/archives/CF1744C/"/>
      <url>/archives/CF1744C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>问当前字符后的第一个 $\tt{g}$ 与它的距离最大是多少。</p><p>当前字符可能有很多个。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>我们把目前找到的当前字符的位置记录下来，找到最早的，记录一下时间差，取个最大。</p><p>但显然我们不能对每一个去找，必须几个打包一找。</p><p>我用 <code>queue</code> 模拟题意，详情见代码。</p><p>由于当前的可能要到下一个循环才能看见 $\tt{g}$，所以要循环两次。</p><p>时间复杂度 $\mathcal O(n)$。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> t,n,z;<span class="type">char</span> c[<span class="number">200020</span>];<span class="type">char</span> tmp;queue&lt;<span class="type">int</span>&gt;q;<span class="type">int</span> ans=INT_MIN;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;ans=INT_MIN;<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;q.<span class="built_in">pop</span>();&#125;<span class="built_in">scanf</span>(<span class="string">&quot;%d %c%s&quot;</span>,&amp;n,&amp;tmp,c<span class="number">+1</span>);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+n;i++)&#123;z=i;<span class="keyword">if</span>(z&gt;n)&#123;z-=n;&#125;<span class="keyword">if</span>(i&lt;=n&amp;&amp;c[z]==tmp)&#123;q.<span class="built_in">push</span>(z);&#125;<span class="keyword">if</span>(c[z]==<span class="string">&#x27;g&#x27;</span>&amp;&amp;!q.<span class="built_in">empty</span>())<span class="comment">//找到g并且有当前字符</span>&#123;ans=<span class="built_in">max</span>(ans,i-q.<span class="built_in">front</span>());<span class="comment">//取一个最大的时间差</span><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;q.<span class="built_in">pop</span>();&#125;&#125;&#125;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);<span class="keyword">while</span>(t--)&#123;<span class="built_in">solve</span>();&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">6</span><span class="comment">5 r</span><span class="comment">rggry</span><span class="comment">1 g</span><span class="comment">g</span><span class="comment">3 r</span><span class="comment">rrg</span><span class="comment">5 y</span><span class="comment">yrrgy</span><span class="comment">7 r</span><span class="comment">rgrgyrg</span><span class="comment">9 y</span><span class="comment">rrrgyyygy</span><span class="comment">*/</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20221203 | SCZ-QZS 模拟赛 T5</title>
      <link href="/archives/20221203_mock/"/>
      <url>/archives/20221203_mock/</url>
      
        <content type="html"><![CDATA[<p>题意很明确了，大意就是一棵树，染色，距离 $\le 2$ 不得染同色，问染色方案。</p><p>首先我们要明确，距离 $\le 2$，具体是什么情况呢？</p><p>显然，分两个大类：</p><ul><li><p>一条链往下</p><ul><li>某节点和它的儿子</li><li>某节点和它的孙子</li></ul></li><li><p>非一条链往下</p><ul><li>某节点和它的兄弟</li></ul></li></ul><p>那么我们就梳理出了 $3$ 中不能涂同一种颜色的情况。</p><p>读到这里，我想应该正解慢慢出来了。</p><p>其次我们要知道，总染色方案就是每个点染色方案之积。</p><p>那么每个点最初有 $k$ 种选择，我们看一下它是否存在爷爷，若存在最多只有 $k-2$ 种，因为有爷爷必然有爸爸。</p><p><strong>一条链往下</strong>的方案已经考虑完了，接下来考虑兄弟。</p><p>兄弟就很简单了，记一个变量，自己的父亲每往下搜索一次加一，既能得到兄弟的个数。</p><p>详情见代码。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> p=<span class="number">1000000007</span>;<span class="type">int</span> n,k,u,v;<span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;<span class="comment">//十年OI一场空，不开long long见祖宗</span><span class="type">bool</span> vis[<span class="number">100020</span>];vector&lt;<span class="type">int</span>&gt;a[<span class="number">100020</span>];<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tmp)</span><span class="comment">//u表示目前节点 tmp表示当前节点涂色数量</span></span><span class="function"></span>&#123;ans*=tmp;<span class="comment">//乘上方案数</span>ans%=p;<span class="comment">//十年OI一场空，忘记取模见祖宗</span>vis[u]=<span class="number">1</span>;<span class="comment">//遍历基本操作，也可以记录father</span><span class="type">int</span> cnt=<span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">auto</span> v:a[u])&#123;<span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;<span class="type">int</span> w=(u==<span class="number">1</span>?k<span class="number">-1</span>:k<span class="number">-2</span>);<span class="comment">//如果是自己根，自己的儿子没有爷爷，反之肯定有爷爷</span>    <span class="comment">//上一条语句也可以写成dfs多带个dep参数，记录深度</span>w-=cnt;<span class="comment">//去除自己的兄弟所要染色的情况</span><span class="built_in">dfs</span>(v,w);<span class="comment">//继续搜索</span>cnt++;<span class="comment">//兄弟+1</span>&#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);a[u].<span class="built_in">push_back</span>(v);a[v].<span class="built_in">push_back</span>(u);        <span class="comment">//建边基本操作，也可以单向</span>&#125;<span class="built_in">dfs</span>(<span class="number">1</span>,k);<span class="comment">//开始搜索</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(<span class="type">int</span>)ans);<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20221022 | CSP2022 考前模拟赛 做题笔记</title>
      <link href="/archives/20221022_mock/"/>
      <url>/archives/20221022_mock/</url>
      
        <content type="html"><![CDATA[<h3 id="赛后感言"><a href="#赛后感言" class="headerlink" title="赛后感言"></a>赛后感言</h3><p>本来能 $400\tt{\ pts}$ 的，T3 边界写错扣十分，这个问题不大，加个判断就过了。T4 真的扣的分真伤，打错了两个数字废了。</p><p>痛失 U 盘！</p><p>比赛点评：一道送分一道板，一道模拟一道原。</p><h3 id="四则混合运算"><a href="#四则混合运算" class="headerlink" title="四则混合运算"></a>四则混合运算</h3><p>题目很简单，扫描两遍字符串，第一遍处理乘除符号，第二遍处理加减符号。</p><p>时间复杂度 $\mathcal O(\left|S\right|)$。</p><p>插一句题外话，像这种题最好不要偷懒在字符串中插入最后一起输出。</p><p>WXR 巨佬因为这个，VP CSP-J 2020 的时候，T3 因为这个没有 AC 爆空间了.</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">1919810</span>],Time,n;string s;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123; <span class="built_in">freopen</span>(<span class="string">&quot;operation.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); <span class="built_in">freopen</span>(<span class="string">&quot;operation.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout); cin&gt;&gt;n&gt;&gt;s; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;<span class="keyword">if</span>(s[i]==<span class="string">&#x27;*&#x27;</span>||s[i]==<span class="string">&#x27;/&#x27;</span>)a[i]=++Time;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;<span class="keyword">if</span>(s[i]==<span class="string">&#x27;+&#x27;</span>||s[i]==<span class="string">&#x27;-&#x27;</span>)a[i]=++Time;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;cout&lt;&lt;s[i];<span class="keyword">if</span>(a[i])<span class="built_in">printf</span>(<span class="string">&quot;(%d)&quot;</span>,a[i]);&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">13</span><span class="comment">2+2+2*2/2-2*2</span><span class="comment">5</span><span class="comment">12345</span><span class="comment">*/</span></code></pre><h3 id="回扣"><a href="#回扣" class="headerlink" title="回扣"></a>回扣</h3><p>题意很显然，完全背包板子，对于每个游客做一遍完全背包即可。</p><p><del>这题我竟然赛时感觉是 dp 想不到是什么 dp 先写了个贪心，切完其他三题再回来的。</del></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n,m,ans;<span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> p,q;&#125;b[<span class="number">120</span>];<span class="type">int</span> a[<span class="number">50</span>];<span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span><span class="function"></span>&#123;<span class="keyword">return</span> a.p*b.q&lt;b.p*a.q;&#125;<span class="type">int</span> f[<span class="number">1000020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123; <span class="built_in">freopen</span>(<span class="string">&quot;cicer.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); <span class="built_in">freopen</span>(<span class="string">&quot;cicer.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout); cin&gt;&gt;n; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123; cin&gt;&gt;a[i];&#125;cin&gt;&gt;m;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;cin&gt;&gt;b[i].p&gt;&gt;b[i].q;&#125;<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=b[i].p;j&lt;=a[k];j++)&#123;f[j]=<span class="built_in">max</span>(f[j],f[j-b[i].p]+b[i].q);&#125;&#125;ans+=f[a[k]];&#125;<span class="comment">//sort(b+1,b+m+1,cmp);</span><span class="comment">//for(int i=1;i&lt;=m;i++)</span><span class="comment">//&#123;</span><span class="comment">//for(int j=1;j&lt;=n;j++)</span><span class="comment">//&#123;</span><span class="comment">//ans+=a[j]/b[i].p*b[i].q;</span><span class="comment">//a[j]%=b[i].p;</span><span class="comment">//&#125;</span><span class="comment">//&#125;</span>cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">3</span><span class="comment">200 300 300</span><span class="comment">5</span><span class="comment">12 2</span><span class="comment">20 4</span><span class="comment">30 5</span><span class="comment">50 5</span><span class="comment">100 18</span><span class="comment"></span><span class="comment">1</span><span class="comment">1000</span><span class="comment">2</span><span class="comment">499 99</span><span class="comment">505 101</span><span class="comment">*/</span></code></pre><h3 id="花不在多"><a href="#花不在多" class="headerlink" title="花不在多"></a>花不在多</h3><p>这题有个性质，数组中的火元素之和，一定等于 $1$，想到这个就是个模拟题很好做了。</p><p>所以我们用个双指针，每次往旁边扫，如果不一样就停止，看一下和走过的路程是否 $\geq m$，$&lt;$ 直接退出，$\geq$ 继续。</p><p>但如果和我一样，左右端点一开始不是都在 $x$ 上，那么要注意你另一个端点摆在 $x$ 左边还是 $x$ 右边，当心像我一样越界。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">1000020</span>];<span class="type">int</span> n,m,x,y,l,r;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123; <span class="built_in">freopen</span>(<span class="string">&quot;eliminate.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); <span class="built_in">freopen</span>(<span class="string">&quot;eliminate.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout); <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;x,&amp;y);n++;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(i==x<span class="number">+1</span>)a[i]=y;<span class="keyword">else</span>&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);&#125;&#125;<span class="comment">// for(int i=1;i&lt;=n;i++)</span><span class="comment">// &#123;</span><span class="comment">// cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;;</span><span class="comment">// &#125;</span><span class="comment">// cout&lt;&lt;endl;</span>x++;<span class="keyword">if</span>(x==n)l=x<span class="number">-1</span>,r=x;<span class="keyword">else</span> l=x,r=x<span class="number">+1</span>;<span class="keyword">while</span>(<span class="number">1</span>&lt;=l&amp;&amp;r&lt;=n)&#123;<span class="keyword">if</span>(a[l]!=a[r])<span class="keyword">break</span>;<span class="type">int</span> tmp=a[l],L=l,R=r;<span class="keyword">for</span>(;l&gt;=<span class="number">1</span>;l--)&#123;<span class="comment">// cout&lt;&lt;l&lt;&lt;&quot; &quot;;</span><span class="keyword">if</span>(a[l]!=tmp)<span class="keyword">break</span>;        &#125;        <span class="keyword">for</span>(;r&lt;=n;r++)        &#123;            <span class="comment">// cout&lt;&lt;r&lt;&lt;&quot; &quot;;</span>            <span class="keyword">if</span>(a[r]!=tmp)<span class="keyword">break</span>;                  &#125;        <span class="comment">// cout&lt;&lt;endl;</span>        <span class="comment">// cout&lt;&lt;(r-R)+(L-l)&lt;&lt;endl;</span>        <span class="keyword">if</span>((r-R)+(L-l)&lt;m)<span class="keyword">break</span>;    &#125;    <span class="keyword">if</span>(l&lt;<span class="number">1</span>&amp;&amp;r&gt;n)    &#123;        <span class="built_in">puts</span>(<span class="string">&quot;pcftxdy&quot;</span>);        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);    <span class="keyword">for</span>(<span class="type">int</span> i=r;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);    <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">7 3 3 2</span><span class="comment">1 1 1 2 2 1 1</span><span class="comment"></span><span class="comment">8 3 2 2</span><span class="comment">1 1 2 2 1 3 3 3</span><span class="comment"></span><span class="comment">8 3 3 2</span><span class="comment">1 1 1 2 2 3 3 3</span><span class="comment">*/</span></code></pre><h3 id="密码锁"><a href="#密码锁" class="headerlink" title="密码锁"></a>密码锁</h3><p>性质：每个按钮最多转四次，旋转先后顺序没有影响。</p><p>实际很简单，最暴力的方法九重循环枚举就能过。</p><p>像我一样 dfs 也可以，dfs 还可以用于 $n$ 个锁的情况。</p><p>bfs 也可以，但当心队列 <code>push</code> 过多爆空间。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">20</span>];<span class="type">int</span> n,ans=INT_MAX;vector&lt;<span class="type">int</span>&gt;b[<span class="number">20</span>];<span class="type">int</span> f[<span class="number">20</span>];<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> dep)</span></span><span class="function"></span>&#123;<span class="keyword">if</span>(dep&gt;<span class="number">9</span>)&#123;<span class="type">int</span> tmp[<span class="number">20</span>],cnt=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;tmp[i]=a[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;<span class="keyword">if</span>(f[i])&#123;cnt+=f[i];<span class="keyword">for</span>(<span class="type">int</span> j:b[i])&#123;tmp[j]+=f[i];tmp[j]%=<span class="number">4</span>;&#125;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;<span class="keyword">if</span>(tmp[i]!=<span class="number">0</span>)&#123;<span class="keyword">return</span>;&#125;&#125;<span class="comment">//cout&lt;&lt;endl;</span><span class="comment">//for(int i=1;i&lt;=9;i++)</span><span class="comment">//&#123;</span><span class="comment">////if(tmp[i])</span><span class="comment">////&#123;</span><span class="comment">////cout&lt;&lt;endl;return;</span><span class="comment">////&#125;</span><span class="comment">//cout&lt;&lt;f[i]&lt;&lt;&#x27; &#x27;;</span><span class="comment">//&#125;</span><span class="comment">//cout&lt;&lt;endl;</span>ans=<span class="built_in">min</span>(ans,cnt);<span class="keyword">return</span>;&#125;f[dep]=<span class="number">1</span>;<span class="built_in">dfs</span>(dep<span class="number">+1</span>);f[dep]=<span class="number">2</span>;<span class="built_in">dfs</span>(dep<span class="number">+1</span>);f[dep]=<span class="number">3</span>;<span class="built_in">dfs</span>(dep<span class="number">+1</span>);f[dep]=<span class="number">0</span>;<span class="built_in">dfs</span>(dep<span class="number">+1</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123; <span class="built_in">freopen</span>(<span class="string">&quot;lock.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); <span class="built_in">freopen</span>(<span class="string">&quot;lock.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout); b[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);b[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);b[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);b[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">5</span>); b[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);b[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);b[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="number">3</span>); b[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);b[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);b[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="number">5</span>);b[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="number">6</span>); b[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);b[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);b[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="number">7</span>); b[<span class="number">5</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);b[<span class="number">5</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);b[<span class="number">5</span>].<span class="built_in">push_back</span>(<span class="number">5</span>);b[<span class="number">5</span>].<span class="built_in">push_back</span>(<span class="number">6</span>);b[<span class="number">5</span>].<span class="built_in">push_back</span>(<span class="number">8</span>); b[<span class="number">6</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);b[<span class="number">6</span>].<span class="built_in">push_back</span>(<span class="number">6</span>);b[<span class="number">6</span>].<span class="built_in">push_back</span>(<span class="number">9</span>); b[<span class="number">7</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);b[<span class="number">7</span>].<span class="built_in">push_back</span>(<span class="number">5</span>);b[<span class="number">7</span>].<span class="built_in">push_back</span>(<span class="number">7</span>);b[<span class="number">7</span>].<span class="built_in">push_back</span>(<span class="number">8</span>); b[<span class="number">8</span>].<span class="built_in">push_back</span>(<span class="number">7</span>);b[<span class="number">8</span>].<span class="built_in">push_back</span>(<span class="number">8</span>);b[<span class="number">8</span>].<span class="built_in">push_back</span>(<span class="number">9</span>); b[<span class="number">9</span>].<span class="built_in">push_back</span>(<span class="number">5</span>);b[<span class="number">9</span>].<span class="built_in">push_back</span>(<span class="number">6</span>);b[<span class="number">9</span>].<span class="built_in">push_back</span>(<span class="number">8</span>);b[<span class="number">9</span>].<span class="built_in">push_back</span>(<span class="number">9</span>); <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) &#123;cin&gt;&gt;a[i]; &#125;<span class="built_in">dfs</span>(<span class="number">1</span>);cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">3 3 0 2 2 2 2 1 2</span><span class="comment"></span><span class="comment">1 1245</span><span class="comment">2 123</span><span class="comment">3 2345</span><span class="comment">4 147 </span><span class="comment">5 24568 </span><span class="comment">6 369 </span><span class="comment">7 4578</span><span class="comment">8 789</span><span class="comment">9 5689</span><span class="comment"></span><span class="comment">1、每个按钮最多只需按多少次？</span><span class="comment">2、按钮的按动次序是否会影响结果？ 0</span><span class="comment">3、每种状态在无多余按键和不考虑按键顺序的情况下有多少种开锁方案？</span><span class="comment">*/</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC029A 複数形</title>
      <link href="/archives/ABC029A/"/>
      <url>/archives/ABC029A/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>在英语中，大多数单词复数是在末尾加 <code>s</code>。</p><p>给你一个单词，输出他的复数形式。</p><p>保证单词复数形式只需加 <code>s</code>。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>输入单词后直接输出这个单词再输出 <code>s</code> 即可。</p><p>注意早期 AT 题目是需要行末输出换行否则不能 AC，所以再输出一个 <code>endl</code> 或者转义 <code>\n</code>。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;string s;cin&gt;&gt;s;cout&lt;&lt;s&lt;&lt;<span class="string">&quot;s\n&quot;</span>;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20221006 | CSP2022 考前模拟赛 做题笔记</title>
      <link href="/archives/20221006_mock/"/>
      <url>/archives/20221006_mock/</url>
      
        <content type="html"><![CDATA[<h3 id="沙漠旅行"><a href="#沙漠旅行" class="headerlink" title="沙漠旅行"></a>沙漠旅行</h3><p>一道最短路模板。</p><p><code>q.push(make_pair(dis[v],v));</code> 写成 <code>q.push(make_pair(w,v));</code> 痛失 $80pts$。</p><hr><p>上述的时间复杂度是带 $\log$ 的，光 $\mathcal O(nm)$ 过不了，要堆优化。</p><p>在看完 std 的思路后焕然大悟，若全是边权为 $1$，bfs 跑一下即可。</p><p>这里边权最多为 $2$，拆成 2 条边就好了。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span> </span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> w,v;&#125;;priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt;q;<span class="type">int</span> n,m;vector&lt;pii&gt;a[<span class="number">300020</span>];<span class="type">int</span> vis[<span class="number">300020</span>];<span class="type">int</span> dis[<span class="number">300020</span>];<span class="function"><span class="type">void</span> <span class="title">dij</span><span class="params">(<span class="type">int</span> s)</span></span><span class="function"></span>&#123;<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,s));dis[s]=<span class="number">0</span>;<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;vis[q.<span class="built_in">top</span>().second])q.<span class="built_in">pop</span>();<span class="keyword">if</span>(q.<span class="built_in">empty</span>())<span class="keyword">break</span>;<span class="type">int</span> u=q.<span class="built_in">top</span>().second;vis[u]=<span class="number">1</span>;<span class="comment">//cout&lt;&lt;u&lt;&lt;endl;</span>q.<span class="built_in">pop</span>();<span class="keyword">for</span>(<span class="keyword">auto</span> i:a[u])&#123;<span class="type">int</span> w=i.first;<span class="type">int</span> v=i.second;<span class="comment">//printf(&quot;%d %d %d\n&quot;,u,v,w);</span><span class="keyword">if</span>(dis[u]+w&lt;dis[v])&#123;vis[i.first]=<span class="number">1</span>;dis[v]=dis[u]+w;q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(w,v));&#125;&#125;&#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;travel.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;travel.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="type">int</span> u,v,w;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);a[u].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(w,v));&#125;<span class="comment">//puts(&quot;&quot;);</span><span class="built_in">dij</span>(<span class="number">1</span>);<span class="comment">//for(int i=1;i&lt;=n;i++)cout&lt;&lt;dis[i]&lt;&lt;&quot; &quot;;</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[n]);    <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">4 5</span><span class="comment">1 3 1</span><span class="comment">2 4 2</span><span class="comment">1 2 2</span><span class="comment">3 4 2</span><span class="comment">2 4 1</span><span class="comment">*/</span></code></pre><h3 id="数列变换"><a href="#数列变换" class="headerlink" title="数列变换"></a>数列变换</h3><p>$60pts$ 的送分写法，暴力，按题意模拟出一个 $f$ 递归函数，执行一遍即可。</p><p>$100pts$ 的写法：先咕着。</p><pre><code class="highlight cpp"></code></pre><h3 id="卡牌游戏"><a href="#卡牌游戏" class="headerlink" title="卡牌游戏"></a>卡牌游戏</h3><pre><code class="highlight cpp"></code></pre><h3 id="舞台表演"><a href="#舞台表演" class="headerlink" title="舞台表演"></a>舞台表演</h3><pre><code class="highlight cpp"></code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20221005 | CSP2022 考前模拟赛 做题笔记</title>
      <link href="/archives/20221005_mock/"/>
      <url>/archives/20221005_mock/</url>
      
        <content type="html"><![CDATA[<h3 id="智商测试"><a href="#智商测试" class="headerlink" title="智商测试"></a>智商测试</h3><p>题目数据有点<strong>小</strong>问题，$t\leq6000$。</p><p>但问题不大。</p><p>首先最暴力的办法是枚举每个时间点，模拟题意。</p><p><del>我就这么做的。</del></p><p>复杂度 $\mathcal O(t)$ 可以接受。</p><p>其次，如果有吊打我的实力能写数学办法，那就是确定行确定列，随便写写。</p><p><code>printf(&quot;%d %d\n&quot;,t/n%n+1,t%n+1);</code> 即可，复杂度 $\mathcal O(1)$。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123; <span class="built_in">freopen</span>(<span class="string">&quot;test.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); <span class="built_in">freopen</span>(<span class="string">&quot;test.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout); <span class="type">int</span> n,t,x=<span class="number">1</span>,y=<span class="number">1</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;t); <span class="keyword">while</span>(t) &#123; <span class="keyword">if</span>(x==n&amp;&amp;y==n)x=y=<span class="number">1</span>; <span class="keyword">else</span> <span class="keyword">if</span>(y!=n)y++; <span class="keyword">else</span> x++,y=<span class="number">1</span>; t--;&#125;<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,x,y);<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="灵石采集"><a href="#灵石采集" class="headerlink" title="灵石采集"></a>灵石采集</h3><p>一个简单贪心。</p><p>首先，如果费用大于等于价值，我们不走，走了也不挣钱。</p><p>其次我们对于费用小至大排序，每次能花费就花费并且拿这个点的价值。</p><p>复杂度只有排序的 $\mathcal O(n \log n)$。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> N,k,n;<span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> v,w;&#125;a[<span class="number">114514</span>];<span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span><span class="function"></span>&#123;<span class="keyword">if</span>(a.w!=b.w)<span class="keyword">return</span> a.w&lt;b.w;<span class="keyword">return</span> a.v&gt;b.v;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123; <span class="built_in">freopen</span>(<span class="string">&quot;collect.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); <span class="built_in">freopen</span>(<span class="string">&quot;collect.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout); <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;k); <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;<span class="type">int</span> v,w;cin&gt;&gt;v&gt;&gt;w;<span class="keyword">if</span>(v&gt;w)a[++n]=(node)&#123;v,w&#125;;&#125;<span class="built_in">sort</span>(a<span class="number">+1</span>,a+n<span class="number">+1</span>,cmp);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(k&gt;a[i].w)k+=(a[i].v-a[i].w);&#125;cout&lt;&lt;k&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="足球队"><a href="#足球队" class="headerlink" title="足球队"></a>足球队</h3><p>一道中等模拟，难点在字符串处理。</p><p>有个坑点，是需要选出选手之后再选队长，不是先安排队长。</p><p>代码主函数很清楚，函数压了一下行，完整函数可以在</p><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">22</span>;i++)&#123;<span class="built_in">getline</span>(cin,player[i].infor);player[i].infor+=<span class="string">&#x27; &#x27;</span>;player[i].year=<span class="number">0</span>;<span class="comment">/*cout&lt;&lt;player[i].infor&lt;&lt;endl;*/</span><span class="type">int</span> j=<span class="number">0</span>;<span class="type">int</span> id=<span class="number">0</span>;<span class="keyword">for</span>(;player[i].infor[j]!=<span class="string">&#x27; &#x27;</span>;j++)&#123;id=id*<span class="number">10</span>+(player[i].infor[j]-<span class="string">&#x27;0&#x27;</span>);&#125;player[i].id=id;j++;string name;<span class="keyword">for</span>(;player[i].infor[j]!=<span class="string">&#x27; &#x27;</span>;j++)&#123;name+=player[i].infor[j];&#125;player[i].name=name;j++;player[i].role=player[i].infor[j];j+=<span class="number">2</span>;<span class="comment">//for(;player[i].infor[j]==&#x27; &#x27;;j++)</span><span class="keyword">while</span>(j&lt;player[i].infor.<span class="built_in">size</span>())&#123;<span class="type">int</span> StartYear=<span class="number">0</span>,EndYear=<span class="number">0</span>;<span class="keyword">for</span>(;player[i].infor[j]!=<span class="string">&#x27;-&#x27;</span>;j++)&#123;StartYear=StartYear*<span class="number">10</span>+(player[i].infor[j]-<span class="string">&#x27;0&#x27;</span>);<span class="comment">//cout&lt;&lt;player[i].infor[j]&lt;&lt;&quot;Year:&quot;&lt;&lt;StartYear&lt;&lt;&#x27;\n&#x27;;</span><span class="comment">//</span>&#125;j++;<span class="keyword">for</span>(;player[i].infor[j]!=<span class="string">&#x27; &#x27;</span>;j++)&#123;EndYear=EndYear*<span class="number">10</span>+(player[i].infor[j]-<span class="string">&#x27;0&#x27;</span>);&#125;j++;player[i].year+=EndYear-StartYear<span class="number">+1</span>;<span class="comment">//cout&lt;&lt;player[i].year&lt;&lt;endl;</span>&#125;&#125;cin&gt;&gt;plan;plan+=<span class="string">&#x27;-&#x27;</span>;<span class="type">int</span> j=<span class="number">0</span>;<span class="comment">/*</span><span class="comment">D后卫</span><span class="comment">*/</span><span class="keyword">for</span>(;plan[j]!=<span class="string">&#x27;-&#x27;</span>;j++)&#123;D=D*<span class="number">10</span>+(plan[j]-<span class="string">&#x27;0&#x27;</span>);&#125;j++;<span class="comment">/*</span><span class="comment">M中场</span><span class="comment">*/</span><span class="keyword">for</span>(;plan[j]!=<span class="string">&#x27;-&#x27;</span>;j++)&#123;M=M*<span class="number">10</span>+(plan[j]-<span class="string">&#x27;0&#x27;</span>);&#125;j++;<span class="comment">/*</span><span class="comment">S前锋</span><span class="comment">*/</span><span class="keyword">for</span>(;plan[j]!=<span class="string">&#x27;-&#x27;</span>;j++)&#123;S=S*<span class="number">10</span>+(plan[j]-<span class="string">&#x27;0&#x27;</span>);&#125;j++;<span class="comment">/*cout&lt;&lt;D&lt;&lt;&quot; &quot;&lt;&lt;M&lt;&lt;&quot; &quot;&lt;&lt;S&lt;&lt;endl;*/</span>&#125;<span class="function"><span class="type">bool</span> <span class="title">cmp_of_role</span><span class="params">(node a,node b)</span></span><span class="function"></span>&#123;<span class="keyword">if</span>(a.role!=b.role)<span class="keyword">return</span> a.role&lt;b.role;<span class="keyword">return</span> a.id&lt;b.id;&#125;<span class="function">string <span class="title">to_str</span><span class="params">(<span class="type">int</span> x)</span></span><span class="function"></span>&#123;string ret=<span class="string">&quot;&quot;</span>;<span class="keyword">while</span>(x)&#123;ret+=<span class="built_in">char</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);x/=<span class="number">10</span>;&#125;<span class="built_in">reverse</span>(ret.<span class="built_in">begin</span>(),ret.<span class="built_in">end</span>());<span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">void</span> <span class="title">sort_them</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">sort</span>(player<span class="number">+1</span>,player<span class="number">+22</span><span class="number">+1</span>,cmp_of_role);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">22</span>;i++)&#123;<span class="keyword">switch</span>(player[i].role)&#123;<span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:&#123;a[<span class="number">0</span>].<span class="built_in">push_back</span>(player[i]);<span class="keyword">break</span>;&#125;<span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:&#123;a[<span class="number">1</span>].<span class="built_in">push_back</span>(player[i]);<span class="keyword">break</span>;&#125;<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:&#123;a[<span class="number">2</span>].<span class="built_in">push_back</span>(player[i]);<span class="keyword">break</span>;&#125;<span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:&#123;a[<span class="number">3</span>].<span class="built_in">push_back</span>(player[i]);<span class="keyword">break</span>;&#125;&#125;&#125;&#125;<span class="function"><span class="type">void</span> <span class="title">choose</span><span class="params">()</span></span><span class="function"></span>&#123;ans[<span class="number">1</span>]=NoNo;<span class="keyword">if</span>(a[<span class="number">3</span>].<span class="built_in">size</span>()&lt;G)&#123;ok_plan=<span class="number">0</span>;<span class="keyword">return</span>;&#125;<span class="keyword">if</span>(a[<span class="number">2</span>].<span class="built_in">size</span>()&lt;D)&#123;ok_plan=<span class="number">0</span>;<span class="keyword">return</span>;&#125;<span class="keyword">if</span>(a[<span class="number">1</span>].<span class="built_in">size</span>()&lt;M)&#123;ok_plan=<span class="number">0</span>;<span class="keyword">return</span>;&#125;<span class="keyword">if</span>(a[<span class="number">0</span>].<span class="built_in">size</span>()&lt;S)&#123;ok_plan=<span class="number">0</span>;<span class="keyword">return</span>;&#125;cnt=<span class="number">1</span>;<span class="keyword">for</span>(<span class="keyword">auto</span> i:a[<span class="number">3</span>])&#123;cnt++;ans[cnt]=i;<span class="keyword">if</span>(cnt==G<span class="number">+1</span>)<span class="keyword">break</span>;&#125;<span class="keyword">for</span>(<span class="keyword">auto</span> i:a[<span class="number">2</span>])&#123;cnt++;ans[cnt]=i;<span class="keyword">if</span>(cnt==G+D<span class="number">+1</span>)<span class="keyword">break</span>;&#125;<span class="keyword">for</span>(<span class="keyword">auto</span> i:a[<span class="number">1</span>])&#123;cnt++;ans[cnt]=i;<span class="keyword">if</span>(cnt==G+D+M<span class="number">+1</span>)<span class="keyword">break</span>;&#125;<span class="keyword">for</span>(<span class="keyword">auto</span> i:a[<span class="number">0</span>])&#123;cnt++;ans[cnt]=i;<span class="keyword">if</span>(cnt==G+D+M+S<span class="number">+1</span>)<span class="keyword">break</span>;&#125;<span class="type">int</span> z=<span class="number">0</span>,Y=<span class="number">-1</span>,id=<span class="number">-1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">12</span>;i++)&#123;<span class="keyword">if</span>(ans[i].year&gt;=Y)&#123;<span class="keyword">if</span>(ans[i].year==Y)&#123;<span class="keyword">if</span>(ans[i].id&gt;id)z=i,Y=ans[i].year,id=ans[i].id;&#125;<span class="keyword">else</span>&#123;z=i,Y=ans[i].year,id=ans[i].id;&#125;&#125;&#125;<span class="built_in">swap</span>(ans[z],ans[<span class="number">1</span>]);&#125;<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="keyword">if</span>(!ok_plan)&#123;<span class="built_in">puts</span>(<span class="string">&quot;IMPOSSIBLE TO ARRANGE&quot;</span>);<span class="keyword">return</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++)&#123;<span class="keyword">if</span>(ans[i].id!=<span class="number">-1</span>)cout&lt;&lt;<span class="built_in">to_str</span>(ans[i].id)&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ans[i].name&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ans[i].role&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;&#125;&#125;</code></pre><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="meta">#<span class="keyword">define</span> NoNo (node)&#123;<span class="string">&quot;-1&quot;</span>,-1,<span class="string">&quot;-1&quot;</span>,<span class="string">&#x27;!&#x27;</span>,-1&#125;</span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">struct</span> <span class="title class_">node</span>&#123;string infor;<span class="type">int</span> id;string name;<span class="type">char</span> role;<span class="type">int</span> year;&#125;player[<span class="number">50</span>];node ans[<span class="number">20</span>];vector&lt;node&gt;a[<span class="number">4</span>];<span class="type">int</span> S,M,D,G=<span class="number">1</span>,cnt=<span class="number">0</span>;<span class="comment">/*</span><span class="comment">S前锋   0</span><span class="comment">M中场   1</span><span class="comment">D后卫   2</span><span class="comment">G守门员 3</span><span class="comment">*/</span><span class="type">bool</span> ok_plan=<span class="number">1</span>;string plan;<span class="function">string <span class="title">to_str</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;string ret=<span class="string">&quot;&quot;</span>;<span class="keyword">while</span>(x)&#123;ret+=<span class="built_in">char</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);x/=<span class="number">10</span>;&#125;<span class="built_in">reverse</span>(ret.<span class="built_in">begin</span>(),ret.<span class="built_in">end</span>());<span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">bool</span> <span class="title">cmp_of_role</span><span class="params">(node a,node b)</span></span>&#123;<span class="keyword">if</span>(a.role!=b.role)<span class="keyword">return</span> a.role&lt;b.role;<span class="keyword">return</span> a.id&lt;b.id;&#125;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">22</span>;i++)&#123;<span class="built_in">getline</span>(cin,player[i].infor);player[i].infor+=<span class="string">&#x27; &#x27;</span>;player[i].year=<span class="number">0</span>;<span class="comment">/*cout&lt;&lt;player[i].infor&lt;&lt;endl;*/</span><span class="type">int</span> j=<span class="number">0</span>;<span class="type">int</span> id=<span class="number">0</span>;<span class="keyword">for</span>(;player[i].infor[j]!=<span class="string">&#x27; &#x27;</span>;j++)&#123;id=id*<span class="number">10</span>+(player[i].infor[j]-<span class="string">&#x27;0&#x27;</span>);&#125;player[i].id=id;j++;string name;<span class="keyword">for</span>(;player[i].infor[j]!=<span class="string">&#x27; &#x27;</span>;j++)&#123;name+=player[i].infor[j];&#125;player[i].name=name;j++;player[i].role=player[i].infor[j];j+=<span class="number">2</span>;<span class="keyword">while</span>(j&lt;player[i].infor.<span class="built_in">size</span>())&#123;<span class="type">int</span> StartYear=<span class="number">0</span>,EndYear=<span class="number">0</span>;<span class="keyword">for</span>(;player[i].infor[j]!=<span class="string">&#x27;-&#x27;</span>;j++)&#123;StartYear=StartYear*<span class="number">10</span>+(player[i].infor[j]-<span class="string">&#x27;0&#x27;</span>);&#125;j++;<span class="keyword">for</span>(;player[i].infor[j]!=<span class="string">&#x27; &#x27;</span>;j++)&#123;EndYear=EndYear*<span class="number">10</span>+(player[i].infor[j]-<span class="string">&#x27;0&#x27;</span>);&#125;j++;player[i].year+=EndYear-StartYear<span class="number">+1</span>;&#125;&#125;cin&gt;&gt;plan;plan+=<span class="string">&#x27;-&#x27;</span>;<span class="type">int</span> j=<span class="number">0</span>;<span class="comment">/*D后卫*/</span><span class="keyword">for</span>(;plan[j]!=<span class="string">&#x27;-&#x27;</span>;j++)&#123;D=D*<span class="number">10</span>+(plan[j]-<span class="string">&#x27;0&#x27;</span>);&#125;j++;<span class="comment">/*M中场*/</span><span class="keyword">for</span>(;plan[j]!=<span class="string">&#x27;-&#x27;</span>;j++)&#123;M=M*<span class="number">10</span>+(plan[j]-<span class="string">&#x27;0&#x27;</span>);&#125;j++;<span class="comment">/*S前锋*/</span><span class="keyword">for</span>(;plan[j]!=<span class="string">&#x27;-&#x27;</span>;j++)&#123;S=S*<span class="number">10</span>+(plan[j]-<span class="string">&#x27;0&#x27;</span>);&#125;j++;<span class="comment">/*cout&lt;&lt;D&lt;&lt;&quot; &quot;&lt;&lt;M&lt;&lt;&quot; &quot;&lt;&lt;S&lt;&lt;endl;*/</span>&#125;<span class="function"><span class="type">void</span> <span class="title">sort_them</span><span class="params">()</span></span>&#123;<span class="built_in">sort</span>(player<span class="number">+1</span>,player<span class="number">+22</span><span class="number">+1</span>,cmp_of_role);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">22</span>;i++)&#123;<span class="keyword">switch</span>(player[i].role)&#123;<span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:&#123;a[<span class="number">0</span>].<span class="built_in">push_back</span>(player[i]);<span class="keyword">break</span>;&#125;<span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:&#123;a[<span class="number">1</span>].<span class="built_in">push_back</span>(player[i]);<span class="keyword">break</span>;&#125;<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:&#123;a[<span class="number">2</span>].<span class="built_in">push_back</span>(player[i]);<span class="keyword">break</span>;&#125;<span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:&#123;a[<span class="number">3</span>].<span class="built_in">push_back</span>(player[i]);<span class="keyword">break</span>;&#125;&#125;&#125;&#125;<span class="function"><span class="type">void</span> <span class="title">choose</span><span class="params">()</span></span>&#123;ans[<span class="number">1</span>]=NoNo;<span class="keyword">if</span>(a[<span class="number">3</span>].<span class="built_in">size</span>()&lt;G)&#123;ok_plan=<span class="number">0</span>;<span class="keyword">return</span>;&#125;<span class="keyword">if</span>(a[<span class="number">2</span>].<span class="built_in">size</span>()&lt;D)&#123;ok_plan=<span class="number">0</span>;<span class="keyword">return</span>;&#125;<span class="keyword">if</span>(a[<span class="number">1</span>].<span class="built_in">size</span>()&lt;M)&#123;ok_plan=<span class="number">0</span>;<span class="keyword">return</span>;&#125;<span class="keyword">if</span>(a[<span class="number">0</span>].<span class="built_in">size</span>()&lt;S)&#123;ok_plan=<span class="number">0</span>;<span class="keyword">return</span>;&#125;cnt=<span class="number">1</span>;<span class="keyword">for</span>(<span class="keyword">auto</span> i:a[<span class="number">3</span>])&#123;cnt++;ans[cnt]=i;<span class="keyword">if</span>(cnt==G<span class="number">+1</span>)<span class="keyword">break</span>;&#125;<span class="keyword">for</span>(<span class="keyword">auto</span> i:a[<span class="number">2</span>])&#123;cnt++;ans[cnt]=i;<span class="keyword">if</span>(cnt==G+D<span class="number">+1</span>)<span class="keyword">break</span>;&#125;<span class="keyword">for</span>(<span class="keyword">auto</span> i:a[<span class="number">1</span>])&#123;cnt++;ans[cnt]=i;<span class="keyword">if</span>(cnt==G+D+M<span class="number">+1</span>)<span class="keyword">break</span>;&#125;<span class="keyword">for</span>(<span class="keyword">auto</span> i:a[<span class="number">0</span>])&#123;cnt++;ans[cnt]=i;<span class="keyword">if</span>(cnt==G+D+M+S<span class="number">+1</span>)<span class="keyword">break</span>;&#125;<span class="type">int</span> z=<span class="number">0</span>,Y=<span class="number">-1</span>,id=<span class="number">-1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">12</span>;i++)&#123;<span class="keyword">if</span>(ans[i].year&gt;=Y)&#123;<span class="keyword">if</span>(ans[i].year==Y)&#123;<span class="keyword">if</span>(ans[i].id&gt;id)z=i,Y=ans[i].year,id=ans[i].id;&#125;<span class="keyword">else</span>&#123;z=i,Y=ans[i].year,id=ans[i].id;&#125;&#125;&#125;<span class="built_in">swap</span>(ans[z],ans[<span class="number">1</span>]);&#125;<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(!ok_plan)&#123;<span class="built_in">puts</span>(<span class="string">&quot;IMPOSSIBLE TO ARRANGE&quot;</span>);<span class="keyword">return</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++)&#123;<span class="keyword">if</span>(ans[i].id!=<span class="number">-1</span>)cout&lt;&lt;<span class="built_in">to_str</span>(ans[i].id)&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ans[i].name&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ans[i].role&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;&#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123; <span class="built_in">freopen</span>(<span class="string">&quot;footballteam.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); <span class="built_in">freopen</span>(<span class="string">&quot;footballteam.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout); <span class="built_in">read</span>();<span class="comment">// cout&lt;&lt;player[6].year&lt;&lt;&quot; &quot;&lt;&lt;player[10].year&lt;&lt;endl;</span><span class="comment">// for(int i=1;i&lt;=22;i++)cout&lt;&lt;player[i].year&lt;&lt;endl;</span> <span class="built_in">sort_them</span>(); <span class="built_in">choose</span>(); <span class="built_in">print</span>();<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">9 PlayerA M 2000-2001 2003-2006</span><span class="comment">2 PlayerB M 2004-2006</span><span class="comment">10 PlayerC D 2001-2005</span><span class="comment">1 PlayerD D 2000-2001 2002-2004</span><span class="comment">11 PlayerE S 2003-2006</span><span class="comment">8 PlayerF M 2005-2006</span><span class="comment">22 PlayerG S 2005-2006</span><span class="comment">25 PlayerH G 2000-2001 2002-2003 2005-2006</span><span class="comment">6 PlayerI D 2003-2006</span><span class="comment">26 PlayerJ D 2003-2004 2000-2001</span><span class="comment">18 PlayerK M 2003-2004</span><span class="comment">19 PlayerL M 2000-2001 2003-2006</span><span class="comment">7 PlayerM S 2003-2006 1999-2001</span><span class="comment">21 PlayerN S 2003-2006</span><span class="comment">13 PlayerO S 2005-2006</span><span class="comment">15 PlayerP G 2001-2006</span><span class="comment">14 PlayerQ D 2003-2004</span><span class="comment">5 PlayerR S 2000-2005</span><span class="comment">20 PlayerS G 2000-2002 2003-2003</span><span class="comment">12 PlayerT M 2004-2005</span><span class="comment">3 PlayerU D 2000-2005</span><span class="comment">4 PlayerZ M 2001-2004</span><span class="comment">4-4-2</span><span class="comment">*/</span></code></pre><h3 id="波浪数"><a href="#波浪数" class="headerlink" title="波浪数"></a>波浪数</h3><p>一眼丁真，鉴定为我不会的 dp。</p><p>但我写了个大概率错的贪心过了……？</p><p>首先观察到这一定是按 <code>大小大小大小大...</code> 或 <code>小大小大小大小</code> 排列的。</p><p>我们讨论是大开头还是小开头，不符合规律就<del>干掉它</del>修改并且算一次次数。</p><p>输出时取个最小值即可。</p><p>PS：欢迎巨佬们出反例 hack 我这个贪心。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> Maxx=<span class="number">1e9</span><span class="number">+1</span>;<span class="type">const</span> <span class="type">int</span> Minn=<span class="number">-1</span>;<span class="type">int</span> Max,Min;<span class="type">int</span> n;<span class="type">int</span> a[<span class="number">114514</span>];<span class="type">int</span> f[<span class="number">114514</span>];<span class="type">int</span> b[<span class="number">114514</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123; <span class="built_in">freopen</span>(<span class="string">&quot;wave.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); <span class="built_in">freopen</span>(<span class="string">&quot;wave.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);cin&gt;&gt;n; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123; cin&gt;&gt;a[i];b[i]=a[i];&#125;<span class="type">int</span> cur,ans;<span class="comment">/*plan A*/</span>cur=<span class="number">0</span>;<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));f[<span class="number">1</span>]=<span class="number">-1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;f[i]=(i&amp;<span class="number">1</span>?<span class="number">-1</span>:<span class="number">1</span>);<span class="keyword">if</span>(f[i<span class="number">-1</span>]==<span class="number">-1</span>)&#123;<span class="keyword">if</span>(a[i]&gt;=a[i<span class="number">-1</span>])&#123;cur++;a[i]=Minn;&#125;&#125;<span class="keyword">if</span>(f[i<span class="number">-1</span>]==<span class="number">1</span>)&#123;<span class="keyword">if</span>(a[i]&lt;=a[i<span class="number">-1</span>])&#123;cur++;a[i]=Maxx;&#125;&#125;&#125;ans=cur;<span class="comment">//for(int i=1;i&lt;=n;i++)cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><span class="comment">//cout&lt;&lt;endl;</span><span class="comment">/*plan B*/</span>cur=<span class="number">0</span>;<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));f[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;f[i]=(i&amp;<span class="number">1</span>?<span class="number">1</span>:<span class="number">-1</span>);<span class="keyword">if</span>(f[i<span class="number">-1</span>]==<span class="number">-1</span>)&#123;<span class="keyword">if</span>(b[i]&gt;=b[i<span class="number">-1</span>])&#123;cur++;b[i]=Minn;&#125;&#125;<span class="keyword">if</span>(f[i<span class="number">-1</span>]==<span class="number">1</span>)&#123;<span class="keyword">if</span>(b[i]&lt;=b[i<span class="number">-1</span>])&#123;cur++;b[i]=Maxx;&#125;&#125;&#125;<span class="comment">//for(int i=1;i&lt;=n;i++)cout&lt;&lt;b[i]&lt;&lt;&quot; &quot;;</span><span class="comment">//cout&lt;&lt;endl;</span>cout&lt;&lt;<span class="built_in">min</span>(ans,cur)&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">6</span><span class="comment">1 1 2 2 3 3</span><span class="comment"></span><span class="comment">11</span><span class="comment">703 702 703 703 702 703 702 702 702</span><span class="comment">700 702</span><span class="comment">*/</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] P1959 遗址</title>
      <link href="/archives/P1959/"/>
      <url>/archives/P1959/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>CSP-J 模拟赛教练放的一道原题，赛时 AC 了听同学说洛谷有，回来写题解。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><h4 id="如何找到正方形的四个顶点"><a href="#如何找到正方形的四个顶点" class="headerlink" title="如何找到正方形的四个顶点"></a>如何找到正方形的四个顶点</h4><p>最简单的最容易思考到的方法：$\mathcal O(n^4)$ 或 $\mathcal O(n^3)$ 枚举四个顶点。</p><p>但由于 $n\leq3000$，肯定超时，复杂度肯定要控制在 $\mathcal O(n^2)$ 左右。</p><p>$\mathcal O(n^2)$ 意味着枚举两个点，我们来观察一下这两个点与另外两个点的位置关系。</p><p><img src="https://s1.ax1x.com/2022/10/04/xleygH.png"></p><p>如图所示，我们将左上顶点定为 $i$，左下顶点对应 $j$，那么可以发现如下关系：</p><ol><li><p>标红段为 $i$ 与 $j$ 的横坐标差，正好为左下顶点与右下顶点的纵坐标之差。</p></li><li><p>标蓝段为 $i$ 与 $j$ 的纵坐标差，正好为左下顶点与右下顶点的横坐标之差。</p></li></ol><p>如此，我们即可仅仅通过两个点推出其余两个点的坐标。</p><h4 id="如何求面积"><a href="#如何求面积" class="headerlink" title="如何求面积"></a>如何求面积</h4><p>前置知识：勾股定理 $a^2+b^2&#x3D;c^2$。</p><p><img src="https://s1.ax1x.com/2022/10/04/xlmFq1.png"></p><p>把连接 $i$ 和 $j$ 的虚线以及红蓝两线当做一个直角三角形，我们把蓝线想成 $a$，红线想成 $b$，那么虚线长度即正方形的边长，即为 $\sqrt{a^2+b^2}$。再根据正方形面积公式，正方形面积为 $\sqrt{a^2+b^2}\times \sqrt{a^2+b^2}&#x3D;a^2+b^2$。 </p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="meta">#<span class="keyword">define</span> max(a,b) a&gt;b?a:b</span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">bool</span> f[<span class="number">5020</span>][<span class="number">5020</span>];<span class="type">int</span> x[<span class="number">3020</span>];<span class="type">int</span> y[<span class="number">3020</span>];<span class="type">int</span> n,m;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="comment">//freopen(&quot;ruin.in&quot;,&quot;r&quot;,stdin);</span><span class="comment">//freopen(&quot;ruin.out&quot;,&quot;w&quot;,stdout);</span><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,x+i,y+i);f[x[i]][y[i]]=<span class="number">1</span>;&#125;<span class="type">int</span> ans=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="type">int</span> a=x[i]-x[j];<span class="type">int</span> b=y[i]-y[j];<span class="type">int</span> Ax=x[i]-b;<span class="type">int</span> Bx=x[j]-b;<span class="type">int</span> Ay=y[i]+a;<span class="type">int</span> By=y[j]+a;            <span class="keyword">if</span>(Ax&lt;<span class="number">1</span>||Ax&gt;<span class="number">5000</span>||Bx&lt;<span class="number">1</span>||Bx&gt;<span class="number">5000</span>||Ay&lt;<span class="number">1</span>||Ay&gt;<span class="number">5000</span>||By&lt;<span class="number">1</span>||By&gt;<span class="number">5000</span>)<span class="keyword">continue</span>;<span class="keyword">if</span>(f[Ax][Ay]&amp;&amp;f[Bx][By])&#123;ans=<span class="built_in">max</span>(ans,a*a+b*b);&#125;&#125;&#125;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20221004 | CSP2022 考前模拟赛 做题笔记</title>
      <link href="/archives/20221004_mock/"/>
      <url>/archives/20221004_mock/</url>
      
        <content type="html"><![CDATA[<h3 id="排名"><a href="#排名" class="headerlink" title="排名"></a>排名</h3><p>一开始不明白为什么一堆大佬死这题了。</p><p>一翻代码：年级从大到小。</p><p>……</p><p>正文开始：</p><p>首先排序，首先按成绩大到小，其次按年级小到大。</p><p>然后可以开个 hash 数组统计到目前为止每个年级的人数，输出直接输出自己年级之前的总和。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> Scr,Grd;&#125;a[<span class="number">114514</span>];<span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span><span class="function"></span>&#123;<span class="keyword">if</span>(a.Scr!=b.Scr)<span class="keyword">return</span> a.Scr&gt;b.Scr;<span class="keyword">return</span> a.Grd&lt;b.Grd;&#125;<span class="type">int</span> n;<span class="type">int</span> h[<span class="number">10</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;paiming.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;paiming.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i].Scr&gt;&gt;a[i].Grd;&#125;<span class="built_in">sort</span>(a<span class="number">+1</span>,a+n<span class="number">+1</span>,cmp);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> ans=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;a[i].Grd;j++)ans+=h[j];h[a[i].Grd]++;cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;&#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h3><p>一道搜索。</p><p>对于每个点，我们扫一遍看它是山还是湖。</p><p>后记：调了一上午，发现是本地栈空间没有机房开得大……</p><p>吃席！</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n,m;<span class="type">bool</span> hill,lake;<span class="type">int</span> mp[<span class="number">1020</span>][<span class="number">1020</span>];<span class="type">bool</span> f[<span class="number">1020</span>][<span class="number">1020</span>];<span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;<span class="type">int</span> dy[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">// int dx[]=&#123;-1,0,0,1&#125;;</span><span class="comment">// int dy[]=&#123;0,-1,1,0&#125;;</span><span class="type">int</span> cnt;<span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><span class="function"></span>&#123;<span class="keyword">return</span> <span class="number">1</span>&lt;=x&amp;&amp;x&lt;=n&amp;&amp;<span class="number">1</span>&lt;=y&amp;&amp;y&lt;=m;&#125;<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><span class="function"></span>&#123;<span class="comment">// cout&lt;&lt;++cnt&lt;&lt;endl;</span><span class="comment">// cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span>f[x][y]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;<span class="type">int</span> X=dx[i]+x,Y=dy[i]+y;<span class="keyword">if</span>(!<span class="built_in">ok</span>(X,Y)||(f[X][Y]&amp;&amp;mp[X][Y]==mp[x][y]))<span class="keyword">continue</span>;<span class="keyword">if</span>(mp[X][Y]&gt;mp[x][y])&#123;lake=<span class="number">1</span>;<span class="keyword">continue</span>;&#125;<span class="keyword">if</span>(mp[X][Y]&lt;mp[x][y])&#123;hill=<span class="number">1</span>;<span class="keyword">continue</span>;&#125;<span class="comment">// cout&lt;&lt;X&lt;&lt;&quot; &quot;&lt;&lt;Y&lt;&lt;endl;</span><span class="built_in">dfs</span>(X,Y);&#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;seek.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;seek.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);cin&gt;&gt;n&gt;&gt;m;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;cin&gt;&gt;mp[i][j];&#125;&#125;<span class="type">int</span> ansf=<span class="number">0</span>,ansg=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;<span class="keyword">if</span>(!f[i][j])&#123;hill=lake=<span class="number">0</span>;<span class="built_in">dfs</span>(i,j);<span class="keyword">if</span>(hill&amp;&amp;lake)<span class="keyword">continue</span>;ansf+=lake;ansg+=hill;&#125;</code></pre><p>}<br>}<br>cout&lt;&lt;ansf&lt;&lt;” “&lt;&lt;ansg&lt;&lt;endl;<br>return 0;</p><pre><code class="highlight">&#125;</code></pre><h3 id="遗址"><a href="#遗址" class="headerlink" title="遗址"></a>遗址</h3><p><a href="https://www.luogu.com.cn/blog/516346/solution-p8197">https://www.luogu.com.cn/blog/516346/solution-p8197</a></p><p>[post cid&#x3D;”84” cover&#x3D;”” size&#x3D;””&#x2F;]</p><h3 id="愤怒的小鸟"><a href="#愤怒的小鸟" class="headerlink" title="愤怒的小鸟"></a>愤怒的小鸟</h3><p>题目改了，可以连续爆炸。</p><p>那么我们只需要找出两两之间的差，除掉前 $k-1$ 个最大的，之后的最大即为答案。</p><p>显然过程是 <code>排序整个数组</code>-<code>得到两两间的差</code>-<code>找出答案</code>。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n,k;<span class="type">int</span> a[<span class="number">50020</span>];priority_queue&lt;<span class="type">int</span>&gt;q;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;angry.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;angry.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);cin&gt;&gt;n&gt;&gt;k;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;<span class="built_in">sort</span>(a<span class="number">+1</span>,a+n<span class="number">+1</span>);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;<span class="comment">/*cout&lt;&lt;a[i]-a[i-1]&lt;&lt;&quot; &quot;;*/</span>q.<span class="built_in">push</span>(a[i]-a[i<span class="number">-1</span>]);&#125;<span class="comment">//cout&lt;&lt;endl;</span><span class="keyword">while</span>(k!=<span class="number">1</span>)&#123;q.<span class="built_in">pop</span>();k--;&#125;cout&lt;&lt;q.<span class="built_in">top</span>()&lt;&lt;endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">7 2</span><span class="comment">20</span><span class="comment">25</span><span class="comment">18</span><span class="comment">8</span><span class="comment">10</span><span class="comment">3</span><span class="comment">1</span><span class="comment"></span><span class="comment">1 3 8 10 18 20 25</span><span class="comment">*/</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[游记] CSP 2022 &amp; NOIP 2022 游记</title>
      <link href="/archives/CSP2022/"/>
      <url>/archives/CSP2022/</url>
      
        <content type="html"><![CDATA[<h2 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h2><h3 id="Day-4"><a href="#Day-4" class="headerlink" title="Day -4"></a>Day -4</h3><p>好耶，逃了信息课去基房四练初赛！</p><p>看了一遍 <a href="https://www.luogu.com.cn/blog/334586/csp-pre-knowledge">159号程序员</a> 的日报，认真刷了一点数学题，感觉差不多了。</p><h3 id="Day-3"><a href="#Day-3" class="headerlink" title="Day -3"></a>Day -3</h3><p>晚自习做了套 tg 组卷子，$69$，感觉过初赛还算稳……？</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h3><p>考前一天还要 whk，呜呜呜想哭。</p><p>下午去学校的基房<del>搞基</del>做了套 pj 组的初赛卷子。$79.5$，最高 $80.5$ 还可以吧……？</p><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>$$Morning$$</p><p>早上睡了个懒觉（？</p><p><del>七点多起不算太晚</del></p><p>然后就到考场 main 基去了。</p><p>重点得看考卷（</p><p>我【】你【】的 €€£，【】有向联通是强连通还是弱联通啊，这都不说的吗？？？</p><p>我【】你【】的 €€£，【】你不给子串定义还好，说了连续<strong>字母</strong>我【】反而没算空串！！！</p><p>pj 貌似只有选择有槽点。</p><p>感觉 pj 要寄了。</p><p>$$afternoon$$</p><p>tg 终于和 byx、cfz、cjy、byx 等巨佬在一起了！</p><p>重点得看考卷（</p><p>我【】你【】的 €€£，【】宇宙射线是个什么鬼？？？出题人脑子被宇宙射线射傻了吧？？？宇宙射线什么时候带出题人的马走啊？？？</p><p>预估明年题目：</p><pre><code class="highlight">射线拦截射线的冰雪小屋射线杀射线棋射线在干什么？有没有空？可以来拯救吗？五彩斑斓的射线找啊找啊找射线射线+线射 Problem射线的修炼合并射线</code></pre><p>我【】你【】的 €€£，【】期末作业是个什么鬼？？？【】的两人做作业六个摆烂？？？</p><p>我【】你【】的 €€£，【】<code>for(int j=0;j&lt;n;j*=2)</code> 是个什么鬼？？？【】的死循环求复杂度是吧，$\Theta(\infty)$？？？</p><p>我【】你【】的 €€£，【】$O()$ 是个什么鬼？？？【】的我都知道复杂度的记号不能这么写！！！</p><p>tg 槽点真【】多。</p><p>感觉 tg 要寄了。</p><p>$$evening$$</p><p>写游记去了。</p><p>总结：这场是练习找茬能力的。</p><h2 id="复赛"><a href="#复赛" class="headerlink" title="复赛"></a>复赛</h2><h3 id="Day-3-1"><a href="#Day-3-1" class="headerlink" title="Day -3"></a>Day -3</h3><p>CCF 取消了 JS 的 CSP！！！</p><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h3><p>CCF 恢复了 JS 的 CSP！！！</p><p>上个课间还在讨论 CCF 的父母身体健康，下个课间整个教学楼的 OIer 都沸腾了。</p><p>因为是做完核酸通知的，还要做核酸。</p><p>不过，我们班参加第二轮有五个，四个正好轮到今天核酸。</p><p>可怜的 GPD 巨佬被老师单独拉走<del>去小黑屋反省</del>出学校去做核酸。</p><h3 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day -1"></a>Day -1</h3><p>模考终于考完了。</p><p>模考废了。</p><p>CSP 别废。</p><h3 id="Day-0-1"><a href="#Day-0-1" class="headerlink" title="Day 0"></a>Day 0</h3><p>CSP 啦！</p><p>在地铁上偶遇 WJC 巨佬<del>但教练说膜拜巨佬 rp 会被巨佬吸去所以不敢膜拜。</del></p><p>提前进了 scz 又遇到一堆巨佬。</p><p><del>如何评价 wjl 在 scz 门口大喊 sxy 我爱你。</del></p><p>进 pj 考场了。</p><p>坐了好久<del>没发现 scz 电脑的扫雷。</del></p><p>但为啥八点半考八点二十五发题？</p><p>算了不管了。</p><p>还眼瞎没找到 README，但我记得去年在 NJ 好像直接在桌面，结果这次在 JSOI 系统上。</p><p>看题第一眼：</p><p>T1 快速幂。</p><p>T2 一元二次方程。</p><p>T3 大模拟。</p><p>T4 不知道。</p><p>第二眼：</p><p>T1 特判。</p><p>T2 一元二次石锤，<del>但我不会怎么办</del>。</p><p>T3 大模拟。</p><p>T4 不知道。</p><p>T1一开始写了个奇奇怪怪的，大概是 $10^9$ 的时候数据过大，拆成 $10^2\times 10^7$，先算 $a^{b\div 100}$，再乘 $100$ 次。</p><p>在最后几分钟玩机房的 Python 才发现特判就能过。</p><p>T2 在切完 T1 3min 后想出正解一元二次方程。但我不会解，写了个奇奇怪怪的二分一直挂，换上了暴力。</p><p>寄。</p><p>T3 数据分治了一下特殊情况，不知道为什么自测分数很低。</p><p>T4 不会，针对 $k&#x3D;0$ 写了个类似并查集的东西，把每个点的贡献集体加到这一组的某个点上，但也挂了。</p><p>考完出来被小五 IOIAKer XYC 吊打了一番，和巨佬一起去天语雅阁吃了个饭。</p><p>下午 tg，小学生参赛有，但 XYC 应该是最小的。</p><p><del>如何评价 XYC 巨佬忽悠高中生不要写 freopen。</del></p><p>提高也提前五分钟发了卷子。</p><p>拿到手，一眼丁真三道图论一道 DS。</p><p>T1 一眼最短路，数据范围表明 $n^2$ 复杂度，我写了个 $\mathcal O(n^2)$ 对每个点 bfs 一下到其他点换几次，然后跑 $\mathcal O(n^4)$ 算答案。</p><p>期望得分 $20\ \tt{pts}$，但自测上了 $70$。</p><p>应该是优化的功劳</p><p>T2 一眼 DS，考完听说正解是 ST 表，赛时没想到，写了个数据分治，$\leq 1000$ 跑暴力，$&gt; 1000$ 写了个不知道对不对的线段树。</p><p>期望得分 $[0,75]\ \tt{pts}$，自测只有 $20$ 挺离谱。</p><p>T3 针对小数据写了暴力，期望得分 $[15,40]\ \tt{pts}$，自测也差不多 $40$。</p><p>但考完听说是诈骗不是图论，很迷。</p><p>T4 摆了。</p><p>感觉这把 tg 打得还行吧，自测 $130$ 左右，实际可能往上一点。听说蓝勾 $150$ 左右，感觉很悬没机会了。但还是祈祷 CCF 数据多给点分吧。</p><h2 id="NOIp"><a href="#NOIp" class="headerlink" title="NOIp"></a>NOIp</h2><h3 id="Day-9"><a href="#Day-9" class="headerlink" title="Day -9"></a>Day -9</h3><p>CSP 出分了&#x2F;hsh</p><p>两组都是因为赛场脑残挂分，痛失双国一，痛失 J 和 S 的前 $20%$……</p><p>也因为挂分，S 没达到 NOIp 参赛线。</p><p>呜呜呜就差一个 T2 的 <code>LLONG_MAX</code> 写成了 <code>INT_MAX</code>！</p><p> 但晚自习的时候，教练讲，因为今年 NOIp 在 CZ 有考场，我们学校所有提高非 $0$ 分都能去！</p><p>耶~</p><h3 id="Day-8"><a href="#Day-8" class="headerlink" title="Day -8"></a>Day -8</h3><p>很不理解为什么班歌大赛班主任让我在台上跳舞。</p><p>同时为什么公开处刑我 S 组省内 rk.300+ 这个糗事啊！我连目标两组都前 $20%$ 都没达到诶！</p><h3 id="Day-1-2"><a href="#Day-1-2" class="headerlink" title="Day -1"></a>Day -1</h3><p>班歌大赛去世了。</p><p>带了墨镜，怎么还全认出我了啊啊啊！！！</p><h3 id="Day-0-2"><a href="#Day-0-2" class="headerlink" title="Day 0"></a>Day 0</h3><p>早起。困。</p><p>到了门口还要做核酸诶。</p><p>去的时候已经有两位巨佬在了，我们交换了食物。<del>巧克力换巧克力等于没换啊喂</del></p><p>等了一会儿，凑齐了我们常外这届初一的 $7$ 位巨佬和我一个蒟蒻。</p><p>带队的老师带我们去机房，但我感觉好像和 CSP 去的路线不太一样……？</p><p>果然，那个楼道被锁了。几十个人被困在了楼道困了 $15\ \tt{min}$。</p><p>真的服了啊！</p><p>然后几位高中生找到了去机房的路，说要带我们去，正要<del>省常中 OIer 起义</del>时，带队老师来了，带我们走了出去。</p><p>NOIp 游记 $\to$ 省常中楼道游寄。</p><p>终于到了机房，不容易啊。</p><p>敲了个缺省源，写了个对拍器，但八点半都过了为什么不发题？？？</p><p><del>哦，原来是特派员去问官方，官方数据人跳出来说“不可以，特派员”。</del></p><p>拿到手，全都不会。</p><p>T1 写了一个多小时，$\mathcal O(n^2m)$ 的写法，后来想到了一点优化，但我很快就想出一种卡死优化的方法，没写。</p><p>预估 $70+\ \tt{pts}$，结果特判数据 $1$ 时，输出完 <code>0 0</code> 没有退出，又跑了后面的，寄。</p><hr><p>出考场的我：</p><p>“这次 T1 谁第一个测试点不 AC 我笑话谁一百年。”</p><hr><p>T2 没写。</p><p>T3 写了个一条链的部分分，对着小数据推的公式，但大数据好像过不了，寄。</p><p>T3 我还为了 $n\leq3,m\leq8$ 的点写了 $200$ 行代码，没调完，我到死都不知道没建边是怎么搜索搜到那里的。</p><p>T4 写了暴力，预估 $8\ \tt{pts}$，这个还是有信心拿到的。</p><p>现在估分可能一共只有 $[77,80]\ \tt{pts}$。</p><hr><p><img src="https://s1.ax1x.com/2022/11/27/zU8eAS.png"></p>]]></content>
      
      
      <categories>
          
          <category> TravelNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20220812 | CSP2022 考前模拟赛 做题笔记</title>
      <link href="/archives/20220812_mock/"/>
      <url>/archives/20220812_mock/</url>
      
        <content type="html"><![CDATA[<p>呜呜呜<strong>卞宇轩</strong>等<strong>巨佬</strong>出的太毒瘤了呜呜呜</p><h4 id="cube"><a href="#cube" class="headerlink" title="cube"></a>cube</h4><p>模拟。</p><p>真就模拟。</p><p>好好想咋模拟。</p><p>不然和我一样瞎写。</p><p>我瞎写写了 $7\ \tt{KB}$ 的模拟。</p><p>我太菜了只会这种一点一点转。</p><p>不像 <code>爬不？立刻！</code> 巨佬一样 $5\  \tt{min}$ 爆切。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> t;<span class="type">int</span> a[<span class="number">130</span>];<span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="keyword">return</span> a[<span class="string">&#x27;a&#x27;</span>]==a[<span class="string">&#x27;b&#x27;</span>]&amp;&amp;a[<span class="string">&#x27;b&#x27;</span>]==a[<span class="string">&#x27;c&#x27;</span>]&amp;&amp;a[<span class="string">&#x27;c&#x27;</span>]==a[<span class="string">&#x27;d&#x27;</span>]&amp;&amp;a[<span class="string">&#x27;e&#x27;</span>]==a[<span class="string">&#x27;f&#x27;</span>]&amp;&amp;a[<span class="string">&#x27;f&#x27;</span>]==a[<span class="string">&#x27;g&#x27;</span>]&amp;&amp;a[<span class="string">&#x27;g&#x27;</span>]==a[<span class="string">&#x27;h&#x27;</span>]&amp;&amp;a[<span class="string">&#x27;i&#x27;</span>]==a[<span class="string">&#x27;j&#x27;</span>]&amp;&amp;a[<span class="string">&#x27;j&#x27;</span>]==a[<span class="string">&#x27;k&#x27;</span>]&amp;&amp;a[<span class="string">&#x27;k&#x27;</span>]==a[<span class="string">&#x27;l&#x27;</span>]&amp;&amp;a[<span class="string">&#x27;m&#x27;</span>]==a[<span class="string">&#x27;n&#x27;</span>]&amp;&amp;a[<span class="string">&#x27;n&#x27;</span>]==a[<span class="string">&#x27;o&#x27;</span>]&amp;&amp;a[<span class="string">&#x27;o&#x27;</span>]==a[<span class="string">&#x27;p&#x27;</span>]&amp;&amp;a[<span class="string">&#x27;q&#x27;</span>]==a[<span class="string">&#x27;r&#x27;</span>]&amp;&amp;a[<span class="string">&#x27;r&#x27;</span>]==a[<span class="string">&#x27;s&#x27;</span>]&amp;&amp;a[<span class="string">&#x27;s&#x27;</span>]==a[<span class="string">&#x27;t&#x27;</span>]&amp;&amp;a[<span class="string">&#x27;u&#x27;</span>]==a[<span class="string">&#x27;v&#x27;</span>]&amp;&amp;a[<span class="string">&#x27;v&#x27;</span>]==a[<span class="string">&#x27;w&#x27;</span>]&amp;&amp;a[<span class="string">&#x27;w&#x27;</span>]==a[<span class="string">&#x27;x&#x27;</span>];&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;cin&gt;&gt;a[<span class="string">&#x27;a&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;b&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;c&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;d&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;e&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;f&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;g&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;h&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;i&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;j&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;k&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;l&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;m&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;n&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;o&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;p&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;q&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;r&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;s&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;t&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;u&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;v&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;w&#x27;</span>]&gt;&gt;a[<span class="string">&#x27;x&#x27;</span>];<span class="type">int</span> c;<span class="comment">/*</span><span class="comment">o-&gt;p</span><span class="comment">p-&gt;u</span><span class="comment">u-&gt;w</span><span class="comment">...</span><span class="comment">*/</span><span class="keyword">if</span>(<span class="built_in">check</span>())&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span>;&#125;<span class="comment">//1</span>c=a[<span class="string">&#x27;o&#x27;</span>];a[<span class="string">&#x27;o&#x27;</span>]=a[<span class="string">&#x27;r&#x27;</span>];a[<span class="string">&#x27;r&#x27;</span>]=a[<span class="string">&#x27;t&#x27;</span>];a[<span class="string">&#x27;t&#x27;</span>]=a[<span class="string">&#x27;e&#x27;</span>];a[<span class="string">&#x27;e&#x27;</span>]=a[<span class="string">&#x27;f&#x27;</span>];a[<span class="string">&#x27;f&#x27;</span>]=a[<span class="string">&#x27;w&#x27;</span>];a[<span class="string">&#x27;w&#x27;</span>]=a[<span class="string">&#x27;u&#x27;</span>];a[<span class="string">&#x27;u&#x27;</span>]=a[<span class="string">&#x27;p&#x27;</span>];a[<span class="string">&#x27;p&#x27;</span>]=c;c=a[<span class="string">&#x27;o&#x27;</span>];a[<span class="string">&#x27;o&#x27;</span>]=a[<span class="string">&#x27;r&#x27;</span>];a[<span class="string">&#x27;r&#x27;</span>]=a[<span class="string">&#x27;t&#x27;</span>];a[<span class="string">&#x27;t&#x27;</span>]=a[<span class="string">&#x27;e&#x27;</span>];a[<span class="string">&#x27;e&#x27;</span>]=a[<span class="string">&#x27;f&#x27;</span>];a[<span class="string">&#x27;f&#x27;</span>]=a[<span class="string">&#x27;w&#x27;</span>];a[<span class="string">&#x27;w&#x27;</span>]=a[<span class="string">&#x27;u&#x27;</span>];a[<span class="string">&#x27;u&#x27;</span>]=a[<span class="string">&#x27;p&#x27;</span>];a[<span class="string">&#x27;p&#x27;</span>]=c;<span class="keyword">if</span>(<span class="built_in">check</span>())&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span>;&#125;<span class="comment">//2</span>c=a[<span class="string">&#x27;o&#x27;</span>];a[<span class="string">&#x27;o&#x27;</span>]=a[<span class="string">&#x27;r&#x27;</span>];a[<span class="string">&#x27;r&#x27;</span>]=a[<span class="string">&#x27;t&#x27;</span>];a[<span class="string">&#x27;t&#x27;</span>]=a[<span class="string">&#x27;e&#x27;</span>];a[<span class="string">&#x27;e&#x27;</span>]=a[<span class="string">&#x27;f&#x27;</span>];a[<span class="string">&#x27;f&#x27;</span>]=a[<span class="string">&#x27;w&#x27;</span>];a[<span class="string">&#x27;w&#x27;</span>]=a[<span class="string">&#x27;u&#x27;</span>];a[<span class="string">&#x27;u&#x27;</span>]=a[<span class="string">&#x27;p&#x27;</span>];a[<span class="string">&#x27;p&#x27;</span>]=c;c=a[<span class="string">&#x27;o&#x27;</span>];a[<span class="string">&#x27;o&#x27;</span>]=a[<span class="string">&#x27;r&#x27;</span>];a[<span class="string">&#x27;r&#x27;</span>]=a[<span class="string">&#x27;t&#x27;</span>];a[<span class="string">&#x27;t&#x27;</span>]=a[<span class="string">&#x27;e&#x27;</span>];a[<span class="string">&#x27;e&#x27;</span>]=a[<span class="string">&#x27;f&#x27;</span>];a[<span class="string">&#x27;f&#x27;</span>]=a[<span class="string">&#x27;w&#x27;</span>];a[<span class="string">&#x27;w&#x27;</span>]=a[<span class="string">&#x27;u&#x27;</span>];a[<span class="string">&#x27;u&#x27;</span>]=a[<span class="string">&#x27;p&#x27;</span>];a[<span class="string">&#x27;p&#x27;</span>]=c;<span class="comment">//3</span>c=a[<span class="string">&#x27;o&#x27;</span>];a[<span class="string">&#x27;o&#x27;</span>]=a[<span class="string">&#x27;r&#x27;</span>];a[<span class="string">&#x27;r&#x27;</span>]=a[<span class="string">&#x27;t&#x27;</span>];a[<span class="string">&#x27;t&#x27;</span>]=a[<span class="string">&#x27;e&#x27;</span>];a[<span class="string">&#x27;e&#x27;</span>]=a[<span class="string">&#x27;f&#x27;</span>];a[<span class="string">&#x27;f&#x27;</span>]=a[<span class="string">&#x27;w&#x27;</span>];a[<span class="string">&#x27;w&#x27;</span>]=a[<span class="string">&#x27;u&#x27;</span>];a[<span class="string">&#x27;u&#x27;</span>]=a[<span class="string">&#x27;p&#x27;</span>];a[<span class="string">&#x27;p&#x27;</span>]=c;c=a[<span class="string">&#x27;o&#x27;</span>];a[<span class="string">&#x27;o&#x27;</span>]=a[<span class="string">&#x27;r&#x27;</span>];a[<span class="string">&#x27;r&#x27;</span>]=a[<span class="string">&#x27;t&#x27;</span>];a[<span class="string">&#x27;t&#x27;</span>]=a[<span class="string">&#x27;e&#x27;</span>];a[<span class="string">&#x27;e&#x27;</span>]=a[<span class="string">&#x27;f&#x27;</span>];a[<span class="string">&#x27;f&#x27;</span>]=a[<span class="string">&#x27;w&#x27;</span>];a[<span class="string">&#x27;w&#x27;</span>]=a[<span class="string">&#x27;u&#x27;</span>];a[<span class="string">&#x27;u&#x27;</span>]=a[<span class="string">&#x27;p&#x27;</span>];a[<span class="string">&#x27;p&#x27;</span>]=c;<span class="keyword">if</span>(<span class="built_in">check</span>())&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span>;&#125;<span class="comment">//4</span>c=a[<span class="string">&#x27;o&#x27;</span>];a[<span class="string">&#x27;o&#x27;</span>]=a[<span class="string">&#x27;r&#x27;</span>];a[<span class="string">&#x27;r&#x27;</span>]=a[<span class="string">&#x27;t&#x27;</span>];a[<span class="string">&#x27;t&#x27;</span>]=a[<span class="string">&#x27;e&#x27;</span>];a[<span class="string">&#x27;e&#x27;</span>]=a[<span class="string">&#x27;f&#x27;</span>];a[<span class="string">&#x27;f&#x27;</span>]=a[<span class="string">&#x27;w&#x27;</span>];a[<span class="string">&#x27;w&#x27;</span>]=a[<span class="string">&#x27;u&#x27;</span>];a[<span class="string">&#x27;u&#x27;</span>]=a[<span class="string">&#x27;p&#x27;</span>];a[<span class="string">&#x27;p&#x27;</span>]=c;c=a[<span class="string">&#x27;o&#x27;</span>];a[<span class="string">&#x27;o&#x27;</span>]=a[<span class="string">&#x27;r&#x27;</span>];a[<span class="string">&#x27;r&#x27;</span>]=a[<span class="string">&#x27;t&#x27;</span>];a[<span class="string">&#x27;t&#x27;</span>]=a[<span class="string">&#x27;e&#x27;</span>];a[<span class="string">&#x27;e&#x27;</span>]=a[<span class="string">&#x27;f&#x27;</span>];a[<span class="string">&#x27;f&#x27;</span>]=a[<span class="string">&#x27;w&#x27;</span>];a[<span class="string">&#x27;w&#x27;</span>]=a[<span class="string">&#x27;u&#x27;</span>];a[<span class="string">&#x27;u&#x27;</span>]=a[<span class="string">&#x27;p&#x27;</span>];a[<span class="string">&#x27;p&#x27;</span>]=c;<span class="comment">//1</span>c=a[<span class="string">&#x27;m&#x27;</span>];a[<span class="string">&#x27;m&#x27;</span>]=a[<span class="string">&#x27;q&#x27;</span>];a[<span class="string">&#x27;q&#x27;</span>]=a[<span class="string">&#x27;s&#x27;</span>];a[<span class="string">&#x27;s&#x27;</span>]=a[<span class="string">&#x27;g&#x27;</span>];a[<span class="string">&#x27;g&#x27;</span>]=a[<span class="string">&#x27;h&#x27;</span>];a[<span class="string">&#x27;h&#x27;</span>]=a[<span class="string">&#x27;x&#x27;</span>];a[<span class="string">&#x27;x&#x27;</span>]=a[<span class="string">&#x27;v&#x27;</span>];a[<span class="string">&#x27;v&#x27;</span>]=a[<span class="string">&#x27;n&#x27;</span>];a[<span class="string">&#x27;n&#x27;</span>]=c;c=a[<span class="string">&#x27;m&#x27;</span>];a[<span class="string">&#x27;m&#x27;</span>]=a[<span class="string">&#x27;q&#x27;</span>];a[<span class="string">&#x27;q&#x27;</span>]=a[<span class="string">&#x27;s&#x27;</span>];a[<span class="string">&#x27;s&#x27;</span>]=a[<span class="string">&#x27;g&#x27;</span>];a[<span class="string">&#x27;g&#x27;</span>]=a[<span class="string">&#x27;h&#x27;</span>];a[<span class="string">&#x27;h&#x27;</span>]=a[<span class="string">&#x27;x&#x27;</span>];a[<span class="string">&#x27;x&#x27;</span>]=a[<span class="string">&#x27;v&#x27;</span>];a[<span class="string">&#x27;v&#x27;</span>]=a[<span class="string">&#x27;n&#x27;</span>];a[<span class="string">&#x27;n&#x27;</span>]=c;<span class="keyword">if</span>(<span class="built_in">check</span>())&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span>;&#125;<span class="comment">//2</span>c=a[<span class="string">&#x27;m&#x27;</span>];a[<span class="string">&#x27;m&#x27;</span>]=a[<span class="string">&#x27;q&#x27;</span>];a[<span class="string">&#x27;q&#x27;</span>]=a[<span class="string">&#x27;s&#x27;</span>];a[<span class="string">&#x27;s&#x27;</span>]=a[<span class="string">&#x27;g&#x27;</span>];a[<span class="string">&#x27;g&#x27;</span>]=a[<span class="string">&#x27;h&#x27;</span>];a[<span class="string">&#x27;h&#x27;</span>]=a[<span class="string">&#x27;x&#x27;</span>];a[<span class="string">&#x27;x&#x27;</span>]=a[<span class="string">&#x27;v&#x27;</span>];a[<span class="string">&#x27;v&#x27;</span>]=a[<span class="string">&#x27;n&#x27;</span>];a[<span class="string">&#x27;n&#x27;</span>]=c;c=a[<span class="string">&#x27;m&#x27;</span>];a[<span class="string">&#x27;m&#x27;</span>]=a[<span class="string">&#x27;q&#x27;</span>];a[<span class="string">&#x27;q&#x27;</span>]=a[<span class="string">&#x27;s&#x27;</span>];a[<span class="string">&#x27;s&#x27;</span>]=a[<span class="string">&#x27;g&#x27;</span>];a[<span class="string">&#x27;g&#x27;</span>]=a[<span class="string">&#x27;h&#x27;</span>];a[<span class="string">&#x27;h&#x27;</span>]=a[<span class="string">&#x27;x&#x27;</span>];a[<span class="string">&#x27;x&#x27;</span>]=a[<span class="string">&#x27;v&#x27;</span>];a[<span class="string">&#x27;v&#x27;</span>]=a[<span class="string">&#x27;n&#x27;</span>];a[<span class="string">&#x27;n&#x27;</span>]=c;<span class="comment">//3</span>c=a[<span class="string">&#x27;m&#x27;</span>];a[<span class="string">&#x27;m&#x27;</span>]=a[<span class="string">&#x27;q&#x27;</span>];a[<span class="string">&#x27;q&#x27;</span>]=a[<span class="string">&#x27;s&#x27;</span>];a[<span class="string">&#x27;s&#x27;</span>]=a[<span class="string">&#x27;g&#x27;</span>];a[<span class="string">&#x27;g&#x27;</span>]=a[<span class="string">&#x27;h&#x27;</span>];a[<span class="string">&#x27;h&#x27;</span>]=a[<span class="string">&#x27;x&#x27;</span>];a[<span class="string">&#x27;x&#x27;</span>]=a[<span class="string">&#x27;v&#x27;</span>];a[<span class="string">&#x27;v&#x27;</span>]=a[<span class="string">&#x27;n&#x27;</span>];a[<span class="string">&#x27;n&#x27;</span>]=c;c=a[<span class="string">&#x27;m&#x27;</span>];a[<span class="string">&#x27;m&#x27;</span>]=a[<span class="string">&#x27;q&#x27;</span>];a[<span class="string">&#x27;q&#x27;</span>]=a[<span class="string">&#x27;s&#x27;</span>];a[<span class="string">&#x27;s&#x27;</span>]=a[<span class="string">&#x27;g&#x27;</span>];a[<span class="string">&#x27;g&#x27;</span>]=a[<span class="string">&#x27;h&#x27;</span>];a[<span class="string">&#x27;h&#x27;</span>]=a[<span class="string">&#x27;x&#x27;</span>];a[<span class="string">&#x27;x&#x27;</span>]=a[<span class="string">&#x27;v&#x27;</span>];a[<span class="string">&#x27;v&#x27;</span>]=a[<span class="string">&#x27;n&#x27;</span>];a[<span class="string">&#x27;n&#x27;</span>]=c;<span class="keyword">if</span>(<span class="built_in">check</span>())&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span>;&#125;<span class="comment">//4</span>c=a[<span class="string">&#x27;m&#x27;</span>];a[<span class="string">&#x27;m&#x27;</span>]=a[<span class="string">&#x27;q&#x27;</span>];a[<span class="string">&#x27;q&#x27;</span>]=a[<span class="string">&#x27;s&#x27;</span>];a[<span class="string">&#x27;s&#x27;</span>]=a[<span class="string">&#x27;g&#x27;</span>];a[<span class="string">&#x27;g&#x27;</span>]=a[<span class="string">&#x27;h&#x27;</span>];a[<span class="string">&#x27;h&#x27;</span>]=a[<span class="string">&#x27;x&#x27;</span>];a[<span class="string">&#x27;x&#x27;</span>]=a[<span class="string">&#x27;v&#x27;</span>];a[<span class="string">&#x27;v&#x27;</span>]=a[<span class="string">&#x27;n&#x27;</span>];a[<span class="string">&#x27;n&#x27;</span>]=c;c=a[<span class="string">&#x27;m&#x27;</span>];a[<span class="string">&#x27;m&#x27;</span>]=a[<span class="string">&#x27;q&#x27;</span>];a[<span class="string">&#x27;q&#x27;</span>]=a[<span class="string">&#x27;s&#x27;</span>];a[<span class="string">&#x27;s&#x27;</span>]=a[<span class="string">&#x27;g&#x27;</span>];a[<span class="string">&#x27;g&#x27;</span>]=a[<span class="string">&#x27;h&#x27;</span>];a[<span class="string">&#x27;h&#x27;</span>]=a[<span class="string">&#x27;x&#x27;</span>];a[<span class="string">&#x27;x&#x27;</span>]=a[<span class="string">&#x27;v&#x27;</span>];a[<span class="string">&#x27;v&#x27;</span>]=a[<span class="string">&#x27;n&#x27;</span>];a[<span class="string">&#x27;n&#x27;</span>]=c;<span class="comment">//1</span>c=a[<span class="string">&#x27;o&#x27;</span>];a[<span class="string">&#x27;o&#x27;</span>]=a[<span class="string">&#x27;m&#x27;</span>];a[<span class="string">&#x27;m&#x27;</span>]=a[<span class="string">&#x27;k&#x27;</span>];a[<span class="string">&#x27;k&#x27;</span>]=a[<span class="string">&#x27;i&#x27;</span>];a[<span class="string">&#x27;i&#x27;</span>]=a[<span class="string">&#x27;g&#x27;</span>];a[<span class="string">&#x27;g&#x27;</span>]=a[<span class="string">&#x27;e&#x27;</span>];a[<span class="string">&#x27;e&#x27;</span>]=a[<span class="string">&#x27;c&#x27;</span>];a[<span class="string">&#x27;c&#x27;</span>]=a[<span class="string">&#x27;a&#x27;</span>];a[<span class="string">&#x27;a&#x27;</span>]=c;c=a[<span class="string">&#x27;o&#x27;</span>];a[<span class="string">&#x27;o&#x27;</span>]=a[<span class="string">&#x27;m&#x27;</span>];a[<span class="string">&#x27;m&#x27;</span>]=a[<span class="string">&#x27;k&#x27;</span>];a[<span class="string">&#x27;k&#x27;</span>]=a[<span class="string">&#x27;i&#x27;</span>];a[<span class="string">&#x27;i&#x27;</span>]=a[<span class="string">&#x27;g&#x27;</span>];a[<span class="string">&#x27;g&#x27;</span>]=a[<span class="string">&#x27;e&#x27;</span>];a[<span class="string">&#x27;e&#x27;</span>]=a[<span class="string">&#x27;c&#x27;</span>];a[<span class="string">&#x27;c&#x27;</span>]=a[<span class="string">&#x27;a&#x27;</span>];a[<span class="string">&#x27;a&#x27;</span>]=c;<span class="keyword">if</span>(<span class="built_in">check</span>())&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span>;&#125;<span class="comment">//2</span>c=a[<span class="string">&#x27;o&#x27;</span>];a[<span class="string">&#x27;o&#x27;</span>]=a[<span class="string">&#x27;m&#x27;</span>];a[<span class="string">&#x27;m&#x27;</span>]=a[<span class="string">&#x27;k&#x27;</span>];a[<span class="string">&#x27;k&#x27;</span>]=a[<span class="string">&#x27;i&#x27;</span>];a[<span class="string">&#x27;i&#x27;</span>]=a[<span class="string">&#x27;g&#x27;</span>];a[<span class="string">&#x27;g&#x27;</span>]=a[<span class="string">&#x27;e&#x27;</span>];a[<span class="string">&#x27;e&#x27;</span>]=a[<span class="string">&#x27;c&#x27;</span>];a[<span class="string">&#x27;c&#x27;</span>]=a[<span class="string">&#x27;a&#x27;</span>];a[<span class="string">&#x27;a&#x27;</span>]=c;c=a[<span class="string">&#x27;o&#x27;</span>];a[<span class="string">&#x27;o&#x27;</span>]=a[<span class="string">&#x27;m&#x27;</span>];a[<span class="string">&#x27;m&#x27;</span>]=a[<span class="string">&#x27;k&#x27;</span>];a[<span class="string">&#x27;k&#x27;</span>]=a[<span class="string">&#x27;i&#x27;</span>];a[<span class="string">&#x27;i&#x27;</span>]=a[<span class="string">&#x27;g&#x27;</span>];a[<span class="string">&#x27;g&#x27;</span>]=a[<span class="string">&#x27;e&#x27;</span>];a[<span class="string">&#x27;e&#x27;</span>]=a[<span class="string">&#x27;c&#x27;</span>];a[<span class="string">&#x27;c&#x27;</span>]=a[<span class="string">&#x27;a&#x27;</span>];a[<span class="string">&#x27;a&#x27;</span>]=c;<span class="comment">//3</span>c=a[<span class="string">&#x27;o&#x27;</span>];a[<span class="string">&#x27;o&#x27;</span>]=a[<span class="string">&#x27;m&#x27;</span>];a[<span class="string">&#x27;m&#x27;</span>]=a[<span class="string">&#x27;k&#x27;</span>];a[<span class="string">&#x27;k&#x27;</span>]=a[<span class="string">&#x27;i&#x27;</span>];a[<span class="string">&#x27;i&#x27;</span>]=a[<span class="string">&#x27;g&#x27;</span>];a[<span class="string">&#x27;g&#x27;</span>]=a[<span class="string">&#x27;e&#x27;</span>];a[<span class="string">&#x27;e&#x27;</span>]=a[<span class="string">&#x27;c&#x27;</span>];a[<span class="string">&#x27;c&#x27;</span>]=a[<span class="string">&#x27;a&#x27;</span>];a[<span class="string">&#x27;a&#x27;</span>]=c;c=a[<span class="string">&#x27;o&#x27;</span>];a[<span class="string">&#x27;o&#x27;</span>]=a[<span class="string">&#x27;m&#x27;</span>];a[<span class="string">&#x27;m&#x27;</span>]=a[<span class="string">&#x27;k&#x27;</span>];a[<span class="string">&#x27;k&#x27;</span>]=a[<span class="string">&#x27;i&#x27;</span>];a[<span class="string">&#x27;i&#x27;</span>]=a[<span class="string">&#x27;g&#x27;</span>];a[<span class="string">&#x27;g&#x27;</span>]=a[<span class="string">&#x27;e&#x27;</span>];a[<span class="string">&#x27;e&#x27;</span>]=a[<span class="string">&#x27;c&#x27;</span>];a[<span class="string">&#x27;c&#x27;</span>]=a[<span class="string">&#x27;a&#x27;</span>];a[<span class="string">&#x27;a&#x27;</span>]=c;<span class="keyword">if</span>(<span class="built_in">check</span>())&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span>;&#125;<span class="comment">//4</span>c=a[<span class="string">&#x27;o&#x27;</span>];a[<span class="string">&#x27;o&#x27;</span>]=a[<span class="string">&#x27;m&#x27;</span>];a[<span class="string">&#x27;m&#x27;</span>]=a[<span class="string">&#x27;k&#x27;</span>];a[<span class="string">&#x27;k&#x27;</span>]=a[<span class="string">&#x27;i&#x27;</span>];a[<span class="string">&#x27;i&#x27;</span>]=a[<span class="string">&#x27;g&#x27;</span>];a[<span class="string">&#x27;g&#x27;</span>]=a[<span class="string">&#x27;e&#x27;</span>];a[<span class="string">&#x27;e&#x27;</span>]=a[<span class="string">&#x27;c&#x27;</span>];a[<span class="string">&#x27;c&#x27;</span>]=a[<span class="string">&#x27;a&#x27;</span>];a[<span class="string">&#x27;a&#x27;</span>]=c;c=a[<span class="string">&#x27;o&#x27;</span>];a[<span class="string">&#x27;o&#x27;</span>]=a[<span class="string">&#x27;m&#x27;</span>];a[<span class="string">&#x27;m&#x27;</span>]=a[<span class="string">&#x27;k&#x27;</span>];a[<span class="string">&#x27;k&#x27;</span>]=a[<span class="string">&#x27;i&#x27;</span>];a[<span class="string">&#x27;i&#x27;</span>]=a[<span class="string">&#x27;g&#x27;</span>];a[<span class="string">&#x27;g&#x27;</span>]=a[<span class="string">&#x27;e&#x27;</span>];a[<span class="string">&#x27;e&#x27;</span>]=a[<span class="string">&#x27;c&#x27;</span>];a[<span class="string">&#x27;c&#x27;</span>]=a[<span class="string">&#x27;a&#x27;</span>];a[<span class="string">&#x27;a&#x27;</span>]=c;<span class="comment">//1</span>c=a[<span class="string">&#x27;p&#x27;</span>];a[<span class="string">&#x27;p&#x27;</span>]=a[<span class="string">&#x27;n&#x27;</span>];a[<span class="string">&#x27;n&#x27;</span>]=a[<span class="string">&#x27;l&#x27;</span>];a[<span class="string">&#x27;l&#x27;</span>]=a[<span class="string">&#x27;j&#x27;</span>];a[<span class="string">&#x27;j&#x27;</span>]=a[<span class="string">&#x27;h&#x27;</span>];a[<span class="string">&#x27;h&#x27;</span>]=a[<span class="string">&#x27;f&#x27;</span>];a[<span class="string">&#x27;f&#x27;</span>]=a[<span class="string">&#x27;d&#x27;</span>];a[<span class="string">&#x27;d&#x27;</span>]=a[<span class="string">&#x27;b&#x27;</span>];a[<span class="string">&#x27;b&#x27;</span>]=c;c=a[<span class="string">&#x27;p&#x27;</span>];a[<span class="string">&#x27;p&#x27;</span>]=a[<span class="string">&#x27;n&#x27;</span>];a[<span class="string">&#x27;n&#x27;</span>]=a[<span class="string">&#x27;l&#x27;</span>];a[<span class="string">&#x27;l&#x27;</span>]=a[<span class="string">&#x27;j&#x27;</span>];a[<span class="string">&#x27;j&#x27;</span>]=a[<span class="string">&#x27;h&#x27;</span>];a[<span class="string">&#x27;h&#x27;</span>]=a[<span class="string">&#x27;f&#x27;</span>];a[<span class="string">&#x27;f&#x27;</span>]=a[<span class="string">&#x27;d&#x27;</span>];a[<span class="string">&#x27;d&#x27;</span>]=a[<span class="string">&#x27;b&#x27;</span>];a[<span class="string">&#x27;b&#x27;</span>]=c;<span class="keyword">if</span>(<span class="built_in">check</span>())&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span>;&#125;<span class="comment">//2</span>c=a[<span class="string">&#x27;p&#x27;</span>];a[<span class="string">&#x27;p&#x27;</span>]=a[<span class="string">&#x27;n&#x27;</span>];a[<span class="string">&#x27;n&#x27;</span>]=a[<span class="string">&#x27;l&#x27;</span>];a[<span class="string">&#x27;l&#x27;</span>]=a[<span class="string">&#x27;j&#x27;</span>];a[<span class="string">&#x27;j&#x27;</span>]=a[<span class="string">&#x27;h&#x27;</span>];a[<span class="string">&#x27;h&#x27;</span>]=a[<span class="string">&#x27;f&#x27;</span>];a[<span class="string">&#x27;f&#x27;</span>]=a[<span class="string">&#x27;d&#x27;</span>];a[<span class="string">&#x27;d&#x27;</span>]=a[<span class="string">&#x27;b&#x27;</span>];a[<span class="string">&#x27;b&#x27;</span>]=c;c=a[<span class="string">&#x27;p&#x27;</span>];a[<span class="string">&#x27;p&#x27;</span>]=a[<span class="string">&#x27;n&#x27;</span>];a[<span class="string">&#x27;n&#x27;</span>]=a[<span class="string">&#x27;l&#x27;</span>];a[<span class="string">&#x27;l&#x27;</span>]=a[<span class="string">&#x27;j&#x27;</span>];a[<span class="string">&#x27;j&#x27;</span>]=a[<span class="string">&#x27;h&#x27;</span>];a[<span class="string">&#x27;h&#x27;</span>]=a[<span class="string">&#x27;f&#x27;</span>];a[<span class="string">&#x27;f&#x27;</span>]=a[<span class="string">&#x27;d&#x27;</span>];a[<span class="string">&#x27;d&#x27;</span>]=a[<span class="string">&#x27;b&#x27;</span>];a[<span class="string">&#x27;b&#x27;</span>]=c;<span class="comment">//3</span>c=a[<span class="string">&#x27;p&#x27;</span>];a[<span class="string">&#x27;p&#x27;</span>]=a[<span class="string">&#x27;n&#x27;</span>];a[<span class="string">&#x27;n&#x27;</span>]=a[<span class="string">&#x27;l&#x27;</span>];a[<span class="string">&#x27;l&#x27;</span>]=a[<span class="string">&#x27;j&#x27;</span>];a[<span class="string">&#x27;j&#x27;</span>]=a[<span class="string">&#x27;h&#x27;</span>];a[<span class="string">&#x27;h&#x27;</span>]=a[<span class="string">&#x27;f&#x27;</span>];a[<span class="string">&#x27;f&#x27;</span>]=a[<span class="string">&#x27;d&#x27;</span>];a[<span class="string">&#x27;d&#x27;</span>]=a[<span class="string">&#x27;b&#x27;</span>];a[<span class="string">&#x27;b&#x27;</span>]=c;c=a[<span class="string">&#x27;p&#x27;</span>];a[<span class="string">&#x27;p&#x27;</span>]=a[<span class="string">&#x27;n&#x27;</span>];a[<span class="string">&#x27;n&#x27;</span>]=a[<span class="string">&#x27;l&#x27;</span>];a[<span class="string">&#x27;l&#x27;</span>]=a[<span class="string">&#x27;j&#x27;</span>];a[<span class="string">&#x27;j&#x27;</span>]=a[<span class="string">&#x27;h&#x27;</span>];a[<span class="string">&#x27;h&#x27;</span>]=a[<span class="string">&#x27;f&#x27;</span>];a[<span class="string">&#x27;f&#x27;</span>]=a[<span class="string">&#x27;d&#x27;</span>];a[<span class="string">&#x27;d&#x27;</span>]=a[<span class="string">&#x27;b&#x27;</span>];a[<span class="string">&#x27;b&#x27;</span>]=c;<span class="keyword">if</span>(<span class="built_in">check</span>())&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span>;&#125;<span class="comment">//4</span>c=a[<span class="string">&#x27;p&#x27;</span>];a[<span class="string">&#x27;p&#x27;</span>]=a[<span class="string">&#x27;n&#x27;</span>];a[<span class="string">&#x27;n&#x27;</span>]=a[<span class="string">&#x27;l&#x27;</span>];a[<span class="string">&#x27;l&#x27;</span>]=a[<span class="string">&#x27;j&#x27;</span>];a[<span class="string">&#x27;j&#x27;</span>]=a[<span class="string">&#x27;h&#x27;</span>];a[<span class="string">&#x27;h&#x27;</span>]=a[<span class="string">&#x27;f&#x27;</span>];a[<span class="string">&#x27;f&#x27;</span>]=a[<span class="string">&#x27;d&#x27;</span>];a[<span class="string">&#x27;d&#x27;</span>]=a[<span class="string">&#x27;b&#x27;</span>];a[<span class="string">&#x27;b&#x27;</span>]=c;c=a[<span class="string">&#x27;p&#x27;</span>];a[<span class="string">&#x27;p&#x27;</span>]=a[<span class="string">&#x27;n&#x27;</span>];a[<span class="string">&#x27;n&#x27;</span>]=a[<span class="string">&#x27;l&#x27;</span>];a[<span class="string">&#x27;l&#x27;</span>]=a[<span class="string">&#x27;j&#x27;</span>];a[<span class="string">&#x27;j&#x27;</span>]=a[<span class="string">&#x27;h&#x27;</span>];a[<span class="string">&#x27;h&#x27;</span>]=a[<span class="string">&#x27;f&#x27;</span>];a[<span class="string">&#x27;f&#x27;</span>]=a[<span class="string">&#x27;d&#x27;</span>];a[<span class="string">&#x27;d&#x27;</span>]=a[<span class="string">&#x27;b&#x27;</span>];a[<span class="string">&#x27;b&#x27;</span>]=c;<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;cube.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;cube.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);cin&gt;&gt;t;<span class="keyword">while</span>(t--)&#123;<span class="built_in">solve</span>();&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="defly"><a href="#defly" class="headerlink" title="defly"></a>defly</h4><p>首先，长宽高肯定自己能穿过一些，但是会有重复的。</p><p>重复的有什么呢？两两配对 GCD 之和即为个数。</p><p>但这样如果有三个长宽高都有的块就多减了，所以再加上三者 GCD。</p><p>答案即为 $L+W+H-\gcd(L,W)-\gcd(L,H)-\gcd(W,H)+\gcd(L,W,H)$。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;defly.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;defly.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);<span class="type">long</span> <span class="type">long</span> l,w,h;cin&gt;&gt;l&gt;&gt;w&gt;&gt;h;cout&lt;&lt;l+w+h-__gcd(l,w)-__gcd(w,h)-__gcd(l,h)+__gcd(__gcd(l,w),h)&lt;&lt;endl; <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="florr"><a href="#florr" class="headerlink" title="florr"></a>florr</h4><p>先咕着。</p><pre><code class="highlight cpp"></code></pre><h4 id="generals"><a href="#generals" class="headerlink" title="generals"></a>generals</h4><p>so lazy</p><p>就贴个<a href="https://www.luogu.com.cn/paste/58yb3rup">剪切板</a>吧。</p><p><del>我自己也说不清</del></p><pre><code class="highlight inform7">## 题解### 递推过程- 每次可以选择向上走,或者左拐一段再向上,或者右拐一段再向上: 显然地,左拐与右拐等价- $a_i$ 为可以走 $i$ 步的答案:$a_0=1,a_1=3,a_2=7,...$- 考虑啥时候向上拐:$a_i=a_&#123;i-1&#125;+2\times(a_&#123;i-2&#125;+...+a_0+1)$对上式解释: 可以直接向上 $a_&#123;i-1&#125;$ ,或向左(右)一步再向上 $2\times a_&#123;i-2&#125;$ ... 或者最后一步上拐 $2\times a_0$ ,或者不上拐(一直直走) $2$- 令 $S_i=\sum\limits_&#123;j=0&#125;^ia_i$ , 有:$a_i=a_&#123;i-1&#125;+2\times S_&#123;i-2&#125;+2$- 做如下变形:$S_&#123;i-2&#125;=\dfrac&#123;a_i-a_&#123;i-1&#125;-2&#125;&#123;2&#125; ......①$$S_&#123;i-1&#125;=\dfrac&#123;a_&#123;i+1&#125;-a_i-2&#125;&#123;2&#125; ......②$用 ②减① ,有:$\dfrac&#123;a_&#123;i+1&#125;-2\times a_i+a_&#123;i-1&#125;&#125;&#123;2&#125;=a_&#123;i-1&#125;$于是: $a_&#123;i+1&#125;=2\times a_i+a_&#123;i-1&#125;$所以: $a_i=2\times a_&#123;i-1&#125;+a_&#123;i-2&#125;$### 矩阵快速幂不会的建议学习矩阵快速幂以及斐波那契的 $O(\log n)$ 算法$\begin&#123;bmatrix&#125;a_i&amp;a_&#123;i-1&#125;\end&#123;bmatrix&#125;=\begin&#123;bmatrix&#125;a_&#123;i-1&#125;&amp;a_&#123;i-2&#125;\end&#123;bmatrix&#125;\begin&#123;bmatrix&#125;2&amp;1\\1 &amp;0\\\end&#123;bmatrix&#125;$### 注意事项1. 进行矩阵快速幂时, $n$ 较小需特判(避免某些错误比如负数次方)2. 记得取模,开 `long long`### 奉上代码```#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;/*- a_1=3- a_2=7- a_3=17<span class="comment">[a_i,a_&#123;i-1&#125;]</span>=<span class="comment">[a_&#123;i-1&#125;,a_&#123;i-2&#125;]</span>*<span class="comment">[2,1]</span>                                <span class="comment">[1,0]</span>*/const long long md=1000000007;struct Matrix&#123;long long a<span class="comment">[2]</span><span class="comment">[2]</span>;&#125;;Matrix operator *(const Matrix &amp;as,const Matrix &amp;bs)//Matrix Mul&#123;Matrix cs;cs.a<span class="comment">[0]</span><span class="comment">[0]</span>=(as.a<span class="comment">[0]</span><span class="comment">[0]</span>*bs.a<span class="comment">[0]</span><span class="comment">[0]</span>+as.a<span class="comment">[0]</span><span class="comment">[1]</span>*bs.a<span class="comment">[1]</span><span class="comment">[0]</span>)%md;cs.a<span class="comment">[0]</span><span class="comment">[1]</span>=(as.a<span class="comment">[0]</span><span class="comment">[0]</span>*bs.a<span class="comment">[0]</span><span class="comment">[1]</span>+as.a<span class="comment">[0]</span><span class="comment">[1]</span>*bs.a<span class="comment">[1]</span><span class="comment">[1]</span>)%md;cs.a<span class="comment">[1]</span><span class="comment">[0]</span>=(as.a<span class="comment">[1]</span><span class="comment">[0]</span>*bs.a<span class="comment">[0]</span><span class="comment">[0]</span>+as.a<span class="comment">[1]</span><span class="comment">[1]</span>*bs.a<span class="comment">[1]</span><span class="comment">[0]</span>)%md;cs.a<span class="comment">[1]</span><span class="comment">[1]</span>=(as.a<span class="comment">[1]</span><span class="comment">[0]</span>*bs.a<span class="comment">[0]</span><span class="comment">[1]</span>+as.a<span class="comment">[1]</span><span class="comment">[1]</span>*bs.a<span class="comment">[1]</span><span class="comment">[1]</span>)%md;return cs;&#125;Matrix qpw(Matrix as,long long bs)//Matrix Pow&#123;Matrix rt;rt.a<span class="comment">[0]</span><span class="comment">[0]</span>=1; rt.a<span class="comment">[0]</span><span class="comment">[1]</span>=0;rt.a<span class="comment">[1]</span><span class="comment">[0]</span>=0; rt.a<span class="comment">[1]</span><span class="comment">[1]</span>=1;while(bs)&#123;if(bs&amp;1)rt=rt*as;as=as*as;bs&gt;&gt;=1;&#125;return rt;&#125;long long f(long long x)//Calc&#123;if(x==0) return 1;if(x==1) return 3;if(x==2) return 7;Matrix rt;rt.a<span class="comment">[0]</span><span class="comment">[0]</span>=2; rt.a<span class="comment">[0]</span><span class="comment">[1]</span>=1;rt.a<span class="comment">[1]</span><span class="comment">[0]</span>=1; rt.a<span class="comment">[1]</span><span class="comment">[1]</span>=0;rt=qpw(rt,x-2);return (7*rt.a<span class="comment">[0]</span><span class="comment">[0]</span>+3*rt.a<span class="comment">[1]</span><span class="comment">[0]</span>)%md;&#125;int T;int main()&#123;//scanf(<span class="string">&quot;%d&quot;</span>,&amp;T);T=1;while(T--)&#123;long long n;scanf(<span class="string">&quot;%lld&quot;</span>,&amp;n);printf(<span class="string">&quot;%lld\n&quot;</span>,f(n));&#125;return 0;&#125;</code></pre><p>70pts</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>;<span class="type">long</span> <span class="type">long</span> f[<span class="number">10000020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;generals.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;generals.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);f[<span class="number">0</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="number">3</span>;<span class="type">long</span> <span class="type">long</span> n;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;f[i]=<span class="number">2</span>*f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>];f[i]%=mod;&#125;cout&lt;&lt;f[n]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20220819 | CSP2022 考前模拟赛 做题笔记</title>
      <link href="/archives/20220819_mock/"/>
      <url>/archives/20220819_mock/</url>
      
        <content type="html"><![CDATA[<h4 id="乒乓比赛"><a href="#乒乓比赛" class="headerlink" title="乒乓比赛"></a>乒乓比赛</h4><p>考虑到最好的方法，是两人一起反向移动（即 A 去贴贴 B，B 去贴贴 A）。</p><p>但中间桌子数为奇数时无法贴贴，考虑改变奇偶性。</p><p>所以肯定有一人到最前或最后，然后再反向移动去贴贴。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span><span class="meta">#<span class="keyword">define</span> S(x) scanf(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><span class="meta">#<span class="keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;x&lt;&lt;endl&lt;&lt;<span class="string">&quot;LINE:&quot;</span>__LINE__&lt;&lt;endl&lt;&lt;<span class="string">&quot;FUNCTION:&quot;</span>&lt;&lt;__FUNCTION__&lt;&lt;endl</span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;match.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;match.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);<span class="type">long</span> <span class="type">long</span> n,a,b;<span class="built_in">S</span>(n);<span class="built_in">S</span>(a);<span class="built_in">S</span>(b);<span class="keyword">if</span>((b-a)%<span class="number">2</span>==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(b-a)/<span class="number">2</span>);<span class="keyword">else</span> &#123;<span class="type">long</span> <span class="type">long</span> x=n-b<span class="number">+1</span>,y=a;<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">min</span>(x+(n-(a+x))/<span class="number">2</span>,y+(b-y-(<span class="number">1</span>))/<span class="number">2</span>));&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="麻将"><a href="#麻将" class="headerlink" title="麻将"></a>麻将</h4><p>一个码量不算太大的模拟。</p><p>依次判断即可。</p><ul><li><p>国士无双十三面</p><p>查看 $1$ 万、$9$ 万、$1$ 条、$9$ 条、$1$ 筒、$9$ 筒、东、南、西、北、中、发、白是否均出现且有一张出现次数 $\geq 2$。</p></li><li><p>七对子</p><p>这个最简单，扫一遍看看是否恰好出现两次。</p></li><li><p>九莲宝灯</p><p>我&amp;%#￥你*@#&amp;的，同色指字母相同哪里说了！！！</p><p>好，身心舒畅了。</p><p>先数数字，然后看是不是都是一样的字母即可。</p></li></ul><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span><span class="meta">#<span class="keyword">define</span> S(x) scanf(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><span class="meta">#<span class="keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;x&lt;&lt;endl&lt;&lt;<span class="string">&quot;LINE:&quot;</span>__LINE__&lt;&lt;endl&lt;&lt;<span class="string">&quot;FUNCTION:&quot;</span>&lt;&lt;__FUNCTION__&lt;&lt;endl</span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> n=<span class="number">14</span>;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;string st[<span class="number">20</span>];map&lt;string,<span class="type">int</span>&gt;mp;mp.<span class="built_in">clear</span>();<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;st[i];mp[st[i]]++;&#125;<span class="comment">//Thirteen</span><span class="keyword">if</span>(mp[<span class="string">&quot;1m&quot;</span>]&gt;=<span class="number">1</span>&amp;&amp;mp[<span class="string">&quot;9m&quot;</span>]&gt;=<span class="number">1</span>&amp;&amp;   mp[<span class="string">&quot;1s&quot;</span>]&gt;=<span class="number">1</span>&amp;&amp;mp[<span class="string">&quot;9s&quot;</span>]&gt;=<span class="number">1</span>&amp;&amp;   mp[<span class="string">&quot;1p&quot;</span>]&gt;=<span class="number">1</span>&amp;&amp;mp[<span class="string">&quot;9p&quot;</span>]&gt;=<span class="number">1</span>&amp;&amp;   mp[<span class="string">&quot;E&quot;</span>] &gt;=<span class="number">1</span>&amp;&amp;mp[<span class="string">&quot;S&quot;</span>] &gt;=<span class="number">1</span>&amp;&amp;mp[<span class="string">&quot;W&quot;</span>] &gt;=<span class="number">1</span>&amp;&amp;mp[<span class="string">&quot;N&quot;</span>] &gt;=<span class="number">1</span>&amp;&amp;   mp[<span class="string">&quot;B&quot;</span>] &gt;=<span class="number">1</span>&amp;&amp;mp[<span class="string">&quot;F&quot;</span>] &gt;=<span class="number">1</span>&amp;&amp;mp[<span class="string">&quot;Z&quot;</span>] &gt;=<span class="number">1</span>&amp;&amp;(   mp[<span class="string">&quot;1m&quot;</span>]&gt;=<span class="number">2</span>||mp[<span class="string">&quot;9m&quot;</span>]&gt;=<span class="number">2</span>||   mp[<span class="string">&quot;1s&quot;</span>]&gt;=<span class="number">2</span>||mp[<span class="string">&quot;9s&quot;</span>]&gt;=<span class="number">2</span>||   mp[<span class="string">&quot;1p&quot;</span>]&gt;=<span class="number">2</span>||mp[<span class="string">&quot;9p&quot;</span>]&gt;=<span class="number">2</span>||   mp[<span class="string">&quot;E&quot;</span>] &gt;=<span class="number">2</span>||mp[<span class="string">&quot;S&quot;</span>] &gt;=<span class="number">2</span>||mp[<span class="string">&quot;W&quot;</span>] &gt;=<span class="number">2</span>||mp[<span class="string">&quot;N&quot;</span>] &gt;=<span class="number">2</span>||   mp[<span class="string">&quot;B&quot;</span>] &gt;=<span class="number">2</span>||mp[<span class="string">&quot;F&quot;</span>] &gt;=<span class="number">2</span>||mp[<span class="string">&quot;Z&quot;</span>] &gt;=<span class="number">2</span>))&#123;<span class="built_in">puts</span>(<span class="string">&quot;Thirteen&quot;</span>);<span class="keyword">return</span>;&#125;<span class="comment">//Seven</span><span class="type">bool</span> flag=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(mp[st[i]]!=<span class="number">2</span>)flag=<span class="number">0</span>;&#125;<span class="keyword">if</span>(flag)&#123;<span class="built_in">puts</span>(<span class="string">&quot;Seven&quot;</span>);<span class="keyword">return</span>;&#125;<span class="comment">//Nine</span><span class="type">int</span> m=<span class="number">0</span>,s=<span class="number">0</span>,p=<span class="number">0</span>;<span class="type">bool</span> fm=<span class="number">1</span>,fs=<span class="number">1</span>,fp=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;<span class="keyword">if</span>(i==<span class="number">1</span>||i==<span class="number">9</span>)&#123;<span class="keyword">if</span>(mp[<span class="built_in">to_string</span>(i)+<span class="string">&quot;m&quot;</span>])m++;<span class="keyword">if</span>(mp[<span class="built_in">to_string</span>(i)+<span class="string">&quot;s&quot;</span>])p++;<span class="keyword">if</span>(mp[<span class="built_in">to_string</span>(i)+<span class="string">&quot;p&quot;</span>])s++;<span class="keyword">if</span>(mp[<span class="built_in">to_string</span>(i)+<span class="string">&quot;m&quot;</span>]&lt;<span class="number">3</span>)fm=<span class="number">0</span>;<span class="keyword">if</span>(mp[<span class="built_in">to_string</span>(i)+<span class="string">&quot;s&quot;</span>]&lt;<span class="number">3</span>)fp=<span class="number">0</span>;<span class="keyword">if</span>(mp[<span class="built_in">to_string</span>(i)+<span class="string">&quot;p&quot;</span>]&lt;<span class="number">3</span>)fs=<span class="number">0</span>;&#125;<span class="keyword">else</span>&#123;<span class="keyword">if</span>(mp[<span class="built_in">to_string</span>(i)+<span class="string">&quot;m&quot;</span>])m++;<span class="keyword">if</span>(mp[<span class="built_in">to_string</span>(i)+<span class="string">&quot;s&quot;</span>])p++;<span class="keyword">if</span>(mp[<span class="built_in">to_string</span>(i)+<span class="string">&quot;p&quot;</span>])s++;<span class="keyword">if</span>(mp[<span class="built_in">to_string</span>(i)+<span class="string">&quot;m&quot;</span>]&lt;<span class="number">1</span>)fm=<span class="number">0</span>;<span class="keyword">if</span>(mp[<span class="built_in">to_string</span>(i)+<span class="string">&quot;s&quot;</span>]&lt;<span class="number">1</span>)fp=<span class="number">0</span>;<span class="keyword">if</span>(mp[<span class="built_in">to_string</span>(i)+<span class="string">&quot;p&quot;</span>]&lt;<span class="number">1</span>)fs=<span class="number">0</span>;&#125;&#125;<span class="keyword">if</span>(mp[<span class="string">&quot;E&quot;</span>]&lt;<span class="number">1</span>&amp;&amp;mp[<span class="string">&quot;S&quot;</span>]&lt;<span class="number">1</span>&amp;&amp;mp[<span class="string">&quot;W&quot;</span>]&lt;<span class="number">1</span>&amp;&amp;mp[<span class="string">&quot;N&quot;</span>]&lt;<span class="number">1</span>&amp;&amp; mp[<span class="string">&quot;B&quot;</span>]&lt;<span class="number">1</span>&amp;&amp;mp[<span class="string">&quot;F&quot;</span>]&lt;<span class="number">1</span>&amp;&amp;mp[<span class="string">&quot;Z&quot;</span>]&lt;<span class="number">1</span>&amp;&amp;(m==<span class="number">9</span>&amp;&amp;!p&amp;&amp;!s&amp;&amp;fm&amp;&amp;!fp&amp;&amp;!fs|| !m&amp;&amp;p==<span class="number">9</span>&amp;&amp;!s&amp;&amp;!fm&amp;&amp;fp&amp;&amp;!fs|| !m&amp;&amp;!p&amp;&amp;s==<span class="number">9</span>&amp;&amp;!fm&amp;&amp;!fp&amp;&amp;fs))<span class="built_in">puts</span>(<span class="string">&quot;Nine&quot;</span>);<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;I don&#x27;t know.&quot;</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;majsoul.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;majsoul.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);<span class="type">int</span> t;<span class="built_in">S</span>(t);<span class="keyword">while</span>(t--)&#123;<span class="built_in">solve</span>();&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="三角田地"><a href="#三角田地" class="headerlink" title="三角田地"></a>三角田地</h4><p>先咕着</p><pre><code class="highlight cpp"></code></pre><h4 id="跳芭蕾"><a href="#跳芭蕾" class="headerlink" title="跳芭蕾"></a>跳芭蕾</h4><p>先咕着</p><pre><code class="highlight cpp"></code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20220810 | CSP2021-J</title>
      <link href="/archives/20220810_mock/"/>
      <url>/archives/20220810_mock/</url>
      
        <content type="html"><![CDATA[<h4 id="分糖果"><a href="#分糖果" class="headerlink" title="分糖果"></a>分糖果</h4><p>分类讨论。</p><p>讨论一下三种情况。</p><p>不细说了，很简单，送分。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;candy.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;candy.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);<span class="type">int</span> n,l,r;cin&gt;&gt;n&gt;&gt;l&gt;&gt;r;<span class="keyword">if</span>(l%n&lt;=r%n)&#123;<span class="keyword">if</span>(r-l&lt;n)&#123;cout&lt;&lt;r%n&lt;&lt;endl;&#125;<span class="keyword">else</span>&#123;cout&lt;&lt;n<span class="number">-1</span>&lt;&lt;endl;&#125;&#125;<span class="keyword">else</span> &#123;cout&lt;&lt;n<span class="number">-1</span>&lt;&lt;endl;&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>暴力想法（大约 $70\ pts$）</p><p>对于每次操作，去找一遍大小关系 $\mathcal O(n)$ 得到位置。</p><p>满分想法（$100\ pts$）</p><p>考虑到 $1$ 操作很少，只有 $5000$，那么对每个一操作，$\mathcal  O(n)$ 修改数字的位置。数字位置只要看和当前要更改的数字比一下，加一减一即可。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">8020</span>];<span class="type">int</span> b[<span class="number">8020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;sort.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;sort.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);<span class="type">int</span> n,q;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;b[i]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;<span class="keyword">if</span>(a[j]&lt;=a[i])b[i]++;&#125;<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)&#123;<span class="keyword">if</span>(a[j]&lt;a[i])b[i]++;&#125;&#125; <span class="keyword">while</span>(q--)&#123;<span class="type">int</span> op;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;<span class="type">int</span> x,v;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;v);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;x;i++)&#123;<span class="keyword">if</span>(a[i]&lt;=a[x]&amp;&amp;v&lt;a[i])&#123;b[i]++;b[x]--;&#125;<span class="keyword">if</span>(a[i]&gt;a[x]&amp;&amp;v&gt;=a[i])&#123;b[i]--;b[x]++;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=x<span class="number">+1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(a[i]&lt;a[x]&amp;&amp;v&lt;=a[i])&#123;b[i]++;b[x]--;&#125;<span class="keyword">if</span>(a[i]&gt;=a[x]&amp;&amp;v&gt;a[i])&#123;b[i]--;b[x]++;&#125;&#125;a[x]=v;&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;<span class="type">int</span> x,ans=<span class="number">1</span>;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b[x]);&#125;&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h4><p>模拟题。</p><p>按题意先处理字符串即可。</p><p>处理之后判断是否合法。</p><p>合法再分两种情况：</p><ul><li><p>服务机</p><ul><li><p>有同 ip 的服务机了</p><p><code>FAIL</code></p></li><li><p>没有<br><code>OK</code>，并且自己占位置。</p></li></ul></li><li><p>客户机</p><ul><li><p>没有同 ip 的服务机</p><p><code>FAIL</code></p></li><li><p>有<br>输出服务机编号。</p></li></ul></li></ul><p>之后，我们只需要考虑怎么把字符串类型映射到一个数字（服务机编号）上。</p><p>诶，map 的翻译就叫映射。</p><p>你，懂了吗？</p><p><del>不懂评论或百度，谢谢</del></p><p>再说几个细节：</p><ol><li>特判前导零</li><li>单独的零不算前导零</li><li>可能 ip 地址分割数字的字符不一定是按 <code>. . . . :</code> 排。</li></ol><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">s_to_i</span><span class="params">(string s)</span></span><span class="function"></span>&#123;<span class="type">int</span> ret=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;ret=ret*<span class="number">10</span>+(s[i]-<span class="string">&#x27;0&#x27;</span>);&#125;<span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">bool</span> <span class="title">all_digit</span><span class="params">(string s)</span></span><span class="function"></span>&#123;<span class="type">bool</span> ret=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;<span class="keyword">if</span>(!<span class="built_in">isdigit</span>(s[i]))ret=<span class="number">0</span>;&#125;<span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string s)</span></span><span class="function"></span>&#123;<span class="type">int</span> i=<span class="number">0</span>;string a,b,c,d,e;a=b=c=d=e=<span class="string">&quot;&quot;</span>;<span class="keyword">for</span>(;i&lt;s.<span class="built_in">size</span>();i++)&#123;<span class="keyword">if</span>(s[i]==<span class="string">&#x27;.&#x27;</span>)&#123;i++;<span class="keyword">break</span>;&#125;a+=s[i];&#125;<span class="keyword">for</span>(;i&lt;s.<span class="built_in">size</span>();i++)&#123;<span class="keyword">if</span>(s[i]==<span class="string">&#x27;.&#x27;</span>)&#123;i++;<span class="keyword">break</span>;&#125;b+=s[i];&#125;<span class="keyword">for</span>(;i&lt;s.<span class="built_in">size</span>();i++)&#123;<span class="keyword">if</span>(s[i]==<span class="string">&#x27;.&#x27;</span>)&#123;i++;<span class="keyword">break</span>;&#125;c+=s[i];&#125;<span class="keyword">for</span>(;i&lt;s.<span class="built_in">size</span>();i++)&#123;<span class="keyword">if</span>(s[i]==<span class="string">&#x27;:&#x27;</span>)&#123;i++;<span class="keyword">break</span>;&#125;d+=s[i];&#125;<span class="keyword">for</span>(;i&lt;s.<span class="built_in">size</span>();i++)&#123;e+=s[i];&#125;<span class="keyword">if</span>(a!=<span class="string">&quot;&quot;</span>&amp;&amp;b!=<span class="string">&quot;&quot;</span>&amp;&amp;c!=<span class="string">&quot;&quot;</span>&amp;&amp;d!=<span class="string">&quot;&quot;</span>&amp;&amp;e!=<span class="string">&quot;&quot;</span>)&#123;<span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;a!=<span class="string">&quot;0&quot;</span>||b[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;b!=<span class="string">&quot;0&quot;</span>||c[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;c!=<span class="string">&quot;0&quot;</span>||d[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;d!=<span class="string">&quot;0&quot;</span>||e[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;e!=<span class="string">&quot;0&quot;</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="keyword">if</span>(<span class="built_in">all_digit</span>(a)&amp;&amp;<span class="built_in">all_digit</span>(b)&amp;&amp;<span class="built_in">all_digit</span>(c)&amp;&amp;<span class="built_in">all_digit</span>(d)&amp;&amp;<span class="built_in">all_digit</span>(e))&#123;<span class="keyword">if</span>(a.<span class="built_in">size</span>()&lt;=<span class="number">3</span>&amp;&amp;b.<span class="built_in">size</span>()&lt;=<span class="number">3</span>&amp;&amp;c.<span class="built_in">size</span>()&lt;=<span class="number">3</span>&amp;&amp;d.<span class="built_in">size</span>()&lt;=<span class="number">3</span>&amp;&amp;e.<span class="built_in">size</span>()&lt;=<span class="number">5</span>)&#123;<span class="type">int</span> aa=<span class="built_in">s_to_i</span>(a),bb=<span class="built_in">s_to_i</span>(b),cc=<span class="built_in">s_to_i</span>(c),dd=<span class="built_in">s_to_i</span>(d),ee=<span class="built_in">s_to_i</span>(e);<span class="keyword">if</span>(<span class="number">0</span>&lt;=aa&amp;&amp;aa&lt;=<span class="number">255</span> &amp;&amp; <span class="number">0</span>&lt;=bb&amp;&amp;bb&lt;=<span class="number">255</span> &amp;&amp; <span class="number">0</span>&lt;=cc&amp;&amp;cc&lt;=<span class="number">255</span> &amp;&amp; <span class="number">0</span>&lt;=dd&amp;&amp;dd&lt;=<span class="number">255</span> &amp;&amp; <span class="number">0</span>&lt;=ee&amp;&amp;ee&lt;=<span class="number">65535</span>)&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;map&lt;string,<span class="type">int</span>&gt;m;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;network.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;network.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);<span class="type">int</span> n;cin&gt;&gt;n;string s,t;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;s&gt;&gt;t;<span class="keyword">if</span>(!<span class="built_in">check</span>(t))&#123;<span class="built_in">puts</span>(<span class="string">&quot;ERR&quot;</span>);<span class="keyword">continue</span>; &#125;<span class="keyword">if</span>(s==<span class="string">&quot;Server&quot;</span>)&#123;<span class="keyword">if</span>(m[t]!=<span class="number">0</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;FAIL&quot;</span>);&#125;<span class="keyword">else</span>&#123;m[t]=i;<span class="built_in">puts</span>(<span class="string">&quot;OK&quot;</span>);&#125;&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">&quot;Client&quot;</span>)&#123;<span class="keyword">if</span>(m[t]==<span class="number">0</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;FAIL&quot;</span>);&#125;<span class="keyword">else</span>&#123;cout&lt;&lt;m[t]&lt;&lt;endl;&#125;&#125;&#125; <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="小熊的果篮"><a href="#小熊的果篮" class="headerlink" title="小熊的果篮"></a>小熊的果篮</h4><p>先咕着</p><pre><code class="highlight cpp">害嗨嗨</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20220809 | CSP2022 考前模拟赛 做题笔记</title>
      <link href="/archives/20220809_mock/"/>
      <url>/archives/20220809_mock/</url>
      
        <content type="html"><![CDATA[<h4 id="神秘能量"><a href="#神秘能量" class="headerlink" title="神秘能量"></a>神秘能量</h4><p>原理在于，对于自然数 $i$，在 $n$ 以内，一定有 $\left\lfloor\frac{n}{i}\right\rfloor$ 个数字是 $i$ 的倍数。</p><p>很好解释，$i$ 的倍数 $i$ 个一循环。</p><p>然后容斥，$[l,r]$ 的答案是 $[1,r]-[1,l-1]$。</p><p>做完可以做一下<a href="https://www.luogu.com.cn/problem/P1403">洛谷 P1403</a>。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;power.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;power.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);<span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;<span class="type">int</span> l,r;cin&gt;&gt;l&gt;&gt;r;l--;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;ans+=(r/i-l/i);&#125;cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="城市联盟"><a href="#城市联盟" class="headerlink" title="城市联盟"></a>城市联盟</h4><p>我们考虑贪心，只要不满足条件的，直接踢出去，同时把其他和它有联系的城市也删减一个边。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">bool</span> f[<span class="number">520</span>];set&lt;<span class="type">int</span>&gt;a[<span class="number">520</span>];<span class="type">int</span> n,m,x,y,sum;<span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(f[i])<span class="keyword">continue</span>;<span class="keyword">if</span>(a[i].<span class="built_in">size</span>()&gt;=x&amp;&amp;sum-y&gt;a[i].<span class="built_in">size</span>())&#123;&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;city.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;city.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;sum=n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="type">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;a[u].<span class="built_in">insert</span>(v);a[v].<span class="built_in">insert</span>(u);&#125;<span class="keyword">while</span>(!<span class="built_in">ok</span>())&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(f[i])<span class="keyword">continue</span>;<span class="keyword">if</span>(a[i].<span class="built_in">size</span>()&gt;=x&amp;&amp;sum-y&gt;a[i].<span class="built_in">size</span>())&#123;&#125;<span class="keyword">else</span>&#123;f[i]=<span class="number">1</span>;sum--;<span class="keyword">for</span>(<span class="type">int</span> j:a[i])&#123;a[j].<span class="built_in">erase</span>(i);&#125;&#125;&#125;&#125;cout&lt;&lt;sum&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="花园计划"><a href="#花园计划" class="headerlink" title="花园计划"></a>花园计划</h4><p>01背包改版，可以选择 取第一种\取第二种\不取</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">220</span>];<span class="type">int</span> b[<span class="number">220</span>];<span class="type">int</span> c[<span class="number">220</span>];<span class="type">int</span> d[<span class="number">220</span>];<span class="type">int</span> f1[<span class="number">2000020</span>];<span class="type">int</span> f2[<span class="number">2000020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;flower.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;flower.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);<span class="type">int</span> n,m,s;cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i]&gt;&gt;d[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">bool</span> flag=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=b[i];j--)&#123;f1[j]=<span class="built_in">max</span>(f1[j],f1[j-b[i]]+a[i]);&#125;<span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=d[i];j--)&#123;f2[j]=<span class="built_in">max</span>(f2[j],f2[j-d[i]]+c[i]);&#125;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)f1[j]=f2[j]=<span class="built_in">max</span>(f1[j],f2[j]);&#125;cout&lt;&lt;f1[m]+s&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="爬塔游戏"><a href="#爬塔游戏" class="headerlink" title="爬塔游戏"></a>爬塔游戏</h4><p>一个 Floyd。</p><p>先找出直接到的，然后再看一下有没有跳跃能更快的，最后做一遍最短路找最短时间。</p><p>建图注意，大楼两边互建，跳的时候只能往一边建。</p><p>注意很多开根号啥的，很烦。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="meta">#<span class="keyword">define</span> xy x[i],y[i],x[j],y[j]</span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">double</span> f[<span class="number">120</span>][<span class="number">120</span>];<span class="type">int</span> x[<span class="number">120</span>];<span class="type">int</span> y[<span class="number">120</span>];<span class="type">int</span> u[<span class="number">120</span>];<span class="type">int</span> n,v;<span class="function"><span class="type">double</span> <span class="title">tower_dis</span><span class="params">(<span class="type">int</span> x_1,<span class="type">int</span> y_1,<span class="type">int</span> x_2,<span class="type">int</span> y_2)</span></span><span class="function"></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="number">1.0</span>*(x_1-x_2)*(x_1-x_2)<span class="number">+1.0</span>*(y_1-y_2)*(y_1-y_2));&#125;<span class="function"><span class="type">double</span> <span class="title">tower_time</span><span class="params">(<span class="type">int</span> x_1,<span class="type">int</span> y_1,<span class="type">int</span> x_2,<span class="type">int</span> y_2)</span></span><span class="function"></span>&#123;<span class="keyword">return</span> <span class="built_in">tower_dis</span>(x_1,y_1,x_2,y_2)/v;&#125;<span class="function"><span class="type">bool</span> <span class="title">can_jump</span><span class="params">(<span class="type">int</span> x_1,<span class="type">int</span> y_1,<span class="type">int</span> x_2,<span class="type">int</span> y_2)</span></span><span class="function"></span>&#123;<span class="keyword">return</span> (x_1==x_2)&amp;&amp;(y_1&gt;y_2);&#125;<span class="function"><span class="type">double</span> <span class="title">jump_time</span><span class="params">(<span class="type">int</span> y_1,<span class="type">int</span> y_2)</span></span><span class="function"></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>((y_1-y_2)*<span class="number">2.0</span>/<span class="number">10.0</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;jump.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;jump.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">120</span>;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">120</span>;j++)&#123;f[i<span class="number">-1</span>][j<span class="number">-1</span>]=<span class="number">1e9</span>;&#125;&#125;cin&gt;&gt;n&gt;&gt;v;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;x[i]&gt;&gt;y[i]&gt;&gt;u[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(u[i]!=<span class="number">0</span>)&#123;<span class="type">int</span> j=u[i];f[i][j]=<span class="built_in">min</span>(f[i][j],<span class="built_in">tower_time</span>(xy));f[j][i]=<span class="built_in">min</span>(f[j][i],<span class="built_in">tower_time</span>(xy));&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="keyword">if</span>(<span class="built_in">can_jump</span>(xy))&#123;f[i][j]=<span class="built_in">min</span>(f[i][j],<span class="built_in">jump_time</span>(y[i],y[j]));&#125;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;f[i][j]=min=(f[i][j],f[i][k]+f[k][j]);&#125;&#125;&#125;cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">2</span>)&lt;&lt;f[<span class="number">1</span>][n]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20220808 | CSP2022 考前模拟赛 做题笔记</title>
      <link href="/archives/20220808_mock/"/>
      <url>/archives/20220808_mock/</url>
      
        <content type="html"><![CDATA[<h4 id="手机"><a href="#手机" class="headerlink" title="手机"></a>手机</h4><p>直接打表即可。</p><p>注意输入用 <code>getline</code>，判断空格。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;string s;<span class="type">char</span> c;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;iphone.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;iphone.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);<span class="built_in">getline</span>(cin,s);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;c=s[i];<span class="keyword">if</span>(c==<span class="string">&#x27;A&#x27;</span>)cout&lt;&lt;<span class="string">&quot;2&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;B&#x27;</span>)cout&lt;&lt;<span class="string">&quot;22&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;C&#x27;</span>)cout&lt;&lt;<span class="string">&quot;222&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;D&#x27;</span>)cout&lt;&lt;<span class="string">&quot;3&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;E&#x27;</span>)cout&lt;&lt;<span class="string">&quot;33&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;F&#x27;</span>)cout&lt;&lt;<span class="string">&quot;333&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;G&#x27;</span>)cout&lt;&lt;<span class="string">&quot;4&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;H&#x27;</span>)cout&lt;&lt;<span class="string">&quot;44&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;I&#x27;</span>)cout&lt;&lt;<span class="string">&quot;444&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;J&#x27;</span>)cout&lt;&lt;<span class="string">&quot;5&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;K&#x27;</span>)cout&lt;&lt;<span class="string">&quot;55&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;L&#x27;</span>)cout&lt;&lt;<span class="string">&quot;555&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;M&#x27;</span>)cout&lt;&lt;<span class="string">&quot;6&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;N&#x27;</span>)cout&lt;&lt;<span class="string">&quot;66&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;O&#x27;</span>)cout&lt;&lt;<span class="string">&quot;666&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;P&#x27;</span>)cout&lt;&lt;<span class="string">&quot;7&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;Q&#x27;</span>)cout&lt;&lt;<span class="string">&quot;77&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;R&#x27;</span>)cout&lt;&lt;<span class="string">&quot;777&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;S&#x27;</span>)cout&lt;&lt;<span class="string">&quot;7777&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;T&#x27;</span>)cout&lt;&lt;<span class="string">&quot;8&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;U&#x27;</span>)cout&lt;&lt;<span class="string">&quot;88&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;V&#x27;</span>)cout&lt;&lt;<span class="string">&quot;888&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;W&#x27;</span>)cout&lt;&lt;<span class="string">&quot;9&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;X&#x27;</span>)cout&lt;&lt;<span class="string">&quot;99&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;Y&#x27;</span>)cout&lt;&lt;<span class="string">&quot;999&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;Z&#x27;</span>)cout&lt;&lt;<span class="string">&quot;9999&quot;</span>;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27; &#x27;</span>)cout&lt;&lt;<span class="string">&quot;0&quot;</span>;&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="方方游戏"><a href="#方方游戏" class="headerlink" title="方方游戏"></a>方方游戏</h4><p>模拟。</p><p>对于将下落的方块，找出最先触碰底方块的，然后直接下移。</p><p>注意细节，比如最底层先铺上方块，初始方块高度大概放三四百。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="meta">#<span class="keyword">define</span> min(x,y) x&lt;y?x:y</span><span class="meta">#<span class="keyword">define</span> max(x,y) x&gt;y?x:y</span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> mp[<span class="number">400</span>][<span class="number">200</span>];<span class="type">int</span> y,x,dx,ux,ly,ry,cnt,num=<span class="number">400</span>,w,n,m;<span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=w;j++)&#123;<span class="type">int</span> _x_=<span class="number">400</span>;<span class="keyword">for</span>(<span class="type">int</span> i=dx;i&lt;=ux;i++)&#123;<span class="keyword">if</span>(mp[i][j]==<span class="number">2</span>)&#123;_x_=i;<span class="keyword">break</span>;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">100</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="keyword">if</span>(mp[i][j]==<span class="number">1</span>)&#123;num=<span class="built_in">min</span>(num,_x_-i);<span class="keyword">break</span>;&#125;&#125; &#125;<span class="keyword">for</span>(<span class="type">int</span> i=dx;i&lt;=ux;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=ly;j&lt;=ry;j++)&#123;<span class="keyword">if</span>(mp[i][j]==<span class="number">2</span>)&#123;mp[i-num<span class="number">+1</span>][j]=<span class="number">1</span>;&#125;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;<span class="type">bool</span> f=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=w;j++)&#123;<span class="keyword">if</span>(mp[i][j]!=<span class="number">1</span>)&#123;f=<span class="number">1</span>;<span class="keyword">break</span>;&#125;&#125;<span class="keyword">if</span>(f==<span class="number">0</span>)cnt++;&#125;cout&lt;&lt;cnt&lt;&lt;endl;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;square.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;square.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);cin&gt;&gt;w&gt;&gt;n&gt;&gt;m;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=w;i++)&#123;mp[<span class="number">0</span>][i]=<span class="number">1</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> x_,y_;cin&gt;&gt;x_&gt;&gt;y_;mp[x_][y_]=<span class="number">1</span>;&#125;cin&gt;&gt;y;ly=ry=y;ux=dx=x=<span class="number">220</span>;mp[x][y]=<span class="number">2</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;<span class="type">int</span> _x,_y;cin&gt;&gt;_x&gt;&gt;_y;mp[x+_x][y+_y]=<span class="number">2</span>;ly=<span class="built_in">min</span>(ly,y+_y);ry=<span class="built_in">max</span>(ry,y+_y);dx=<span class="built_in">min</span>(dx,x+_x);ux=<span class="built_in">max</span>(ux,x+_x);&#125;<span class="built_in">down</span>();<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="传球"><a href="#传球" class="headerlink" title="传球"></a>传球</h4><p>NOIp……原……原题？</p><p><a href="https://www.luogu.com.cn/problem/P1057">洛谷 P1057</a>。</p><p>$f_{i,j}$ 表示第 $i$ 轮求球在 $j$ 手上方案数。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">long</span> <span class="type">long</span> f[<span class="number">50</span>][<span class="number">50</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;ball.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;ball.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);<span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;f[<span class="number">0</span>][n]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="keyword">if</span>(j==<span class="number">1</span>)f[i][j]+=f[i<span class="number">-1</span>][n];<span class="keyword">else</span> f[i][j]+=f[i<span class="number">-1</span>][j<span class="number">-1</span>];<span class="keyword">if</span>(j==n)f[i][j]+=f[i<span class="number">-1</span>][<span class="number">1</span>];<span class="keyword">else</span> f[i][j]+=f[i<span class="number">-1</span>][j<span class="number">+1</span>];&#125;&#125;cout&lt;&lt;f[m][n]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="找位置"><a href="#找位置" class="headerlink" title="找位置"></a>找位置</h4><p>最短路。</p><p>找到了所有商店到其他店的最短路径，由于 $k\leq5$，所以直接全排列枚举路线。</p><p><del>tnnd，一个最短路调一晚上。</del></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="meta">#<span class="keyword">define</span> min(x,y) x&lt;y?x:y</span><span class="meta">#<span class="keyword">define</span> max(x,y) x&gt;y?x:y</span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">bool</span> b[<span class="number">10020</span>];<span class="type">bool</span> vis[<span class="number">10020</span>];<span class="type">int</span> p[<span class="number">20</span>],order[<span class="number">20</span>];<span class="type">int</span> f[<span class="number">20</span>][<span class="number">10020</span>];<span class="type">int</span> u,v,w;<span class="type">int</span> n,m,k;<span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> v,w;&#125;;vector&lt;node&gt;a[<span class="number">10020</span>];<span class="function"><span class="type">void</span> <span class="title">dijk</span><span class="params">(<span class="type">int</span> s)</span></span><span class="function"></span>&#123;<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;q;f[s][p[s]]=<span class="number">0</span>;q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,p[s]));<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;u=q.<span class="built_in">top</span>().second;q.<span class="built_in">pop</span>();<span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;vis[u]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="keyword">auto</span> i:a[u])&#123;v=i.v;w=i.w;<span class="keyword">if</span>(f[s][u]+w&lt;f[s][v])&#123;f[s][v]=f[s][u]+w;q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(f[s][v],v));&#125;&#125;&#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;relocation.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;relocation.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;cin&gt;&gt;p[i];b[p[i]]=<span class="number">1</span>;order[i]=i;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;a[u].<span class="built_in">push_back</span>(&#123;v,w&#125;);a[v].<span class="built_in">push_back</span>(&#123;u,w&#125;);&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;<span class="built_in">dijk</span>(i);&#125;<span class="type">int</span> ans=INT_MAX;<span class="keyword">do</span>&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> sum=<span class="number">0</span>;<span class="keyword">if</span>(b[i])<span class="keyword">continue</span>;sum+=f[order[<span class="number">1</span>]][i];<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=k;j++)&#123;sum+=f[order[j<span class="number">-1</span>]][p[order[j]]];&#125;sum+=f[order[k]][i];ans=<span class="built_in">min</span>(ans,sum);&#125;&#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(order<span class="number">+1</span>,order+k<span class="number">+1</span>));cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC262 做题笔记</title>
      <link href="/archives/ABC262/"/>
      <url>/archives/ABC262/</url>
      
        <content type="html"><![CDATA[<h3 id="abc262-a"><a href="#abc262-a" class="headerlink" title="abc262_a"></a><a href="https://atcoder.jp/contests/abc262/tasks/abc262_a">abc262_a</a></h3><h4 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>问第 $Y$ 年后（包括第 $Y$ 年）最近一次世界杯在什么时候。</p><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>世界杯举办的年份 $\bmod 4$ 为 $2$。</p><h4 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> a;cin&gt;&gt;a;cout&lt;&lt;a+(<span class="number">4</span>-(a<span class="number">-2</span>)%<span class="number">4</span>)%<span class="number">4</span>&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc262-b"><a href="#abc262-b" class="headerlink" title="abc262_b"></a><a href="https://atcoder.jp/contests/abc262/tasks/abc262_b">abc262_b</a></h3><h4 id="题目翻译-1"><a href="#题目翻译-1" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>无向图三元环计数。</p><h4 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h4><p>$n&#x3D;100$，$n^3$ 枚举可过。</p><p>可以用邻接矩阵。</p><h4 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">bool</span> b[<span class="number">105</span>][<span class="number">105</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,m,ans=<span class="number">0</span>;cin&gt;&gt;n&gt;&gt;m;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="type">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;b[u][v]=b[v][u]=<span class="number">1</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)&#123;<span class="keyword">for</span>(<span class="type">int</span> k=j<span class="number">+1</span>;k&lt;=n;k++)&#123;<span class="keyword">if</span>(b[i][j]==<span class="number">1</span>&amp;&amp;b[j][k]==<span class="number">1</span>&amp;&amp;b[k][i]==<span class="number">1</span>)&#123;ans++;&#125;&#125;&#125;&#125;cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc262-c"><a href="#abc262-c" class="headerlink" title="abc262_c"></a><a href="https://atcoder.jp/contests/abc262/tasks/abc262_c">abc262_c</a></h3><h4 id="题目翻译-2"><a href="#题目翻译-2" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>问有多少两元组 $(i,j)$ 满足：</p><ul><li>$1\leq i&lt;j\leq n$。</li><li>$\min(a_i,a_j)&#x3D;i$</li><li>$\max(a_i,a_j)&#x3D;j$</li></ul><h4 id="题目思路-2"><a href="#题目思路-2" class="headerlink" title="题目思路"></a>题目思路</h4><p>由题意可知，只有以下两种情况：</p><p>$a_i&#x3D;i,a_j&#x3D;j$</p><p>$a_i&#x3D;j,a_j&#x3D;i$</p><p>对于第一种，数一下自己下标为自己的个数，然后组合一下 $C_x^2$，$x$ 是自己下标为自己个数。</p><p>对于第二种，$j$ 可以用 $a_i$ 表示，就是 $a_{a_i}&#x3D;i$ 的个数。</p><h4 id="AC-代码-2"><a href="#AC-代码-2" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">500020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;<span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>,cnt=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> j=a[i];<span class="keyword">if</span>(a[j]==i&amp;&amp;i!=j)&#123;ans++;&#125;<span class="keyword">if</span>(a[i]==i)&#123;cnt++;&#125;&#125;cout&lt;&lt;<span class="number">1LL</span>*ans/<span class="number">2</span><span class="number">+1LL</span>*cnt*(cnt<span class="number">-1</span>)/<span class="number">2</span>&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 简单动态规划 做题笔记</title>
      <link href="/archives/DPeasy/"/>
      <url>/archives/DPeasy/</url>
      
        <content type="html"><![CDATA[<p>总计 $30$ 题。</p><h3 id="洛谷"><a href="#洛谷" class="headerlink" title="洛谷"></a>洛谷</h3><p>总计 $17$ 题。</p><h4 id="P1002"><a href="#P1002" class="headerlink" title="P1002"></a><a href="https://www.luogu.com.cn/problem/P1002">P1002</a></h4><p>没什么好说的，注意一下细节。</p><p>如果马的掌控范围不在棋盘内，特判防 RE。</p><p>$\Huge 不开 long\ long 见祖宗！！！$</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">long</span> <span class="type">long</span> f[<span class="number">50</span>][<span class="number">50</span>]; <span class="type">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">0</span>&#125;;<span class="type">int</span> dy[]=&#123;<span class="number">2</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,m,x,y;cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;x++;y++;n++;m++;f[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">8</span>;i++)&#123;<span class="type">int</span> X=dx[i]+x,Y=dy[i]+y;<span class="keyword">if</span>(X&gt;<span class="number">0</span>&amp;&amp;Y&gt;<span class="number">0</span>)f[X][Y]=<span class="number">-1</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;<span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;j==<span class="number">1</span>)<span class="keyword">continue</span>;<span class="keyword">if</span>(f[i][j]==<span class="number">-1</span>)&#123;f[i][j]=<span class="number">0</span>;<span class="keyword">continue</span>;&#125;f[i][j]=f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>];&#125;&#125;cout&lt;&lt;f[n][m]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="P1044"><a href="#P1044" class="headerlink" title="P1044"></a><a href="https://www.luogu.com.cn/problem/P1044">P1044</a></h4><p>对每个出栈的数，当前的方案数一定是比他小的方案数，乘上比它大的。</p><p>枚举一下即可。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> f[<span class="number">20</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;f[<span class="number">0</span>]=f[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;f[i]+=f[j<span class="number">-1</span>]*f[i-j]; &#125;&#125;cout&lt;&lt;f[n]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="P1057"><a href="#P1057" class="headerlink" title="P1057"></a><a href="https://www.luogu.com.cn/problem/P1057">P1057</a></h4><p>$f_{i,j}$ 表示第 $i$ 次传球，球在 $j$ 号同学的手中方案数。</p><p>每次往左往右加一下。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> f[<span class="number">50</span>][<span class="number">50</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="keyword">if</span>(j==<span class="number">1</span>)f[i][n]+=f[i<span class="number">-1</span>][j];<span class="keyword">else</span> f[i][j<span class="number">-1</span>]+=f[i<span class="number">-1</span>][j];<span class="keyword">if</span>(j==n)f[i][<span class="number">1</span>]+=f[i<span class="number">-1</span>][j];<span class="keyword">else</span> f[i][j<span class="number">+1</span>]+=f[i<span class="number">-1</span>][j];&#125;&#125;cout&lt;&lt;f[m][<span class="number">1</span>]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="P1077"><a href="#P1077" class="headerlink" title="P1077"></a><a href="">P1077</a></h4><p>$f_{i,j}$ 表示 $n$ 种花选 $m$ 盆的最大值。</p><p>然后直接多重背包。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> f[<span class="number">120</span>][<span class="number">120</span>];<span class="type">int</span> a[<span class="number">120</span>];<span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e6</span><span class="number">+7</span>;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="built_in">min</span>(a[i],j);k++)&#123;f[i][j]+=f[i<span class="number">-1</span>][j-k];f[i][j]%=mod;&#125;&#125;&#125;cout&lt;&lt;f[n][m]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="P1091"><a href="#P1091" class="headerlink" title="P1091"></a><a href="https://www.luogu.com.cn/problem/P1091">P1091</a></h4><p>导弹拦截第一问做两遍，$n$ 规模较小 $\mathcal O(n^2)$ 的写法可过。</p><p>从左到右，从右到左各做一次，看能拦截多少“导弹”，最后减一下即为“拦截不住”即“该出列的学生”。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> f[<span class="number">120</span>];<span class="type">int</span> g[<span class="number">120</span>];<span class="type">int</span> a[<span class="number">120</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;<span class="keyword">if</span>(a[j]&lt;a[i])f[i]=<span class="built_in">max</span>(f[i],f[j]);&#125;f[i]++;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)&#123;<span class="keyword">if</span>(a[j]&lt;a[i])g[i]=<span class="built_in">max</span>(g[i],g[j]);&#125;g[i]++;&#125;<span class="type">int</span> ans=<span class="number">-114514</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> x=f[i],y=g[i];ans=<span class="built_in">max</span>(x+y<span class="number">-1</span>,ans);&#125;cout&lt;&lt;n-ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="P1095"><a href="#P1095" class="headerlink" title="P1095"></a><a href="https://www.luogu.com.cn/problem/P1095">P1095</a></h4><p>$f_i$ 表示第 $i$ 个时刻最长距离。</p><p>我们先考虑只能位移，然后再扫一遍，如果走路更优就走路。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> f[<span class="number">300020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> m,s,t;cin&gt;&gt;m&gt;&gt;s&gt;&gt;t;<span class="keyword">for</span>(<span class="type">int</span> tt=<span class="number">1</span>;tt&lt;=t;tt++)&#123;<span class="keyword">if</span>(m&gt;=<span class="number">10</span>)&#123;m-=<span class="number">10</span>;f[tt]=f[tt<span class="number">-1</span>]<span class="number">+60</span>;&#125;<span class="keyword">else</span>&#123;m+=<span class="number">4</span>;f[tt]=f[tt<span class="number">-1</span>];&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> tt=<span class="number">1</span>;tt&lt;=t;tt++)&#123;f[tt]=<span class="built_in">max</span>(f[tt],f[tt<span class="number">-1</span>]<span class="number">+17</span>);<span class="keyword">if</span>(f[tt]&gt;=s)&#123;<span class="built_in">printf</span>(<span class="string">&quot;Yes\n%d\n&quot;</span>,tt);<span class="keyword">return</span> <span class="number">0</span>;&#125;&#125;<span class="built_in">printf</span>(<span class="string">&quot;No\n%d\n&quot;</span>,f[t]);<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="P1358"><a href="#P1358" class="headerlink" title="P1358"></a><a href="https://www.luogu.com.cn/problem/P1358">P1358</a></h4><p>热知识，杨辉三角可以用于求组合数。</p><p>$C^m_n$ 即为下标从 $0$ 开始的第 $n$ 行第 $m$ 列的数字。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> mod=<span class="number">10007</span>;<span class="type">int</span> f[<span class="number">10020</span>][<span class="number">120</span>]; <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)&#123;f[i][<span class="number">0</span>]=<span class="number">1</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,<span class="number">100</span>);j++)&#123;f[i][j]=f[i<span class="number">-1</span>][j]+f[i<span class="number">-1</span>][j<span class="number">-1</span>];f[i][j]%=mod;&#125;&#125; <span class="type">int</span> n,m;<span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;cin&gt;&gt;n&gt;&gt;m;<span class="keyword">while</span>(m--)&#123;<span class="type">int</span> x;cin&gt;&gt;x;ans*=<span class="number">1LL</span>*f[n][x];ans%=mod;n-=x;&#125;cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="P1439"><a href="#P1439" class="headerlink" title="P1439"></a><a href="https://www.luogu.com.cn/problem/P1439">P1439</a></h4><p>乍一眼，是个 LCS。</p><p>但看了 <a href="https://www.luogu.com.cn/user/15289">阮行止</a> 大佬的博客，受益匪浅，可以转换成 LIS 做。</p><p>所以这题是个复杂度只能为 $\mathcal O(n\log n)$ 的导弹拦截第一问。</p><p>但略有不同，导弹拦截是最长不上升子序列，即非严格 LDS，这题是最长上升，即 LIS。</p><p>但原理相同，二分优化。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">100020</span>];<span class="type">int</span> b[<span class="number">100020</span>];<span class="type">int</span> f[<span class="number">100020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> x;cin&gt;&gt;x;a[x]=i;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> x;cin&gt;&gt;x;b[i]=a[x];&#125;<span class="type">int</span> ans=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(!ans||f[ans]&lt;b[i])&#123;f[++ans]=b[i];&#125;<span class="keyword">else</span>&#123;<span class="type">int</span> mid=<span class="built_in">lower_bound</span>(f<span class="number">+1</span>,f+ans<span class="number">+1</span>,b[i])-f;f[mid]=b[i];&#125;&#125;cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="P1616"><a href="#P1616" class="headerlink" title="P1616"></a><a href="https://www.luogu.com.cn/problem/P1616">P1616</a></h4><p>完全背包板子。</p><p>$\Huge 不开 long\ long 见祖宗！！！$</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">long</span> <span class="type">long</span> f[<span class="number">10000020</span>];<span class="type">int</span> a[<span class="number">10020</span>];<span class="type">int</span> b[<span class="number">10020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> v,n;cin&gt;&gt;v&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i]&gt;&gt;b[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=a[i];j&lt;=v;j++)&#123;f[j]=<span class="built_in">max</span>(f[j],f[j-a[i]]+b[i]);&#125;&#125;cout&lt;&lt;f[v]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="P1679"><a href="#P1679" class="headerlink" title="P1679"></a><a href="https://www.luogu.com.cn/problem/P1679">P1679</a></h4><p>完全背包。</p><p>价值为 $1$，重量为 $i^4$，问价值最小。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> mod=<span class="number">10007</span>;<span class="type">int</span> f[<span class="number">100020</span>]; <span class="type">int</span> a[<span class="number">50</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));<span class="type">int</span> m;cin&gt;&gt;m;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)&#123;a[i]=i*i*i*i;&#125;<span class="built_in">memset</span>(f,<span class="number">0x7f</span>,<span class="built_in">sizeof</span>(f));f[<span class="number">0</span>]=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=a[i];j&lt;=m;j++)&#123;f[j]=<span class="built_in">min</span>(f[j],f[j-a[i]]<span class="number">+1</span>);&#125;&#125;cout&lt;&lt;f[m]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="P1734"><a href="#P1734" class="headerlink" title="P1734"></a><a href="https://www.luogu.com.cn/problem/P1734">P1734</a></h4><p>01背包，物品重量 $i$，价值 $a_i$。</p><p>$a_i$ 为 $i$ 的约数和去掉本身。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> f[<span class="number">1020</span>];<span class="type">int</span> a[<span class="number">1020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;<span class="keyword">if</span>(i%j==<span class="number">0</span>)&#123;a[i]+=j;&#125; &#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;=i;j--)&#123;f[j]=<span class="built_in">max</span>(f[j],f[j-i]+a[i]);&#125;&#125; cout&lt;&lt;f[n]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="P1853"><a href="#P1853" class="headerlink" title="P1853"></a><a href="https://www.luogu.com.cn/problem/P1853">P1853</a></h4><p>表面上题目挺吓人的，但其实只是完全背包，容量每年在变而已。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">long</span> <span class="type">long</span> f[<span class="number">10000020</span>];<span class="type">int</span> a[<span class="number">10020</span>];<span class="type">int</span> b[<span class="number">10020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> v,n,x;cin&gt;&gt;v&gt;&gt;x&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i]&gt;&gt;b[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=x;k++)&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=a[i];j&lt;=v;j++)&#123;f[j]=<span class="built_in">max</span>(f[j],f[j-a[i]]+b[i]);&#125;&#125;v+=f[v];&#125;cout&lt;&lt;v&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="P2008"><a href="#P2008" class="headerlink" title="P2008"></a><a href="https://www.luogu.com.cn/problem/P2008">P2008</a></h4><p>求最长不下降子序列时，顺便存一下和即可。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">10020</span>];<span class="type">int</span> f[<span class="number">10020</span>];<span class="type">int</span> s[<span class="number">10020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;<span class="keyword">if</span>(a[j]&lt;=a[i])&#123;<span class="keyword">if</span>(f[j]&gt;f[i])&#123;f[i]=f[j];s[i]=s[j];&#125;&#125;&#125;s[i]+=a[i];f[i]++;cout&lt;&lt;s[i]&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="P2347"><a href="#P2347" class="headerlink" title="P2347"></a><a href="https://www.luogu.com.cn/problem/P2347">P2347</a></h4><p>和背包很类似，如果 $i$ 重量可以组成，$i+w_i$ 也可以组成。</p><p>暂且把 $w_i$ 看成题目中的砝码重量。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">bool</span> f[<span class="number">1020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;f[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)&#123;<span class="type">int</span> x,y=<span class="number">0</span>;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="keyword">switch</span>(i)&#123;<span class="keyword">case</span> <span class="number">4</span>:y=<span class="number">5</span>;<span class="keyword">break</span>;<span class="keyword">case</span> <span class="number">5</span>:y=<span class="number">10</span>;<span class="keyword">break</span>;<span class="keyword">case</span> <span class="number">6</span>:y=<span class="number">20</span>;<span class="keyword">break</span>;<span class="keyword">default</span>:y=i;&#125;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=x;j++)&#123;<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1000</span>;k&gt;=y;k--)&#123;f[k]|=f[k-y];&#125; &#125;&#125;<span class="type">int</span> ans=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++)&#123;ans+=f[i];&#125;<span class="built_in">printf</span>(<span class="string">&quot;Total=%d&quot;</span>,ans);<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p>当然，上个代码中，</p><pre><code class="highlight cpp"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1000</span>;k&gt;=y;k--)&#123;f[k]|=f[k-y];&#125;</code></pre><p>这一部分，可以简化。</p><p>C++ 一个 STL 容器，叫做 bitset。</p><p>bitset 自带或操作和位移操作。</p><p>那么，上述代码可以简化为</p><pre><code class="highlight cpp">b|=b&lt;&lt;y;</code></pre><p><code>b&lt;&lt;y</code> 是整个容器右移 $y$ 位，相当于原来代码 $-y$。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;bitset&lt;1020&gt;b;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;b[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)&#123;<span class="type">int</span> x,y=<span class="number">0</span>;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="keyword">switch</span>(i)&#123;<span class="keyword">case</span> <span class="number">4</span>:y=<span class="number">5</span>;<span class="keyword">break</span>;<span class="keyword">case</span> <span class="number">5</span>:y=<span class="number">10</span>;<span class="keyword">break</span>;<span class="keyword">case</span> <span class="number">6</span>:y=<span class="number">20</span>;<span class="keyword">break</span>;<span class="keyword">default</span>:y=i;&#125;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=x;j++)&#123;b|=b&lt;&lt;y;&#125;&#125;<span class="built_in">printf</span>(<span class="string">&quot;Total=%d&quot;</span>,b.<span class="built_in">count</span>()<span class="number">-1</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="P2639"><a href="#P2639" class="headerlink" title="P2639"></a><a href="https://www.luogu.com.cn/problem/P2639">P2639</a></h4><p>01背包，装箱问题的双倍经验。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">520</span>];<span class="type">int</span> b[<span class="number">520</span>];<span class="type">int</span> f[<span class="number">45020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> v,n;cin&gt;&gt;v&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];b[i]=a[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=v;j&gt;=a[i];j--)&#123;f[j]=<span class="built_in">max</span>(f[j],f[j-a[i]]+b[i]);&#125;&#125;cout&lt;&lt;f[v]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="P2722"><a href="#P2722" class="headerlink" title="P2722"></a><a href="https://www.luogu.com.cn/problem/P2722">P2722</a></h4><p>无限背包板子。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">10020</span>];<span class="type">int</span> b[<span class="number">10020</span>];<span class="type">int</span> f[<span class="number">10020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> v,n;cin&gt;&gt;v&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i]&gt;&gt;b[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=b[i];j&lt;=v;j++)&#123;f[j]=<span class="built_in">max</span>(f[j],f[j-b[i]]+a[i]);&#125;&#125;cout&lt;&lt;f[v]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="P2925"><a href="#P2925" class="headerlink" title="P2925"></a><a href="https://www.luogu.com.cn/problem/P2925">P2925</a></h4><p>01背包模板。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> f[<span class="number">50020</span>];<span class="type">int</span> a[<span class="number">5020</span>];<span class="type">int</span> b[<span class="number">5020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> v,n;cin&gt;&gt;v&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];b[i]=a[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=v;j&gt;=a[i];j--)&#123;f[j]=<span class="built_in">max</span>(f[j],f[j-a[i]]+b[i]);&#125;&#125;cout&lt;&lt;f[v]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="CF"><a href="#CF" class="headerlink" title="CF"></a>CF</h3><p>总计 $6$ 题。</p><h4 id="CF414B"><a href="#CF414B" class="headerlink" title="CF414B"></a><a href="https://codeforces.com/problemset/problem/414/B">CF414B</a></h4><p>又是个小清新题！</p><p>$f_{i,j}$ 表示最大 $i$，长度 $j$ 的序列个数。</p><p>伪代码如下：</p><pre><code class="highlight pseudocode">枚举数列长度枚举最大值枚举与前一项的商</code></pre><p>但显然，复杂度 $\mathcal O(n^2k)$，然而本题 $n\leq 2000,k\leq 2000$ 明显不行。</p><p>考虑优化，如果前一项乘上商已经比 $n$ 大，就可以换一个最大值枚举了。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> f[<span class="number">2020</span>][<span class="number">2020</span>];<span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;f[i][<span class="number">1</span>]=<span class="number">1</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=k;j++)&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> _=<span class="number">1</span>;_*i&lt;=n;_++)&#123;f[i*_][j]+=f[i][j<span class="number">-1</span>];f[i*_][j]%=mod;&#125;&#125;&#125;<span class="type">int</span> ans=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;ans+=f[i][k];ans%=mod;&#125;cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="CF417A"><a href="#CF417A" class="headerlink" title="CF417A"></a><a href="https://codeforces.com/problemset/problem/417/A">CF417A</a></h4><p>无限背包。</p><p>题意很复杂，什么保送，什么赛制。</p><p>其实就是做无限背包后求 $\min\limits_{x \in [0,2]}\{f_{n\times m-x}\}$ 。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> f[<span class="number">10020</span>]; <span class="type">int</span> a[<span class="number">10</span>];<span class="type">int</span> b[<span class="number">10</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));<span class="type">int</span> c,d,n,m,k,v;cin&gt;&gt;c&gt;&gt;d&gt;&gt;n&gt;&gt;m&gt;&gt;k;<span class="keyword">if</span>(n*m&lt;=k)&#123;cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;v=n*m;a[<span class="number">1</span>]=n;b[<span class="number">1</span>]=c;a[<span class="number">2</span>]=<span class="number">1</span>;b[<span class="number">2</span>]=d;f[<span class="number">0</span>]=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> kk=<span class="number">0</span>;kk&lt;=k;kk++)&#123;v=n*m-kk;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=a[i];j&lt;=v;j++)&#123;f[j]=<span class="built_in">min</span>(f[j],f[j-a[i]]+b[i]);&#125;&#125;&#125;<span class="type">int</span> ans=INT_MAX;<span class="keyword">for</span>(<span class="type">int</span> kk=<span class="number">0</span>;kk&lt;=k;kk++)&#123;v=n*m-kk;ans=<span class="built_in">min</span>(ans,f[v]);&#125;cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="CF431C"><a href="#CF431C" class="headerlink" title="CF431C"></a><a href="https://codeforces.com/problemset/problem/431/C">CF431C</a></h4><p>小清新题，爱了爱了。</p><p>用 $f_{i,0&#x2F;1}$ 分别表示权值和为 $i$ 时，当前边权（看为 $j$）是否大于等于 $d$。</p><p>分成 $j\geq d$ 和 $j&lt;d$ 两种情况。</p><ul><li><p>$j\geq d$</p><p>$f_{i,0}&#x3D; f_{i-j,0}$</p><p>$f_{i,1}&#x3D;f_{i-j,0}+f_{i-j,1}$</p></li><li><p>$j&lt;d$</p><p>$f_{i,0}&#x3D; f_{i-j,0}$</p><p>$f_{i,1}&#x3D;f_{i-j,1}$</p></li></ul><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> mod=<span class="number">1000000007</span>;<span class="type">long</span> <span class="type">long</span> f[<span class="number">120</span>][<span class="number">2</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,k,d;cin&gt;&gt;n&gt;&gt;k&gt;&gt;d;f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;<span class="keyword">if</span>(j&gt;i)<span class="keyword">break</span>;<span class="keyword">if</span>(j&gt;=d)&#123;f[i][<span class="number">1</span>]+=f[i-j][<span class="number">0</span>]+f[i-j][<span class="number">1</span>];f[i][<span class="number">1</span>]%=mod;&#125;<span class="keyword">else</span>&#123;f[i][<span class="number">0</span>]+=f[i-j][<span class="number">0</span>];f[i][<span class="number">1</span>]+=f[i-j][<span class="number">1</span>];f[i][<span class="number">0</span>]%=mod;f[i][<span class="number">1</span>]%=mod;&#125;&#125;&#125;cout&lt;&lt;f[n][<span class="number">1</span>]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="CF545C"><a href="#CF545C" class="headerlink" title="CF545C"></a><a href="https://codeforces.com/problemset/problem/545/C">CF545C</a></h4><p><del>读完这题，你就会发现，这题是个贪心。</del></p><p>确实可以贪心，这题贪心十分简单，所以我们写 dp。</p><p><del>不为别的，就为装B。</del></p><p>dp 用 $f_{i,0&#x2F;1&#x2F;2}$ 表示第 $i$ 棵树不倒&#x2F;往左边倒&#x2F;往右边倒时的最大倒下树木。</p><ul><li><p>$f_{i,0}$</p><p>即为前面的三种情况取最大值。</p></li><li><p>$f_{i,1}$</p><p>分类讨论，再空间足够时，讨论由哪种转变来。</p></li><li><p>$f_{i,2}$</p><p>如果可以就往右倒。</p></li></ul><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> x[<span class="number">100020</span>];<span class="type">int</span> h[<span class="number">100020</span>];<span class="type">int</span> f[<span class="number">100020</span>][<span class="number">3</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;x[i]&gt;&gt;h[i];&#125;f[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>][<span class="number">2</span>]=x[<span class="number">2</span>]-x[<span class="number">1</span>]&gt;h[<span class="number">1</span>];x[n<span class="number">+1</span>]=<span class="number">2000000001</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;f[i][<span class="number">0</span>]=<span class="built_in">max</span>(<span class="built_in">max</span>(f[i<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">1</span>]),f[i<span class="number">-1</span>][<span class="number">2</span>]);<span class="keyword">if</span>(h[i<span class="number">-1</span>]+x[i<span class="number">-1</span>]&lt;x[i]-h[i])&#123;f[i][<span class="number">1</span>]=f[i<span class="number">-1</span>][<span class="number">2</span>]<span class="number">+1</span>;&#125;<span class="keyword">if</span>(x[i<span class="number">-1</span>]&lt;x[i]-h[i])&#123;f[i][<span class="number">1</span>]=<span class="built_in">max</span>(f[i][<span class="number">1</span>],<span class="built_in">max</span>(f[i<span class="number">-1</span>][<span class="number">0</span>]<span class="number">+1</span>,f[i<span class="number">-1</span>][<span class="number">1</span>]<span class="number">+1</span>));&#125;<span class="keyword">if</span>(x[i]+h[i]&lt;x[i<span class="number">+1</span>])&#123;f[i][<span class="number">2</span>]=<span class="built_in">max</span>(<span class="built_in">max</span>(f[i<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">1</span>]),f[i<span class="number">-1</span>][<span class="number">2</span>])<span class="number">+1</span>;&#125; &#125;cout&lt;&lt;<span class="built_in">max</span>(<span class="built_in">max</span>(f[n][<span class="number">0</span>],f[n][<span class="number">1</span>]),f[n][<span class="number">2</span>])&lt;&lt;endl;     <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="CF933A"><a href="#CF933A" class="headerlink" title="CF933A"></a><a href="https://codeforces.com/problemset/problem/933/A">CF933A</a></h4><p>多看大佬博客受益匪浅。</p><p><del>所以这题暴力。</del></p><p>$n&#x3D;2000$，暴力想都别想。</p><p>得到的最长不下降，一定是 $111\dots222\dots111\dots222$ 这种排列的。</p><p>我们用 $f_{i,j}$ 表示前 $i$ 个第 $j$ 段的答案。</p><p>那么可以得出：</p><p>$f_{i,1}=f_{i-1,1}+[a_i=1]$<p><p>$f_{i,2}=\max(f_{i-1,1},f_{i-1,2}+[a_i=2])$<p><p>$f_{i,3}=\max(f_{i-1,2},f_{i-1,3}+[a_i=1])$</p><p>$f_{i,4}=\max(f_{i-1,3},f_{i-1,4}+[a_i=2])$</p>然后压掉第一维。<pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> f[<span class="number">4</span>];<span class="type">int</span> a[<span class="number">2020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;f[<span class="number">0</span>]=f[<span class="number">0</span>]+(a[i]==<span class="number">1</span>);f[<span class="number">1</span>]=<span class="built_in">max</span>(f[<span class="number">0</span>],f[<span class="number">1</span>]+(a[i]==<span class="number">2</span>));f[<span class="number">2</span>]=<span class="built_in">max</span>(f[<span class="number">1</span>],f[<span class="number">2</span>]+(a[i]==<span class="number">1</span>));f[<span class="number">3</span>]=<span class="built_in">max</span>(f[<span class="number">2</span>],f[<span class="number">3</span>]+(a[i]==<span class="number">2</span>));&#125;cout&lt;&lt;f[<span class="number">3</span>]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="CF1195C"><a href="#CF1195C" class="headerlink" title="CF1195C"></a><a href="https://codeforces.com/problemset/problem/1195/C">CF1195C</a></h4><p>dp 用 $f_{i,0&#x2F;1&#x2F;2}$ 表示第 $i$ 组人不选&#x2F;选第一个&#x2F;选第二个时的最大体重。</p><p>$f_{i,0}&#x3D;\max(f_{i-1,0},f_{i-1,1},f_{i-1,2})$。</p><p>$f_{i,1}&#x3D;\max(f_{i-1,0},f_{i-1,2})+a_i$。</p><p>$f_{i,2}&#x3D;\max(f_{i-1,0},f_{i-1,1})+b_i$。</p><p>$\Huge 不开 long\ long 见祖宗！！！$</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">100020</span>];<span class="type">int</span> b[<span class="number">100020</span>];<span class="type">long</span> <span class="type">long</span> f[<span class="number">100020</span>][<span class="number">3</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;b[i];&#125;f[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1LL</span>*a[<span class="number">1</span>];f[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1LL</span>*b[<span class="number">1</span>];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;f[i][<span class="number">0</span>]=<span class="number">1LL</span>*<span class="built_in">max</span>(<span class="built_in">max</span>(f[i<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">1</span>]),f[i<span class="number">-1</span>][<span class="number">2</span>]);f[i][<span class="number">1</span>]=<span class="number">1LL</span>*<span class="built_in">max</span>(f[i<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">2</span>])<span class="number">+1LL</span>*a[i];f[i][<span class="number">2</span>]=<span class="number">1LL</span>*<span class="built_in">max</span>(f[i<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">1</span>])<span class="number">+1LL</span>*b[i];&#125;cout&lt;&lt;<span class="built_in">max</span>(<span class="built_in">max</span>(f[n][<span class="number">0</span>],f[n][<span class="number">1</span>]),f[n][<span class="number">2</span>])&lt;&lt;endl;     <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="AT"><a href="#AT" class="headerlink" title="AT"></a>AT</h3><p>总计 $7$ 题。</p><h4 id="DP-A"><a href="#DP-A" class="headerlink" title="DP_A"></a><a href="https://atcoder.jp/contests/dp/tasks/dp_a">DP_A</a></h4><p>用 $f_i$ 记录跳到第 $i$ 个位置的最小花费。</p><p>注意，是从 $1$ 号开始，<del>看错这个调了好久</del>。</p><p>那么，每一步的最小应该是前两步和前一步分别加上差的绝对值取 $\min$。</p><p>转移方程：$f_i&#x3D;\min(f_{i-1}+\vert a_i-a_{i-1} \vert,f_{i-2}+\vert a_i-a_{i-2} \vert)$。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">100020</span>];<span class="type">int</span> f[<span class="number">100020</span>]; <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;f[<span class="number">2</span>]=<span class="built_in">abs</span>(a[<span class="number">1</span>]-a[<span class="number">2</span>]);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;f[i]=<span class="built_in">min</span>(f[i<span class="number">-1</span>]+<span class="built_in">abs</span>(a[i]-a[i<span class="number">-1</span>]),f[i<span class="number">-2</span>]+<span class="built_in">abs</span>(a[i]-a[i<span class="number">-2</span>]));&#125;cout&lt;&lt;f[n]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="DP-B"><a href="#DP-B" class="headerlink" title="DP_B"></a><a href="https://atcoder.jp/contests/dp/tasks/dp_b">DP_B</a></h4><p>用 $f_i$ 记录跳到第 $i$ 个位置的最小花费。</p><p>和上一题几乎一样，只是不是二选一，是多选一。</p><p>$n&#x3D;10^5,k&#x3D;100,n\times k&#x3D;10^7$ 不超时。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">100020</span>];<span class="type">int</span> f[<span class="number">100020</span>]; <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;f[<span class="number">1</span>+i]=<span class="built_in">abs</span>(a[<span class="number">1</span>]-a[<span class="number">1</span>+i]);&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;<span class="keyword">if</span>(j+i&gt;n)<span class="keyword">break</span>;f[i+j]=<span class="built_in">min</span>(f[i+j],f[i]+<span class="built_in">abs</span>(a[i+j]-a[i]));&#125;&#125;cout&lt;&lt;f[n]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="DP-C"><a href="#DP-C" class="headerlink" title="DP_C"></a><a href="https://atcoder.jp/contests/dp/tasks/dp_c">DP_C</a></h4><p>用 $dp_{i,j}$ 表示第 $i$ 天选第 $j$ 种的最大收益。</p><p>每次对上一天的另两个取 $\max$，再加上今天的。</p><p>最后输出 $\max(f_{n,0},f_{n,1},f_{n,2})$。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> f[<span class="number">100020</span>][<span class="number">3</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;f[i][<span class="number">0</span>]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][<span class="number">1</span>],f[i<span class="number">-1</span>][<span class="number">2</span>])+a;f[i][<span class="number">1</span>]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">2</span>])+b;f[i][<span class="number">2</span>]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">1</span>])+c;&#125;cout&lt;&lt;<span class="built_in">max</span>(f[n][<span class="number">0</span>],<span class="built_in">max</span>(f[n][<span class="number">1</span>],f[n][<span class="number">2</span>]))&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="DP-D"><a href="#DP-D" class="headerlink" title="DP_D"></a><a href="https://atcoder.jp/contests/dp/tasks/dp_d">DP_D</a></h4><p>最基础的01背包。</p><p>注意开 <code>long long</code>。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">long</span> <span class="type">long</span> f[<span class="number">100020</span>];<span class="type">int</span> a[<span class="number">120</span>];<span class="type">int</span> b[<span class="number">120</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> v,n;cin&gt;&gt;n&gt;&gt;v;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i]&gt;&gt;b[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=v;j&gt;=a[i];j--)&#123;f[j]=<span class="built_in">max</span>(f[j],f[j-a[i]]+b[i]);&#125;&#125;cout&lt;&lt;f[v]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="DP-E"><a href="#DP-E" class="headerlink" title="DP_E"></a><a href="https://atcoder.jp/contests/dp/tasks/dp_e">DP_E</a></h4><p>和上题一致，01背包，只是数据范围做了调整。</p><p>$f$ 数组不能记录每个重量的最大收益了，要记录每个收益最小重量。</p><p>注意这里初始化 $f$ 数组很关键。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">long</span> <span class="type">long</span> f[<span class="number">100020</span>];<span class="type">int</span> a[<span class="number">120</span>];<span class="type">int</span> b[<span class="number">120</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));f[<span class="number">0</span>]=<span class="number">0</span>;<span class="type">int</span> v,n;cin&gt;&gt;n&gt;&gt;v;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i]&gt;&gt;b[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">100000</span>;j&gt;=b[i];j--)&#123;f[j]=<span class="built_in">min</span>(f[j],f[j-b[i]]+a[i]);&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">100000</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="keyword">if</span>(f[i]&lt;=v)&#123;cout&lt;&lt;i&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="DP-F"><a href="#DP-F" class="headerlink" title="DP_F"></a><a href="https://atcoder.jp/contests/dp/tasks/dp_f">DP_F</a></h4><p>此题可以看成两问：</p><ul><li><p>最长公共子序列的长度。</p><p>正宗 LCS。</p></li><li><p>知道了动态规划过程，还原最长公共子序列。</p><p>反着再操作你的动态规划一次。</p></li></ul><p>可能有人觉得，dp 时顺便做一下字符串相加不行吗？</p><p>我很负责任的告诉你，会发生以下错误：</p><ol><li><p>MLE</p><p>要不是 AT 都开 $1024\ \tt{MB}$，早就寄了。</p></li><li><p>TLE</p><p>字符串加法不是 $\mathcal O(1)$ 的。</p></li></ol><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> f[<span class="number">3020</span>][<span class="number">3020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;string s1,s2;cin&gt;&gt;s1&gt;&gt;s2;s1=<span class="string">&quot;+&quot;</span>+s1;s2=<span class="string">&quot;+&quot;</span>+s2;<span class="type">int</span> len1=s<span class="number">1.</span><span class="built_in">size</span>(),len2=s<span class="number">2.</span><span class="built_in">size</span>();<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len1;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;len2;j++)&#123;<span class="keyword">if</span>(s1[i]==s2[j])&#123;f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;&#125;<span class="keyword">else</span> &#123;<span class="keyword">if</span>(f[i<span class="number">-1</span>][j]&gt;f[i][j<span class="number">-1</span>])&#123;f[i][j]=f[i<span class="number">-1</span>][j];&#125;<span class="keyword">else</span>&#123;f[i][j]=f[i][j<span class="number">-1</span>];&#125;&#125;&#125;&#125;<span class="type">int</span> x=len1<span class="number">-1</span>,y=len2<span class="number">-1</span>;string ans=<span class="string">&quot;&quot;</span>;<span class="keyword">while</span>(x&gt;<span class="number">0</span>&amp;&amp;y&gt;<span class="number">0</span>)&#123;<span class="keyword">if</span>(s1[x]==s2[y])&#123;ans+=s1[x];x--;y--;&#125;<span class="keyword">else</span>&#123;<span class="keyword">if</span>(f[x<span class="number">-1</span>][y]&gt;f[x][y<span class="number">-1</span>])&#123;x--;&#125;<span class="keyword">else</span> &#123;y--;&#125;&#125;&#125;<span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="DP-H"><a href="#DP-H" class="headerlink" title="DP_H"></a><a href="https://atcoder.jp/contests/dp/tasks/dp_h">DP_H</a></h4><p>简单，不需要讲。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> mod=<span class="number">1000000007</span>;<span class="type">int</span> f[<span class="number">1020</span>][<span class="number">1020</span>]; <span class="type">char</span> c[<span class="number">1020</span>][<span class="number">1020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;cin&gt;&gt;c[i][j];&#125;&#125;f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;<span class="keyword">if</span>(c[i][j]==<span class="string">&#x27;#&#x27;</span>)<span class="keyword">continue</span>;f[i][j]=f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>];f[i][j]%=mod;&#125;&#125;cout&lt;&lt;f[n][m]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC261 做题笔记</title>
      <link href="/archives/ABC261/"/>
      <url>/archives/ABC261/</url>
      
        <content type="html"><![CDATA[<h3 id="abc261-a"><a href="#abc261-a" class="headerlink" title="abc261_a"></a><a href="https://atcoder.jp/contests/abc261/tasks/abc261_a">abc261_a</a></h3><h4 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>问<strong>数轴上</strong> $[l_1,r_1]$ 和 $[l_2,r_2]$ 重叠长度。</p><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>注意数轴上，不是问重叠数字个数。</p><p>罚时带来的教训。</p><h4 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> l1,r1,l2,r2,ans=<span class="number">0</span>;cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;<span class="keyword">for</span>(<span class="type">int</span> i=l1;i&lt;=r1;i++)&#123;<span class="keyword">if</span>(l2&lt;=i&amp;&amp;i&lt;=r2)ans++;&#125;cout&lt;&lt;<span class="built_in">max</span>(<span class="number">0</span>,ans<span class="number">-1</span>)&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc261-b"><a href="#abc261-b" class="headerlink" title="abc261_b"></a><a href="https://atcoder.jp/contests/abc261/tasks/abc261_b">abc261_b</a></h3><h4 id="题目翻译-1"><a href="#题目翻译-1" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有 $n$ 个人对局，生成了 $n \times n$ 大小的结果表。</p><p>$a_{i,j}$ 即为第 $i$ 人对第 $j$ 人的结果。</p><p><code>W</code> 为胜利。</p><p><code>L</code> 为失败。</p><p><code>-</code> 为未知，任何结果都可能。</p><p><code>D</code> 为平局。</p><p>问结果表是否合法。</p><h4 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h4><p>直接扫一遍。</p><h4 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">char</span> a[<span class="number">1020</span>][<span class="number">1020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;<span class="type">bool</span> f=<span class="number">0</span>;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;cin&gt;&gt;a[i][j];&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="keyword">if</span>(a[j][i]==<span class="string">&#x27;D&#x27;</span>&amp;&amp;a[i][j]==<span class="string">&#x27;D&#x27;</span>||a[j][i]==<span class="string">&#x27;W&#x27;</span>&amp;&amp;a[i][j]==<span class="string">&#x27;L&#x27;</span>||a[j][i]==<span class="string">&#x27;L&#x27;</span>&amp;&amp;a[i][j]==<span class="string">&#x27;W&#x27;</span>||a[j][i]==<span class="string">&#x27;-&#x27;</span>||a[i][j]==<span class="string">&#x27;-&#x27;</span>)&#123;&#125;<span class="keyword">else</span>&#123;f=<span class="number">1</span>;&#125;&#125;&#125;<span class="built_in">puts</span>(f==<span class="number">1</span>?<span class="string">&quot;incorrect&quot;</span>:<span class="string">&quot;correct&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc261-c"><a href="#abc261-c" class="headerlink" title="abc261_c"></a><a href="https://atcoder.jp/contests/abc261/tasks/abc261_c">abc261_c</a></h3><h4 id="题目翻译-2"><a href="#题目翻译-2" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>新建文件或文件夹时，若名字重复，往往会命名为 <code>新建文件夹(1)</code> 的名字。</p><p>给出创建的文件，输出最后命名。</p><h4 id="题目思路-2"><a href="#题目思路-2" class="headerlink" title="题目思路"></a>题目思路</h4><p><code>map</code> 练习题，很裸，不多说。</p><h4 id="AC-代码-2"><a href="#AC-代码-2" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;map&lt;string,<span class="type">int</span>&gt;m;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="keyword">while</span>(n--)&#123;string s;cin&gt;&gt;s;m[s]++;<span class="keyword">if</span>(m[s]==<span class="number">1</span>)cout&lt;&lt;s&lt;&lt;endl;<span class="keyword">else</span> cout&lt;&lt;s&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;(m[s]<span class="number">-1</span>)&lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;endl;&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc261-d"><a href="#abc261-d" class="headerlink" title="abc261_d"></a><a href="https://atcoder.jp/contests/abc261/tasks/abc261_d">abc261_d</a></h3><h4 id="题目翻译-3"><a href="#题目翻译-3" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有 $n$ 个数 $a_1,a_2,\dots a_n$。</p><p>你可以抛 $n$ 次硬币，第 $i$ 次正面可以获得 $a_i$ 的分数，并记录连击。</p><p>连击数达到指定值时，会获得连击奖励。</p><h4 id="题目思路-3"><a href="#题目思路-3" class="headerlink" title="题目思路"></a>题目思路</h4><p>我们用 $f_{i,j}$ 表示前 $i$ 次<strong>最后</strong>连击次数。</p><p>分两种情况：</p><ul><li>延续连击：$f_{i,j}&#x3D;f_{i-1,j-1}+连击奖励+分数$</li><li>停止连击：$f_{i,0}&#x3D;\max(f_{i,0},f_{i-1,j})$</li></ul><h4 id="AC-代码-3"><a href="#AC-代码-3" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">5020</span>];<span class="type">int</span> b[<span class="number">5020</span>];<span class="type">long</span> <span class="type">long</span> f[<span class="number">5020</span>][<span class="number">5020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,m;<span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;cin&gt;&gt;n&gt;&gt;m;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;<span class="keyword">while</span>(m--)&#123;<span class="type">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;b[x]=y;&#125;f[<span class="number">1</span>][<span class="number">1</span>]=a[<span class="number">1</span>]+b[<span class="number">1</span>];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>]+b[j]+a[i];f[i][<span class="number">0</span>]=<span class="built_in">max</span>(f[i][<span class="number">0</span>],f[i<span class="number">-1</span>][j]);&#125;f[i][i]=f[i<span class="number">-1</span>][i<span class="number">-1</span>]+a[i]+b[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)ans=<span class="built_in">max</span>(ans,f[n][i]);cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20220714 | JSOI2022 考前模拟赛 做题笔记</title>
      <link href="/archives/20220714_mock/"/>
      <url>/archives/20220714_mock/</url>
      
        <content type="html"><![CDATA[<h4 id="奶牛式乘法"><a href="#奶牛式乘法" class="headerlink" title="奶牛式乘法"></a>奶牛式乘法</h4><p>题目很简单，就是每位数字相乘做加法。</p><p>下列描述中，均将两个数字 $A,B$ 分别用字符串 $S,T$ 表示，$n&#x3D;\left|S\right|,m&#x3D;\left|T\right|$。</p><p>很显然，有一种 $\mathcal O(nm)$ 的写法，直接模拟题意。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;string a,b;<span class="type">int</span> ans;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;cin&gt;&gt;a&gt;&gt;b;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;b.<span class="built_in">size</span>();j++)&#123;ans+=(<span class="type">int</span>)(a[i]-<span class="string">&#x27;0&#x27;</span>)*(<span class="type">int</span>)(b[j]-<span class="string">&#x27;0&#x27;</span>);&#125;&#125;cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p>当然，我们做一个乘法分配律的逆运用。</p><p>$S_1\times T_1 + S1 \times T_2 + \dots +S_n\times T_1 + S_n \times \dots + S_n\times T_m$。</p><p>然后会发现，上式即为 $(S_1+\dots+S_n)\times T_1+(S_1+\dots+S_n)\times T_2+\dots +(S_1+\dots+S_n)\times T_m$。</p><p>再次合并，即为 $(S_1+\dots +S_n)\times (T_1+\dots+T_m)$，也就是数字和相乘。</p><p>复杂度仅为 $\mathcal O(n+m)$。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;string a,b;<span class="type">int</span> suma,sumb;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;cin&gt;&gt;a&gt;&gt;b;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;suma+=a[i]-<span class="string">&#x27;0&#x27;</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;b.<span class="built_in">size</span>();i++)&#123;sumb+=b[i]-<span class="string">&#x27;0&#x27;</span>;&#125;cout&lt;&lt;suma*sumb&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p>最后提供一种 $\mathcal O(1)$ 的写法：</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;string a,b;<span class="type">int</span> suma,sumb;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;cin&gt;&gt;a&gt;&gt;b;    <span class="keyword">if</span>(a==<span class="string">&quot;1&quot;</span>)    &#123;        <span class="keyword">if</span>(b==<span class="string">&quot;1&quot;</span>)<span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);        <span class="keyword">else</span> <span class="keyword">if</span>(b==<span class="string">&quot;2&quot;</span>)<span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);        <span class="keyword">else</span> ....        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);    &#125;    <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">&quot;2&quot;</span>)    &#123;        ...    &#125;    <span class="keyword">else</span>    &#123;        ...    &#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p>没事，一共才 $10^9 \times 10^9&#x3D;10^{18}$ 次打表（（（</p><h4 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a><a href="/problem/20220714/str">回文串</a></h4><p>双指针，分类讨论。</p><p>对于对应的两个字符，有一下情况：</p><ul><li><p>$s_l&#x3D;\tt{*}$</p><ul><li><p>$s_r&#x3D;\tt{*}$</p><p>为了字典序最小，我们选择最小的 $\tt{A}$。</p></li><li><p>$s_r \neq \tt{*}$</p><p>为了保持回文，我们把 $s_l$ 换为 $s_r$。</p></li></ul></li><li><p>$s_r&#x3D;\tt{*}$</p><ul><li><p>$s_l&#x3D;\tt{*}$</p><p>为了字典序最小，我们选择最小的 $\tt{A}$。</p></li><li><p>$s_l \neq \tt{*}$</p><p>为了保持回文，我们把 $s_r$ 换为 $s_l$。</p></li></ul></li><li><p>上述条件均不满足</p><ul><li>无解。</li></ul></li></ul><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;string s;<span class="type">int</span> len,l,r;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;cin&gt;&gt;s;len=s.<span class="built_in">size</span>();l=<span class="number">0</span>;r=len<span class="number">-1</span>;<span class="keyword">while</span>(l&lt;r)&#123;<span class="keyword">if</span>(s[l]==<span class="string">&#x27;*&#x27;</span>)&#123;<span class="keyword">if</span>(s[r]==<span class="string">&#x27;*&#x27;</span>)&#123;s[l]=s[r]=<span class="string">&#x27;a&#x27;</span>;&#125;<span class="keyword">else</span>&#123;s[l]=s[r];&#125;&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[r]==<span class="string">&#x27;*&#x27;</span>)&#123;<span class="keyword">if</span>(s[l]==<span class="string">&#x27;*&#x27;</span>)&#123;s[l]=s[r]=<span class="string">&#x27;a&#x27;</span>;&#125;<span class="keyword">else</span>&#123;s[r]=s[l];&#125;&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[l]!=s[r])&#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;l++;r--;&#125;cout&lt;&lt;s&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>很明显是道贪心，优先选择 $6$ 个的，其次 $5$ 个，最后 $4$ 个。</p><p>可以想一下，这个选择与价值对比：</p><table><thead><tr><th>花费</th><th>价值</th><th>单个价值</th></tr></thead><tbody><tr><td>$6$</td><td>$4$</td><td>$\frac{2}{3}&#x3D;0.666\dots$</td></tr><tr><td>$5$</td><td>$2$</td><td>$\frac{2}{5}&#x3D;0.4$</td></tr><tr><td>$4$</td><td>$1$</td><td>$\frac{1}{4}&#x3D;0.25$</td></tr></tbody></table><p><del>当然我不会贪心正确性证明</del></p><p><del>我为啥不去问？别人不理我</del></p><p>代码如下：</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="meta">#<span class="keyword">define</span> min(a,b) (a&gt;b?b:a)</span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">10</span>];<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;<span class="type">int</span> minn=INT_MAX,cnt=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)&#123;cin&gt;&gt;a[i];cnt+=(a[i]!=<span class="number">0</span>);&#125;<span class="keyword">while</span>(<span class="number">1</span>)&#123;minn=INT_MAX;cnt=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)&#123;<span class="keyword">if</span>(a[i]!=<span class="number">0</span>)minn=<span class="built_in">min</span>(minn,a[i]),cnt++;&#125;<span class="keyword">if</span>(cnt&lt;<span class="number">4</span>)<span class="keyword">break</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)&#123;<span class="keyword">if</span>(a[i]==<span class="number">0</span>)<span class="keyword">continue</span>;a[i]-=minn;&#125;<span class="keyword">if</span>(cnt==<span class="number">6</span>)ans+=<span class="number">4</span>*minn;<span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">5</span>)ans+=<span class="number">2</span>*minn;<span class="keyword">else</span> ans+=minn;&#125;cout&lt;&lt;ans&lt;&lt;endl;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> t;cin&gt;&gt;t;<span class="keyword">while</span>(t--)&#123;<span class="built_in">solve</span>();&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="流星雨"><a href="#流星雨" class="headerlink" title="流星雨"></a>流星雨</h4><p>bfs。</p><p>先把陨石投放时间记一下，然后 bfs Bessie 位置，如果那个地方没有陨石就输出，反之继续把位置入队。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> x,y,t;&#125;;<span class="type">int</span> mp[<span class="number">500</span>][<span class="number">500</span>],z;<span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;<span class="type">int</span> dy[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;queue&lt;node&gt;q;<span class="type">bool</span> vis[<span class="number">500</span>][<span class="number">500</span>];<span class="function"><span class="type">bool</span> <span class="title">in</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><span class="function"></span>&#123;<span class="keyword">return</span> !vis[x][y]&amp;&amp;<span class="number">0</span>&lt;=x&amp;&amp;<span class="number">0</span>&lt;=y;&#125;<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> t)</span></span><span class="function"></span>&#123;mp[x][y]=<span class="built_in">min</span>(t,mp[x][y]);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;<span class="type">int</span> X=x+dx[i],Y=y+dy[i];<span class="keyword">if</span>(X&gt;=<span class="number">0</span>&amp;&amp;Y&gt;=<span class="number">0</span>)mp[X][Y]=<span class="built_in">min</span>(t,mp[X][Y]);&#125;&#125;<span class="function"><span class="type">void</span> <span class="title">walk</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> t)</span></span><span class="function"></span>&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;<span class="type">int</span> X=x+dx[i],Y=y+dy[i];<span class="keyword">if</span>(<span class="built_in">in</span>(X,Y))&#123;vis[X][Y]=<span class="number">1</span>;<span class="keyword">if</span>(mp[X][Y]==z)&#123;cout&lt;&lt;t<span class="number">+1</span>&lt;&lt;endl;<span class="built_in">exit</span>(<span class="number">0</span>);&#125;<span class="keyword">if</span>(mp[X][Y]&gt;t<span class="number">+1</span>)&#123;q.<span class="built_in">push</span>(&#123;X,Y,t<span class="number">+1</span>&#125;);&#125;&#125;&#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">memset</span>(mp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(mp));<span class="type">int</span> n,x=<span class="number">0</span>,y=<span class="number">0</span>;z=mp[<span class="number">0</span>][<span class="number">0</span>];cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> x,y,t;cin&gt;&gt;x&gt;&gt;y&gt;&gt;t;<span class="built_in">f</span>(x,y,t);&#125;q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;node u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();vis[u.x][u.y]=<span class="number">1</span>;<span class="built_in">walk</span>(u.x,u.y,u.t);&#125;cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h4><p><del>推导的注释比代码长，谁知道我经历了什么</del></p><p>我们可以反着考虑。</p><p>不太好解释，直接放过程。</p><pre><code class="highlight basic"><span class="symbol">6 </span><span class="number">6</span> <span class="number">6</span><span class="symbol">6 </span><span class="number">6</span> <span class="number">3</span><span class="symbol">6 </span><span class="number">4</span> <span class="number">3</span><span class="symbol">3 </span><span class="number">4</span> <span class="number">3</span><span class="symbol">3 </span><span class="number">3</span> <span class="number">3</span><span class="symbol">22 </span><span class="number">22</span> <span class="number">22</span><span class="symbol">13 </span><span class="number">16</span> <span class="number">22</span><span class="symbol">10 </span><span class="number">13</span> <span class="number">16</span><span class="symbol">04 </span><span class="number">10</span> <span class="number">13</span> <span class="symbol">04 </span><span class="number">07</span> <span class="number">10</span> <span class="symbol">04 </span><span class="number">04</span> <span class="number">07</span><span class="symbol">04 </span><span class="number">04</span> <span class="number">04</span></code></pre><p>那么代码如下</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> x,y,a,b,c,cur,cnt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;cin&gt;&gt;x&gt;&gt;y;<span class="keyword">if</span>(x==y)&#123;cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;a=b=c=y;<span class="keyword">while</span>(a!=x||b!=x||c!=x)&#123;cnt++;<span class="keyword">if</span>(a&gt;b)<span class="built_in">swap</span>(a,b);<span class="keyword">if</span>(b&gt;c)<span class="built_in">swap</span>(b,c);<span class="keyword">if</span>(a&gt;b)<span class="built_in">swap</span>(a,b);a=b+c<span class="number">-1</span>;<span class="keyword">if</span>(a&gt;x)a=x;&#125;cout&lt;&lt;cnt&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="路面修整"><a href="#路面修整" class="headerlink" title="路面修整"></a>路面修整</h4>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC260 做题笔记</title>
      <link href="/archives/ABC260/"/>
      <url>/archives/ABC260/</url>
      
        <content type="html"><![CDATA[<h3 id="abc260-a"><a href="#abc260-a" class="headerlink" title="abc260_a"></a><a href="https://atcoder.jp/contests/abc260/tasks/abc260_a">abc260_a</a></h3><h4 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>聊天聊过头晚开题我是什么品种的制杖。</p><p>有一个长度为 $3$ 的字符串 $s$，问 $s$ 中只出现一次的字符是什么，没有输出 $-1$。</p><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>建一个数组存放每个小写字母出现次数，最后扫一遍。</p><h4 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="string">&#x27;z&#x27;</span><span class="number">+1</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;string s;cin&gt;&gt;s;a[s[<span class="number">0</span>]]++;a[s[<span class="number">1</span>]]++;a[s[<span class="number">2</span>]]++;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="string">&#x27;a&#x27;</span>;i&lt;=<span class="string">&#x27;z&#x27;</span>;i++)&#123;<span class="keyword">if</span>(a[i]==<span class="number">1</span>)&#123;cout&lt;&lt;<span class="built_in">char</span>(i)&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;&#125;cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc260-b"><a href="#abc260-b" class="headerlink" title="abc260_b"></a><a href="https://atcoder.jp/contests/abc260/tasks/abc260_b">abc260_b</a></h3><h4 id="题目翻译-1"><a href="#题目翻译-1" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>忘了 <code>greater&lt;pair&lt;int,int&gt;&gt;()</code> 对 <code>second</code> 也从大到小排序我是什么品种的制杖。</p><p>有 $n$ 个学生，第 $i$ 个学生数学成绩 $a_i$，英语成绩 $b_i$。</p><p>选取数学成绩前 $x$ 个，英语成绩前 $y$ 个，总成绩前 $z$ 个学生录取，一位同学若录取多次，资格顺延。</p><p>问录取了哪些学生。</p><h4 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h4><p>结构体排序，存放数学、英语、总分、学号。</p><p>或者和我一样，写几个 <code>pair</code> 储存。</p><h4 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;a[<span class="number">1005</span>];pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;b[<span class="number">1005</span>];pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;c[<span class="number">1005</span>];set&lt;<span class="type">int</span>&gt;ans;<span class="type">bool</span> f[<span class="number">1005</span>];<span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;b)</span></span><span class="function"></span>&#123;<span class="keyword">if</span>(a.first!=b.first)<span class="keyword">return</span> a.first&gt;b.first;<span class="keyword">return</span> a.second&lt;b.second;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,x,y,z;cin&gt;&gt;n&gt;&gt;x&gt;&gt;y&gt;&gt;z;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i].first;a[i].second=i;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;b[i].first;b[i].second=i;c[i].first=a[i].first+b[i].first;c[i].second=i;&#125;<span class="built_in">sort</span>(a<span class="number">+1</span>,a+n<span class="number">+1</span>,cmp);<span class="built_in">sort</span>(b<span class="number">+1</span>,b+n<span class="number">+1</span>,cmp);<span class="built_in">sort</span>(c<span class="number">+1</span>,c+n<span class="number">+1</span>,cmp);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)&#123;<span class="keyword">if</span>(!f[a[i].second])&#123;f[a[i].second]=<span class="number">1</span>;ans.<span class="built_in">insert</span>(a[i].second);&#125;<span class="keyword">else</span>&#123;x++;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=y;i++)&#123;<span class="keyword">if</span>(!f[b[i].second])&#123;f[b[i].second]=<span class="number">1</span>;ans.<span class="built_in">insert</span>(b[i].second);&#125;<span class="keyword">else</span>&#123;y++;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=z;i++)&#123;<span class="keyword">if</span>(!f[c[i].second])&#123;f[c[i].second]=<span class="number">1</span>;ans.<span class="built_in">insert</span>(c[i].second);&#125;<span class="keyword">else</span>&#123;z++;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i:ans)cout&lt;&lt;i&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc260-c"><a href="#abc260-c" class="headerlink" title="abc260_c"></a><a href="https://atcoder.jp/contests/abc260/tasks/abc260_c">abc260_c</a></h3><h4 id="题目翻译-2"><a href="#题目翻译-2" class="headerlink" title="题目翻译"></a>题目翻译</h4><p><code>check</code> 函数写错我是什么品种的制杖。</p><p><del>你一开始有一个红 Buff，可以减速敌人并且打出真伤。可以和队友交换能减 CD 回蓝量的蓝 Buff。</del></p><p>每个 $m$ 级红宝石，可兑换 $1$ 个 $m-1$ 级红宝石<strong>和</strong> $x$ 个 $m$ 级蓝宝石。</p><p>每个 $m$ 级蓝宝石，可兑换 $1$ 个 $m-1$ 级红宝石<strong>和</strong> $y$ 个 $m-1$ 级蓝宝石。</p><p>你有一个 $n$ 级红色宝石，问最多能换几个蓝宝石。</p><h4 id="题目思路-2"><a href="#题目思路-2" class="headerlink" title="题目思路"></a>题目思路</h4><p>换最多的蓝宝石，必定是 $1$ 级蓝宝石。</p><p>循环操作兑换过程即可。</p><h4 id="AC-代码-2"><a href="#AC-代码-2" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">long</span> <span class="type">long</span> red[<span class="number">20</span>];<span class="type">long</span> <span class="type">long</span> blue[<span class="number">20</span>];<span class="type">int</span> n,x,y;<span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">10</span>;i++)&#123;<span class="keyword">if</span>(blue[i]||red[i])<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;red[n]++;<span class="keyword">while</span>(!<span class="built_in">check</span>())&#123;<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">2</span>;i--)&#123;<span class="type">long</span> <span class="type">long</span> z=red[i];red[i]-=z;red[i<span class="number">-1</span>]+=z;blue[i]+=z*x;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">2</span>;i--)&#123;<span class="type">long</span> <span class="type">long</span> z=blue[i];blue[i]-=z;blue[i<span class="number">-1</span>]+=z*y;red[i<span class="number">-1</span>]+=z;&#125;&#125;cout&lt;&lt;blue[<span class="number">1</span>]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc260-d"><a href="#abc260-d" class="headerlink" title="abc260_d"></a><a href="https://atcoder.jp/contests/abc260/tasks/abc260_d">abc260_d</a></h3><h4 id="题目翻译-3"><a href="#题目翻译-3" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>看错输出 21:39 发现并交代码我是什么品种的制杖。</p><p>有 $n$ 张牌 $p_1,p_2,p_3,\dots,p_n$，$p$ 是 $n$ 的排列。</p><p>维护若干个牌堆，执行以下操作：</p><ul><li>如果所有牌堆堆顶都比 $p_i$ 小，新开牌堆并把 $p_i$ 当堆顶。</li><li>如果有牌堆堆顶比 $p_i$ 大，$p_i$ 放在比它大的最小的牌堆堆顶那一个牌堆。</li><li>如果某个牌堆数量到了 $k$，永远不放牌了并且这个牌堆的牌的答案为 $i$。</li></ul><h4 id="题目思路-3"><a href="#题目思路-3" class="headerlink" title="题目思路"></a>题目思路</h4><p>I love set.</p><p>用 STL 中的 <code>set</code>。</p><p>每次暴力找牌堆堆顶是不可取的，把这些牌堆存进 <code>set</code> 并二分这个牌堆。</p><p>其他的按题意说的操作即可。</p><h4 id="AC-代码-3"><a href="#AC-代码-3" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">200005</span>];<span class="type">int</span> fa[<span class="number">200005</span>],id,c[<span class="number">200005</span>],d[<span class="number">200005</span>];<span class="type">bool</span> f[<span class="number">200005</span>];<span class="type">int</span> ans[<span class="number">200005</span>];set&lt;<span class="type">int</span>&gt;s;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];<span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>||a[i]&gt;*s.<span class="built_in">rbegin</span>())&#123;s.<span class="built_in">insert</span>(a[i]);id++;fa[a[i]]=id;c[id]=a[i];d[id]++;<span class="keyword">if</span>(d[id]==k)&#123;f[id]=<span class="number">1</span>;ans[id]=i;s.<span class="built_in">erase</span>(a[i]);&#125;&#125;<span class="keyword">else</span>&#123;<span class="keyword">auto</span> it=s.<span class="built_in">upper_bound</span>(a[i]);<span class="type">int</span> x=fa[*it];<span class="keyword">if</span>(f[x]==<span class="number">1</span>)&#123;<span class="keyword">continue</span>;&#125;c[x]=a[i];d[x]++;fa[a[i]]=x;s.<span class="built_in">erase</span>(it);s.<span class="built_in">insert</span>(a[i]);<span class="keyword">if</span>(d[x]==k)&#123;f[x]=<span class="number">1</span>;ans[x]=i;s.<span class="built_in">erase</span>(a[i]);&#125;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cout&lt;&lt;(ans[fa[i]]==<span class="number">0</span>?<span class="number">-1</span>:ans[fa[i]])&lt;&lt;endl;&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[游记] 信息与未来 2022 游记</title>
      <link href="/archives/JSOI2022/"/>
      <url>/archives/JSOI2022/</url>
      
        <content type="html"><![CDATA[<p>JSOI&#x3D;信息与未来，非 JS 省选。</p><h3 id="2022-7-15"><a href="#2022-7-15" class="headerlink" title="2022.7.15"></a>2022.7.15</h3><p>群里早就约好了面基时间地点，还有一天就面基啦！</p><h3 id="2022-7-16"><a href="#2022-7-16" class="headerlink" title="2022.7.16"></a>2022.7.16</h3><p>九点半出了地铁。</p><p>九点四十就开始排队了，大家太积极了。</p><p>等了半个多小时，捕捉了一只野生 cyc。</p><p>PS：可惜了，几年前的手机拍照延迟过高，大头照没拍到几张清楚的。</p><p>又过了一会儿，同班同学也来了。</p><p>可惜我们<a href="https://www.luogu.com.cn/user/400269">珂爱的佳雨小姐姐</a>上午在家内卷写作业呢，下午才来。</p><p><a href="https://www.luogu.com.cn/user/556205">IOIAKer Public</a>也有课，中午才能main&#x2F;kk。</p><p>中午去吃了个饭，<del>顺便玩了一会儿 pie.ai。</del></p><p>吃完饭就进去了呢。</p><p>一起坐在休息室，也就是 scz 的阶梯教室。</p><p>又 main 到了 IOIAKer Public 和 佳雨小姐姐还有 <a href="https://www.luogu.com.cn/user/426624">神犇lzx</a> 以及 <a href="https://www.luogu.com.cn/user/525255">CZOI rk.1 柏巨佬</a>。</p><p>还有好多好多初次 main 到的。</p><p>main 完就比赛了 QwQ。</p><p>P1：一眼丁真，鉴定为数位 dp。（但其实数据规模不大，只是个暴力。</p><p>P2：一眼丁真，鉴定为搜索基础题。（就我 dfs 出错改 bfs，别人咋又暴力过了。</p><p>P3：一眼丁真，鉴定为双指针。（虽然我想到了一种能卡掉我想法的数据。</p><p>P4：一眼丁真，鉴定为我不会的东西。（但我瞎写写出了 12pts&#x2F;jk。</p><p>P5：一眼丁真，鉴定为我不会的东西。（交互+mathler，WC2022T3 复现了属于是。</p><p>P6：一眼丁真，鉴定为我不会的东西。（输出俄罗斯方块摆放位置以通关，真毒瘤！<del>最后两分钟交代码，没编译就交了结果少打一个分号 CE&#x2F;kk</del>。</p><p>最终得分：15pts+15pts+12pts+12pts+2pts+0pts，合计 56pts。</p><p>还好别人赛前问我和第一能差多少分，我说肯定不超过 50pts，<del>但 tm 谁知道 zxx 还能 ak 啊</del>，差了 44pts，差点真差了 50pts。</p><h3 id="2022-7-17"><a href="#2022-7-17" class="headerlink" title="2022.7.17"></a>2022.7.17</h3><p>中午出成绩了。</p><p>全市第四，但按 NJ 的水准，排二十多个去了。</p><p>我就是个废物。</p>]]></content>
      
      
      <categories>
          
          <category> TravelNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1010B Rocket</title>
      <link href="/archives/CF1010B/"/>
      <url>/archives/CF1010B/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>有一个数 $x$，你可以询问<strong>至多</strong> $60$ 次，每次会返回 $0,1,-1$ 中的任意一个数。 $1$ 代表询问的数 $&gt;x$，$-1$ 代表询问的数 $&lt;x$，$0$ 代表询问的数 $&#x3D;x$。</p><p>有时候可能会返回错误的信息，可能会 $1$ 和 $-1$ 交换。但相等时，是不会返回错误信息的。信息返回的周期长度为 $n$。</p><p>本题注意事项：</p><ul><li><p>得到 $0$ 或 $-1$ 返回时，立即终止程序。</p></li><li><p>本题是交互题，输出后需要 <code>fflush(stdout);</code>（C++ 之外的语言请自行查看原题面）。</p></li></ul><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>至多 $60$ 次，范围在 $1\leq x\leq 1\times 10^9$ 内，明显是二分。</p><p>已知一个三十二位有符号整数（C++ 的 <code>int</code>）上限为 $2^{31}-1&#x3D;2,147,483,647$，所以二分算法最坏情况大约要 $30$ 次查询。</p><p>但这还不够，我们要知道，每次返回是正确的还是错误的。正好 $n\leq 30$，加上二分次数正好 $60$。</p><p>我们查询 $n$ 次，每次询问 $1$。$1$ 只可能返回 $1$ 或 $0$，那么 $-1$ 即为错误的。</p><p>知道了每次信息是否正确，就能进行二分了。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">bool</span> f[<span class="number">50</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n, m, cnt = <span class="number">0</span>;    cin &gt;&gt; m &gt;&gt; n;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)    &#123;        cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;        <span class="built_in">fflush</span>(stdout);        <span class="type">int</span> x;        cin &gt;&gt; x;        <span class="keyword">if</span> (x == <span class="number">-1</span>)            f[i] = <span class="number">0</span>;        <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">1</span>)            f[i] = <span class="number">1</span>;        <span class="keyword">else</span>            <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="type">int</span> mid, x, l = <span class="number">2</span>, r = m;    <span class="keyword">while</span> (l &lt;= r)    &#123;        cnt %= n;        mid = (l + r) / <span class="number">2</span>;        cout &lt;&lt; mid &lt;&lt; endl;        <span class="built_in">fflush</span>(stdout);        cin &gt;&gt; x;        <span class="keyword">if</span> (f[cnt] == <span class="number">0</span> &amp;&amp; x == <span class="number">-1</span> || f[cnt] == <span class="number">1</span> &amp;&amp; x == <span class="number">1</span>)            l = mid + <span class="number">1</span>;        <span class="keyword">else</span> <span class="keyword">if</span> (f[cnt] == <span class="number">0</span> &amp;&amp; x == <span class="number">1</span> || f[cnt] == <span class="number">1</span> &amp;&amp; x == <span class="number">-1</span>)            r = mid - <span class="number">1</span>;        <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">-2</span> || x == <span class="number">0</span>)            <span class="keyword">return</span> <span class="number">0</span>;        cnt++;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC258 做题笔记</title>
      <link href="/archives/ABC258/"/>
      <url>/archives/ABC258/</url>
      
        <content type="html"><![CDATA[<h3 id="abc258-a"><a href="#abc258-a" class="headerlink" title="abc258_a"></a><a href="https://atcoder.jp/contests/abc258/tasks/abc258_a">abc258_a</a></h3><h4 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>Atcoder 的 ABC 一般在东京时间 $\tt{21:00}$ 开始，持续 $100$ 分钟。</p><p>问开始后 $x$ 分钟后，是东京时间几点？</p><p>注意时和分有前导零。</p><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>随便写写，特判前导零，或者用 <code>printf</code>。</p><h4 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> k;cin&gt;&gt;k;cout&lt;&lt;<span class="number">21</span>+k/<span class="number">60</span>&lt;&lt;<span class="string">&quot;:&quot;</span>;<span class="keyword">if</span>(k%<span class="number">60</span>&lt;<span class="number">10</span>)cout&lt;&lt;<span class="number">0</span>&lt;&lt;k%<span class="number">60</span>;<span class="keyword">else</span> cout&lt;&lt;k%<span class="number">60</span>;cout&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc258-b"><a href="#abc258-b" class="headerlink" title="abc258_b"></a><a href="https://atcoder.jp/contests/abc258/tasks/abc258_b">abc258_b</a></h3><h4 id="题目翻译-1"><a href="#题目翻译-1" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有一个 $n\times n$ 的棋盘，你可以从某个点出发，向上、下、左、右、上左、上右、下左、下右八个方向走 $n-1$ 次。</p><blockquote><p>PS：这里写左上之类的是不是读起来更流畅。</p></blockquote><p>其中，你当前走这条路的收益，就是 $n$ 个点上的数字按经过顺序组成的数。</p><p>问收益最大是多少。</p><h4 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h4><p>$8$ 个方向扫。</p><p>可以直接写，也可以写 $dx[]&#x3D;…,dy[]&#x3D;…$。</p><p><del>题不在难，码量大则毒瘤。</del></p><blockquote><p>PS：我算什么品种的制杖，因为 stoi 参数爆 int 最后过才 B。</p></blockquote><h4 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">char</span> a[<span class="number">100</span>][<span class="number">100</span>];<span class="type">int</span> n;<span class="function">string <span class="title">U</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><span class="function"></span>&#123;<span class="type">int</span> x=n;string ret=<span class="string">&quot;&quot;</span>;<span class="keyword">for</span>(;x&gt;=<span class="number">1</span>;i--,x--)&#123;<span class="keyword">if</span>(i==<span class="number">0</span>)i=n;ret+=a[i][j];&#125;<span class="keyword">return</span> ret;&#125;<span class="function">string <span class="title">D</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><span class="function"></span>&#123;<span class="type">int</span> x=n;string ret=<span class="string">&quot;&quot;</span>;<span class="keyword">for</span>(;x&gt;=<span class="number">1</span>;i++,x--)&#123;<span class="keyword">if</span>(i==n<span class="number">+1</span>)i=<span class="number">1</span>;ret+=a[i][j];&#125;<span class="keyword">return</span> ret;&#125;<span class="function">string <span class="title">L</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><span class="function"></span>&#123;<span class="type">int</span> x=n;string ret=<span class="string">&quot;&quot;</span>;<span class="keyword">for</span>(;x&gt;=<span class="number">1</span>;j--,x--)&#123;<span class="keyword">if</span>(j==<span class="number">0</span>)j=n;ret+=a[i][j];&#125;<span class="keyword">return</span> ret;&#125;<span class="function">string <span class="title">R</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><span class="function"></span>&#123;<span class="type">int</span> x=n;string ret=<span class="string">&quot;&quot;</span>;<span class="keyword">for</span>(;x&gt;=<span class="number">1</span>;j++,x--)&#123;<span class="keyword">if</span>(j==n<span class="number">+1</span>)j=<span class="number">1</span>; ret+=a[i][j];&#125;<span class="keyword">return</span> ret;&#125;<span class="function">string <span class="title">UL</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><span class="function"></span>&#123;<span class="type">int</span> x=n;string ret=<span class="string">&quot;&quot;</span>;<span class="keyword">for</span>(;x&gt;=<span class="number">1</span>;i--,j--,x--)&#123;<span class="keyword">if</span>(i==<span class="number">0</span>)i=n;<span class="keyword">if</span>(j==<span class="number">0</span>)j=n;ret+=a[i][j];&#125;<span class="keyword">return</span> ret;&#125;<span class="function">string <span class="title">UR</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><span class="function"></span>&#123;<span class="type">int</span> x=n;string ret=<span class="string">&quot;&quot;</span>;<span class="keyword">for</span>(;x&gt;=<span class="number">1</span>;i--,j++,x--)&#123;<span class="keyword">if</span>(i==<span class="number">0</span>)i=n;<span class="keyword">if</span>(j==n<span class="number">+1</span>)j=<span class="number">1</span>;ret+=a[i][j];&#125;<span class="keyword">return</span> ret;&#125;<span class="function">string <span class="title">DL</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><span class="function"></span>&#123;<span class="type">int</span> x=n;string ret=<span class="string">&quot;&quot;</span>;<span class="keyword">for</span>(;x&gt;=<span class="number">1</span>;i++,j--,x--)&#123;<span class="keyword">if</span>(i==n<span class="number">+1</span>)i=<span class="number">1</span>;<span class="keyword">if</span>(j==<span class="number">0</span>)j=n;ret+=a[i][j];&#125;<span class="keyword">return</span> ret;&#125;<span class="function">string <span class="title">DR</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><span class="function"></span>&#123;<span class="type">int</span> x=n;string ret=<span class="string">&quot;&quot;</span>;<span class="keyword">for</span>(;x&gt;=<span class="number">1</span>;i++,j++,x--)&#123;<span class="keyword">if</span>(i==n<span class="number">+1</span>)i=<span class="number">1</span>;<span class="keyword">if</span>(j==n<span class="number">+1</span>)j=<span class="number">1</span>;ret+=a[i][j];&#125;<span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;cin&gt;&gt;a[i][j];&#125;&#125;<span class="type">long</span> <span class="type">long</span> ans=<span class="number">-1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;ans=<span class="built_in">max</span>(ans,<span class="built_in">stoll</span>(<span class="built_in">U</span>(i,j)));ans=<span class="built_in">max</span>(ans,<span class="built_in">stoll</span>(<span class="built_in">D</span>(i,j)));ans=<span class="built_in">max</span>(ans,<span class="built_in">stoll</span>(<span class="built_in">L</span>(i,j)));ans=<span class="built_in">max</span>(ans,<span class="built_in">stoll</span>(<span class="built_in">R</span>(i,j)));ans=<span class="built_in">max</span>(ans,<span class="built_in">stoll</span>(<span class="built_in">UL</span>(i,j)));ans=<span class="built_in">max</span>(ans,<span class="built_in">stoll</span>(<span class="built_in">UR</span>(i,j)));ans=<span class="built_in">max</span>(ans,<span class="built_in">stoll</span>(<span class="built_in">DL</span>(i,j)));ans=<span class="built_in">max</span>(ans,<span class="built_in">stoll</span>(<span class="built_in">DR</span>(i,j)));&#125;&#125;cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p>再赋另一种写法。</p><p>by @<a href="https://atcoder.jp/users/Factorio">Factorio</a>。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n;string s[<span class="number">10</span>], z;<span class="type">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;<span class="type">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;cin &gt;&gt; n;<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;cin &gt;&gt; s[i];&#125;<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)&#123;string t;<span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; n; l++)&#123;t += s[(i + dx[k] * l + n) % n][(j + dy[k] * l + n) % n];&#125;z = <span class="built_in">max</span>(z, t);&#125;&#125;&#125;cout &lt;&lt; z &lt;&lt; endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc258-c"><a href="#abc258-c" class="headerlink" title="abc258_c"></a><a href="https://atcoder.jp/contests/abc258/tasks/abc258_c">abc258_c</a></h3><h4 id="题目翻译-2"><a href="#题目翻译-2" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有长度为 $n$ 的字符串 $s$，有 $q$ 次操作。</p><p>操作 <code>1 x</code>，把 $s$ 的后 $x$ 个字符挪到前面。</p><p>操作 <code>2 x</code>，输出 $s$ 的第 $x$ 位。</p><h4 id="题目思路-2"><a href="#题目思路-2" class="headerlink" title="题目思路"></a>题目思路</h4><p>统计操作 <code>1 x</code>，$x$ 的和共有多少（下文与代码统称 $c$），<strong>不可以</strong>每次模拟。</p><p>统计出 $c$，看一下 $c \bmod n$ 和操作 <code>2 x</code> 的大小关系。</p><p>$\bmod n$ 是因为可能有移了超过 $n$ 次。</p><h4 id="AC-代码-2"><a href="#AC-代码-2" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,q,c=<span class="number">0</span>;string s;cin&gt;&gt;n&gt;&gt;q&gt;&gt;s;<span class="keyword">while</span>(q--)&#123;<span class="type">int</span> o;cin&gt;&gt;o;<span class="keyword">if</span>(o==<span class="number">1</span>)&#123;<span class="type">int</span> x;cin&gt;&gt;x;c+=x;c%=n;&#125;<span class="keyword">else</span>&#123;<span class="type">int</span> y=n-c;<span class="type">int</span> x;cin&gt;&gt;x;<span class="keyword">if</span>(x&lt;=c)&#123;cout&lt;&lt;s[y<span class="number">-1</span>+x]&lt;&lt;endl;&#125;<span class="keyword">else</span>&#123;x-=c;cout&lt;&lt;s[x<span class="number">-1</span>]&lt;&lt;endl;&#125;&#125;&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc258-d"><a href="#abc258-d" class="headerlink" title="abc258_d"></a><a href="https://atcoder.jp/contests/abc258/tasks/abc258_d">abc258_d</a></h3><h4 id="题目翻译-3"><a href="#题目翻译-3" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有 $n$ 个关卡，第 $i$ 关，第一次通过需要 $a_i+b_i$ 时间，之后只需 $b_i$ 时间。</p><p>只有通过 $i-1$ 的关卡才可游玩 $i$ 关。</p><p>问过 $x$ 关，至少需要多少时间。</p><h4 id="题目思路-3"><a href="#题目思路-3" class="headerlink" title="题目思路"></a>题目思路</h4><p>我们最后一定是重复过<strong>最后通过的一关</strong>。</p><p>然后枚举最后打哪一关。</p><h4 id="AC-代码-3"><a href="#AC-代码-3" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">using</span> <span class="keyword">namespace</span> std;ll a[<span class="number">200005</span>],b[<span class="number">200005</span>],c[<span class="number">200005</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;ll n,x;cin&gt;&gt;n&gt;&gt;x;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i]&gt;&gt;b[i];c[i]=c[i<span class="number">-1</span>]+a[i]+b[i];&#125;ll ans=<span class="number">9e18</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;ll y=i<span class="number">-1</span>;<span class="keyword">if</span>(y&gt;=x)&#123;ans=<span class="built_in">min</span>(ans,c[i<span class="number">-1</span>]);&#125;<span class="keyword">else</span>&#123;ll z=x-y,cnt=c[i<span class="number">-1</span>];z--;cnt+=a[i]+b[i];cnt+=z*b[i];ans=<span class="built_in">min</span>(ans,cnt);&#125;&#125;cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC257 做题笔记</title>
      <link href="/archives/ABC257/"/>
      <url>/archives/ABC257/</url>
      
        <content type="html"><![CDATA[<p>由于作者代码风格有变，头文件较长，以下代码均舍去头文件。</p><h3 id="abc257-a"><a href="#abc257-a" class="headerlink" title="abc257_a"></a><a href="https://atcoder.jp/contests/abc257/tasks/abc257_a">abc257_a</a></h3><h4 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>给定一个 $n$，生成一个字符串，内容为 $n$ 个 $\tt{A}$，$n$ 个 $\tt{B}$，一直到 $n$ 个 $\tt{Z}$。</p><p>输出第 $k$ 位。</p><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>直接模拟到第 $n$ 位。</p><p>这是最暴力的写法。</p><p>也可以用数学知识算一下当前是哪个字符。</p><p>我采用了最暴力的。</p><h4 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n, x, cnt = <span class="number">0</span>;    cin &gt;&gt; n &gt;&gt; x;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)        &#123;            cnt++;            <span class="keyword">if</span> (cnt == x)            &#123;                cout &lt;&lt; <span class="built_in">char</span> (i + <span class="string">&#x27;A&#x27;</span> - <span class="number">1</span>) &lt;&lt; endl;                <span class="keyword">return</span> <span class="number">0</span>;            &#125;        &#125;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc257-b"><a href="#abc257-b" class="headerlink" title="abc257_b"></a><a href="https://atcoder.jp/contests/abc257/tasks/abc257_b">abc257_b</a></h3><h4 id="题目翻译-1"><a href="#题目翻译-1" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有个长度为 $n$ 的道路，第 $a_i$ 个位置上有一个士兵。</p><p>有 $Q$ 次操作，第 $i$ 次操作将第 $l_i$ 个士兵往右一位。</p><p>如果自己是最后一个位置或者右边有人，不移动。</p><p>输出士兵位置。</p><h4 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h4><p>模拟。</p><p>由于 $n\leq100,Q \leq1000$，每次扫一遍不超时。</p><h4 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="type">int</span> a[<span class="number">205</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n, k, q;    cin &gt;&gt; n &gt;&gt; k &gt;&gt; q;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)    &#123;        <span class="type">int</span> x;        cin &gt;&gt; x;        a[x] = <span class="number">1</span>;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)    &#123;        <span class="type">int</span> l, cnt = <span class="number">0</span>;        cin &gt;&gt; l;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)        &#123;            <span class="keyword">if</span> (a[j] == <span class="number">1</span>)            &#123;                cnt++;            &#125;            <span class="keyword">if</span> (cnt == l)            &#123;                <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= n &amp;&amp; a[j + <span class="number">1</span>] != <span class="number">1</span>)                &#123;                    a[j] = <span class="number">0</span>;                    a[j + <span class="number">1</span>] = <span class="number">1</span>;                &#125;            &#125;        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">if</span> (a[i] == <span class="number">1</span>)        &#123;            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;        &#125;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc257-c"><a href="#abc257-c" class="headerlink" title="abc257_c"></a><a href="https://atcoder.jp/contests/abc257/tasks/abc257_c">abc257_c</a></h3><h4 id="题目翻译-2"><a href="#题目翻译-2" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有 $n$ 个人，每个人有个体重 $w_i$，以及 $\tt{0}$ 代表他是小孩，$\tt{1}$ 代表成人。</p><p>我们认为，比 $X$ 轻的是小孩，反之是成人。</p><p>请选择一个 $X$，使身份匹配正确的人数最多。</p><h4 id="题目思路-2"><a href="#题目思路-2" class="headerlink" title="题目思路"></a>题目思路</h4><p>把这些人按体重排序，相同体重成人在前。</p><p>统计这里一共多少成人。</p><p>对于每个 $[1,i]$ 的区间，算一下类似前缀和的操作。</p><p>是小孩，之前统计的加 $1$，反之 $-1$。</p><h4 id="AC-代码-2"><a href="#AC-代码-2" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;    <span class="type">bool</span> f;    <span class="type">int</span> w;&#125; a[<span class="number">200005</span>];<span class="function"><span class="type">bool</span> <span class="title">cmp</span> <span class="params">(node x, node y)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (x.w == y.w)    &#123;        <span class="keyword">return</span> x.f &gt; y.f;    &#125;    <span class="keyword">return</span> x.w &lt; y.w;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n, ch = <span class="number">0</span>, ans;    cin &gt;&gt; n;    <span class="type">char</span> c;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        cin &gt;&gt; c;        <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>)        &#123;            a[i].f = <span class="number">0</span>;        &#125;        <span class="keyword">else</span>        &#123;            a[i].f = <span class="number">1</span>;            ch++;        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        cin &gt;&gt; a[i].w;    &#125;    <span class="built_in">sort</span> (a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);    ans = ch;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">if</span> (a[i].f == <span class="number">0</span>)        &#123;            ch++;        &#125;        <span class="keyword">else</span>        &#123;            ch--;        &#125;        ans = <span class="built_in">max</span> (ans, ch);    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc257-d"><a href="#abc257-d" class="headerlink" title="abc257_d"></a><a href="https://atcoder.jp/contests/abc257/tasks/abc257_d">abc257_d</a></h3><h4 id="题目翻译-3"><a href="#题目翻译-3" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有 $n$ 个蹦床，每个蹦床坐标为 $(x_i,y_i)$，并拥有主场 buff $p_i$ 加持。</p><p>（这样说是不是通俗易懂</p><p><strong>可以自选起点。</strong></p><p>如果从第 $i$ 个往第 $j$ 个跳，所需 $S\times p_i\geq \left|x_i-x_j\right|+\left|y_i-y_j\right|$ 的必备条件。</p><p>问 $S$ 最小多少。</p><h4 id="题目思路-3"><a href="#题目思路-3" class="headerlink" title="题目思路"></a>题目思路</h4><p>Floyd 最短路。</p><p>先求出从 $i$ 跳到 $j$ 的所需 $S$，再用 Floyd 做最短路，看经过中间过渡，能否缩小 $S$。</p><p>转移即为 $f_{i,j} &#x3D; \min(\max (f_{i,k}, f_{k,j}), f{i,j})$。</p><h4 id="AC-代码-3"><a href="#AC-代码-3" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp">ll x[<span class="number">205</span>], y[<span class="number">205</span>], p[<span class="number">205</span>];ll f[<span class="number">205</span>][<span class="number">205</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    ll n;    cin &gt;&gt; n;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; p[i];    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)        &#123;            ll s = <span class="built_in">abs</span> (x[i] - x[j]) + <span class="built_in">abs</span> (y[i] - y[j]);            <span class="keyword">if</span>(s%p[i]==<span class="number">0</span>)f[i][j]=s/p[i];            <span class="keyword">else</span> f[i][j]=s/p[i]<span class="number">+1</span>;        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        &#123;            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)            &#123;                f[i][j] = <span class="built_in">min</span> (<span class="built_in">max</span> (f[i][k], f[k][j]), f[i][j]);            &#125;        &#125;    &#125;    ll ans = <span class="number">1e20</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        ll x = <span class="number">-1e20</span>;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)        &#123;            x = <span class="built_in">max</span> (f[i][j], x);        &#125;        ans = <span class="built_in">min</span> (ans, x);    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc257-e"><a href="#abc257-e" class="headerlink" title="abc257_e"></a><a href="https://atcoder.jp/contests/abc257/tasks/abc257_e">abc257_e</a></h3><h4 id="题目翻译-4"><a href="#题目翻译-4" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有 $9$ 种数字，$1,2,\dots9$。</p><p>数字 $i$ 可以花 $c_i$ 的价格购买，你有 $n$ 元。</p><p>最后输出你购买的数字拼成的最大值。</p><h4 id="题目思路-4"><a href="#题目思路-4" class="headerlink" title="题目思路"></a>题目思路</h4><p>我们考虑，先让位数最大。</p><p>然后，再最大化最高位、次高位、次次高位，一直往下。</p><p>最大位数，即为用 $n$ 除以最便宜的价钱。</p><p>然后，你可能会有剩余的钱。</p><p>剩余的，我们开始置换。</p><p>从 $9$ 开始枚举，能换就换，并输出你置换的数字。</p><p>这样最大化了较高位，还保证位数没有变少。</p><p>具体可以品味下代码。</p><h4 id="AC-代码-4"><a href="#AC-代码-4" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="type">int</span> c[<span class="number">20</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n, mnc = INT_MAX, maxn;    cin &gt;&gt; n;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)    &#123;        cin &gt;&gt; c[i];        <span class="keyword">if</span> (c[i] &lt;= mnc)        &#123;            mnc = c[i];            maxn = i;        &#125;    &#125;    <span class="type">int</span> cnt = n / mnc;    <span class="type">int</span> x = <span class="number">0</span>, cnt2 = <span class="number">0</span>;    <span class="type">int</span> s = n - cnt * mnc;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">1</span>; i--)    &#123;        <span class="keyword">if</span> (i &gt; maxn)        &#123;            <span class="keyword">if</span> (c[i] - mnc &lt;= s)            &#123;                cnt2 = s / (c[i] - mnc);                cnt -= cnt2;                s%=c[i] - mnc;                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt2; j++)                &#123;                    cout &lt;&lt; i;                &#125;            &#125;        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)    &#123;        cout &lt;&lt; maxn;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC254 做题笔记</title>
      <link href="/archives/ABC254/"/>
      <url>/archives/ABC254/</url>
      
        <content type="html"><![CDATA[<h3 id="abc254-a"><a href="#abc254-a" class="headerlink" title="abc254_a"></a><a href="https://atcoder.jp/contests/abc254/tasks/abc254_a">abc254_a</a></h3><h4 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>输入一个数，输出它的后两位。</p><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p><code>int</code> 读入，要特判前导零。</p><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p><code>char</code> 读入，直接输出。</p><p>我写的是 <code>int</code> 读入。</p><h4 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n;    cin &gt;&gt; n;    <span class="keyword">if</span> (n / <span class="number">10</span> % <span class="number">10</span> == <span class="number">0</span>)    &#123;        cout &lt;&lt; <span class="number">0</span> &lt;&lt; n % <span class="number">10</span> &lt;&lt; endl;    &#125;    <span class="keyword">else</span>    &#123;        cout &lt;&lt; n % <span class="number">100</span> &lt;&lt; endl;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc254-b"><a href="#abc254-b" class="headerlink" title="abc254_b"></a><a href="https://atcoder.jp/contests/abc254/tasks/abc254_b">abc254_b</a></h3><h4 id="题目翻译-1"><a href="#题目翻译-1" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>杨辉三角。</p><h4 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h4><p>算得上 dp 初学入门题（？</p><p>状态转移方程：$dp_{i,j}&#x3D;dp_{i-1,j}+dp_{i-1,j-1}$。</p><p>特判一下 $n&#x3D;1$，$dp_{1,1}&#x3D;1$。</p><h4 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">35</span>][<span class="number">35</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n;    cin &gt;&gt; n;    a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;    cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)        &#123;            a[i][j] = a[i - <span class="number">1</span>][j] + a[i - <span class="number">1</span>][j - <span class="number">1</span>];            cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;        &#125;        cout &lt;&lt; endl;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc254-c"><a href="#abc254-c" class="headerlink" title="abc254_c"></a><a href="https://atcoder.jp/contests/abc254/tasks/abc254_c">abc254_c</a></h3><h4 id="题目翻译-2"><a href="#题目翻译-2" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>输入一个数组，只有下标之差<strong>恰好</strong>是 $k$ 的两个位置才能交换。<br>可以交换任意多次。<br>问能不能让数组变成升序。</p><h4 id="题目思路-2"><a href="#题目思路-2" class="headerlink" title="题目思路"></a>题目思路</h4><p>其实就是 $i \bmod k$ 相同的，可以互换。</p><p>我们考虑把这一串数组，按 $i\bmod k$ 的值，把它变成一个二维数组。</p><p>举个栗子：</p><pre><code class="highlight basic"><span class="symbol">10 </span><span class="number">3</span><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></code></pre><p>按 $i \bmod k$ 分类，即为：</p><pre><code class="highlight dns">等于<span class="number">1：1 4 7</span> <span class="number">10</span>等于<span class="number">2：2 5 8</span>等于<span class="number">0：3 6 9</span></code></pre><p>然后横向排列，最后组合在一起，形成一维数组。</p><p>如果组合起来是升序的，也就可以升序。</p><h4 id="AC-代码-2"><a href="#AC-代码-2" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">200005</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n, k;    cin &gt;&gt; n &gt;&gt; k;    vector&lt;<span class="type">int</span>&gt;v[k + <span class="number">5</span>];    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="type">int</span> x;        cin &gt;&gt; x;        v[i % k == <span class="number">0</span> ? k : i % k].<span class="built_in">push_back</span> (x);    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)    &#123;        <span class="built_in">sort</span> (v[i].<span class="built_in">begin</span>(), v[i].<span class="built_in">end</span>());        <span class="type">int</span> cnt = <span class="number">1</span>;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v[i].<span class="built_in">size</span>(); j++)        &#123;            a[cnt + i - <span class="number">1</span>] = v[i][j];            cnt += k;        &#125;    &#125;    <span class="built_in">puts</span> (<span class="built_in">is_sorted</span> (a + <span class="number">1</span>, a + n + <span class="number">1</span>) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc254-d"><a href="#abc254-d" class="headerlink" title="abc254_d"></a><a href="https://atcoder.jp/contests/abc254/tasks/abc254_d">abc254_d</a></h3><h4 id="题目翻译-3"><a href="#题目翻译-3" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>问有多少 $i,j$，$i,j\leq n$ 且 $i\times j$ 为完全平方数。</p><h4 id="题目思路-3"><a href="#题目思路-3" class="headerlink" title="题目思路"></a>题目思路</h4><p>很有趣的思维题。</p><p>我们考虑把每个完全平方数，看成 $x\times \gcd(i,j)\times y\times gcd(i,j)$。</p><p>当然，这里 $x$ 和 $y$ 也必须是完全平方数。</p><p>如果只是 $x\times y$ 是完全平方数，不是自己是完全平方数，还要拆干嘛？又回到第一步</p><blockquote><p>我们考虑把每个完全平方数，看成 $x\times \gcd(i,j)\times y\times gcd(i,j)$。</p></blockquote><p>了。</p><p>当然，这里的 $i&#x3D;x\times\gcd(i,j),j&#x3D;y\times\gcd(i,j)$。</p><p>显然，$\gcd(x,y)&#x3D;1$，不然这个最大公因数就求错了，不满足 $i&#x3D;x\times\gcd(i,j),j&#x3D;y\times\gcd(i,j)$。</p><p>所以，$x,y$ 分别为两个互质的完全平方数。</p><p>我们只需枚举 $x,y$。</p><p>枚举后，自然也会发现，这里的 $\gcd(i,j)$ 会有很多选择。</p><p>$\gcd(i,j)$ 最大的可能是 $\left\lfloor\dfrac{n}{\max(x,y)}\right\rfloor$。</p><p>所以，我们枚举每组 $x,y$，加上 $\left\lfloor\dfrac{n}{\max(x,y)}\right\rfloor$ 即为答案。</p><p>放个伪代码：</p><pre><code class="highlight stylus"><span class="function"><span class="title">for</span><span class="params">(<span class="number">1</span>~sqrt(n)</span></span>)生成完全平方数<span class="function"><span class="title">for</span><span class="params">(<span class="number">1</span>~完全平方数个数)</span></span><span class="built_in">for</span>(<span class="number">1</span>~完全平方数个数) <span class="built_in">if</span>(两个完全平方数互质)加上可能的gcd，也就是 n/较大的完全平方数</code></pre><h4 id="AC-代码-3"><a href="#AC-代码-3" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">1000</span>],sz;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;<span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)&#123;a[++sz]=i*i;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sz;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=sz;j++)&#123;<span class="keyword">if</span>(__gcd(a[i],a[j])==<span class="number">1</span>)&#123;ans+=n/<span class="built_in">max</span>(a[i],a[j]);&#125;&#125;&#125;cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc254-e"><a href="#abc254-e" class="headerlink" title="abc254_e"></a><a href="https://atcoder.jp/contests/abc254/tasks/abc254_e">abc254_e</a></h3><h4 id="题目翻译-4"><a href="#题目翻译-4" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>输入一个图，每个点度数至多是 $3$。<br>$Q$ 个询问，每次问到点 $x$ 的距离小于等于 $k$ 的点，所有点的标号之和。<br>$k$ 至多是 $3$。</p><h4 id="题目思路-4"><a href="#题目思路-4" class="headerlink" title="题目思路"></a>题目思路</h4><p>就是个搜索。</p><p>因为度数 $\leq 3$，所以每个点连接的点数不会超过 $40$。</p><p>但有个问题，正常搜索，需要 <code>vis</code> 数组，所以每次清空会超时。</p><p>我们考虑用一个 <code>set</code> 存下点坐标。</p><p>最后相加即为答案。</p><h4 id="AC-代码-4"><a href="#AC-代码-4" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;vector&lt;<span class="type">int</span>&gt;a[<span class="number">150005</span>];set&lt;<span class="type">int</span>&gt;vis;<span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> dep, <span class="type">int</span> k, <span class="type">int</span> x)</span></span><span class="function"></span>&#123;<span class="keyword">if</span> (dep &gt; k)    &#123;        <span class="keyword">return</span>;    &#125;    vis.<span class="built_in">insert</span> (x);    <span class="keyword">for</span> (<span class="keyword">auto</span> i : a[x])    &#123;        <span class="built_in">dfs</span> (dep + <span class="number">1</span>, k, i);    &#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n, m;    cin &gt;&gt; n &gt;&gt; m;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)    &#123;        <span class="type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        a[x].<span class="built_in">push_back</span> (y);        a[y].<span class="built_in">push_back</span> (x);    &#125;    <span class="type">int</span> q;    cin &gt;&gt; q;    <span class="keyword">while</span> (q--)    &#123;        vis.<span class="built_in">clear</span>();        <span class="type">int</span> x, k, ans = <span class="number">0</span>;        cin &gt;&gt; x &gt;&gt; k;        <span class="built_in">dfs</span> (<span class="number">0</span>, k, x);        <span class="keyword">for</span> (<span class="type">int</span> i : vis)        &#123;            ans += i;        &#125;        cout &lt;&lt; ans &lt;&lt; endl;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC253 做题笔记</title>
      <link href="/archives/ABC253/"/>
      <url>/archives/ABC253/</url>
      
        <content type="html"><![CDATA[<h3 id="abc253-a"><a href="#abc253-a" class="headerlink" title="abc253_a"></a><a href="https://atcoder.jp/contests/abc253/tasks/abc253_a">abc253_a</a></h3><h4 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>给定 $a,b,c$，问 $b$ 是不是中位数。</p><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>排序，判断。</p><h4 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> a, b, c, d;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;    d = b;    <span class="keyword">if</span> (a &gt; b)    &#123;        <span class="built_in">swap</span> (a, b);    &#125;    <span class="keyword">if</span> (b &gt; c)    &#123;        <span class="built_in">swap</span> (b, c);    &#125;    <span class="keyword">if</span> (a &gt; c)    &#123;        <span class="built_in">swap</span> (a, c);    &#125;    <span class="keyword">if</span> (a &gt; b)    &#123;        <span class="built_in">swap</span> (a, b);    &#125;    <span class="keyword">if</span> (b &gt; c)    &#123;        <span class="built_in">swap</span> (b, c);    &#125;    <span class="keyword">if</span> (a &gt; c)    &#123;        <span class="built_in">swap</span> (a, c);    &#125;    <span class="keyword">if</span> (b == d)    &#123;        <span class="built_in">puts</span> (<span class="string">&quot;Yes&quot;</span>);    &#125;    <span class="keyword">else</span>    &#123;        <span class="built_in">puts</span> (<span class="string">&quot;No&quot;</span>);    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc253-b"><a href="#abc253-b" class="headerlink" title="abc253_b"></a><a href="https://atcoder.jp/contests/abc253/tasks/abc253_b">abc253_b</a></h3><h4 id="题目翻译-1"><a href="#题目翻译-1" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>给定一个 $n\times m$ 的矩阵，找两个 <code>o</code> 之间的哈夫曼距离。</p><h4 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h4><p>按题意做即可。</p><h4 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n, m, i1, i2, j1, j2;    i1 = i2 = j1 = j2 = <span class="number">0</span>;    cin &gt;&gt; n &gt;&gt; m;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)        &#123;            <span class="type">char</span> c;            cin &gt;&gt; c;            <span class="keyword">if</span> (c == <span class="string">&#x27;o&#x27;</span>)            &#123;                <span class="keyword">if</span> (i1 == <span class="number">0</span>)                &#123;                    i1 = i;                    j1 = j;                &#125;                <span class="keyword">else</span>                &#123;                    i2 = i;                    j2 = j;                &#125;            &#125;        &#125;    &#125;    cout &lt;&lt; <span class="built_in">abs</span> (i1 - i2) + <span class="built_in">abs</span> (j1 - j2) &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc253-c"><a href="#abc253-c" class="headerlink" title="abc253_c"></a><a href="https://atcoder.jp/contests/abc253/tasks/abc253_c">abc253_c</a></h3><h4 id="题目翻译-2"><a href="#题目翻译-2" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有 $q$ 个询问。</p><p><code>1 x</code> 表示插入一个 $x$。</p><p><code>2 x c</code> 表示删去 $c$ 个 $x$，如果 $x$ 数量不够，删完。</p><p><code>3</code> 输出目前最大值减去最小值。</p><h4 id="题目思路-2"><a href="#题目思路-2" class="headerlink" title="题目思路"></a>题目思路</h4><p>用一个 <code>map</code> 存当前哪个数出现几次，当然，第二种操作需要 <code>erase</code>。</p><h4 id="AC-代码-2"><a href="#AC-代码-2" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> q;    cin &gt;&gt; q;    <span class="keyword">while</span> (q--)    &#123;        <span class="type">int</span> o;        cin &gt;&gt; o;        <span class="keyword">if</span> (o == <span class="number">1</span>)        &#123;            <span class="type">int</span> x;            cin &gt;&gt; x;            m[x]++;        &#125;        <span class="keyword">if</span> (o == <span class="number">2</span>)        &#123;            <span class="type">int</span> x, c;            cin &gt;&gt; x &gt;&gt; c;            m[x] = <span class="built_in">max</span> (m[x] - c, <span class="number">0</span>);            <span class="keyword">if</span> (m[x] == <span class="number">0</span>)            &#123;                <span class="keyword">auto</span> it = m.<span class="built_in">find</span> (x);                m.<span class="built_in">erase</span> (it);            &#125;        &#125;        <span class="keyword">if</span> (o == <span class="number">3</span>)        &#123;            cout &lt;&lt; (--m.<span class="built_in">end</span>())-&gt;first - m.<span class="built_in">begin</span>()-&gt;first &lt;&lt; endl;        &#125;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc253-d"><a href="#abc253-d" class="headerlink" title="abc253_d"></a><a href="https://atcoder.jp/contests/abc253/tasks/abc253_d">abc253_d</a></h3><h4 id="题目翻译-3"><a href="#题目翻译-3" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>问 $[1,n]$ 中不是 $a$ 的倍数或 $b$ 的倍数的数之和。</p><h4 id="题目思路-3"><a href="#题目思路-3" class="headerlink" title="题目思路"></a>题目思路</h4><p>容斥原理，答案就是 <code>总和-a的倍数和-b的倍数和+a和b最大公因数的倍数和</code>。</p><p>可以用等差数列。</p><p>以 $a$ 的倍数为例：</p><pre><code class="highlight bash">项数=n/a和=（首项+末项）*项数/2</code></pre><h4 id="AC-代码-3"><a href="#AC-代码-3" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    ll n, a, b;    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;    ll lcm = a / __gcd (a, b) * b;    ll sum = (lcm + (lcm + ( (n / lcm) - <span class="number">1</span>) * lcm)) * (n / lcm) / <span class="number">2</span>;    ll asum = (a + (a + ( (n / a) - <span class="number">1</span>) * a)) * (n / a) / <span class="number">2</span>;    ll bsum = (b + (b + ( (n / b) - <span class="number">1</span>) * b)) * (n / b) / <span class="number">2</span>;    cout &lt;&lt; (<span class="number">1</span> + n) *n / <span class="number">2</span> - asum - bsum + sum &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1348B Phoenix and Beauty</title>
      <link href="/archives/CF1348B/"/>
      <url>/archives/CF1348B/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>有一个长度为 $n$ 的数组，里面有 $n$ 个元素，$a_1,a_2,a_3,…a_n$。</p><p>给定一个 $k$，可以通过在 $a$ 数组中插入 $[1,n]$ 之间的数字，使<strong>任意</strong> $k$ 个连续的元素之和相等。</p><p>如无解，输出 $-1$。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>我们可以考虑，把这个数组分成很多段，也就变成 $b_1,b_2,b_3,…,b_k,b_1,b_2,b_3,…,b_k,b_1,b_2,b_3……$ 这样的数组。</p><p>可以很明显的发现，任意 $k$ 个肯定是 $b_1,b_2,b_3,…,b_k$ 出现一次。</p><p>那么也就满足了和相等。</p><p>当然，如果我们输入的 $a$，<strong>去重</strong>后元素数量大于 $k$，肯定无法构造。</p><p>那么我们需要输出几次 $b_1,…b_k$ 呢？</p><p>答案很简单，$n$ 次。</p><p>我们用一个例子解释一下。</p><pre><code class="highlight txt">5 55 3 2 4 1</code></pre><pre><code class="highlight tap">注：原数组元素会在下方标注，‘|’分割每组1<span class="number"> 2 </span>3<span class="number"> 4 </span>5|1<span class="number"> 2 </span>3<span class="number"> 4 </span>5|1<span class="number"> 2 </span>3<span class="number"> 4 </span>5|1<span class="number"> 2 </span>3<span class="number"> 4 </span>5|1<span class="number"> 2 </span>3<span class="number"> 4 </span>5        ^     ^       ^             ^   ^</code></pre><p>当然，我们要进行去重。</p><pre><code class="highlight txt">5 55 5 5 5 5</code></pre><pre><code class="highlight txt">5|5|5|5|5^</code></pre><p>但是，不要忘了刚才说的：</p><blockquote><p>如果我们输入的 $a$，<strong>去重</strong>后元素数量大于 $k$，肯定无法构造。</p></blockquote><p>所以，像下组数据：</p><pre><code class="highlight txt">5 35 3 2 4 1</code></pre><p>就得输出 $-1$。</p><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    set&lt;<span class="type">int</span>&gt;s;    <span class="type">int</span> n, k;    cin &gt;&gt; n &gt;&gt; k;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="type">int</span> x;        cin &gt;&gt; x;        s.<span class="built_in">insert</span> (x);    &#125;    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; k)    &#123;        <span class="built_in">puts</span> (<span class="string">&quot;-1&quot;</span>);        <span class="keyword">return</span>;    &#125;    cout &lt;&lt; n * k &lt;&lt; endl;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> it : s)        &#123;            cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;        &#125;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k - s.<span class="built_in">size</span>(); j++)        &#123;            cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;        &#125;    &#125;    cout &lt;&lt; endl;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC252 做题笔记</title>
      <link href="/archives/ABC252/"/>
      <url>/archives/ABC252/</url>
      
        <content type="html"><![CDATA[<h3 id="abc252-a"><a href="#abc252-a" class="headerlink" title="abc252_a"></a><a href="https://atcoder.jp/contests/abc252/tasks/abc252_a">abc252_a</a></h3><h4 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>给一个数字 $n$，输出 ASCLL 码里第 $n$ 位的字母。</p><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>直接输出。</p><h4 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;cout&lt;&lt;<span class="built_in">char</span>(n)&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc252-b"><a href="#abc252-b" class="headerlink" title="abc252_b"></a><a href="https://atcoder.jp/contests/abc252/tasks/abc252_b">abc252_b</a></h3><h4 id="题目翻译-1"><a href="#题目翻译-1" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有 $n$ 个数，$a_1,a_2,a_3…a_n$，选择 $k$ 个数，分别为 $b_1,b_2,b_3…b_k$。</p><p>问 $b$ 里是否有最大数。</p><h4 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h4><p>先找出 $a$ 的最大值，判断是否有最大即可。</p><h4 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,k,maxx=<span class="number">-1</span>;<span class="type">bool</span> f=<span class="number">0</span>;cin&gt;&gt;n&gt;&gt;k;<span class="type">int</span> a[n<span class="number">+1</span>];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];maxx=<span class="built_in">max</span>(maxx,a[i]);&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;<span class="type">int</span> x;cin&gt;&gt;x;<span class="keyword">if</span>(a[x]==maxx)f=<span class="number">1</span>;&#125;<span class="built_in">puts</span>(f?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc252-c"><a href="#abc252-c" class="headerlink" title="abc252_c"></a><a href="https://atcoder.jp/contests/abc252/tasks/abc252_c">abc252_c</a></h3><h4 id="题目翻译-2"><a href="#题目翻译-2" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>输入 $n$ 个 $0$ 到 $9$，$10$ 个数字构成的排列。<br>如果在第 $i$ 秒按下停止按钮，那么他会显示第 $i%10$ 个字符（$0$秒最左的字符，$9$ 秒最右的字符）。<br>同一秒只能按下一个停止按钮。<br>目标是让这 $n$ 个排列显示相同的字母。<br>问最优情况下需要几秒。</p><h4 id="题目思路-2"><a href="#题目思路-2" class="headerlink" title="题目思路"></a>题目思路</h4><p>枚举最后出现哪个数字。</p><h4 id="AC-代码-2"><a href="#AC-代码-2" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;string s[<span class="number">105</span>];<span class="type">int</span> a[<span class="number">105</span>][<span class="number">105</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,ans=INT_MAX;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;s[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s[i].<span class="built_in">size</span>();j++)<span class="comment">//0开始，错了好几次QwQ</span>&#123;a[s[i][j]-<span class="string">&#x27;0&#x27;</span>][i]=j;<span class="comment">//每种字符的第i的字符串所在位置。</span><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;i;k++)&#123;<span class="keyword">if</span>(a[s[i][j]-<span class="string">&#x27;0&#x27;</span>][k]%<span class="number">10</span>==j)&#123;a[s[i][j]-<span class="string">&#x27;0&#x27;</span>][i]+=<span class="number">10</span>;<span class="comment">//多10秒</span>&#125;&#125;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;<span class="type">int</span> m=<span class="number">-1</span>,cnt=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;m=<span class="built_in">max</span>(m,a[i][j]);&#125;ans=<span class="built_in">min</span>(ans,m);&#125;cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc252-d"><a href="#abc252-d" class="headerlink" title="abc252_d"></a><a href="https://atcoder.jp/contests/abc252/tasks/abc252_d">abc252_d</a></h3><h4 id="题目翻译-3"><a href="#题目翻译-3" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有 $n$ 个数，问是否存在 $a_i\ne a_j \ne a_k$ 且 $i&lt;j&lt;k$。</p><h4 id="题目思路-3"><a href="#题目思路-3" class="headerlink" title="题目思路"></a>题目思路</h4><p>容斥原理，看<strong>所有排列 $-$ 三个一样 $-$ 两个一样</strong>。</p><h4 id="AC-代码-3"><a href="#AC-代码-3" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">long</span> <span class="type">long</span> s[<span class="number">200005</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">long</span> <span class="type">long</span> n;cin&gt;&gt;n;<span class="type">int</span> a[n<span class="number">+1</span>];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];s[a[i]]++;&#125;<span class="type">long</span> <span class="type">long</span> x=n*(n<span class="number">-1</span>)/<span class="number">2</span>*(n<span class="number">-2</span>)/<span class="number">3</span>;<span class="comment">//总数</span><span class="type">long</span> <span class="type">long</span> y=<span class="number">0</span>,z=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200000</span>;i++)<span class="comment">//三个一样</span>&#123;<span class="type">long</span> <span class="type">long</span> yy=<span class="number">0</span>;<span class="keyword">if</span>(s[i]&gt;=<span class="number">3</span>)&#123;yy=s[i]*(s[i]<span class="number">-1</span>)/<span class="number">2</span>*(s[i]<span class="number">-2</span>)/<span class="number">3</span>;&#125;y+=yy;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200000</span>;i++)<span class="comment">//两个一样</span>&#123;<span class="type">long</span> <span class="type">long</span> zz=<span class="number">0</span>;<span class="keyword">if</span>(s[i]&gt;=<span class="number">2</span>)&#123;zz=s[i]*(s[i]<span class="number">-1</span>)/<span class="number">2</span>*(n-s[i]);&#125;z+=zz;&#125;cout&lt;&lt;x-y-z&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc252-f"><a href="#abc252-f" class="headerlink" title="abc252_f"></a><a href="https://atcoder.jp/contests/abc252/tasks/abc252_f">abc252_f</a></h3><h4 id="题目翻译-4"><a href="#题目翻译-4" class="headerlink" title="题目翻译"></a>题目翻译</h4><p><a href="https://www.luogu.com.cn/problem/P1334">双倍经验</a>。</p><h4 id="题目思路-4"><a href="#题目思路-4" class="headerlink" title="题目思路"></a>题目思路</h4><p>同上，不同在于，考虑有剩余的话，再请一个人来拿走剩余部分。</p><h4 id="AC-代码-4"><a href="#AC-代码-4" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;multiset&lt;<span class="type">long</span> <span class="type">long</span>&gt;s;<span class="type">long</span> <span class="type">long</span> n,l,ss=<span class="number">0</span>;cin&gt;&gt;n&gt;&gt;l;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">long</span> <span class="type">long</span> x;cin&gt;&gt;x;s.<span class="built_in">insert</span>(x);ss+=x;&#125;<span class="keyword">if</span>(l-ss!=<span class="number">0</span>)s.<span class="built_in">insert</span>(l-ss);<span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;<span class="keyword">while</span>(s.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;<span class="type">long</span> <span class="type">long</span> x=*s.<span class="built_in">begin</span>();s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());<span class="type">long</span> <span class="type">long</span> y=*s.<span class="built_in">begin</span>();s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());s.<span class="built_in">insert</span>(x+y);sum+=x+y;&#125;cout&lt;&lt;sum&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[工程] 如何快速上手 Hexo 博客</title>
      <link href="/archives/how_to_build_hexo_blog/"/>
      <url>/archives/how_to_build_hexo_blog/</url>
      
        <content type="html"><![CDATA[<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><h3 id="硬件方面"><a href="#硬件方面" class="headerlink" title="硬件方面"></a>硬件方面</h3><p>有台电脑。</p><p><del>和没说有区别吗</del></p><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p><a href="https://nodejs.org/">官网地址</a>。</p><p>安装后在 cmd 等命令行输入</p><pre><code class="highlight bash">node -v</code></pre><p>和</p><pre><code class="highlight bash">npm -v</code></pre><p>检查版本号。</p><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p><a href="https://www.git-scm.com/downloads">官网地址</a></p><p>安装后在 cmd 等命令行输入</p><pre><code class="highlight bash">git --version</code></pre><p>检查版本号。</p><h3 id="配置-Hexo"><a href="#配置-Hexo" class="headerlink" title="配置 Hexo"></a>配置 Hexo</h3><p>首先，随意找一个盘，如 E盘，右键，Git Bash Here。</p><p><img src="https://s1.ax1x.com/2022/05/19/ObfwSP.png"></p><p>出现这样的界面即可。</p><p>之后，分别执行以下操作：</p><pre><code class="highlight bash">npm install hexo-cli -ghexo init blog<span class="built_in">cd</span> blognpm installhexo s</code></pre><p><img src="https://s1.ax1x.com/2022/05/19/ObjNzF.png"></p><p>PS：手残打错了，localhost:4000。</p><p>大概和我这个步骤差不多。</p><p>然后，访问 <a href="http://localhost:4000/">http://localhost:4000</a> 就可以看到你的本地博客了。</p><p><img src="https://s1.ax1x.com/2022/05/19/ObjRQe.png"></p><p>大概默认是长这样。</p><p>可以 Ctrl+C 停止本地博客。</p><p>注意，一旦停止或退出 Git Bash，本地博客将立刻停止。</p><h2 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h2><h3 id="建立仓库"><a href="#建立仓库" class="headerlink" title="建立仓库"></a>建立仓库</h3><p>如果想使你的博客可以被访问链接而被他人看到，不是只有你自己用这台电脑看得到，那么，就需要用 Github 进行托管，并白嫖一个二级域名。</p><p>也可以自己购买域名后按后文步骤进行域名绑定。</p><h4 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h4><p><a href="https://github.com/">GitHub</a>。</p><p>点击进去，Sign up，注册结束后进入这样的页面。</p><p><img src="https://s1.ax1x.com/2022/05/19/ObjOyQ.png"></p><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>点击右上角加号，New repository，创建一个仓库来托管你的网站。</p><p><img src="https://s1.ax1x.com/2022/05/19/ObvKfK.png"></p><p>打开后，在 repository name 里填写 <code>你的注册时的用户名，也就是左边的+github.io</code>。</p><p><strong>一定不能擅自更改！！！</strong></p><p><img src="https://s1.ax1x.com/2022/05/19/Obv5X4.png"></p><h3 id="生成-SSH"><a href="#生成-SSH" class="headerlink" title="生成 SSH"></a>生成 SSH</h3><p>为啥要用 <del>Karry5307</del> SSH 呢，要把我们本地的文件，传输至你的 Github 仓库上，被 Github 托管，然后才能被访问。</p><p>先在你的文件夹里 Git Bash，然后输入</p><pre><code class="highlight bash">ssh</code></pre><p>测试是否安装。</p><pre><code class="highlight bash">admin@LAPTOP-U5FCCV9Q MINGW64 /e/blog$ sshusage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface]           [-b bind_address] [-c cipher_spec] [-D [bind_address:]port]           [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11]           [-i identity_file] [-J [user@]host[:port]] [-L address]           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]           [-w local_tun[:remote_tun]] destination [<span class="built_in">command</span> [argument ...]]</code></pre><p>大概长这样就对了。</p><p>然后输入：</p><pre><code class="highlight bash">ssh-keygen -t rsa -C <span class="string">&quot;注册 Github 的邮件地址&quot;</span></code></pre><p>忘记了注册电邮，前往 <a href="https://github.com/settings/emails">https://github.com/settings/emails</a> 查看。</p><p>之后，执行以下操作：</p><pre><code class="highlight bash">enter回车一次输入 yenter回车一次enter回车一次</code></pre><p>出现了</p><pre><code class="highlight bash">+---[RSA 3072]----+|o   .. ...       || o .  o .  .     ||+ o  . . .+      ||o+  . + .+ .     ||...  + .Sooo     ||o.    = +oB      || +.. . O.o.=     || .+ . *.+ . o    || Eo. o=X.    .   |+----[SHA256]-----+</code></pre><p>之类的图案即可。</p><p>然后进入 <code>C盘-User（有的电脑就叫用户）-admin（有的自己设置过可能会有偏差）-.ssh</code>。</p><p>用记事本打开 id_rsa.pub。</p><p>Ctrl+A，Ctrl+C，Ctrl+V 全选。</p><p>接着，进入 <a href="https://github.com/settings/ssh/new">https://github.com/settings/ssh/new</a> 来新建个 key。</p><p>Title 随便，Key 黏贴刚才复制的文字。</p><p>然后输入</p><pre><code class="highlight bash">ssh -T git@github.com</code></pre><p>确认是否绑定成功，有要输入 y 的就输入。</p><p>出现 Hi …即可。</p><h3 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h3><p>在根目录里输入</p><pre><code class="highlight bash">hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</code></pre><p>然后，访问 <a href="http://localhost:4000/">http://localhost:4000</a> 就可以看到你的本地博客了。</p><h2 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h2><p>进入根目录，在里面有个 _config.yml。</p><p>最下面应该是这样的：</p><pre><code class="highlight bash"><span class="comment"># Deployment</span><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span>deploy:  <span class="built_in">type</span>: <span class="string">&#x27;&#x27;</span></code></pre><p>我们魔改一下：</p><pre><code class="highlight bash"><span class="comment"># Deployment</span><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span>deploy:  <span class="built_in">type</span>: git  repository: <span class="comment">#你的博客仓库地址，推荐用 ssh 版，我的就是 git@github.com:chen20091119/chen20091119.github.io.git</span>  branch: main <span class="comment">#这里是分支，原先默认是 master，但 Github 有一次更新，把后注册的仓库改成了 main。</span></code></pre><p>输入</p><pre><code class="highlight bash">npm install hexo-deployer-git --save</code></pre><p>安装部署功能。</p><p>然后</p><pre><code class="highlight bash">hexo d</code></pre><p>部署。</p><p>现在我们去看 Github 仓库，就会有东西了。</p><p>接着，访问你的博客地址就能看到博客了。</p><p>如果此时在命令行里或者弹出弹窗，让你输入东西，可以看<strong>参考文献</strong>部分的视频。</p><p>这个 <a href="https://www.bilibili.com/video/BV1mU4y1j72n?p=5&t=384.6">B-stack</a> 精准空降到输入部分。</p><p>之后就可以开始美化啦！</p><h2 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h2><p>原版很难看，可以在 <a href="https://hexo.io/themes/">https://hexo.io/themes</a> 来看主题，我在用 <a href="https://github.com/solstice23/hexo-theme-argon">argon</a>。</p><p>argon 作者有写操作，跟着做即可。</p><h2 id="美化博客"><a href="#美化博客" class="headerlink" title="美化博客"></a>美化博客</h2><p><del>持续更新，争取每周有一个小技巧分享！</del></p><h3 id="快捷部署"><a href="#快捷部署" class="headerlink" title="快捷部署"></a>快捷部署</h3><p>在一个地方，如你的桌面，创建一个后缀为 .sh 的文件，用记事本打开，输入以下内容：</p><pre><code class="highlight bash"><span class="built_in">cd</span> 你的博客根目录hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><p>自动清空+生成+部署。</p><p>每次省五秒钟，一百二十次就是十分钟啊！（大雾</p><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>可以去 <code>根目录-themes-argon-_config.yml</code> 查看。</p><p>本教学为 Giscus 评论系统。</p><p>先新建一个仓库，名字可以起 blogtalk 之类的。</p><p><img src="https://s1.ax1x.com/2022/05/21/OjanXj.png"></p><p>注意 public！！1</p><p><img src="https://s1.ax1x.com/2022/05/21/Ojatc4.png"></p><p>把 Discussions 打开。</p><p>进入 <a href="https://github.com/apps/giscus">https://github.com/apps/giscus</a> 下载 Giscus。</p><p><img src="https://s1.ax1x.com/2022/05/21/OjdsZn.png"></p><p>点击 Install。</p><p>最后进入 <a href="https://giscus.app/zh-CN">Giscus</a>，填写仓库。</p><p><img src="https://s1.ax1x.com/2022/05/21/OjdWzF.png"></p><p>之后在下方 <strong>启用 giscus</strong> 里会出现你的信息。</p><p>打开 <code>根目录-themes-argon-_config.yml</code>。</p><pre><code class="highlight bash">giscus: <span class="comment"># https://giscus.app/zh-CN</span>  <span class="built_in">enable</span>: <span class="literal">false</span> <span class="comment"># 是否启用 Giscus 评论系统</span>  repo: <span class="string">&#x27;&#x27;</span>  repo_id: <span class="string">&#x27;&#x27;</span>  category: <span class="string">&#x27;&#x27;</span>  category_id: <span class="string">&#x27;&#x27;</span>  mapping: <span class="string">&#x27;pathname&#x27;</span>  input_position: <span class="string">&#x27;top&#x27;</span>  theme: <span class="string">&#x27;light&#x27;</span>  lang: <span class="string">&#x27;zh-CN&#x27;</span></code></pre><p>将其中的 <code>repo</code> 等信息更改为你显示的信息。</p><p>大功告成，只需部署即可。</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p><del>详见 【置顶】如何快速白嫖顶级域名</del>。</p><p>Freenom 已停止维护，故本内容已失效。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>视频好像被下架了，流汗。</p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC251 做题笔记</title>
      <link href="/archives/ABC251/"/>
      <url>/archives/ABC251/</url>
      
        <content type="html"><![CDATA[<h3 id="abc251-a"><a href="#abc251-a" class="headerlink" title="abc251_a"></a><a href="https://atcoder.jp/contests/abc251/tasks/abc251_a">abc251_a</a></h3><h4 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有一个字符串，输出这个字符串交替的前 $6$ 位。</p><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>判断长度。</p><h4 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;string s;cin&gt;&gt;s;<span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">1</span>)cout&lt;&lt;s&lt;&lt;s&lt;&lt;s&lt;&lt;s&lt;&lt;s&lt;&lt;s&lt;&lt;endl;<span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">2</span>)cout&lt;&lt;s&lt;&lt;s&lt;&lt;s&lt;&lt;endl;<span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">3</span>)cout&lt;&lt;s&lt;&lt;s&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc251-b"><a href="#abc251-b" class="headerlink" title="abc251_b"></a><a href="https://atcoder.jp/contests/abc251/tasks/abc251_b">abc251_b</a></h3><h4 id="题目翻译-1"><a href="#题目翻译-1" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有 $n$ 个数，最多选 $3$ 个，和正好凑到 $w$ 及以下的有几个。</p><h4 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h4><p>$n\leqslant 300$，枚举即可。</p><h4 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">bool</span> b[<span class="number">3000001</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,w;<span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;cin&gt;&gt;n&gt;&gt;w;<span class="type">int</span> a[n<span class="number">+1</span>];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;b[a[i]]=<span class="number">1</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)&#123;b[a[i]+a[j]]=<span class="number">1</span>;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)&#123;<span class="keyword">for</span>(<span class="type">int</span> k=j<span class="number">+1</span>;k&lt;=n;k++)&#123;b[a[i]+a[j]+a[k]]=<span class="number">1</span>;&#125;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=w;i++)&#123;<span class="keyword">if</span>(b[i]==<span class="number">1</span>)ans++;&#125;cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc251-c"><a href="#abc251-c" class="headerlink" title="abc251_c"></a><a href="https://atcoder.jp/contests/abc251/tasks/abc251_c">abc251_c</a></h3><h4 id="题目翻译-2"><a href="#题目翻译-2" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有个 OJ，每个人交了个内容为 $s_i$ 的代码，获得 $t_i$ 分数。后交的相同代码判为抄袭。</p><p>问没有抄袭的代码里，分数最高的是谁。</p><h4 id="题目思路-2"><a href="#题目思路-2" class="headerlink" title="题目思路"></a>题目思路</h4><p>用一个 <code>set</code> 存每个人的代码，如果插入后大小不变，就是前面有相同的，那么就不算分。否则，计算分数。</p><h4 id="AC-代码-2"><a href="#AC-代码-2" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;set&lt;string&gt;s;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,maxx=<span class="number">-1</span>,ans=<span class="number">-1</span>;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;string str;<span class="type">int</span> score;cin&gt;&gt;str&gt;&gt;score;<span class="type">int</span> sz=s.<span class="built_in">size</span>();s.<span class="built_in">insert</span>(str);<span class="keyword">if</span>(s.<span class="built_in">size</span>()!=sz)&#123;<span class="keyword">if</span>(score&gt;maxx)&#123;maxx=score;ans=i;&#125;&#125;&#125;cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc251-d"><a href="#abc251-d" class="headerlink" title="abc251_d"></a><a href="https://atcoder.jp/contests/abc251/tasks/abc251_d">abc251_d</a></h3><h4 id="题目翻译-3"><a href="#题目翻译-3" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>B 题题面相反，给出 $w$，问造一个数组，满足选三个正好是等于所有 $\leqslant w$ 的。</p><h4 id="题目思路-3"><a href="#题目思路-3" class="headerlink" title="题目思路"></a>题目思路</h4><p>这个 $w$ 最多 $7$ 位，但 $&lt;w$ 只有 $6$ 位。</p><p>我们把这个数设为 $\overline{abcdef}$，然后分成 $\overline{ab}$、$\overline{cd}$、$\overline{ef}$。</p><p>每个都有 $99$ 种可能，加上 $10^6$，一共 $298$ 个。</p><h4 id="AC-代码-3"><a href="#AC-代码-3" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;cout&lt;&lt;<span class="number">298</span>&lt;&lt;endl;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">99</span>;i++)&#123;cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">99</span>;i++)&#123;cout&lt;&lt;i*<span class="number">100</span>&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">99</span>;i++)&#123;cout&lt;&lt;i*<span class="number">100</span>*<span class="number">100</span>&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;cout&lt;&lt;<span class="number">1000000</span>&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[游记] CZOI 2022 游记</title>
      <link href="/archives/CZOI2022/"/>
      <url>/archives/CZOI2022/</url>
      
        <content type="html"><![CDATA[<h3 id="2022-5-12"><a href="#2022-5-12" class="headerlink" title="2022.5.12"></a>2022.5.12</h3><h4 id="First"><a href="#First" class="headerlink" title="First"></a>First</h4><p>放学回家，发布一条 QQ 动态和微信朋友圈，内容为几张照片，还有一段文字：</p><pre><code class="highlight cpp">点赞这条动态/朋友圈，会获得jiangly和tourist保佑，一整年AK所有比赛，快来试试顺带一提，明天就是信息与未来的选拔赛了，所以，<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> rp=<span class="number">0</span>;rp--;</code></pre><h4 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h4><p>背模板ing&amp;看博客ing。</p><h4 id="Third"><a href="#Third" class="headerlink" title="Third"></a>Third</h4><p>看了会儿 BFS 的博客和之前写的代码，差不多理解 BFS 的运行方法了。</p><h4 id="Fourth"><a href="#Fourth" class="headerlink" title="Fourth"></a>Fourth</h4><p>背了会儿快速幂之类的重要函数。</p><h4 id="Fifth"><a href="#Fifth" class="headerlink" title="Fifth"></a>Fifth</h4><p>第一次默写快速幂，错了一处。</p><h4 id="Sixth"><a href="#Sixth" class="headerlink" title="Sixth"></a>Sixth</h4><p>第二次默写快速幂，全对。</p><h4 id="Seventh"><a href="#Seventh" class="headerlink" title="Seventh"></a>Seventh</h4><p>第一次默写进制转换，函数写反了。</p><h4 id="Eighth"><a href="#Eighth" class="headerlink" title="Eighth"></a>Eighth</h4><p>第二次默写进制转换，函数又双叒叕写反了。</p><h4 id="Ninth"><a href="#Ninth" class="headerlink" title="Ninth"></a>Ninth</h4><p>第三次默写进制转换，终于对了。</p><h4 id="Tenth"><a href="#Tenth" class="headerlink" title="Tenth"></a>Tenth</h4><p>第一次没背诵默写 dfs，错了很多当初写 dfs 就错的。</p><h4 id="Eleventh"><a href="#Eleventh" class="headerlink" title="Eleventh"></a>Eleventh</h4><p>第二次默写 dfs，写对了。</p><h4 id="Twelfth"><a href="#Twelfth" class="headerlink" title="Twelfth"></a>Twelfth</h4><p>看了一眼，凭记忆默了 bfs，全对，但是默得不太熟。</p><h4 id="Thirteenth"><a href="#Thirteenth" class="headerlink" title="Thirteenth"></a>Thirteenth</h4><p>第一次默写递归版约瑟夫，全对。</p><h4 id="Fourteenth"><a href="#Fourteenth" class="headerlink" title="Fourteenth"></a>Fourteenth</h4><p>第一次默写二分，其他都对。在处理 mid 时，与原来写的不一样，但是一般都对，就不管了。</p><h4 id="Fifteenth"><a href="#Fifteenth" class="headerlink" title="Fifteenth"></a>Fifteenth</h4><p>dp 呢，好像之前没看到考过，就当他不考（反正我也不太熟</p><p>整理常用函数和平时的错误ing。</p><h3 id="2022-5-13"><a href="#2022-5-13" class="headerlink" title="2022.5.13"></a>2022.5.13</h3><h4 id="First-1"><a href="#First-1" class="headerlink" title="First"></a>First</h4><p>呜呜呜好紧张。。。</p><h4 id="Second-1"><a href="#Second-1" class="headerlink" title="Second"></a>Second</h4><p>做完核酸，赶紧溜去机房，先背会儿东西。</p><h4 id="Third-1"><a href="#Third-1" class="headerlink" title="Third"></a>Third</h4><p>发卷了发卷了（这密码还是数学题。</p><p>T1：一眼秒了。</p><p>T2：有点难诶，没看懂。</p><p>T3：看懂了，感觉是枚举四个数代表什么。</p><p>T4：太简单了，和前两天做的 Codeforces 和经典题《小A数字母》差不多，就是扫一遍数组记位置。</p><p>T5：小学数学题？送分吧？</p><p>T6：神马鬼玩意儿。</p><p>T7：神马鬼玩意儿。</p><h4 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h4><p>应该有 $\Theta(1)$ 写法，但是太烦了。</p><p>我写了个 $\Theta(m-n)$ 的写法。</p><hr><p>PS：过了呢！</p><h4 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h4><p>没思路。。。</p><p>我手算了几个，写了特判。</p><hr><p>PS：$70$ 分，拿了 $49$ 分。</p><h4 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h4><p>特判是万能的！</p><p>又双叒叕手算几个。</p><hr><p>PS：$80$ 分，拿了 $12$ 分。</p><h4 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h4><p>好简单诶。</p><p>就是实现很烦。</p><hr><p>麻了，样例没过，每个语句后面加个调试信息吧。</p><hr><p>过样例了，先做后面的。</p><hr><p>考完检查，发现我有个变量没清零，改了一下，顺便换了个 <code>long double</code>。</p><hr><p>PS：90分拿满了。</p><p>话说 <code>long double</code> 存多少位啊，$100$ 位的数字都存下了。</p><hr><p>想通了，数据估计没有 $100$ 位全是小数点前的。</p><h4 id="T5"><a href="#T5" class="headerlink" title="T5"></a>T5</h4><p>小学数学题？</p><p>感觉是第一次一个全程，第二次两个，判一下时间。</p><hr><p>PS：$100$ 分果然不是这么好拿的，拿了一半也还行。</p><h4 id="T6"><a href="#T6" class="headerlink" title="T6"></a>T6</h4><p>不会，摆烂，写特判（</p><hr><p>PS：没分。</p><h4 id="T7"><a href="#T7" class="headerlink" title="T7"></a>T7</h4><p>不会，摆烂，写特判（</p><hr><p>PS：没分。</p><h4 id="Fourth-1"><a href="#Fourth-1" class="headerlink" title="Fourth"></a>Fourth</h4><p>爸爸问我多少，我说估分 $\frac{1}{3}$，我爸说别人模拟能 $600$，我咋考这么点分。</p><p>差点想 AFO 了。。。</p><h4 id="Fifth-1"><a href="#Fifth-1" class="headerlink" title="Fifth"></a>Fifth</h4><p>玩了一晚上。。。</p><h3 id="2022-5-14"><a href="#2022-5-14" class="headerlink" title="2022.5.14"></a>2022.5.14</h3><h4 id="First-2"><a href="#First-2" class="headerlink" title="First"></a>First</h4><p>八点半，同学给我 QQ 发消息，才起床，看了眼 XB 区名单出来了，我第一。</p><p>激动死了。</p><h4 id="Second-2"><a href="#Second-2" class="headerlink" title="Second"></a>Second</h4><p>炫耀分数ing。</p><h4 id="Third-2"><a href="#Third-2" class="headerlink" title="Third"></a>Third</h4><p>CZ 某知名老师跟我爸聊天，说留个手机号，有学校想谈谈。</p><p>难道前十进 cfs 是真的？</p><h4 id="Fourth-2"><a href="#Fourth-2" class="headerlink" title="Fourth"></a>Fourth</h4><p>中午，大部分地区出分了。</p><pre><code class="highlight cpp">主城区高于<span class="number">200</span>分的有:钟楼<span class="number">277</span>钟楼<span class="number">261</span>新北<span class="number">261</span>钟楼<span class="number">244</span>钟楼<span class="number">235</span>天宁<span class="number">235</span>钟楼<span class="number">218</span>新北<span class="number">205</span>新北<span class="number">203</span>天宁<span class="number">201</span>天宁<span class="number">201</span>天宁<span class="number">200</span></code></pre><p>PS：新北 $261$ 是我啦。</p><h4 id="Fifth-2"><a href="#Fifth-2" class="headerlink" title="Fifth"></a>Fifth</h4><p>lzx 和 pbc 都说和我一样高。</p><p>迷幻的分数。</p><h4 id="Sixth-1"><a href="#Sixth-1" class="headerlink" title="Sixth"></a>Sixth</h4><p>貌似 WJ 的也出来了。</p><p>我好像是全市 rk.3。</p><h4 id="Seventh-1"><a href="#Seventh-1" class="headerlink" title="Seventh"></a>Seventh</h4><p>怎么讲评还有人骂脏话啊&#x2F;fn</p><p>举报了举报了。</p><hr><p>PS：好耶，封号一天大礼包。</p>]]></content>
      
      
      <categories>
          
          <category> TravelNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC250 做题笔记</title>
      <link href="/archives/ABC250/"/>
      <url>/archives/ABC250/</url>
      
        <content type="html"><![CDATA[<h3 id="abc250-a"><a href="#abc250-a" class="headerlink" title="abc250_a"></a><a href="https://atcoder.jp/contests/abc250/tasks/abc250_a">abc250_a</a></h3><h4 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有一个 $h\times w$ 的矩阵，有个数对 $(r,c)$，问与 $(r,c)$ 相邻的有几个。</p><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>判断 $r,c$ 是否在边界。</p><h4 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> h,w,r,c;cin&gt;&gt;h&gt;&gt;w&gt;&gt;r&gt;&gt;c;<span class="type">int</span> a=<span class="number">4</span>;<span class="keyword">if</span>(r==h)a--;<span class="keyword">if</span>(r==<span class="number">1</span>)a--;<span class="keyword">if</span>(c==<span class="number">1</span>)a--;<span class="keyword">if</span>(c==w)a--;cout&lt;&lt;a&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc250-b"><a href="#abc250-b" class="headerlink" title="abc250_b"></a><a href="https://atcoder.jp/contests/abc250/tasks/abc250_b">abc250_b</a></h3><h4 id="题目翻译-1"><a href="#题目翻译-1" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>绘制一个 $(a\times n)\times(b\times n)$ 的矩阵。</p><p>矩阵要求很复杂，建议直接看样例就懂了。</p><h4 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h4><p>判断奇偶。</p><h4 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,a,b;cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=a;j++)&#123;<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n;l++)&#123;<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=b;k++)&#123;cout&lt;&lt;((l+i)%<span class="number">2</span>==<span class="number">0</span>?<span class="string">&#x27;.&#x27;</span>:<span class="string">&#x27;#&#x27;</span>);&#125;&#125;cout&lt;&lt;endl;&#125;&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc250-g"><a href="#abc250-g" class="headerlink" title="abc250_g"></a><a href="https://atcoder.jp/contests/abc250/tasks/abc250_g">abc250_g</a></h3><h4 id="题目翻译-2"><a href="#题目翻译-2" class="headerlink" title="题目翻译"></a>题目翻译</h4><p><a href="https://codeforces.com/problemset/problem/865/D">双倍经验</a>。</p><h4 id="题目思路-2"><a href="#题目思路-2" class="headerlink" title="题目思路"></a>题目思路</h4><p>反悔贪心。</p><h4 id="AC-代码-2"><a href="#AC-代码-2" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;priority_queue&lt;<span class="type">int</span>&gt;q;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">long</span> <span class="type">long</span> n,ans=<span class="number">0</span>,minn=INT_MAX;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="type">int</span> x;cin&gt;&gt;x;q.<span class="built_in">push</span>(-x);q.<span class="built_in">push</span>(-x);ans+=x+q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();&#125;cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre><h3 id="abc250-d"><a href="#abc250-d" class="headerlink" title="abc250_d"></a><a href="https://atcoder.jp/contests/abc250/tasks/abc250_d">abc250_d</a></h3><h4 id="题目翻译-3"><a href="#题目翻译-3" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>问 $[1,n]$ 中有多少数，可以拆分成 $p\times q^3$，且 $p&lt;q$，并都是质数。</p><h4 id="题目思路-3"><a href="#题目思路-3" class="headerlink" title="题目思路"></a>题目思路</h4><p>统计 $[1,\sqrt[3]{n}]$ 的质数个数，枚举 $q$ 推出 $p$。</p><h4 id="AC-代码-3"><a href="#AC-代码-3" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">bool</span> pri[<span class="number">1000005</span>];<span class="type">int</span> prime[<span class="number">1000005</span>];<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span><span class="function"></span>&#123;pri[<span class="number">0</span>]=pri[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)&#123;<span class="keyword">if</span>(!pri[i])&#123;<span class="keyword">for</span>(<span class="type">int</span> cnt=<span class="number">2</span>;cnt&lt;=n/i;cnt++)&#123;pri[i*cnt]=<span class="number">1</span>;&#125;&#125;&#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">long</span> <span class="type">long</span> n,ans=<span class="number">0</span>;cin&gt;&gt;n;<span class="built_in">init</span>(<span class="number">1000000</span>);prime[<span class="number">0</span>]=prime[<span class="number">1</span>]=<span class="number">0</span>;prime[<span class="number">2</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">3</span>;i&lt;=<span class="number">1000000</span>;i++)&#123;prime[i]=(pri[i]==<span class="number">0</span>)+(prime[i<span class="number">-1</span>]);&#125;<span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">2</span>;i*i*i&lt;=n;i++)<span class="comment">//q</span>&#123;<span class="keyword">if</span>(pri[i]==<span class="number">0</span>)&#123;<span class="type">long</span> <span class="type">long</span> j=n/(i*i*i);<span class="keyword">if</span>(j&gt;=i)j=i<span class="number">-1</span>;ans+=prime[j]-prime[<span class="number">1</span>];&#125;&#125;cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="abc250-c"><a href="#abc250-c" class="headerlink" title="abc250_c"></a><a href="https://atcoder.jp/contests/abc250/tasks/abc250_c">abc250_c</a></h3><h4 id="题目翻译-4"><a href="#题目翻译-4" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>初始一个 $1$ 到 $n$ 的排列。<br>$q$ 次操作，每次操作 $x$。<br>把数字 $x$ 和 $x$ 右边的数字交换。<br>如果数字 $x$ 是最后一个，那么和自己左边的数字交换。<br>输出 $q$ 次交换之后的结果。</p><h4 id="题目思路-4"><a href="#题目思路-4" class="headerlink" title="题目思路"></a>题目思路</h4><p>两个数组统计每个球的数字和位置。</p><h4 id="AC-代码-4"><a href="#AC-代码-4" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">200005</span>],b[<span class="number">200005</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,q;cin&gt;&gt;n&gt;&gt;q;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;a[i]=b[i]=i;&#125;<span class="keyword">while</span>(q--)&#123;<span class="type">int</span> x;cin&gt;&gt;x;<span class="keyword">if</span>(a[x]==n)<span class="built_in">swap</span>(b[a[x]<span class="number">-1</span>],b[a[x]]),<span class="built_in">swap</span>(a[b[a[x]<span class="number">-1</span>]],a[b[a[x]]]);<span class="keyword">else</span> <span class="built_in">swap</span>(b[a[x]<span class="number">+1</span>],b[a[x]]),<span class="built_in">swap</span>(a[b[a[x]<span class="number">+1</span>]],a[b[a[x]]]);&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cout&lt;&lt;b[i]&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC061C Big Array</title>
      <link href="/archives/ABC061C/"/>
      <url>/archives/ABC061C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>$n$ 次操作，每次两个数 $a_i,b_i$，在一个初始为空的序列里插入 $b_i$ 个 $a_i$，操作结束后问第 $k$ 小是什么。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>类似于 <a href="https://atcoder.jp/contests/abc247/tasks/abc247_d">ABC247D</a> 的写法，还是个弱化版。</p><p>我们不用真的插入 $b_i$ 个 $a_i$，只需记录 $b_i$ 有多少即可，因为很多的数都用不到。</p><p>这是很多个一添，同理，我们可以很多个一删。</p><p>所以我们用一个 <code>pair</code> 记录两个量，<strong>数字</strong>和<strong>次数</strong>。</p><p>然后按数字的大小排序，最后遍历数组，每次用 $k$ 减掉出现次数，如果此时 $k\leqslant0$，那么就输出当前数字。</p><p>注意，$k$ 最大可以为 $100000^2$，那么开好 <code>long long</code>。</p><p>我因为这个错了一次……</p><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">using</span> <span class="keyword">namespace</span> std;vector&lt;pair&lt;ll,ll&gt;&gt;v;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;ll n,k;cin&gt;&gt;n&gt;&gt;k;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;v.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(a,b));<span class="comment">//插入数字和次数</span>&#125;<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());<span class="comment">//pair的排序默认先看first，也就是此题中的数字的大小</span><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="type">int</span>)v.<span class="built_in">size</span>();i++)&#123;k-=v[i].second;<span class="comment">//减掉出现次数</span><span class="keyword">if</span>(k&lt;=<span class="number">0</span>)&#123;cout&lt;&lt;v[i].first&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//&lt;=0时，输出当前数字。</span>&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC249 做题笔记</title>
      <link href="/archives/ABC249/"/>
      <url>/archives/ABC249/</url>
      
        <content type="html"><![CDATA[<h3 id="abc249-a"><a href="#abc249-a" class="headerlink" title="abc249_a"></a><a href="https://atcoder.jp/contests/abc249/tasks/abc249_a">abc249_a</a></h3><h4 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>两个人走路，一个 $a$ 秒走 $b$ 米，休息 $c$ 秒，一个 $d$ 秒走 $e$ 米，休息 $f$ 秒。问 $x$ 秒后，谁走得多。</p><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>小学数学题。$a+c$ 为一循环，$d+f$ 为一循环。之后再处理剩余秒数。</p><h4 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> a,b,c,d,e,f,x;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f&gt;&gt;x;<span class="type">int</span> asec=x%(a+c),arnd=x/(a+c),ameter;ameter=(arnd*a+<span class="built_in">min</span>(a,asec))*b;<span class="type">int</span> bsec=x%(d+f),brnd=x/(d+f),bmeter;bmeter=(brnd*d+<span class="built_in">min</span>(d,bsec))*e;<span class="keyword">if</span>(bmeter==ameter)<span class="built_in">puts</span>(<span class="string">&quot;Draw&quot;</span>);<span class="keyword">else</span> <span class="keyword">if</span>(bmeter&gt;ameter)<span class="built_in">puts</span>(<span class="string">&quot;Aoki&quot;</span>);<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Takahashi&quot;</span>);&#125;</code></pre><h3 id="abc249-b"><a href="#abc249-b" class="headerlink" title="abc249_b"></a><a href="https://atcoder.jp/contests/abc249/tasks/abc249_b">abc249_b</a></h3><h4 id="题目翻译-1"><a href="#题目翻译-1" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有一个字符串，如果它既出现了小写字母，也出现了大写字母，并且所有字母均不同，那么输出 <code>Yes</code> ，否则输出 <code>No</code>。</p><h4 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h4><p>按题意模拟即可。</p><h4 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;string s;<span class="type">bool</span> low=<span class="number">0</span>,upp=<span class="number">0</span>,same=<span class="number">0</span>;cin&gt;&gt;s;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;<span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;Z&#x27;</span>)upp=<span class="number">1</span>;<span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;z&#x27;</span>)low=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)<span class="keyword">if</span>(s[i]==s[j])same=<span class="number">1</span>;&#125;<span class="built_in">puts</span>(same==<span class="number">0</span>&amp;&amp;upp==<span class="number">1</span>&amp;&amp;low==<span class="number">1</span>?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);&#125;</code></pre><h3 id="abc249-c"><a href="#abc249-c" class="headerlink" title="abc249_c"></a><a href="https://atcoder.jp/contests/abc249/tasks/abc249_c">abc249_c</a></h3><h4 id="题目翻译-2"><a href="#题目翻译-2" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>$n$ 个字符串，随意选几个字符串，问选出的字符串中，恰好出现 $k$ 次的字母有多少。</p><h4 id="题目思路-2"><a href="#题目思路-2" class="headerlink" title="题目思路"></a>题目思路</h4><p>枚举每个字符串的可能，为<strong>选</strong>和<strong>不选</strong>，之后对选了的进行判断。</p><p>肯定不超时，最高只有 $2^{15}\times 26&#x3D;851968$。</p><h4 id="AC-代码-2"><a href="#AC-代码-2" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp">string s[<span class="number">20</span>];<span class="type">bool</span> f[<span class="number">20</span>];<span class="type">int</span> a[<span class="number">30</span>];<span class="type">int</span> ans;<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> dep,<span class="type">int</span> k)</span></span><span class="function"></span>&#123;<span class="keyword">if</span>(dep==n)&#123;<span class="keyword">for</span>(<span class="type">int</span> kk=<span class="number">0</span>;kk&lt;=<span class="number">1</span>;kk++)&#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));<span class="keyword">if</span>(kk==<span class="number">0</span>)f[n]=<span class="number">0</span>;<span class="keyword">else</span> f[n]=<span class="number">1</span>;<span class="type">int</span> sum=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(f[i]==<span class="number">1</span>)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s[i].<span class="built_in">size</span>();j++)&#123;a[s[i][j]-<span class="string">&#x27;a&#x27;</span><span class="number">+1</span>]++;&#125;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)&#123;<span class="keyword">if</span>(a[i]==k)&#123;sum++;&#125;&#125;ans=<span class="built_in">max</span>(ans,sum);&#125;&#125;<span class="keyword">else</span>&#123;f[dep]=<span class="number">1</span>;<span class="built_in">dfs</span>(n,dep<span class="number">+1</span>,k);f[dep]=<span class="number">0</span>;<span class="built_in">dfs</span>(n,dep<span class="number">+1</span>,k);&#125;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;s[i];&#125;<span class="built_in">dfs</span>(n,<span class="number">1</span>,k);cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre><h3 id="abc249-d"><a href="#abc249-d" class="headerlink" title="abc249_d"></a><a href="https://atcoder.jp/contests/abc249/tasks/abc249_d">abc249_d</a></h3><h4 id="题目翻译-3"><a href="#题目翻译-3" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>输入 $n$ 个数字，选出三元组 $(i,j,k)$ 且 $\frac{a_i}{a_j}&#x3D;a_k$。</p><h4 id="题目思路-3"><a href="#题目思路-3" class="headerlink" title="题目思路"></a>题目思路</h4><p>找出每个数字出现次数，枚举 $a_i$ 和 $a_k$。</p><h4 id="AC-代码-3"><a href="#AC-代码-3" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="type">int</span> b[<span class="number">200005</span>];<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,maxx=<span class="number">-1</span>,minn=<span class="number">200005</span>;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> x;cin&gt;&gt;x;maxx=<span class="built_in">max</span>(maxx,x);b[x]++;&#125;<span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxx;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=maxx;j+=i)&#123;ans+=<span class="number">1LL</span>*b[i]*b[j/i]*b[j];&#125;&#125;cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC248 做题笔记</title>
      <link href="/archives/ABC248/"/>
      <url>/archives/ABC248/</url>
      
        <content type="html"><![CDATA[<h3 id="abc248-a"><a href="#abc248-a" class="headerlink" title="abc248_a"></a><a href="https://atcoder.jp/contests/abc248/tasks/abc248_a">abc248_a</a></h3><h4 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有一个字符串 $s$，找出 $0$ 到 $9$ 中没出现的数。</p><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>直接开数组存出现次数。</p><h4 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="type">int</span> a[<span class="number">10</span>];<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;string s;cin&gt;&gt;s;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;a[s[i]-<span class="string">&#x27;0&#x27;</span>]++;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;<span class="keyword">if</span>(a[i]==<span class="number">0</span>)&#123;cout&lt;&lt;i;<span class="keyword">return</span>;&#125;&#125;&#125;</code></pre><h3 id="abc248-b"><a href="#abc248-b" class="headerlink" title="abc248_b"></a><a href="https://atcoder.jp/contests/abc248/tasks/abc248_b">abc248_b</a></h3><h4 id="题目翻译-1"><a href="#题目翻译-1" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>$a\times k^{x-1}\geq b$，问 $x$ 最小是几。</p><h4 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h4><p>模拟，<code>while</code> 循环。</p><h4 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">long</span> <span class="type">long</span> a,b,k,ans=<span class="number">0</span>;cin&gt;&gt;a&gt;&gt;b&gt;&gt;k;<span class="keyword">while</span>(a&lt;b)&#123;ans++;a*=k;&#125;cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre><h3 id="abc248-c"><a href="#abc248-c" class="headerlink" title="abc248_c"></a><a href="https://atcoder.jp/contests/abc248/tasks/abc248_c">abc248_c</a></h3><h4 id="题目翻译-2"><a href="#题目翻译-2" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>从 $m$ 里选 $n$ 个数，保证 $\sum\limits_{i&#x3D;1}^na_i\leq k$，问方案数。</p><h4 id="题目思路-2"><a href="#题目思路-2" class="headerlink" title="题目思路"></a>题目思路</h4><p>考虑 $f_{i,j}$ 记录 $i$ 个数和为 $j$ 的方案数。</p><h4 id="AC-代码-2"><a href="#AC-代码-2" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;<span class="type">int</span> f[<span class="number">55</span>][<span class="number">2505</span>];<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,m,k;cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;f[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;f[<span class="number">1</span>][i]=<span class="number">1</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;<span class="keyword">for</span>(<span class="type">int</span> kk=<span class="number">0</span>;kk&lt;k;kk++)&#123;<span class="keyword">if</span>(kk+j&lt;=k)&#123;f[i][kk+j]+=f[i<span class="number">-1</span>][kk];&#125;<span class="keyword">else</span>&#123;<span class="keyword">break</span>;&#125;f[i][kk+j]%=mod;&#125;&#125;&#125;<span class="type">int</span> ans=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;ans+=f[n][i];ans%=mod;&#125;cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre><h3 id="abc248-d"><a href="#abc248-d" class="headerlink" title="abc248_d"></a><a href="https://atcoder.jp/contests/abc248/tasks/abc248_d">abc248_d</a></h3><h4 id="题目翻译-3"><a href="#题目翻译-3" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>$q$ 个询问，问 $[l,r]$ 中，有多少数 $&#x3D;k$。</p><h4 id="题目思路-3"><a href="#题目思路-3" class="headerlink" title="题目思路"></a>题目思路</h4><p><code>lower_bound</code> 和 <code>upper_bound</code> 找一下。</p><p>值和位置一起排序，两次二分，找到符合要求的区间。</p><h4 id="AC-代码-3"><a href="#AC-代码-3" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp">vector&lt;<span class="type">int</span>&gt;v[<span class="number">200005</span>];<span class="type">int</span> a[<span class="number">200005</span>];<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,q;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];v[a[i]].<span class="built_in">push_back</span>(i);&#125;cin&gt;&gt;q;<span class="keyword">while</span>(q--)&#123;<span class="type">int</span> l,r,k;cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;<span class="type">long</span> <span class="type">long</span> ans=<span class="built_in">upper_bound</span>(v[k].<span class="built_in">begin</span>(),v[k].<span class="built_in">end</span>(),r)-<span class="built_in">lower_bound</span>(v[k].<span class="built_in">begin</span>(),v[k].<span class="built_in">end</span>(),l);cout&lt;&lt;ans&lt;&lt;endl;&#125;&#125;</code></pre><h3 id="abc248-e"><a href="#abc248-e" class="headerlink" title="abc248_e"></a><a href="https://atcoder.jp/contests/abc248/tasks/abc248_e">abc248_e</a></h3><h4 id="题目翻译-4"><a href="#题目翻译-4" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>输入 $n$ 个点的坐标和一个整数 $k$，问有多少条直线通过其中恰好 $k$ 个点，如果无穷多个输出 <code>Infinity</code>。</p><h4 id="题目思路-4"><a href="#题目思路-4" class="headerlink" title="题目思路"></a>题目思路</h4><p>$n$ 个点一共可以生成至多 $\frac{n*(n-1)}{2}$ 个直线，每个直线判断一下。</p><h4 id="AC-代码-4"><a href="#AC-代码-4" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;<span class="type">int</span> x[<span class="number">305</span>],y[<span class="number">305</span>];<span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k)</span></span><span class="function"></span>&#123;<span class="keyword">return</span> (x[j]-x[i])*(y[k]-y[i])-(x[k]-x[i])*(y[j]-y[i])==<span class="number">0</span>;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,k,ans=<span class="number">0</span>;cin&gt;&gt;n&gt;&gt;k;<span class="keyword">if</span>(k==<span class="number">1</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;Infinity&quot;</span>);<span class="keyword">return</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;x[i]&gt;&gt;y[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)&#123;<span class="type">int</span> sum=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> kk=<span class="number">1</span>;kk&lt;=n;kk++)&#123;<span class="keyword">if</span>(<span class="built_in">check</span>(i,j,kk))&#123;<span class="keyword">if</span>(kk!=i&amp;&amp;kk&lt;j)&#123;sum=<span class="number">0</span>;<span class="keyword">break</span>;&#125;sum++;&#125;&#125;<span class="keyword">if</span>(sum&gt;=k)&#123;ans++;&#125;&#125;&#125;cout&lt;&lt;ans&lt;&lt;endl;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="comment">//freopen(&quot;example.in&quot;,&quot;r&quot;,stdin);</span><span class="comment">//freopen(&quot;example.out&quot;,&quot;w&quot;,stdout);</span><span class="comment">//std::ios::sync_with_stdio(false);</span><span class="comment">//cin.tie(nullptr);cout.tie(nullptr);</span><span class="type">int</span> t=<span class="number">1</span>;<span class="keyword">while</span>(t--)&#123;<span class="built_in">solve</span>();&#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1657B XY Sequence</title>
      <link href="/archives/CF1657B/"/>
      <url>/archives/CF1657B/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>四个整数，$n,B,x,y$，每次可以选择 $a_i&#x3D;a_{i-1}+x$ 或者 $a_i&#x3D;a_{i-1}-y$，必须保证 $a_i\leq B$，问 $a$ 数组的元素和。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>这道题可以贪心。</p><p>每次尽可能加上 $x$，如果超过就减掉 $y$。</p><p>这肯定是对的贪心策略；</p><p>因为，这样肯定保证多加上少减去。</p><p>每次都是加 $x$，减 $y$，所以多加少减肯定正确。</p><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,b,x,y;cin&gt;&gt;n&gt;&gt;b&gt;&gt;x&gt;&gt;y;ll ans=<span class="number">0</span>,last=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;last=(last+x&gt;b?last-y:last+x);ans+=last;&#125;cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC247 做题笔记</title>
      <link href="/archives/ABC247/"/>
      <url>/archives/ABC247/</url>
      
        <content type="html"><![CDATA[<h3 id="abc247-a"><a href="#abc247-a" class="headerlink" title="abc247_a"></a><a href="https://atcoder.jp/contests/abc247/tasks/abc247_a">abc247_a</a></h3><h4 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>一个字符串，输出向左移 $1$ 位的结果，第四个位置移完后消失。</p><h4 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h4><p>直接输出前一个位置。</p><h4 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">char</span> c1,c2,c3,c4;cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;c3&gt;&gt;c4;cout&lt;&lt;<span class="number">0</span>&lt;&lt;c1&lt;&lt;c2&lt;&lt;c3&lt;&lt;endl;&#125;</code></pre><h3 id="abc247-b"><a href="#abc247-b" class="headerlink" title="abc247_b"></a><a href="https://atcoder.jp/contests/abc247/tasks/abc247_b">abc247_b</a></h3><h4 id="题目翻译-1"><a href="#题目翻译-1" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>输入 $n$ 个人的姓和名，每个人的昵称是自己的姓或名，不能出现自己的昵称与其他人的姓或名相同。问是否可以做到。</p><h4 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h4><p>把姓名存进一个 <code>multiset</code> 里，自己的姓名一样只存一次。看自己的姓名是否出现 $&gt;1$ 次。</p><h4 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp">string fir[<span class="number">105</span>],sec[<span class="number">105</span>];multiset&lt;string&gt;name;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;fir[i]&gt;&gt;sec[i];<span class="keyword">if</span>(fir[i]==sec[i])&#123;name.<span class="built_in">insert</span>(fir[i]);&#125;<span class="keyword">else</span>&#123;name.<span class="built_in">insert</span>(fir[i]);name.<span class="built_in">insert</span>(sec[i]);&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(name.<span class="built_in">count</span>(fir[i])&gt;<span class="number">1</span>&amp;&amp;name.<span class="built_in">count</span>(sec[i])&gt;<span class="number">1</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);<span class="keyword">return</span>;&#125;&#125;<span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);&#125;</code></pre><h3 id="abc247-c"><a href="#abc247-c" class="headerlink" title="abc247_c"></a><a href="https://atcoder.jp/contests/abc247/tasks/abc247_c">abc247_c</a></h3><h4 id="题目翻译-2"><a href="#题目翻译-2" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>已知 $s_1&#x3D;\text{1}$。</p><p>之后 $s_x&#x3D;s_{x-1}+x+s_{x-1}$。</p><p>例如 $s_2&#x3D;\text{1 2 1}$</p><h4 id="题目思路-2"><a href="#题目思路-2" class="headerlink" title="题目思路"></a>题目思路</h4><p>按题意模拟即可，就是个基础的动态规划。</p><h4 id="AC-代码-2"><a href="#AC-代码-2" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp">string s[<span class="number">20</span>];<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;s[<span class="number">1</span>]=<span class="string">&quot;1&quot;</span>;<span class="type">int</span> n;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;s[i]=s[i<span class="number">-1</span>]+<span class="string">&quot; &quot;</span>+<span class="built_in">to_string</span>(i)+<span class="string">&quot; &quot;</span>+s[i<span class="number">-1</span>];&#125;cout&lt;&lt;s[n]&lt;&lt;endl;&#125;</code></pre><h3 id="abc247-d"><a href="#abc247-d" class="headerlink" title="abc247_d"></a><a href="https://atcoder.jp/contests/abc247/tasks/abc247_d">abc247_d</a></h3><h4 id="题目翻译-3"><a href="#题目翻译-3" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>维护一个队列。</p><p><code>1 x c</code> 表示队尾插入 $x$ 个 $c$。</p><p><code>1 c</code> 表示输出队首前 $c$ 的元素和，并出队。</p><h4 id="题目思路-3"><a href="#题目思路-3" class="headerlink" title="题目思路"></a>题目思路</h4><p>不能按题意模拟，超时。</p><p>队列里每个位置记录两个量，元素和个数。</p><p>每次输出就看个数。</p><h4 id="AC-代码-3"><a href="#AC-代码-3" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> cnt,val;&#125;;queue&lt;node&gt;q;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> query;cin&gt;&gt;query;<span class="keyword">while</span>(query--)&#123;<span class="type">int</span> qq;cin&gt;&gt;qq;<span class="keyword">if</span>(qq==<span class="number">1</span>)&#123;<span class="type">int</span> x,c;cin&gt;&gt;x&gt;&gt;c;node z;z.cnt=c;z.val=x;q.<span class="built_in">push</span>(z);&#125;<span class="keyword">else</span>&#123;<span class="type">int</span> c;<span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;cin&gt;&gt;c;<span class="keyword">while</span>(c&gt;<span class="number">0</span>)&#123;<span class="keyword">if</span>(q.<span class="built_in">front</span>().cnt&gt;c)&#123;sum+=<span class="number">1LL</span>*c*q.<span class="built_in">front</span>().val;q.<span class="built_in">front</span>().cnt-=c;<span class="keyword">break</span>;&#125;<span class="keyword">else</span>&#123;sum+=<span class="number">1LL</span>*q.<span class="built_in">front</span>().cnt*q.<span class="built_in">front</span>().val;c-=q.<span class="built_in">front</span>().cnt;q.<span class="built_in">pop</span>();&#125;&#125;cout&lt;&lt;sum&lt;&lt;endl;&#125;&#125;&#125;</code></pre><h3 id="abc247-e"><a href="#abc247-e" class="headerlink" title="abc247_e"></a><a href="https://atcoder.jp/contests/abc247/tasks/abc247_e">abc247_e</a></h3><h4 id="题目翻译-4"><a href="#题目翻译-4" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>输入一个长度为 $n$ 个数字，还有 $X$ 和 $Y$。<br>问数组中有几个区间最大值是 $X$ 且最小值是 $Y$。</p><h4 id="题目思路-4"><a href="#题目思路-4" class="headerlink" title="题目思路"></a>题目思路</h4><p>所有数字分为 $a_i&gt;Y$，$a_i&#x3D;Y$，$a_i&lt;X$，$a_i&#x3D;X$，$X&lt;a_i&lt;Y$ 五种情况。<br>$&gt;Y$ 和 $&lt;X$ 的位置一定不能选。<br>选一个区间，包含至少一个 $&#x3D;Y$，包含至少一个 $&#x3D;X$，问有多少种方案。<br>问以每个位置作为结尾，有多少个方案。<br>对于每个位置，找自己之前的最近的 $X$ 是多少，最近的 $Y$ 是多少，至多选多少个数字没有 $&gt;Y$ 和 $&lt;X$ 的情况。</p><h4 id="AC-代码-4"><a href="#AC-代码-4" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,x,y,maxxid=<span class="number">0</span>,minnid=<span class="number">0</span>,la=<span class="number">1</span>;<span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> z;cin&gt;&gt;z;<span class="keyword">if</span>(z==x)&#123;maxxid=i;&#125;<span class="keyword">if</span>(z==y)&#123;minnid=i;&#125;<span class="keyword">if</span>(z&gt;x||z&lt;y)&#123;maxxid=<span class="number">0</span>;minnid=<span class="number">0</span>;la=i<span class="number">+1</span>;&#125;<span class="keyword">if</span>(maxxid!=<span class="number">0</span>&amp;&amp;minnid!=<span class="number">0</span>)&#123;ans+=<span class="built_in">min</span>(maxxid,minnid)-la<span class="number">+1</span>;&#125;&#125;cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre><h3 id="abc247-f"><a href="#abc247-f" class="headerlink" title="abc247_f"></a><a href="https://atcoder.jp/contests/abc247/tasks/abc247_f">abc247_f</a></h3><h4 id="题目翻译-5"><a href="#题目翻译-5" class="headerlink" title="题目翻译"></a>题目翻译</h4><p>有 $n$ 张牌，第 $i$ 张牌正面是 $P_i$，反面是 $Q_i$。保证 $P_i$和 $Q_i$ 是 $1$ 到 $n$ 的排列。<br>从所有的牌中选一个子集，使得从 $1$ 到 $n$ 的每个数字，都出现过（正面或反面） 。</p><h4 id="题目思路-5"><a href="#题目思路-5" class="headerlink" title="题目思路"></a>题目思路</h4><p>把每张牌看做是连接 $P_i$ 和 $Q_i$ 的一条边。</p><p>因为都是排列，整个图是由若干环组成的。</p><p>对每个换来说，选一个子集，不能有连续的两条边不选。</p><p>答案是 Lucas Number。</p><p>不同环不互相影响，不同环的答案撑起来就可以了。</p><h4 id="AC-代码-5"><a href="#AC-代码-5" class="headerlink" title="AC 代码"></a>AC 代码</h4><pre><code class="highlight cpp"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;<span class="type">int</span> f[<span class="number">200050</span>];<span class="type">int</span> c[<span class="number">200050</span>];<span class="type">int</span> p[<span class="number">200050</span>];<span class="type">int</span> q[<span class="number">200050</span>];<span class="type">int</span> g[<span class="number">200050</span>]=&#123;<span class="number">2</span>,<span class="number">1</span>&#125;;<span class="type">long</span> <span class="type">long</span> z=<span class="number">1</span>;<span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> x)</span></span><span class="function"></span>&#123;<span class="keyword">return</span> f[x]!=x?f[x]=<span class="built_in">F</span>(f[x]):x;&#125;<span class="function"><span class="type">void</span> <span class="title">U</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><span class="function"></span>&#123;x=<span class="built_in">F</span>(x);y=<span class="built_in">F</span>(y);<span class="keyword">if</span>(x==y)&#123;<span class="keyword">return</span>;&#125;f[x]=y;c[y]+=c[x];&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;g[i]=(g[i<span class="number">-1</span>]+g[i<span class="number">-2</span>])%mod;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;f[i]=i;c[i]=<span class="number">1</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;p[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;q[i];<span class="built_in">U</span>(p[i],q[i]);&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(f[i]==i)&#123;z=z*g[c[i]]%mod;&#125;&#125;cout&lt;&lt;z&lt;&lt;endl;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 洛谷题单 117 | 基础数学问题 做题笔记</title>
      <link href="/archives/math1/"/>
      <url>/archives/math1/</url>
      
        <content type="html"><![CDATA[<p><strong>题目都超链接了，可以直接点开。</strong></p><h4 id="P1143-进制转换"><a href="#P1143-进制转换" class="headerlink" title="P1143 进制转换"></a><a href="https://www.luogu.com.cn/problem/P1143">P1143 进制转换</a></h4><p>十进制与 $n$ 进制的互相转换，板子题，不多说。</p><pre><code class="highlight cpp">string c=<span class="string">&quot;0123456789ABCDEF&quot;</span>;<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> m)</span></span><span class="function"></span>&#123;<span class="keyword">if</span>(x/m)&#123;<span class="built_in">f</span>(x/m,m);&#125;cout&lt;&lt;c[x%m];&#125;<span class="function"><span class="type">int</span> <span class="title">fu</span><span class="params">(string x,<span class="type">int</span> m)</span></span><span class="function"></span>&#123;<span class="built_in">reverse</span>(x.<span class="built_in">begin</span>(),x.<span class="built_in">end</span>());<span class="type">int</span> sum=<span class="number">0</span>,cnt=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.<span class="built_in">size</span>();i++)&#123;sum+=cnt*(x[i]-(x[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;x[i]&lt;=<span class="string">&#x27;9&#x27;</span>?<span class="number">48</span>:<span class="number">55</span>));cnt*=m;&#125;<span class="keyword">return</span> sum;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,m;string s;cin&gt;&gt;n&gt;&gt;s&gt;&gt;m;<span class="built_in">f</span>(<span class="built_in">fu</span>(s,n),m);&#125;</code></pre><h4 id="P1469-找筷子"><a href="#P1469-找筷子" class="headerlink" title="P1469 找筷子"></a><a href="https://www.luogu.com.cn/problem/P1469">P1469 找筷子</a></h4><p>清楚两个异或相关的概念。</p><p>相同数异或，结果为 $0$。</p><p>$0$ 与一个数异或，结果等于那一个数。</p><p>恰巧这题 $n$ 范围较大，空间较小，用此概念。</p><p>答案即为所有数异或。</p><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> x=<span class="number">0</span>,y,n;cin&gt;&gt;n;<span class="keyword">while</span>(n--)&#123;cin&gt;&gt;y;x^=y;&#125;cout&lt;&lt;x&lt;&lt;endl;&#125;</code></pre><h4 id="P1100-高低位交换"><a href="#P1100-高低位交换" class="headerlink" title="P1100 高低位交换"></a><a href="https://www.luogu.com.cn/problem/P1100">P1100 高低位交换</a></h4><p>位运算。</p><p><code>a&lt;&lt;x</code> 为 $a$ 向左移动 $x$ 位。</p><p><code>a&gt;&gt;x</code> 为 $a$ 向右移动 $x$ 位。</p><p>$2^{32}$ 爆 <code>int</code>，但是用 <code>unsigned int</code> 就够了。</p><p><del>样例是一生一世我爱你可还行，被酸了。</del></p><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">unsigned</span> <span class="type">int</span> n;cin&gt;&gt;n;cout&lt;&lt;(n&lt;&lt;<span class="number">16</span>)+(n&gt;&gt;<span class="number">16</span>)&lt;&lt;endl;&#125;</code></pre><h4 id="P1017-NOIP2000-提高组-进制转换"><a href="#P1017-NOIP2000-提高组-进制转换" class="headerlink" title="P1017 [NOIP2000 提高组] 进制转换"></a><a href="https://www.luogu.com.cn/problem/P1017">P1017 [NOIP2000 提高组] 进制转换</a></h4><p>负数进制与十进制转换。</p><p>可以去看我的</p><p>[post cid&#x3D;”13” cover&#x3D;”” size&#x3D;””&#x2F;]</p><p>题解，同步发表于<a href="https://www.luogu.com.cn/blog/516346/solution-at4239">洛谷博客</a>。</p><p>这题就是 <a href="https://www.luogu.com.cn/problem/AT4239">AT4239</a> 的双倍经验，看我的博客吧，不说了。</p><pre><code class="highlight cpp"><span class="type">int</span> a[<span class="number">100005</span>];string c=<span class="string">&quot;0123456789ABCDEFGHIJ&quot;</span>;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;ll n,r;cin&gt;&gt;n&gt;&gt;r;<span class="type">int</span> x=<span class="number">-1</span>;<span class="keyword">if</span>(n==<span class="number">0</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;0=0(base%lld)&quot;</span>,r);<span class="keyword">return</span>;&#125;<span class="built_in">printf</span>(<span class="string">&quot;%lld=&quot;</span>,n);<span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;a[++x]=n%(r);n/=(r);<span class="keyword">if</span>(a[x]&lt;<span class="number">0</span>)&#123;n++;a[x]-=r; &#125;&#125;<span class="built_in">reverse</span>(a,a+x<span class="number">+1</span>);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=x;i++)&#123;cout&lt;&lt;c[a[i]];&#125;<span class="built_in">printf</span>(<span class="string">&quot;(base%lld)&quot;</span>,r);&#125;</code></pre><h4 id="P1866-编号"><a href="#P1866-编号" class="headerlink" title="P1866 编号"></a><a href="https://www.luogu.com.cn/problem/P1866">P1866 编号</a></h4><p>排列组合。</p><p>注意，前面兔子选的数，后面不能选，所以要减一下。</p><p>注意答案取模。</p><pre><code class="highlight cpp"><span class="type">int</span> a[<span class="number">55</span>];<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;ll ans=<span class="number">1</span>;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;<span class="built_in">sort</span>(a<span class="number">+1</span>,a+n<span class="number">+1</span>);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;ans*=a[i]-i<span class="number">+1</span>;ans%=<span class="number">1000000007</span>;&#125;cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre><h4 id="P2822-NOIP2016-提高组-组合数问题"><a href="#P2822-NOIP2016-提高组-组合数问题" class="headerlink" title="P2822 [NOIP2016 提高组] 组合数问题"></a><a href="https://www.luogu.com.cn/problem/P2822">P2822 [NOIP2016 提高组] 组合数问题</a></h4><h4 id="P2789-直线交点数"><a href="#P2789-直线交点数" class="headerlink" title="P2789 直线交点数"></a><a href="https://www.luogu.com.cn/problem/P2789">P2789 直线交点数</a></h4><p>动态规划。</p><p><code>f[i][j]</code> 表示 $i$ 个直线，其中因为平行少了 $j$ 个交点，是否可能（$0$ 或 $1$）。</p><pre><code class="highlight cpp">bitset&lt;305&gt;f[<span class="number">30</span>];<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i*(i<span class="number">-1</span>)/<span class="number">2</span>;j++)&#123;<span class="keyword">if</span>(f[i][j])&#123;<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;i+k&lt;=n;k++)&#123;f[i+k][j+k*(k<span class="number">-1</span>)/<span class="number">2</span>]=<span class="number">1</span>;&#125;&#125;&#125;&#125;cout&lt;&lt;f[n].<span class="built_in">count</span>()&lt;&lt;endl;&#125;</code></pre><h4 id="P3913-车的攻击"><a href="#P3913-车的攻击" class="headerlink" title="P3913 车的攻击"></a><a href="https://www.luogu.com.cn/problem/P3913">P3913 车的攻击</a></h4><p>没有被打到的，肯定是<strong>总数 $-$ 打到的</strong>。</p><p>所以，看有多少被打到的位置就行。</p><p>但可能会一个位置被打多次，要去重。</p><pre><code class="highlight cpp"><span class="type">int</span> x[<span class="number">1000005</span>],y[<span class="number">1000005</span>];<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;ll n,k;cin&gt;&gt;n&gt;&gt;k;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;cin&gt;&gt;x[i]&gt;&gt;y[i];&#125;<span class="built_in">sort</span>(x<span class="number">+1</span>,x+k<span class="number">+1</span>);<span class="built_in">sort</span>(y<span class="number">+1</span>,y+k<span class="number">+1</span>);<span class="type">int</span> xx=<span class="built_in">unique</span>(x<span class="number">+1</span>,x+k<span class="number">+1</span>)-x<span class="number">-1</span>;<span class="type">int</span> yy=<span class="built_in">unique</span>(y<span class="number">+1</span>,y+k<span class="number">+1</span>)-y<span class="number">-1</span>;cout&lt;&lt;n*n-(n-xx)*(n-yy)&lt;&lt;endl;&#125;</code></pre><h4 id="P2638-安全系统"><a href="#P2638-安全系统" class="headerlink" title="P2638 安全系统"></a><a href="https://www.luogu.com.cn/problem/P2638">P2638 安全系统</a></h4><h4 id="P1246-编码"><a href="#P1246-编码" class="headerlink" title="P1246 编码"></a><a href="https://www.luogu.com.cn/problem/P1246">P1246 编码</a></h4><p>由于这题没想到数学写法，索性暴力。</p><p>枚举所有可能，找到比输入的字符串小的，答案加上 $1$。</p><p>但是，一个迷惑的点，字符串之间比较有点怪。</p><p>下面这两行比较，就不是等价的。</p><pre><code class="highlight cpp">cout&lt;&lt;((string)<span class="string">&quot;z&quot;</span>&lt;(string)<span class="string">&quot;ab&quot;</span>);cout&lt;&lt;(<span class="string">&quot;z&quot;</span>&lt;<span class="string">&quot;ab&quot;</span>);</code></pre><p>所以我索性自己写了个比较函数。</p><p>有个注意点，自己也算上，所以答案要加 $1$。</p><pre><code class="highlight cpp"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string st,string s)</span></span><span class="function"></span>&#123;<span class="keyword">if</span>(st.<span class="built_in">size</span>()&gt;s.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="number">0</span>;<span class="keyword">if</span>(st.<span class="built_in">size</span>()&lt;s.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="number">1</span>;<span class="keyword">return</span> st&lt;s;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;string s;<span class="type">int</span> ans=<span class="number">0</span>;cin&gt;&gt;s;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;<span class="keyword">if</span>(s[i]&gt;=s[i<span class="number">+1</span>])&#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);<span class="keyword">return</span>;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)&#123;string st=<span class="string">&quot;&quot;</span>;st+=<span class="built_in">char</span>(i+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);<span class="keyword">if</span>(<span class="built_in">check</span>(st,s))&#123;ans++;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=<span class="number">26</span>;j++)&#123;string st=<span class="string">&quot;&quot;</span>;st+=<span class="built_in">char</span>(i+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);st+=<span class="built_in">char</span>(j+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);<span class="keyword">if</span>(<span class="built_in">check</span>(st,s))&#123;ans++;&#125;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=<span class="number">26</span>;j++)&#123;<span class="keyword">for</span>(<span class="type">int</span> k=j<span class="number">+1</span>;k&lt;=<span class="number">26</span>;k++)&#123;string st=<span class="string">&quot;&quot;</span>;st+=<span class="built_in">char</span>(i+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);st+=<span class="built_in">char</span>(j+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);st+=<span class="built_in">char</span>(k+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);<span class="keyword">if</span>(<span class="built_in">check</span>(st,s))&#123;ans++;&#125;&#125;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=<span class="number">26</span>;j++)&#123;<span class="keyword">for</span>(<span class="type">int</span> k=j<span class="number">+1</span>;k&lt;=<span class="number">26</span>;k++)&#123;<span class="keyword">for</span>(<span class="type">int</span> l=k<span class="number">+1</span>;l&lt;=<span class="number">26</span>;l++)&#123;string st=<span class="string">&quot;&quot;</span>;st+=<span class="built_in">char</span>(i+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);st+=<span class="built_in">char</span>(j+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);st+=<span class="built_in">char</span>(k+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);st+=<span class="built_in">char</span>(l+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);<span class="keyword">if</span>(<span class="built_in">check</span>(st,s))&#123;ans++;&#125;&#125;&#125;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=<span class="number">26</span>;j++)&#123;<span class="keyword">for</span>(<span class="type">int</span> k=j<span class="number">+1</span>;k&lt;=<span class="number">26</span>;k++)&#123;<span class="keyword">for</span>(<span class="type">int</span> l=k<span class="number">+1</span>;l&lt;=<span class="number">26</span>;l++)&#123;<span class="keyword">for</span>(<span class="type">int</span> m=l<span class="number">+1</span>;m&lt;=<span class="number">26</span>;m++)&#123;string st=<span class="string">&quot;&quot;</span>;st+=<span class="built_in">char</span>(i+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);st+=<span class="built_in">char</span>(j+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);st+=<span class="built_in">char</span>(k+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);st+=<span class="built_in">char</span>(l+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);st+=<span class="built_in">char</span>(m+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);<span class="keyword">if</span>(<span class="built_in">check</span>(st,s))&#123;ans++;&#125;&#125;&#125;&#125;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=<span class="number">26</span>;j++)&#123;<span class="keyword">for</span>(<span class="type">int</span> k=j<span class="number">+1</span>;k&lt;=<span class="number">26</span>;k++)&#123;<span class="keyword">for</span>(<span class="type">int</span> l=k<span class="number">+1</span>;l&lt;=<span class="number">26</span>;l++)&#123;<span class="keyword">for</span>(<span class="type">int</span> m=l<span class="number">+1</span>;m&lt;=<span class="number">26</span>;m++)&#123;<span class="keyword">for</span>(<span class="type">int</span> n=m<span class="number">+1</span>;n&lt;=<span class="number">26</span>;n++)&#123;string st=<span class="string">&quot;&quot;</span>;st+=<span class="built_in">char</span>(i+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);st+=<span class="built_in">char</span>(j+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);st+=<span class="built_in">char</span>(k+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);st+=<span class="built_in">char</span>(l+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);st+=<span class="built_in">char</span>(m+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);st+=<span class="built_in">char</span>(n+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);<span class="keyword">if</span>(<span class="built_in">check</span>(st,s))&#123;ans++;&#125;&#125;&#125;&#125;&#125;&#125;&#125;cout&lt;&lt;ans<span class="number">+1</span>&lt;&lt;endl;&#125;</code></pre><h4 id="P2926-USACO08DEC-Patting-Heads-S"><a href="#P2926-USACO08DEC-Patting-Heads-S" class="headerlink" title="P2926 [USACO08DEC]Patting Heads S"></a><a href="https://www.luogu.com.cn/problem/P2926">P2926 [USACO08DEC]Patting Heads S</a></h4><p>有点类似下一题，线性筛。</p><p>枚举每个数，那个数的倍数就答案多一。</p><p>当然，最后输出要减一，因为有自己。</p><pre><code class="highlight cpp"><span class="type">int</span> a[<span class="number">100005</span>],b[<span class="number">1000005</span>],ans[<span class="number">1000005</span>];<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,maxx=<span class="number">0</span>;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];b[a[i]]++;maxx=<span class="built_in">max</span>(maxx,a[i]);&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxx;i++)&#123;<span class="keyword">if</span>(!b[i])&#123;<span class="keyword">continue</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=maxx;j+=i)&#123;ans[j]+=b[i];&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cout&lt;&lt;ans[a[i]]<span class="number">-1</span>&lt;&lt;endl;&#125;&#125;</code></pre><h4 id="P3383-【模板】线性筛素数"><a href="#P3383-【模板】线性筛素数" class="headerlink" title="P3383 【模板】线性筛素数"></a><a href="https://www.luogu.com.cn/problem/P3383">P3383 【模板】线性筛素数</a></h4><p>模板题。</p><p>线性筛，就是把一些数的倍数，打上合数的标签。</p><pre><code class="highlight cpp"><span class="type">bool</span> pri[<span class="number">100000005</span>];<span class="type">int</span> a[<span class="number">6000000</span>];<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span><span class="function"></span>&#123;pri[<span class="number">0</span>]=pri[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)&#123;<span class="keyword">if</span>(!pri[i])&#123;<span class="keyword">for</span>(<span class="type">int</span> cnt=<span class="number">2</span>;cnt&lt;=n/i;cnt++)&#123;pri[i*cnt]=<span class="number">1</span>;&#125;&#125;&#125;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,q,sz=<span class="number">1</span>;cin&gt;&gt;n&gt;&gt;q;<span class="built_in">init</span>(n);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(!pri[i])&#123;a[sz++]=i;&#125;&#125;<span class="keyword">while</span>(q--)&#123;<span class="type">int</span> x;cin&gt;&gt;x;cout&lt;&lt;a[x]&lt;&lt;endl;&#125;&#125;</code></pre><h4 id="P1835-素数密度"><a href="#P1835-素数密度" class="headerlink" title="P1835 素数密度"></a><a href="https://www.luogu.com.cn/problem/P1835">P1835 素数密度</a></h4><p>有一个做法可以直接求 $1$ 到 $n$ 个质数个数。</p><p>注意到 $R-L\leq10^6$。</p><p>注意到 $2^{31}$ 以下的合数，一定有一个 $\leq\sqrt{R}$ 的质因数。</p><p>用一个长度为 $R-L+1$ 的数组存每个数字是否是合数。</p><p><code>f[i]</code> 表示 $i$ 是否是合数。</p><p>如果 <code>f[i] == 1</code> 表示 $L+i$ 是合数。</p><p>如果 <code>f[i] == 0</code> 表示 $L+i$ 是质数。</p><p>枚举所有 $\leq \sqrt{R}$ 的质数 $p$。</p><p>枚举在 $L$ 到 $R$ 之间的，所有 $p$ 的倍数（不包括 $p$ 本身）设为 $i$。</p><p>标记 $i$ 是合数.</p><pre><code class="highlight cpp"><span class="type">int</span> pri[<span class="number">1000005</span>];<span class="type">int</span> v[<span class="number">1000005</span>];<span class="type">long</span> <span class="type">long</span> l,r,sum;<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span></span><span class="function"></span>&#123;<span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)&#123;<span class="keyword">if</span>(!v[i])&#123;<span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j=<span class="built_in">max</span>((l+i<span class="number">-1LL</span>)/i,<span class="number">2LL</span>)*i;j&lt;=r;j+=i)&#123;pri[j-l]=<span class="number">1</span>;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=r/j;j+=i)&#123;v[j] = i;&#125;&#125;&#125;</code></pre><h4 id="P1029-NOIP2001-普及组-最大公约数和最小公倍数问题"><a href="#P1029-NOIP2001-普及组-最大公约数和最小公倍数问题" class="headerlink" title="P1029 [NOIP2001 普及组] 最大公约数和最小公倍数问题"></a><a href="https://www.luogu.com.cn/problem/P1029">P1029 [NOIP2001 普及组] 最大公约数和最小公倍数问题</a></h4><p>我们枚举 $P$。</p><p>判断 $P$ 是否是 $n\times m$ 的因数。</p><p>又因为 $\gcd(a,b)\times\operatorname{lcm}(a,b)&#x3D;a\times b$。</p><p>所以可以算出 $Q$。</p><p>最后判断 $P$ 和 $Q$ 的最大公因数和最小公倍数即可。</p><p>当然，可以互换，答案 $\times 2$。</p><p>如果 $x&#x3D;y$，答案还要 $-1$。</p><pre><code class="highlight cpp"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> y)</span></span><span class="function"></span>&#123;<span class="keyword">return</span> y?<span class="built_in">gcd</span>(y,x%y):x;&#125;<span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">lcm</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> y)</span></span><span class="function"></span>&#123;<span class="keyword">return</span> x/<span class="built_in">gcd</span>(x,y)*y;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">long</span> <span class="type">long</span> n,m,ans=<span class="number">0</span>;cin&gt;&gt;n&gt;&gt;m;<span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">sqrt</span>(n*m);i++)&#123;<span class="keyword">if</span>(n*m%i==<span class="number">0</span>&amp;&amp;<span class="built_in">gcd</span>(i,n*m/i)==n&amp;&amp;<span class="built_in">lcm</span>(i,n*m/i)==m)ans++;&#125;cout&lt;&lt;(n==m?ans*<span class="number">2</span><span class="number">-1</span>:ans*<span class="number">2</span>)&lt;&lt;endl;&#125;</code></pre><h4 id="P1072-NOIP2009-提高组-Hankson-的趣味题"><a href="#P1072-NOIP2009-提高组-Hankson-的趣味题" class="headerlink" title="P1072 [NOIP2009 提高组] Hankson 的趣味题"></a><a href="https://www.luogu.com.cn/problem/P1072">P1072 [NOIP2009 提高组] Hankson 的趣味题</a></h4><h4 id="P1069-NOIP2009-普及组-细胞分裂"><a href="#P1069-NOIP2009-普及组-细胞分裂" class="headerlink" title="P1069 [NOIP2009 普及组] 细胞分裂"></a><a href="https://www.luogu.com.cn/problem/P1069">P1069 [NOIP2009 普及组] 细胞分裂</a></h4><h4 id="P1572-计算分数"><a href="#P1572-计算分数" class="headerlink" title="P1572 计算分数"></a><a href="https://www.luogu.com.cn/problem/P1572">P1572 计算分数</a></h4><h4 id="P4057-Code-1-晨跑"><a href="#P4057-Code-1-晨跑" class="headerlink" title="P4057 [Code+#1]晨跑"></a><a href="https://www.luogu.com.cn/problem/P4057">P4057 [Code+#1]晨跑</a></h4><p>三数的最小公倍数。</p><p>两两算最小公倍数，其实就是 $\operatorname{lcm}(\operatorname{lcm}(a,b),c)$。</p><p>当然，$\operatorname{lcm}(a,b)&#x3D;a\div\gcd(a,b)\times b$。</p><p>所以， $\operatorname{lcm}(\operatorname{lcm}(a,b),c)&#x3D;c\div\gcd(a\div\gcd(a,b)\times b,c)\times a\div\gcd(a,b)\times b$。</p><p>很简单，推一下就好。</p><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">long</span> <span class="type">long</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;cout&lt;&lt;c/__gcd(a/__gcd(a,b)*b,c)*a/__gcd(a,b)*b&lt;&lt;endl;&#125;</code></pre><h4 id="P1414-又是毕业季II"><a href="#P1414-又是毕业季II" class="headerlink" title="P1414 又是毕业季II"></a><a href="https://www.luogu.com.cn/problem/P1414">P1414 又是毕业季II</a></h4><p>我们把 $n$ 个数的因数存下来，存到数组里。</p><p>就从最大的因数开始往下找，找到某个因数，出现次数正好大于等于 $k$，即为当前询问答案。</p><pre><code class="highlight cpp"><span class="type">int</span> a[<span class="number">1000005</span>];<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,maxx=<span class="number">-1</span>;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> x;cin&gt;&gt;x;maxx=<span class="built_in">max</span>(maxx,x);<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">sqrt</span>(x);j++)&#123;<span class="keyword">if</span>(x%j==<span class="number">0</span>)&#123;a[x/j]++;a[j]++;<span class="keyword">if</span>(j*j==x)&#123;a[j]--;&#125;&#125;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">while</span>(a[maxx]&lt;i)&#123;maxx--;&#125;cout&lt;&lt;maxx&lt;&lt;endl;&#125;&#125;</code></pre><h4 id="P2651-添加括号III"><a href="#P2651-添加括号III" class="headerlink" title="P2651 添加括号III"></a><a href="https://www.luogu.com.cn/problem/P2651">P2651 添加括号III</a></h4><p>结论就是判断 $a_1\times a_3\times a_4 \times a_5\times…\times a_n \bmod a_2&#x3D;0$ 是否成立。</p><p>因为最好的办法就是让 $a_2$ 为分母，其他为分子。</p><p>注意多组数据。</p><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,sum=<span class="number">0</span>,a2;cin&gt;&gt;n;<span class="type">int</span> x;cin&gt;&gt;x&gt;&gt;a2;a2/=__gcd(a2,x);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;cin&gt;&gt;x;a2/=__gcd(a2,x);&#125;<span class="built_in">puts</span>(a2==<span class="number">1</span>?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);&#125;</code></pre><h4 id="P2660-zzc-种田"><a href="#P2660-zzc-种田" class="headerlink" title="P2660 zzc 种田"></a><a href="https://www.luogu.com.cn/problem/P2660">P2660 zzc 种田</a></h4><p>每次都种若干个<strong>以宽为边长</strong>的正方形。</p><p>这样子，长变成了宽。</p><p>宽变成了原来的长种完之后剩下的长度。</p><p>过程类似于辗转相除一样。</p><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">long</span> <span class="type">long</span> n,m,ans=<span class="number">0</span>;cin&gt;&gt;n&gt;&gt;m;<span class="keyword">while</span>(n&amp;&amp;m)&#123;<span class="keyword">if</span>(n&gt;m)<span class="built_in">swap</span>(n,m);ans+=m/n*n*<span class="number">4</span>;m%=n;&#125;cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre><h4 id="P3601-签到题"><a href="#P3601-签到题" class="headerlink" title="P3601 签到题"></a><a href="https://www.luogu.com.cn/problem/P3601">P3601 签到题</a></h4><p>和素数密度差不多做法，不多说。</p><pre><code class="highlight cpp"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">666623333</span>;<span class="type">long</span> <span class="type">long</span> a[<span class="number">1000020</span>]; <span class="type">long</span> <span class="type">long</span> f[<span class="number">1000020</span>]; <span class="type">long</span> <span class="type">long</span> l,r;<span class="type">int</span> v[<span class="number">1000020</span>];<span class="function"><span class="type">void</span> <span class="title">DO</span><span class="params">(<span class="type">long</span> <span class="type">long</span> p)</span></span><span class="function"></span>&#123;<span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=(l+p<span class="number">-1</span>)/p*p;i&lt;=r;i+=p)&#123;<span class="keyword">while</span>(a[i-l]%p==<span class="number">0</span>)&#123;a[i-l]/=p;&#125;f[i-l]=f[i-l]/p*(p<span class="number">-1</span>);&#125;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=r-l;i++)&#123;a[i]=l+i;f[i]=l+i;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=r/i;i++)&#123;<span class="keyword">if</span>(!v[i])&#123;<span class="built_in">DO</span>(i);&#125;<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=r/j;j+=i)&#123;v[j]=i;&#125;&#125;<span class="type">long</span> <span class="type">long</span> z=(l+r)%mod*(r-l<span class="number">+1</span>)%mod*<span class="number">333311667</span>%mod;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=r-l;i++)&#123;<span class="keyword">if</span>(a[i]&gt;<span class="number">1</span>)&#123;f[i]=f[i]/a[i]*(a[i]<span class="number">-1</span>);&#125;z=(z-f[i])%mod;&#125;<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(z+mod)%mod);&#125;</code></pre><h4 id="P1403-AHOI2005-约数研究"><a href="#P1403-AHOI2005-约数研究" class="headerlink" title="P1403 [AHOI2005]约数研究"></a><a href="https://www.luogu.com.cn/problem/P1403">P1403 [AHOI2005]约数研究</a></h4><p>每 $x$ 个数中，就有 $1$ 个 $x$ 的倍数。</p><p>枚举约数，用 $n$ 去除一下，就知道有多少个倍数。</p><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,ans=<span class="number">0</span>;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;ans+=n/i;&#125;cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre><h4 id="P1593-因子和"><a href="#P1593-因子和" class="headerlink" title="P1593 因子和"></a><a href="https://www.luogu.com.cn/problem/P1593">P1593 因子和</a></h4>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] B3619 10 进制转 x 进制</title>
      <link href="/archives/B3619/"/>
      <url>/archives/B3619/</url>
      
        <content type="html"><![CDATA[<h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>就是进制转换啦。</p><p>进制转换，肯定要讲一下短除法。就是每次看余数并做除法。</p><p>比如 $10$ 转换 $2$ 进制。</p><p>$13\bmod2&#x3D;1$。</p><p>$6 \bmod 2&#x3D;0$。</p><p>$3 \bmod2&#x3D;1$。</p><p>$1\bmod2&#x3D;1$。</p><p>最后倒序枚举余数即可。</p><p>那么，我们可以有两种方案，<strong>递归</strong>和<strong>存数组</strong>。</p><p>存数组，字面意思，把余数存下来，最后翻转，输出。</p><p>递归，每次准备着输出数，但先递归后面的余数，最后返回来输出。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><p>我用的是递归。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">using</span> <span class="keyword">namespace</span> std;string c=<span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;<span class="comment">//存数</span><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ll x,ll m)</span></span>&#123;<span class="keyword">if</span>(x/m)<span class="built_in">f</span>(x/m,m);cout&lt;&lt;c[x%m];&#125;<span class="comment">//递归</span><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;ll n,x;cin&gt;&gt;n&gt;&gt;x;<span class="keyword">if</span>(x==<span class="number">0</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);<span class="keyword">return</span>;&#125;<span class="built_in">f</span>(n,x);    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p><a href="https://www.luogu.com.cn/problem/B2143">想了解其他做法，可以参考B2143。</a></p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF727C Guess the Array</title>
      <link href="/archives/CF727C/"/>
      <url>/archives/CF727C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>一个长度为 $n$ 的数组，最多 $n$ 次询问，输出数组元素。</p><p>询问：每次输出 <code>? x y</code>，返回 $x+y$ 的值。</p><p>输出：输出 <code> !</code> 之后空一格，正常输出数组元素。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>小学数学知识。</p><p>我们先询问 $x+y$ 的值，在询问 $x+z$ 的值，最后询问 $y+z$ 的值。</p><p>恰好每个数出现两次，把总和除以二，得到 $x+y+z$。</p><p>知道三数总和，知道两两之和，相减求 $3$ 个数的值。</p><p>接着处理余下的数。</p><p>整除 $3$，输出。</p><p>余 $2$，查询两个数的和，在随机找一个数搭配算出来。</p><p>余 $1$，随便找数搭配算。</p><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="type">int</span> a[n<span class="number">+1</span>];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-n%<span class="number">3</span>;i+=<span class="number">3</span>)<span class="comment">//先3个一组解决</span>&#123;<span class="type">int</span> x,y,z;cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i<span class="number">+2</span>&lt;&lt;endl;<span class="built_in">fflush</span>(stdout);cin&gt;&gt;x;cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i<span class="number">+1</span>&lt;&lt;endl;<span class="built_in">fflush</span>(stdout);cin&gt;&gt;y;cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;i<span class="number">+1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i<span class="number">+2</span>&lt;&lt;endl;<span class="built_in">fflush</span>(stdout);cin&gt;&gt;z;<span class="type">int</span> sum=x+y+z;sum/=<span class="number">2</span>;a[i<span class="number">+1</span>]=sum-x;a[i<span class="number">+2</span>]=sum-y;a[i]=sum-z;&#125;    <span class="comment">//解决剩下的</span><span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">2</span>)&#123;cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;n&lt;&lt;endl;<span class="built_in">fflush</span>(stdout);<span class="type">int</span> x,y;cin&gt;&gt;x;cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;n&lt;&lt;endl;<span class="built_in">fflush</span>(stdout);cin&gt;&gt;y;a[n]=y-a[<span class="number">1</span>];a[n<span class="number">-1</span>]=x-a[n];&#125;<span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">1</span>)&#123;cout&lt;&lt;<span class="string">&quot;? 1 &quot;</span>&lt;&lt;n&lt;&lt;endl;<span class="built_in">fflush</span>(stdout);<span class="type">int</span> x;cin&gt;&gt;x;a[n]=x-a[<span class="number">1</span>];&#125;cout&lt;&lt;<span class="string">&quot;! &quot;</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;&#125;</code></pre><p>不知道交互题怎么解决，看<a href="https://www.luogu.com.cn/problem/P1947">P1947</a>和<a href="https://www.luogu.com.cn/problem/P1733">P1733</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1656B Subtract Operation</title>
      <link href="/archives/CF1656B/"/>
      <url>/archives/CF1656B/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>有 $n$ 个数，每次选一个删掉，其他数都减去删掉的数，问最后一个数会不会等于 $k$。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题一看就是结论题。我们先把 $a$ 数组假设为删除数字顺序定下来的数组，看最后结果。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xhqaiz6i.png"></p><p>上述过程每步已经化简。</p><p>那么，很容易看出，最后答案是两个数的差。</p><p>这题便成为了：$n$ 个数里，是否有两个数字差为 $k$。</p><p>那么我想到是用 <code>map</code> 和 <code>set</code> 做。</p><p><code>map</code> 没访问的位置便不存在，不担心 RE，<code>set</code> 自带 <code>count</code> 找出现次数。</p><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;set&lt;ll&gt;s;s.<span class="built_in">clear</span>();ll n,k;cin&gt;&gt;n&gt;&gt;k;<span class="type">bool</span> f=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;ll x;cin&gt;&gt;x;s.<span class="built_in">insert</span>(x);<span class="keyword">if</span>(s.<span class="built_in">count</span>(x-k)||s.<span class="built_in">count</span>(x+k))<span class="comment">//差值为k，可能x是较大数，也可能是较小数。</span>&#123;f=<span class="number">1</span>;&#125;&#125;<span class="built_in">puts</span>(f==<span class="number">1</span>?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> t;cin&gt;&gt;t;<span class="keyword">while</span>(t--)&#123;<span class="built_in">solve</span>();&#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;map&lt;ll,<span class="type">bool</span>&gt;mp;mp.<span class="built_in">clear</span>();ll n,k;cin&gt;&gt;n&gt;&gt;k;<span class="type">bool</span> f=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;ll x;cin&gt;&gt;x;mp[x]=<span class="number">1</span>;<span class="keyword">if</span>(mp[x-k]||mp[x+k])&#123;f=<span class="number">1</span>;&#125;&#125;<span class="built_in">puts</span>(f==<span class="number">1</span>?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> t;cin&gt;&gt;t;<span class="keyword">while</span>(t--)&#123;<span class="built_in">solve</span>();&#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1654A Maximum Cake Tastiness</title>
      <link href="/archives/CF1654A/"/>
      <url>/archives/CF1654A/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>有 $n$ 个数，可以选择一个区间 $[l,r]$ 进行一次翻转。最大的相邻两个数的和是多少。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>最大的和，肯定就是最大加次大。而次大肯定能翻转到最大旁边，所以答案就是次大加最大。</p><p>为什么次大肯定翻转到最大旁边：用样例解释一下。</p><pre><code class="highlight tex">65 2 1 4 7 3</code></pre><p>翻转 $[1,4]$。</p><pre><code class="highlight tex">64 1 2 5 7 3</code></pre><p>最大是 $7$，次大是 $5$。</p><p>不管怎么样，以次大为一个端点，最大旁边为一个端点，永远能保证次大换到最大旁边。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="type">int</span> a[n<span class="number">+1</span>];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;<span class="built_in">sort</span>(a<span class="number">+1</span>,a+n<span class="number">+1</span>);<span class="comment">//sort从小到大排序。</span>cout&lt;&lt;a[n]+a[n<span class="number">-1</span>]&lt;&lt;endl;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF630E A rectangle</title>
      <link href="/archives/CF630E/"/>
      <url>/archives/CF630E/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>有一个矩形，四个顶点分别是 $x_1,y_1,x_2,y_2$。问在中间铺设正六边形，每个六边形不能整个超出矩形范围，可以最多超过 $\frac{3}{4}$，问最多能铺多少个。</p><p>如样例中，左下角的正六边形露出了 $\frac{3}{4}$，最下面第二个正六边形露出了 $\frac{1}{2}$。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>我们通过观察下图，很容易发现，这些正六边形摆放都是按以下规律：</p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/CF630E/48c2c84bca0c98bd6d46d326b4d0dd0c737e119c.png"></p><p>第奇数列，摆 $n$ 个。</p><p>第偶数列，摆 $n-1$ 个。</p><p>那么我们算出摆了多少列和 $n$ 具体是多少即可。</p><p>我们考虑把这张图，整体往左移半格。那么这张图的 $x_1&#x3D;0.5$，$x_2&#x3D;4.5$。再加上超过的部分，长就是 $4.5-0.5+1&#x3D;5$。</p><p>同理，这张图的宽也加上超过的部分，就是 $5-1+2&#x3D;6$。</p><p>那么通过长，算出奇列数和偶列数，通过宽，算出每列上面有多少的格子。</p><p>最后只要<strong>奇数列个数 $\times$ 奇数列的格子 $+$ 偶数列个数 $\times$ 偶数列的格子</strong>。</p><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span><span class="comment">//记得开longlong</span></span><span class="function"></span>&#123;ll x1,y1,x2,y2;cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;ll x=x2-x1<span class="number">+1</span>,y=y2-y1<span class="number">+1</span>;<span class="comment">//算出长宽</span>ll ans=((y<span class="number">+1</span>)/<span class="number">2</span>)*((x<span class="number">+1</span>)/<span class="number">2</span>)+((y<span class="number">-1</span>)/<span class="number">2</span>)*((x<span class="number">-1</span>)/<span class="number">2</span>);<span class="comment">//结论带入</span>cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1651B Prove Him Wrong</title>
      <link href="/archives/CF1651B/"/>
      <url>/archives/CF1651B/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>我们有一个长度为 $n$ 的数组，操作若干次以下操作，能否使数组总和不会变小，能的话请输出数组。</p><ul><li>找到 $a_i$ 和 $a_j$ 且 $i\neq j$。</li><li>$a_i &#x3D; a_j &#x3D; \left|a_i-a_j\right|$。</li></ul><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>不会变小，我们尽可能保证是相等，因为 $a_i\leq10^9$。</p><p>那么 $\left|a_i-a_j\right|\times2&#x3D;a_i+a_j$。</p><p>那么很容易想到了，$a_i$ 与 $a_j$ 是 $3$ 倍的关系。</p><p>我们只要判断，多少个 $3$ 相乘 $\leq10^9$。</p><p>那么应该是 $3^{18}&#x3D;387420489$。</p><p>再加上开始的 $1$，所以数组有 $19$ 位，$n\leq19$ 是 <code>YES</code> ，否则是 <code>NO</code>。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><pre><code class="highlight cpp"><span class="comment">//我这边是打表找出所有数的，也可以把这些数据在程序中算出来。</span>ll a[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">27</span>,<span class="number">81</span>,<span class="number">243</span>,<span class="number">729</span>,<span class="number">2187</span>,<span class="number">6561</span>,<span class="number">19683</span>,<span class="number">59049</span>,<span class="number">177147</span>,<span class="number">531441</span>,<span class="number">1594323</span>,<span class="number">4782969</span>,<span class="number">14348907</span>,<span class="number">43046721</span>,<span class="number">129140163</span>,<span class="number">387420489</span>&#125;;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="keyword">if</span>(n&lt;=<span class="number">19</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cout&lt;&lt;a[i<span class="number">-1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;cout&lt;&lt;endl;&#125;<span class="keyword">else</span>&#123;<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);&#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] P8197 [传智杯 #4 决赛] 排排队</title>
      <link href="/archives/P8197/"/>
      <url>/archives/P8197/</url>
      
        <content type="html"><![CDATA[<h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>从交换相邻这里，我们可以明显看出来，这有些类似冒泡排序。</p><p>但是，我们要来思考一下怎样情况输出 <code>NO</code>。</p><p>我们就用冒泡排序的代码来分析一下。为了方便分析，就用 <code>for</code> 循环版的。</p><pre><code class="highlight cpp"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n-i;j++)&#123;<span class="keyword">if</span>(a[j]&lt;a[j<span class="number">+1</span>])&#123;<span class="built_in">swap</span>(a[j],a[j<span class="number">+1</span>]);&#125;&#125;&#125;</code></pre><p>我们能很快的反应出来，$(n-1)\times (n-i)$ 肯定是比 $n^2$ 要小的。</p><p>所以，$n^2$ 的操作绰绰有余。</p><p>因此，我们只要判断数组元素是否相同就可以了，不用考虑能否在 $n^2$ 次操作内完成。</p><p>我们先写出判断一样的代码。</p><pre><code class="highlight cpp"><span class="type">int</span> n=<span class="built_in">read</span>();<span class="type">int</span> a[n<span class="number">+1</span>],b[n<span class="number">+1</span>],c[n<span class="number">+1</span>],d[n<span class="number">+1</span>];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];c[i]=a[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;b[i];d[i]=b[i];&#125;<span class="built_in">sort</span>(c<span class="number">+1</span>,c+n<span class="number">+1</span>);<span class="built_in">sort</span>(d<span class="number">+1</span>,d+n<span class="number">+1</span>);<span class="comment">//因为不能打乱ab数组，就用别的数组代替。如果排序后一模一样，里面元素也一样。</span><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(c[i]!=d[i])&#123;<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);<span class="keyword">return</span>;&#125;<span class="comment">//判断ab数组元素是否相同</span>&#125;</code></pre><p>接着，如果可以构造出来，我们就可以每次确定一个数的位置，最后就能创造出来。</p><pre><code class="highlight cpp"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//循环b的元素</span>&#123;<span class="type">int</span> x;<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;<span class="keyword">if</span>(a[j]==b[i])&#123;x=j;<span class="comment">//找位置</span><span class="keyword">break</span>;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> j=x;j&gt;i;j--)<span class="comment">//交换</span>&#123;<span class="built_in">swap</span>(a[j],a[j<span class="number">-1</span>]);cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;j<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;&#125;&#125;cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</code></pre><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);ch=<span class="built_in">getchar</span>();&#125;<span class="keyword">return</span> x*f;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n=<span class="built_in">read</span>();<span class="type">int</span> a[n<span class="number">+1</span>],b[n<span class="number">+1</span>],c[n<span class="number">+1</span>],d[n<span class="number">+1</span>];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];c[i]=a[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;b[i];d[i]=b[i];&#125;<span class="built_in">sort</span>(c<span class="number">+1</span>,c+n<span class="number">+1</span>);<span class="built_in">sort</span>(d<span class="number">+1</span>,d+n<span class="number">+1</span>);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(c[i]!=d[i])&#123;<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);<span class="keyword">return</span>;&#125;&#125;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> x;<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)<span class="comment">//这里赛时写错过了，事后被同学 hack 了 QwQ</span>&#123;<span class="keyword">if</span>(a[j]==b[i])&#123;x=j;<span class="keyword">break</span>;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> j=x;j&gt;i;j--)&#123;<span class="built_in">swap</span>(a[j],a[j<span class="number">-1</span>]);cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;j<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;&#125;&#125;cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> t=<span class="built_in">read</span>();<span class="keyword">while</span>(t--)&#123;<span class="built_in">solve</span>();&#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1648A Weird Sum</title>
      <link href="/archives/CF1648A/"/>
      <url>/archives/CF1648A/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>一个 $n\times m$ 的网格，每个格子里有 $1$ 个数，问对于所有相同的数，曼哈顿距离总和是多少？</p><p>曼哈顿距离：$a_{i_1,j_1}$ 与 $a_{i_2,j_2}$ 距离为 $\left|i_1-i_2\right|+\left|j_1-j_2\right|$。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>暴力搜一遍，肯定挂掉，$n\times m$ 有 $100000$。</p><p>所以，我们对每种数进行分类，每一类再分成 $x$ 轴的总距离求和加上 $y$ 轴的总距离求和。</p><p>这是蒟蒻我能想到的最优解了。</p><h3 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h3><p>那么总距离求和该怎么做呢，例如上文的 $x$ 轴的总距离求和。</p><p>我们考虑把它们排序，放在一根数轴上。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4x536hgp.png"></p><p>我们以端点为 $i_2$ 和 $i_3$ 的线段做例子：</p><p>本身长度 $2$。</p><p>往右边走，有 $i_3,i_4,i_5$，产生 $3$ 次贡献。</p><p>左边每个点都可以与上面 $3$ 个点产生连接，左边有 $2$ 个点，$i_1$ 和 $i_2$。</p><p>注意，线段的两个端点也算进去。</p><p>那么这个线段产生<strong>左边端点个数 $\times$ 线段长度 $\times$ 右边端点个数</strong>这么多贡献。</p><p>同理，每个线段也产生上述贡献。</p><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="meta">#<span class="keyword">define</span> ll long long</span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> x,y;<span class="comment">//记录x轴和y轴</span>&#125;;vector&lt;node&gt;a[<span class="number">100020</span>];<span class="comment">//对数字分类</span><span class="function">ll <span class="title">s</span><span class="params">(vector&lt;<span class="type">int</span>&gt;a)</span><span class="comment">//求和</span></span><span class="function"></span>&#123;ll sum=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;sum+=i*(a[i]-a[i<span class="number">-1</span>])*(a.<span class="built_in">size</span>()-i);&#125;<span class="keyword">return</span> sum;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,m,maxx=INT_MIN;cin&gt;&gt;n&gt;&gt;m;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;<span class="type">int</span> z;cin&gt;&gt;z;node zz;zz.x=i;zz.y=j;a[z].<span class="built_in">push_back</span>(zz);<span class="comment">//插入这个点信息</span>maxx=<span class="built_in">max</span>(z,maxx);<span class="comment">//找出最大值</span>&#125;&#125;ll sum=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxx;i++)&#123;vector&lt;<span class="type">int</span>&gt;xx;<span class="comment">//记录x轴</span>vector&lt;<span class="type">int</span>&gt;yy;<span class="comment">//记录y轴</span><span class="keyword">for</span>(<span class="keyword">auto</span> j:a[i])<span class="comment">//插入点的信息</span>&#123;xx.<span class="built_in">push_back</span>(j.x);yy.<span class="built_in">push_back</span>(j.y);&#125;        <span class="comment">//排序</span><span class="built_in">sort</span>(xx.<span class="built_in">begin</span>(),xx.<span class="built_in">end</span>());<span class="built_in">sort</span>(yy.<span class="built_in">begin</span>(),yy.<span class="built_in">end</span>());ll sx=<span class="built_in">s</span>(xx);ll sy=<span class="built_in">s</span>(yy);sum+=sx+sy;<span class="comment">//求和</span>&#125;cout&lt;&lt;sum&lt;&lt;endl;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> t=<span class="number">1</span>;<span class="keyword">while</span>(t--)&#123;<span class="built_in">solve</span>();&#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1646B Quality vs Quantity</title>
      <link href="/archives/CF1646B/"/>
      <url>/archives/CF1646B/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>我们对于 $n$ 个数 $a_1,a_2,…,a_n$，每个数可以选择标记为 <code>Red</code> 或 <code>Blue</code>。</p><p>对于颜色 $c$，<code>Count(c)</code> 表示颜色 $c$ 出现几次。</p><p>对于颜色 $c$，<code>Sum(c)</code> 表示标记为颜色 $c$ 的数字总和。</p><p>问是否存在 <code>Sum(Red)</code> $&gt;$ <code>Sum(Blue)</code> 且  <code>Count(Red)</code> $&lt;$  <code>Count(Blue)</code></p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>个人认为像贪心。</p><p>我们尽量让多的个数和少的个数差距缩小，最好为 $1$，再让多的个数全选小的，少的个数全选大的，最大程度缩小差距。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;ll a[n<span class="number">+5</span>];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;<span class="built_in">sort</span>(a<span class="number">+1</span>,a+n<span class="number">+1</span>);<span class="comment">//排序，更好区分大小</span>ll l=<span class="number">2</span>,r=n,sl=a[<span class="number">1</span>]+a[<span class="number">2</span>],sr=a[n];<span class="comment">//默认多的有两个，少的有一个，小的和默认为两个最小的，大的和默认一个最大的</span><span class="type">bool</span> f=<span class="number">0</span>;<span class="comment">//记录是否实现</span><span class="keyword">if</span>(sr&gt;sl)<span class="comment">//默认状态就实现，去输出</span>&#123;f=<span class="number">1</span>;<span class="keyword">goto</span> check;&#125;<span class="keyword">while</span>(l<span class="number">+2</span>&lt;r)<span class="comment">//每次左右都移一次，所以这里是+2</span>&#123;l++;r--;sl+=a[l];sr+=a[r];<span class="keyword">if</span>(sr&gt;sl)<span class="comment">//判断</span>&#123;f=<span class="number">1</span>;<span class="keyword">break</span>;&#125;&#125;check:;<span class="keyword">if</span>(f==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC105C Base -2 Number</title>
      <link href="/archives/ABC105C/"/>
      <url>/archives/ABC105C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>给定一个 $10$ 进制数，将其转变成 $-2$ 进制。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>和二进制一样短除法。</p><p>注意事项：</p><ul><li>特判数据 $n&#x3D;0$ ，不特判的话，它本身进入不了短除法代码，答案就没有记录</li><li>任何位置上不可能出现 $-1$，要转成 $1$ 输出。</li><li>短除法倒着输出。</li></ul><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span><span class="comment">//没加上快读快写、long long定义ll，防抄袭</span></span><span class="function"></span>&#123;<span class="type">int</span> a[<span class="number">105</span>];<span class="comment">//存储答案</span>ll n=<span class="built_in">read</span>();<span class="type">int</span> x=<span class="number">-1</span>;<span class="comment">//存储答案位数</span><span class="keyword">if</span>(n==<span class="number">0</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);<span class="keyword">return</span>;&#125;<span class="comment">//特判</span><span class="keyword">while</span>(n!=<span class="number">0</span>)<span class="comment">//短除法</span>&#123;a[++x]=n%(<span class="number">-2</span>);n/=(<span class="number">-2</span>);<span class="keyword">if</span>(a[x]==(<span class="number">-1</span>))<span class="comment">//注意事项栏</span>&#123;n++;a[x]=<span class="number">1</span>; &#125;&#125;<span class="built_in">reverse</span>(a,a+x<span class="number">+1</span>);<span class="comment">//倒着输出，翻转区间</span><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=x;<span class="built_in">write</span>(a[i++]));&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1644B Anti-Fibonacci Permutation</title>
      <link href="/archives/CF1644B/"/>
      <url>/archives/CF1644B/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>我们定义对于所有 $i$ ($3 \leq i \leq n$)， $p_{i-2}+p_{i-1} \ne p_i$  这样的数列称之为 <strong>反斐波那契数列</strong> ，给定一个 $n$ ，请输出 $n$ 个长度为 $n$ 的不同的反斐波那契数列。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>只要 $p_{i-2}$ 和 $p_{i-1}$ 中任意一个数大于 $p_i$ ，那么肯定为反斐波那契数列。</p><p>所以构造一个<strong>降序</strong>的数列，然后每次把最后一个数往前挪，肯定能构成一个反斐波那契数列。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="type">int</span> f=n;<span class="comment">//记录最小位置</span><span class="type">int</span> a[n<span class="number">+1</span>];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=n-i<span class="number">+1</span>;<span class="comment">//创造降序数组</span><span class="keyword">for</span>(<span class="type">int</span> nn=<span class="number">0</span>;nn&lt;n;nn++)<span class="comment">//n个数列</span>&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;cout&lt;&lt;endl;<span class="built_in">swap</span>(a[f],a[f<span class="number">-1</span>]);<span class="comment">//每次把最小往前</span>f--;<span class="comment">//更新最小位置</span>&#125;&#125;</code></pre><p>多组数据，代码未全。请勿copy，当心踩坑。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF17FINALA AKIBA</title>
      <link href="/archives/CF17FINALA/"/>
      <url>/archives/CF17FINALA/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>输入一个字符串，可不可以在任意一位插入 $\tt A$，使这个字符串变为 <code>AKIHABARA</code>。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p><code>AKIHABARA</code> 中只出现了 $4$ 次 $\tt A$ ，所以，我们枚举所有可能，每个位置都可以有 <em>选</em> 或 <em>不选</em> 两种可能，所以一共只有 $2^4$ 种可能，十分少。</p><p>我们只要分别枚举 没有 $\tt A$、一个 $\tt A$、两个 $\tt A$、三个 $\tt A$、四个 $\tt A$ 的情况即可。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><pre><code class="highlight cpp"><span class="comment">//没有 A</span><span class="keyword">if</span>(s==<span class="string">&quot;KIHBR&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//一个 A</span><span class="keyword">if</span>(s==<span class="string">&quot;AKIHBR&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;KIHABR&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;KIHBAR&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;KIHBRA&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//两个 A</span><span class="keyword">if</span>(s==<span class="string">&quot;AKIHABR&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;AKIHBAR&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;AKIHBRA&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;KIHABAR&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;KIHABRA&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;KIHBARA&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//三个 A</span><span class="keyword">if</span>(s==<span class="string">&quot;AKIHABAR&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;AKIHABRA&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;AKIHBARA&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;KIHABARA&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//四个 A</span><span class="keyword">if</span>(s==<span class="string">&quot;AKIHABARA&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//都不满足</span><span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC142D Disjoint Set of Common Divisors</title>
      <link href="/archives/ABC142D/"/>
      <url>/archives/ABC142D/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>给定两个数 $a$ 和 $b$ ，求能同时整除 $a$ 和 $b$ 的数的个数，且这些数需要两两互质。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>两两互质，也就说明有以下几种情况：</p><ol><li>均为不同的质数。</li><li>相邻 。</li><li>一个是质数，另一个不是他的倍数。</li><li>所有数和 $1$。</li><li>相邻奇数</li><li>较大数是质数。<br>……</li></ol><p>这是常见的情况，其实还有很多。那么我们肯定不能全写到程序里。我们只选择第 $1$ 个性质：均为不同的质数。</p><p>确保了找的答案是质数，然后确保它是这两个数的因数（因为能整除），那么我们只要找到两个数<strong>共同的质因数</strong>。</p><p>共同的质因数，一定是两个数最大公因数的质因数。</p><p>所以找出最大公因数，再找出所有最大公因数的质因数（还要算上特殊的”1”），即为答案。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="meta">#<span class="keyword">define</span> ll long long<span class="comment">//数据很大，要long long</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;ll a,b,s=<span class="number">1</span>;<span class="comment">//1一定是两个数的公因数</span><span class="function">ll <span class="title">gcd</span><span class="params">(ll x,ll y)</span></span><span class="function"></span>&#123;<span class="keyword">return</span> y?<span class="built_in">gcd</span>(y,x%y):x;<span class="comment">//辗转相除法求最大公因数</span>&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;cin&gt;&gt;a&gt;&gt;b;ll g=<span class="built_in">gcd</span>(a,b);<span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(g);i++)<span class="comment">//枚举最大公因数的质因数</span>&#123;<span class="keyword">if</span>(g%i==<span class="number">0</span>)<span class="comment">//如果是的（后续补充说明）</span>&#123;s++;<span class="comment">//找到了一个</span><span class="keyword">while</span>(g%i==<span class="number">0</span>)g/=i;<span class="comment">//把这个质因数除完</span>&#125;&#125;cout&lt;&lt;(g!=<span class="number">1</span>?++s:s);<span class="comment">//如果有剩余的质因数，再加上1</span>&#125;</code></pre><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>第 $15$ 行 <code>if(g%i==0)</code> 解释</p><p>找到了$g$ 最小能整除的数 $i$，那么 $i$ <strong>肯定是个质数</strong>，不用加以判断。</p><p>举个不成功的反例验证一下结论。</p><p>如果 $i$ 不是质数，说明 $i$ 还有其他因数，那么 $i$ 的因数也就是 $g$ 的因数了，$i$ 肯定不是最小能被整除的数了。</p><p>所以得出结论，$i$ 肯定是个质数，不用加上质数判断。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1633C Kill the Monster</title>
      <link href="/archives/CF1633C/"/>
      <url>/archives/CF1633C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>一个 01 串，找到一个它的子串，1 的个数多删所有 0，0 的个数多删所有 1。问最多删几个数。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>首先统计 01 个数是必须的。</p><p>之后，分类讨论 3 种情况。</p><h4 id="情况1：0-的个数比-1-多。"><a href="#情况1：0-的个数比-1-多。" class="headerlink" title="情况1：0 的个数比 1 多。"></a>情况1：0 的个数比 1 多。</h4><p>输出 1 的个数。</p><h4 id="情况2：1-的个数比-0-多。"><a href="#情况2：1-的个数比-0-多。" class="headerlink" title="情况2：1 的个数比 0 多。"></a>情况2：1 的个数比 0 多。</h4><p>输出 0 的个数。</p><h4 id="情况-3：1-的个数和-0-的个数相等。"><a href="#情况-3：1-的个数和-0-的个数相等。" class="headerlink" title="情况 3：1 的个数和 0 的个数相等。"></a>情况 3：1 的个数和 0 的个数相等。</h4><p>这里有个小问题。</p><p>有人可能问，一样不是输出 $0$ 吗？</p><p>但是，重新审题。<strong>找到一个它的子串</strong>，这里划重点。</p><p>也就是说，不用看整个字符串。</p><p>那么我们少拿一个 0 或少拿一个 1，答案就更多了。</p><p>所以，输出 0 的个数 -1。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;string s;cin&gt;&gt;s;<span class="type">int</span> cnt0=<span class="number">0</span>,cnt1=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)<span class="comment">//记录01个数</span>&#123;<span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)cnt1++;<span class="keyword">else</span> cnt0++;&#125;<span class="keyword">if</span>(cnt0==cnt1)cout&lt;&lt;cnt0<span class="number">-1</span>&lt;&lt;endl;<span class="comment">//分类讨论</span><span class="keyword">else</span> cout&lt;&lt;<span class="built_in">min</span>(cnt0,cnt1)&lt;&lt;endl;&#125;</code></pre><p>多组数据，代码未全。请勿copy，当心踩坑！</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1633B Minority</title>
      <link href="/archives/CF1633B/"/>
      <url>/archives/CF1633B/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>一个 01 串，找到一个它的子串，1 的个数多删所有 0，0 的个数多删所有 1。问最多删几个数。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>首先统计 01 个数是必须的。</p><p>之后，分类讨论 3 种情况。</p><h4 id="情况1：0-的个数比-1-多。"><a href="#情况1：0-的个数比-1-多。" class="headerlink" title="情况1：0 的个数比 1 多。"></a>情况1：0 的个数比 1 多。</h4><p>输出 1 的个数。</p><h4 id="情况2：1-的个数比-0-多。"><a href="#情况2：1-的个数比-0-多。" class="headerlink" title="情况2：1 的个数比 0 多。"></a>情况2：1 的个数比 0 多。</h4><p>输出 0 的个数。</p><h4 id="情况-3：1-的个数和-0-的个数相等。"><a href="#情况-3：1-的个数和-0-的个数相等。" class="headerlink" title="情况 3：1 的个数和 0 的个数相等。"></a>情况 3：1 的个数和 0 的个数相等。</h4><p>这里有个小问题。</p><p>有人可能问，一样不是输出 $0$ 吗？</p><p>但是，重新审题。<strong>找到一个它的子串</strong>，这里划重点。</p><p>也就是说，不用看整个字符串。</p><p>那么我们少拿一个 0 或少拿一个 1，答案就更多了。</p><p>所以，输出 0 的个数 -1。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;string s;cin&gt;&gt;s;<span class="type">int</span> cnt0=<span class="number">0</span>,cnt1=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)<span class="comment">//记录01个数</span>&#123;<span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)cnt1++;<span class="keyword">else</span> cnt0++;&#125;<span class="keyword">if</span>(cnt0==cnt1)cout&lt;&lt;cnt0<span class="number">-1</span>&lt;&lt;endl;<span class="comment">//分类讨论</span><span class="keyword">else</span> cout&lt;&lt;<span class="built_in">min</span>(cnt0,cnt1)&lt;&lt;endl;&#125;</code></pre><p>多组数据，代码未全。请勿copy，当心踩坑！</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1627B Not Sitting</title>
      <link href="/archives/CF1627B/"/>
      <url>/archives/CF1627B/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>A 和 B 两个人，在 $n \times m$ 的教室找位置。A 想和 B 坐得近，B 想和 A 坐得远，由 A 先选位置，请问对于所有情况，A 与 B 之间的距离各是多少？</p><p>补充：距离的定义为：$a_{i_1,j_1}$ 与 $a_{i_2,j_2}$ 距离为 $\left|i_1-i_2\right|+\left|j_1-j_2\right|$</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>A 会选什么位置，我们不用考虑，因为题目求所有情况，不是最优或最坏，所以只需考虑 B 坐的位置。由于想离得远，那么不管 A 坐哪，B 一定选择四个角上离得最远的位置。</p><p>根据上述分析，我们只需穷举 A 坐的位置，并且每次判断 A 的位置与四个角的距离，就可以得出所有结果。</p><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">int</span> <span class="title">juli</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2)</span><span class="comment">//求距离函数</span></span><span class="function"></span>&#123;<span class="keyword">return</span> <span class="built_in">abs</span>(x1-x2)+<span class="built_in">abs</span>(y1-y2);&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;multiset&lt;<span class="type">int</span>&gt;s;<span class="comment">//答案要求排序，set自动排序+去重，mutiset自动排序+不去重</span><span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)<span class="comment">//双重循环穷举答案</span>&#123;s.<span class="built_in">insert</span>(<span class="built_in">max</span>(&#123;<span class="built_in">juli</span>(i,j,<span class="number">1</span>,<span class="number">1</span>),<span class="built_in">juli</span>(i,j,<span class="number">1</span>,m),<span class="built_in">juli</span>(i,j,n,<span class="number">1</span>),<span class="built_in">juli</span>(i,j,n,m)&#125;));<span class="comment">//判断四个角的最大距离</span>&#125;&#125;<span class="keyword">for</span>(<span class="keyword">auto</span> i:s)cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//输出答案</span>cout&lt;&lt;endl;&#125;</code></pre><p>多组数据，代码未全。请勿copy，当心踩坑！</p><p><a href="https://codeforces.com/contest/1627/submission/142843751">完整代码在这</a></p><h3 id="科普一个热知识："><a href="#科普一个热知识：" class="headerlink" title="科普一个热知识："></a>科普一个热知识：</h3><p>可能有些同学对于 <code>s.insert(max(&#123;juli(i,j,1,1),juli(i,j,1,m),juli(i,j,n,1),juli(i,j,n,m)&#125;)); </code> 这一行有疑惑，本机运行可能报错。其实这是新语法，之前求多个最大值要写很多 <code>max()</code>，现在只需 <code>max(&#123;&#125;)</code>，在大括号里写上多个值，如这样：</p><p>求 $a,b,c,d$ 的最大值</p><p>正常代码 <code>cout&lt;&lt;max(max(a,b),max(c,d))&lt;&lt;endl;</code> 要写 $3$ 个 <code>max()</code>，现在只需 <code>cout&lt;&lt;max(&#123;a,b,c,d&#125;)&lt;&lt;endl;</code> 即可。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1621A Stable Arrangement of Rooks</title>
      <link href="/archives/CF1621A/"/>
      <url>/archives/CF1621A/</url>
      
        <content type="html"><![CDATA[<h4 id="题目翻译："><a href="#题目翻译：" class="headerlink" title="题目翻译："></a>题目翻译：</h4><p>有 $n \times n$ 大小的棋盘，一共放 $k$ 辆车，使得这个棋盘稳定。</p><p>稳定的概念是：所有的车移动至相邻四格（上下左右）不会出现一行一列有 $\ge 2$ 辆车。</p><h4 id="做题思路"><a href="#做题思路" class="headerlink" title="做题思路:"></a>做题思路:</h4><p>我们可以考虑，移动之后没有同一行一列有多辆车，那么就让它移动之后还是只有它一辆车，换句话说，每辆车之间至少空一行和一列，也就是在对角线上放是最优想法。如果对角线放不下 $k$ 辆车了，无解输出 <code>-1</code> 。</p><h4 id="深入思考（此分析大佬跳过）"><a href="#深入思考（此分析大佬跳过）" class="headerlink" title="深入思考（此分析大佬跳过）"></a>深入思考（此分析大佬跳过）</h4><p>在怎样的情况下 $n \times n$ 的棋盘放不下 $k$ 辆车呢？</p><p>很显然，每两行两列放一辆车，那么最多可以放 $\left\lfloor\dfrac{n+1}{2}\right\rfloor$ 辆车（大多数语言整数除法自动下取整），所以只要判断 $\dfrac{n+1}{2}$ 与 $k$ 的大小关系。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;<span class="keyword">if</span>((n<span class="number">+1</span>)/<span class="number">2</span>&lt;k)<span class="comment">//判断是否放得下</span>&#123;cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;<span class="keyword">return</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="keyword">if</span>(i==j&amp;&amp;i%<span class="number">2</span>!=<span class="number">0</span>&amp;&amp;k&gt;<span class="number">0</span>)<span class="comment">//判断分别为：对角线、隔一行一列、还可以放车</span>&#123;cout&lt;&lt;<span class="string">&#x27;R&#x27;</span>;k--;<span class="comment">//放完一辆</span>&#125;<span class="keyword">else</span>&#123;cout&lt;&lt;<span class="string">&#x27;.&#x27;</span>;&#125;&#125;cout&lt;&lt;endl;&#125;&#125;</code></pre><p>多组数据，代码未全。请勿copy，当心踩坑！</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1615A Closing The Gap</title>
      <link href="/archives/CF1615A/"/>
      <url>/archives/CF1615A/</url>
      
        <content type="html"><![CDATA[<h4 id="题目翻译："><a href="#题目翻译：" class="headerlink" title="题目翻译："></a>题目翻译：</h4><p>有 $n$ 个数，每个数为 $a_i$  ，你可以每次选 $2$ 个数 $a$ 和 $b$ ，把 $a$ 高度 $-1$ ，把 $b$ 高度 $+1$。在经历无限次操作后，求 $max(a)-min(a)$ 的值。</p><h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><p>其实就是求平均数，如果求出的和是 $n$ 的倍数，那么意味数组 $a$ 中的每个值<strong>相等</strong>且均为<strong>正整数</strong>，那么相差<strong>都为 $0$</strong>。反之不是 $n$ 的倍数，那么总会有数多出 $1$ ，那么最大与最小的差<strong>就为 $1$</strong> 。这个想法非常好证明，取模之后的数比 $n$ 要小，那么每个数添上 $1$ 总会有没添上的，那么差就是为 $1$。</p><h4 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h4><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,sum=<span class="number">0</span>; cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> x;cin&gt;&gt;x;<span class="comment">//输入 </span>sum+=x;<span class="comment">//求和 </span>&#125;cout&lt;&lt;(sum%n==<span class="number">0</span>?<span class="number">0</span>:<span class="number">1</span>)&lt;&lt;endl;<span class="comment">//判断 输出 </span>&#125;</code></pre><p>或者不会三步运算符可用 $if … else…$ 代替</p><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,sum=<span class="number">0</span>; cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> x;cin&gt;&gt;x;<span class="comment">//输入 </span>sum+=x;<span class="comment">//求和 </span>&#125;<span class="keyword">if</span>(sum%n==<span class="number">0</span>)<span class="comment">//如果是第一种情况 </span>&#123;cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;&#125; <span class="keyword">else</span><span class="comment">//如果是第二种情况</span>&#123;cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;&#125;&#125;</code></pre><p>多组数据，代码未全。请勿copy，当心踩坑。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1613B Absent Remainder</title>
      <link href="/archives/CF1613B/"/>
      <url>/archives/CF1613B/</url>
      
        <content type="html"><![CDATA[<p>题目说了，每组数不同，并且 $x\bmod y$ 也不出现在数组 $a$ 中，那么我们可以对数组进行<strong>排序</strong>，因为 $a\bmod b$ 得出的结果是<strong>一定比 $b$ 小的</strong>。那么拿数组的其他数分别去取模最小的数，那么得出的结果一定比数组最小的数还小，则一定<strong>不可能出现</strong>在数组 $a$ 之内。</p><p>简单解释一下这个数据：</p><pre><code class="highlight basic"><span class="number">6</span><span class="symbol">2 </span><span class="number">7</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">8</span></code></pre><p>按我的思路，则会排序成以下数组：</p><p>$[2,3,4,5,7,8]$。</p><p>$3\bmod2$ 不在数组 $a$ 中，</p><p>$4\bmod2$ 不在数组 $a$ 中，</p><p>$5\bmod2$ 不在数组 $a$ 中，</p><p>$7\bmod2$ 不在数组 $a$ 中，</p><p>$8\bmod2$ 不在数组 $a$ 中。</p><p>贴代码：</p><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="type">int</span> a[n];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;cin&gt;&gt;a[i];&#125;<span class="built_in">sort</span>(a,a+n);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)<span class="comment">//n/2组数据即可 </span>&#123;cout&lt;&lt;a[n-i<span class="number">-1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[<span class="number">0</span>]&lt;&lt;endl;<span class="comment">//分别输出x与y,注意顺序，必须x在前y在后 </span>&#125;&#125;</code></pre><p>多组数据，代码未全，当心踩坑。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1555A PizzaForces</title>
      <link href="/archives/CF1555A/"/>
      <url>/archives/CF1555A/</url>
      
        <content type="html"><![CDATA[<h3 id="题目传送："><a href="#题目传送：" class="headerlink" title="题目传送："></a>题目传送：</h3><ul><li><a href="https://www.luogu.com.cn/problem/CF1555A">洛谷</a>；</li><li><a href="https://codeforces.com/problemset/problem/1555/A">CodeForces</a>。</li></ul><h3 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h3><p>这题有 $3$ 大要点：</p><ul><li>平均价一样 $2.5$ 分钟，只需满足尽量披萨数与人数差尽量小。</li><li>$6,8,10$ 可以凑出所有大于等于 $6$ 的偶数。<br>转化一下：$3,4,5$ 可以凑出所有大于等于 $3$ 的整数，因为 $3,4$ 凑不出的最大数为 $5$，具体见<a href="https://www.luogu.com.cn/problem/P3951">洛谷 P3951</a>。</li><li>语言特性：大部分编程语言做除法都是向下取整，所以数学上四舍五入 $a$ 除以 $b$ 等于编程语言中的 <code>(a+b-1)/b</code>。</li></ul><h3 id="做题思路："><a href="#做题思路：" class="headerlink" title="做题思路："></a>做题思路：</h3><p>先特判：<br>$n &lt; 6$ 是 $15$ 分钟；<br>$n \geq 6$ 时，输出 <code>(n+1)/2*5</code>,（因为 $n$ 可能是奇数，所以要加 $1$），前面提到，这个 $\frac{n + 1}{2}$ 一定会被 $3,4,5$ 凑出来，然后把乘 $2.5$ 转化为除以 $2$ 乘 $5$（否则万一 $n+1$ 是奇数就玩完）。</p><h3 id="AC-代码："><a href="#AC-代码：" class="headerlink" title="AC 代码："></a>AC 代码：</h3><h4 id="C-版："><a href="#C-版：" class="headerlink" title="C++ 版："></a>C++ 版：</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> ll long long</span><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;ll t;cin&gt;&gt;t;<span class="keyword">while</span>(t--)&#123;ll n;cin&gt;&gt;n;<span class="keyword">if</span>(n&lt;<span class="number">6</span>)n=<span class="number">6</span>;cout&lt;&lt;(n<span class="number">+1</span>)/<span class="number">2</span>*<span class="number">5</span>&lt;&lt;endl;&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="Python-版："><a href="#Python-版：" class="headerlink" title="Python 版："></a>Python 版：</h4><pre><code class="highlight python">t=<span class="built_in">int</span>(<span class="built_in">input</span>())<span class="keyword">for</span> tt <span class="keyword">in</span> <span class="built_in">range</span>(t):    n=<span class="built_in">int</span>(<span class="built_in">input</span>())    <span class="keyword">if</span> n&lt;<span class="number">6</span>:        <span class="built_in">print</span>(<span class="number">15</span>)    <span class="keyword">else</span>:        <span class="built_in">print</span>((n+<span class="number">1</span>)//<span class="number">2</span>*<span class="number">5</span>)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
