<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【置顶】Something to Say</title>
      <link href="/archives/somethingtosay/"/>
      <url>/archives/somethingtosay/</url>
      
        <content type="html"><![CDATA[<p>这里是我的博客的移植版。</p><p>我的早期内容糟粕很多，甚至可能有错误内容&#x2F;xk 远古文章当个乐子看吧。</p>]]></content>
      
      
      <categories>
          
          <category> Essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF710D Two Arithmetic Progressions</title>
      <link href="/archives/CF710D/"/>
      <url>/archives/CF710D/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是今天粉兔杯每日一题，也是根分日报例题，补一下。</p><p><a href="https://www.luogu.com.cn/blog/Amateur-threshold/pu-li-mei-xue-qian-tan-gen-hao-fen-zhi">暴力美学——浅谈根号分治 - paulzrm 的博客 - 洛谷博客</a></p><h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给出两个等差数列，求在 $[L,R]$ 之间的交集大小。</p><p>等差数列形式为 $ak+b$。</p><p>$1\leq a_1,a_2\leq 2\times 10^9,-2\times 10^9 \leq b_1,b_2,L,R \leq 2\times 10^9,L \le R$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>观察到 $a$ 大，等差数列在 $[L,R]$ 之间的项数就很少。反之亦然。</p><p>所以考虑根号分治。显然阈值 $B&#x3D;\sqrt{2\times 10^9}\approx44722$。</p><p>为了方便，另 $a_1\geq a_2$。</p><ul><li>$a_1\leq B$</li></ul><p>循环节长度为 $\operatorname{lcm}(a_1,a_2)$ 很显然，那么我们找到第一个重复出现的数即可。</p><p>又因为循环节长度为 $\operatorname{lcm}(a_1,a_2)$，所以我们枚举前 $\dfrac{\operatorname{lcm}}{a_1}$ 个在 $a_1k+b_1$ 中的数即可找到第一个重复的数。我一开始实现的时候保守了枚举了 $a_2$ 个，但是我们令 $a_1\geq a_2$，所以其实范围是差不多的。</p><p>知道重复的数 $x$ 之后，答案就是 $\lceil\dfrac{R-x+1}{\operatorname{lcm}}\rceil$。</p><ul><li>$a_1\gt B$</li></ul><p>这是很简单的，因为公差大，所以项数不多，直接枚举 $a_1k+b_1$，判断是否在 $a_2k+b_2$ 中即可。</p><hr><p>实现的时候注意一下开始的位置应该是 $\max{b_1,b_2,L}$。然后自己微调一下变成等差数列中的某个数就行。</p><p>开始循环的位置是 <code>ll start = (max(&#123;b1, b2, L&#125;) - b1 + a1 - 1) / a1 * a1 + b1;</code>。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>$15\ \tt{ms}$ 是目前 CF 最优解了。正解是 exgcd。</p><p><a href="https://codeforces.com/contest/710/submission/247832379">CF submission 247832379</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="type">const</span> <span class="type">int</span> B = <span class="number">44722</span>;ll a1, b1, a2, b2;ll L, R;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; a1 &gt;&gt; b1 &gt;&gt; a2 &gt;&gt; b2 &gt;&gt; L &gt;&gt; R;    <span class="keyword">if</span> (a1 &lt;= a2)        <span class="built_in">swap</span>(a1, a2), <span class="built_in">swap</span>(b1, b2);    ll start = (<span class="built_in">max</span>(&#123;b1, b2, L&#125;) - b1 + a1 - <span class="number">1</span>) / a1 * a1 + b1;    <span class="keyword">if</span> (a1 &lt;= B)    &#123;        ll Lcm = a1 / __gcd(a1, a2) * a2;        <span class="keyword">for</span> (ll i = start, j = <span class="number">1</span>; i &lt;= R &amp;&amp; j &lt;= Lcm / a1 + <span class="number">5</span>; i += a1, j++)        &#123;            <span class="keyword">if</span> ((i - b2) % a2)                <span class="keyword">continue</span>;            <span class="keyword">return</span> cout &lt;&lt; ((R - i + <span class="number">1</span>) + (Lcm - <span class="number">1</span>)) / Lcm &lt;&lt; endl, <span class="number">0</span>;        &#125;        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;    &#125;    <span class="keyword">else</span>    &#123;        <span class="type">int</span> ans = <span class="number">0</span>;        <span class="keyword">for</span> (ll i = start; i &lt;= R; i += a1)            ans += !((i - b2) % a2);        cout &lt;&lt; ans &lt;&lt; endl;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1926F Vlad and Avoiding X</title>
      <link href="/archives/CF1926F/"/>
      <url>/archives/CF1926F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定 $7\times 7$ 的黑白网格，问至少改多少点才能使得不出现大小为 $3\times 3$ 的<strong>黑色</strong> $\tt X$ 形。定义改一个点指改变这个点的颜色，黑变成白，白变成黑。</p><p>多测，$1\leq t\leq 200$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>显然只需要黑色改白色。</p><p>一个不是很显然的结论是 $ans\leq 8$。</p><p>你考虑对于网格进行红绿染色（其实就是黑白染色，但是和题意重合了）。就是 $(1,1)$ 红色，$(1,2)$ 和 $(2,1)$ 绿色这样子交叉递推。显然红色与绿色的部分是可以分开计算的。</p><p>然后我们瞪眼法发现一个 $ans&#x3D;8$ 的通解：染色 $(3,3),(3,4),(3,5),(4,3),(4,5),(5,3),(5,4),(5,5)$。这也就告诉我们，$ans$ 上界为 $8$。其中红绿两部分各 $4$ 个。</p><p>但是这不一定能构造最优解。<del>因为我在 test 2 的 case 16 WA 了。</del></p><p>但是这启发我们，因为答案很小，每个部分也都很少，我们可以直接暴力枚举具体是哪 $4$ 个格子被染白了。</p><p>时间复杂度是 $\mathcal O(\binom{25}{4}\times 25+\binom{24}{4}\times 24)$ 的。后面加的 $\times 25$ 之类的是用来 check 是否为合法的方案的。<del>时间复杂度能这么写吗我不知道啊。</del></p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>写的很丑。</p><p><a href="https://codeforces.com/contest/1926/submission/247566445">CF submission 247566445</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">min</span>(x, y); &#125;<span class="type">const</span> <span class="type">int</span> n = <span class="number">7</span>;<span class="type">const</span> <span class="type">int</span> m = <span class="number">9</span>;<span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;<span class="type">const</span> <span class="type">int</span> dy[] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;<span class="type">char</span> mp[<span class="number">10</span>][<span class="number">10</span>];vector&lt;pii&gt; v[<span class="number">2</span>];<span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> mp[x - <span class="number">1</span>][y - <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; mp[x - <span class="number">1</span>][y + <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; mp[x + <span class="number">1</span>][y - <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; mp[x + <span class="number">1</span>][y + <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span>; &#125;<span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(pii a, <span class="type">char</span> to)</span> </span>&#123; mp[a.first][a.second] = to; &#125;<span class="function"><span class="type">int</span> <span class="title">siz</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span><span class="function"></span>&#123;    set&lt;<span class="type">int</span>&gt; s;    s.<span class="built_in">insert</span>(a);    s.<span class="built_in">insert</span>(b);    s.<span class="built_in">insert</span>(c);    s.<span class="built_in">insert</span>(d);    <span class="keyword">return</span> s.<span class="built_in">size</span>();&#125;<span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(vector&lt;pii&gt; &amp;v)</span></span><span class="function"></span>&#123;    <span class="type">bool</span> need = <span class="number">0</span>;    <span class="keyword">for</span> (pii p : v)    &#123;        <span class="type">int</span> x = p.first;        <span class="type">int</span> y = p.second;        <span class="keyword">if</span> (mp[x][y] == <span class="string">&#x27;B&#x27;</span>)            <span class="keyword">if</span> (<span class="built_in">ok</span>(x, y))                need = <span class="number">1</span>;    &#125;    <span class="keyword">if</span> (!need)        <span class="keyword">return</span> <span class="number">0</span>;    <span class="type">int</span> ret = <span class="number">8</span>;    <span class="keyword">for</span> (<span class="type">int</span> p1 = <span class="number">0</span>; p1 &lt; v.<span class="built_in">size</span>(); p1++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> p2 = p1; p2 &lt; v.<span class="built_in">size</span>(); p2++)        &#123;            <span class="keyword">for</span> (<span class="type">int</span> p3 = p2; p3 &lt; v.<span class="built_in">size</span>(); p3++)            &#123;                <span class="keyword">for</span> (<span class="type">int</span> p4 = p3; p4 &lt; v.<span class="built_in">size</span>(); p4++)                &#123;                    need = <span class="number">1</span>;                    <span class="built_in">change</span>(v[p1], <span class="string">&#x27;W&#x27;</span>), <span class="built_in">change</span>(v[p2], <span class="string">&#x27;W&#x27;</span>), <span class="built_in">change</span>(v[p3], <span class="string">&#x27;W&#x27;</span>), <span class="built_in">change</span>(v[p4], <span class="string">&#x27;W&#x27;</span>);                    <span class="keyword">for</span> (pii p : v)                    &#123;                        <span class="type">int</span> x = p.first;                        <span class="type">int</span> y = p.second;                        <span class="keyword">if</span> (mp[x][y] == <span class="string">&#x27;B&#x27;</span>)                            <span class="keyword">if</span> (<span class="built_in">ok</span>(x, y))                                need = <span class="number">0</span>;                    &#125;                    <span class="keyword">if</span> (need)                        <span class="built_in">chkmn</span>(ret, <span class="built_in">siz</span>(p1, p2, p3, p4));                    <span class="built_in">change</span>(v[p1], <span class="string">&#x27;B&#x27;</span>), <span class="built_in">change</span>(v[p2], <span class="string">&#x27;B&#x27;</span>), <span class="built_in">change</span>(v[p3], <span class="string">&#x27;B&#x27;</span>), <span class="built_in">change</span>(v[p4], <span class="string">&#x27;B&#x27;</span>);                &#125;            &#125;        &#125;    &#125;    <span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    v[<span class="number">0</span>].<span class="built_in">clear</span>(), v[<span class="number">1</span>].<span class="built_in">clear</span>();    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)            cin &gt;&gt; mp[i][j];    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)            <span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;B&#x27;</span>)                v[(i &amp; <span class="number">1</span>) ^ (j &amp; <span class="number">1</span>)].<span class="built_in">push_back</span>(&#123;i, j&#125;);    &#125;    cout &lt;&lt; <span class="built_in">calc</span>(v[<span class="number">0</span>]) + <span class="built_in">calc</span>(v[<span class="number">1</span>]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> t;    cin &gt;&gt; t;    <span class="keyword">while</span> (t--)        <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF995E Number Clicker</title>
      <link href="/archives/CF1129B/"/>
      <url>/archives/CF1129B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在『江莉XCPC民间算法交流枢纽』有群友扔了这题，还挺有趣的。（这里是专有名词中英文之间不加括号没事的吧？）</p><h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>给定 $u,v,p$，保证 $p$ 是质数，有 $3$ 种操作：</p><ol><li>$u\gets u+1$</li><li>$u\gets u-1$</li><li>$u\gets u^{p-2}$</li></ol><p>以上操作过后均对 $p$ 取模。</p><p>求一种不超过 $200$ 次操作使得 $u&#x3D;v$ 的操作方案。</p><p>$0\leq u,v\lt p,3\leq p\leq 10^9+9$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>$200$ 直接搜就算有很多操作重复也是会炸的。考虑直接双向搜索，从 $u,v$ <strong>同时</strong>开搜。</p><p><del>你怎么知道我没睡醒两边各搜 100 个 TLE on 3。</del></p><p>为啥这样子时间复杂度是正确的？$u\gets u^{p-2}$ 其实就相当于随机选位置跳了，几乎一点关系没有。根据生日悖论，大概搜 $\mathcal O(\sqrt p)$ 次就能搜到，这样子跳到重复的概率其实是非常高的。</p><p>搜的时候记录一下前驱后驱，$v$ 搜碰到通过 $u$ 搜到的位置就可以停下输出了。我每个点都是不到 $40$ 次操作。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="type">int</span> x, y, p;<span class="type">int</span> pos;<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(ll x, <span class="type">int</span> y)</span></span><span class="function"></span>&#123;    ll ret = <span class="number">1</span>;    <span class="keyword">for</span> (; y &gt; <span class="number">0</span>; y &gt;&gt;= <span class="number">1</span>)    &#123;        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)            (ret *= x) %= p;        (x *= x) %= p;    &#125;    <span class="keyword">return</span> ret;&#125;<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">inv</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">qpow</span>(x, p - <span class="number">2</span>); &#125;map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; frt;map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; bck;map&lt;<span class="type">int</span>, pii&gt; pre;map&lt;<span class="type">int</span>, pii&gt; suf;queue&lt;pii&gt; q1;queue&lt;pii&gt; q2;<span class="type">bool</span> ok;<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> op)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (op == <span class="number">1</span>)        <span class="keyword">return</span> (x + <span class="number">1</span>) % p;    <span class="keyword">if</span> (op == <span class="number">2</span>)        <span class="keyword">return</span> (x + p - <span class="number">1</span>) % p;    <span class="keyword">return</span> <span class="built_in">inv</span>(x);&#125;<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">in</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &lt;= x &amp;&amp; x &lt; p; &#125;<span class="function"><span class="type">void</span> <span class="title">out_pre</span><span class="params">(<span class="type">int</span> x)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (!pre[x].first)        <span class="keyword">return</span>;    <span class="built_in">out_pre</span>(pre[x].second);    cout &lt;&lt; pre[x].first &lt;&lt; <span class="string">&quot; &quot;</span>;&#125;<span class="function"><span class="type">void</span> <span class="title">out_suf</span><span class="params">(<span class="type">int</span> x)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (!suf[x].first)        <span class="keyword">return</span>;    cout &lt;&lt; (suf[x].first == <span class="number">3</span> ? <span class="number">3</span> : <span class="number">3</span> - suf[x].first) &lt;&lt; <span class="string">&quot; &quot;</span>;    <span class="built_in">out_suf</span>(suf[x].second);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; x &gt;&gt; y &gt;&gt; p;    pre[x] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;    suf[y] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;    q<span class="number">1.</span><span class="built_in">push</span>(&#123;x, frt[x] = <span class="number">0</span>&#125;);    q<span class="number">2.</span><span class="built_in">push</span>(&#123;y, bck[y] = <span class="number">0</span>&#125;);    <span class="keyword">while</span> (!ok &amp;&amp; !q<span class="number">1.</span><span class="built_in">empty</span>() &amp;&amp; !q<span class="number">2.</span><span class="built_in">empty</span>())    &#123;        <span class="type">int</span> u = q<span class="number">1.f</span>ront().first, v = q<span class="number">2.f</span>ront().first;        <span class="type">int</span> du = q<span class="number">1.f</span>ront().second, dv = q<span class="number">2.f</span>ront().second;        <span class="comment">// cout &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; endl;</span>        q<span class="number">1.</span><span class="built_in">pop</span>(), q<span class="number">2.</span><span class="built_in">pop</span>();        <span class="keyword">for</span> (<span class="type">int</span> op = <span class="number">1</span>; op &lt;= <span class="number">3</span>; op++)        &#123;            <span class="type">int</span> tx = <span class="built_in">F</span>(u, op);            <span class="keyword">if</span> (frt.<span class="built_in">count</span>(tx))                <span class="keyword">continue</span>;            pre[tx] = &#123;op, u&#125;;            q<span class="number">1.</span><span class="built_in">push</span>(&#123;tx, frt[tx] = du + <span class="number">1</span>&#125;);        &#125;        <span class="keyword">for</span> (<span class="type">int</span> op = <span class="number">1</span>; op &lt;= <span class="number">3</span>; op++)        &#123;            <span class="type">int</span> ty = <span class="built_in">F</span>(v, op);            <span class="keyword">if</span> (bck.<span class="built_in">count</span>(ty))                <span class="keyword">continue</span>;            suf[ty] = &#123;op, v&#125;;            q<span class="number">2.</span><span class="built_in">push</span>(&#123;ty, bck[ty] = dv + <span class="number">1</span>&#125;);            <span class="keyword">if</span> (frt.<span class="built_in">count</span>(ty))            &#123;                ok = <span class="number">1</span>, pos = ty;                <span class="keyword">break</span>;            &#125;        &#125;    &#125;    cout &lt;&lt; frt[pos] + bck[pos] &lt;&lt; endl;    <span class="built_in">out_pre</span>(pos);    <span class="built_in">out_suf</span>(pos);    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC339F Product Equality</title>
      <link href="/archives/ABC339F/"/>
      <url>/archives/ABC339F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>$n$ 个大数 $a_i$，找三元组 $(i,j,k)$ 个数满足 $1\leq i,j,k\leq n$ 且 $a_i\times a_j&#x3D;a_k$。</p><p>$n\leq 1000,a_i\leq \color{red}{10^{1000}}$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>显然可以直接 FFT 高精度乘法。然后喜提 TLE，因为这个 $a_i$ 位数很长并且要跑很多轮乘法。</p><p>我们集中注意力，注意到满足 $a_i\times a_j&#x3D;a_k$ 的必要条件是对于任意模数 $p$ 存在 $(a_i\bmod p)\times(a_j\bmod p)\equiv a_k \pmod p$。</p><p>所以我们多写几个模数判一下就好。高精度取模低精度可以一位一位扫过去。</p><p>时间复杂度是 $\mathcal O(n^2\log n)$，如果手写个 hash 可以做到 $\mathcal O(n^2)$。</p><p>本人组了 $8$ 个自己生日、同学生日和【数据删除】生日以及一些众所周知的大质数。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://atcoder.jp/contests/abc339/submissions/49960822">AT submission 49960822</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="type">const</span> <span class="type">int</span> P[] = &#123;<span class="number">20091119</span>,                 <span class="number">11190119</span>,                 <span class="number">20102009</span>,                 <span class="number">998244353</span>,                 <span class="number">19260817</span>,                 <span class="number">1000000007</span>,                 <span class="number">998244853</span>,                 <span class="number">1145141</span>&#125;;map&lt;vector&lt;ll&gt;, <span class="type">int</span>&gt; mp;<span class="function">vector&lt;ll&gt; <span class="title">f</span><span class="params">(string &amp;s)</span></span><span class="function"></span>&#123;    vector&lt;ll&gt; p;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)        p.<span class="built_in">push_back</span>(<span class="number">0</span>);    <span class="keyword">for</span> (<span class="type">char</span> c : s)    &#123;        <span class="type">int</span> d = c ^ <span class="string">&#x27;0&#x27;</span>;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)            p[i] = (p[i] * <span class="number">10</span> + d) % P[i];    &#125;    <span class="keyword">return</span> p;&#125;<span class="type">int</span> n;<span class="type">int</span> ans;string s[<span class="number">1020</span>];vector&lt;ll&gt; v[<span class="number">1020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin &gt;&gt; n;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        cin &gt;&gt; s[i];        <span class="comment">// vector&lt;ll&gt; a ;</span>        v[i] = <span class="built_in">f</span>(s[i]);        mp[v[i]]++;        <span class="comment">// for (int j : v[i])</span>        <span class="comment">//     cout &lt;&lt; j &lt;&lt; &quot; &quot;;</span>        <span class="comment">// cout &lt;&lt; endl;</span>    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)        &#123;            vector&lt;ll&gt; a = v[i];            vector&lt;ll&gt; b = v[j];            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)                a[k] = a[k] * b[k] % P[k];            <span class="comment">// for (int i : a)</span>            <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span>            <span class="comment">// cout &lt;&lt; endl;</span>            ans += mp[a];        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] P3628 [APIO2010] 特别行动队</title>
      <link href="/archives/P3628/"/>
      <url>/archives/P3628/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3628">特别行动队</a></p><p>易得 $\mathcal O(n^2)$ 状态转移方程 $f_i\gets \max\limits_{j&#x3D;0}^{j&lt;i}{f_j+a(s_i-s_j)^2+b(s_i-s_j)+c}$，特殊的，约定 $f_0&#x3D;0$。</p><p>考虑化简式子，</p><p>$$<br>\begin{aligned}<br>f_j+a(s_i-s_j)^2+b(s_i-s_j)+c<br>&amp;&#x3D; f_j+a(s_i^2-2\cdot s_i\cdot s_j+s_j^2)+b\cdot s_i-b\cdot s_j+c \<br>&amp;&#x3D; f_j+a\cdot s_i^2-2a\cdot s_i\cdot s_j+a\cdot s_j^2+b\cdot s_i-b\cdot s_j+c<br>\end{aligned}<br>$$</p><p>设函数 $F(i)$ 由上式只含有 $i$ 的项组成，$G(j)$ 由上式只含有 $j$ 的项组成。</p><p>那么</p><p>$$<br>\begin{aligned}<br>F(i)<br>&amp;&#x3D; a\cdot s_i^2+b\cdot s_i\<br>G(i)<br>&amp;&#x3D; f_j+a\cdot s_j^2-b\cdot s_j<br>\end{aligned}<br>$$</p><p>则上式即为 $F(i)+G(j)+c$，那么转移方程即为 $f_i\gets \max\limits_{j&#x3D;0}^{j&lt;i}{F(i)+G(j)-2a\cdot s_i\cdot s_j+c}$。</p><p>发现 $F(i)+c$ 是共有的，那么便是 $f_i\gets \max\limits_{j&#x3D;0}^{j&lt;i}{G(j)-2a\cdot s_i\cdot s_j}+F(i)+c$。</p><p>约定 $j_1&lt;j_2$，那么当 $j_1$ 转移优于 $j_2$ 即 $G(j_1)+2a\cdot s_i\cdot s_{j_1}&gt;G(j_2)+2a\cdot s_i\cdot s_{j_2}$ 时，则有$(f_{j_1}+a\cdot s_{j_1}^2-b\cdot s_{j_1}-2a\cdot s_i\cdot s_{j_1})-(f_{j_2}+a\cdot s_{j_2}^2-b\cdot s_{j_2}-2a\cdot s_i\cdot s_{j_2})&gt;0$。</p><p>移项得 $s_i&gt;\dfrac{(f_{j_1}+a\cdot s_{j_1}^2-b\cdot s_{j_1})-(f_{j_2}+a\cdot s_{j_2}^2-b\cdot s_{j_2})}{2a(s_{j_1}-s_{j_2})}$。</p><p>题目说了 $a&lt;0,x_i&gt;0$，也就是 $s_{j_1}-s_{j_2}&lt;0$，所以不用变号。</p><p>那么 $j_1$ 到 $j_2$ 的连线我们是可以看做是斜率 $k&#x3D;\dfrac{(f_{j_1}+a\cdot s_{j_1}^2-b\cdot s_{j_1})-(f_{j_2}+a\cdot s_{j_2}^2-b\cdot s_{j_2})}{2a(s_{j_1}-s_{j_2})}$ 的直线。</p><p>然后使用单调队列维护凸壳就可以了。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;<span class="meta">#<span class="keyword">define</span> getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span><span class="function"></span>&#123;    x = <span class="number">0</span>;    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="keyword">for</span> (; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)            f = -f;    <span class="keyword">for</span> (; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;    x *= f;&#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x, Args &amp;...y)</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(x);    <span class="built_in">read</span>(y...);&#125;<span class="type">int</span> n;ll a, b, c;ll s[<span class="number">1000020</span>];ll f[<span class="number">1000020</span>];<span class="type">int</span> q[<span class="number">1000020</span>];ll hd, tl;<span class="function">ll <span class="title">FF</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> f[x] + a * (s[x] * s[x]) - b * s[x]; &#125;<span class="function">ld <span class="title">slope</span><span class="params">(<span class="type">int</span> j1, <span class="type">int</span> j2)</span> </span>&#123; <span class="keyword">return</span> (<span class="number">1.0</span> * <span class="built_in">FF</span>(j1) - <span class="number">1.0</span> * <span class="built_in">FF</span>(j2)) / (<span class="number">2.0</span> * a * (s[j1] - s[j2])); &#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">read</span>(n, a, b, c);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">read</span>(s[i]), s[i] += s[i - <span class="number">1</span>];    q[hd = tl = <span class="number">1</span>] = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">while</span> (hd &lt; tl &amp;&amp; s[i] &gt; <span class="built_in">slope</span>(q[hd], q[hd + <span class="number">1</span>]))            hd++;        <span class="type">int</span> j = q[hd];        f[i] = f[j] + a * (s[i] - s[j]) * (s[i] - s[j]) + b * (s[i] - s[j]) + c;        <span class="keyword">while</span> (hd &lt; tl &amp;&amp; <span class="built_in">slope</span>(q[tl - <span class="number">1</span>], q[tl]) &gt; <span class="built_in">slope</span>(q[tl], i))            tl--;        q[++tl] = i;    &#125;    cout &lt;&lt; f[n] &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[游记] THUPC 2024 游记</title>
      <link href="/archives/THUPC2024/"/>
      <url>/archives/THUPC2024/</url>
      
        <content type="html"><![CDATA[<h1 id="Day-22"><a href="#Day-22" class="headerlink" title="Day -22"></a>Day -22</h1><p>找的队友跑路了，在 LA 重找。</p><p>找到了 @<a href="https://www.luogu.com.cn/user/661641">Cx114514</a> 和 @<a href="https://www.luogu.com.cn/user/562119">xzy090626</a>。</p><p>由于分别是来自【常州】（我）【无锡】（Cx114514）【徐州】（xzy090626），所以队名是【黑无常，白无常，徐无常】。</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h1><p>约好了要周六上午 vp 一场 gym 里的比赛试试。睡不了懒觉了呜呜呜。</p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>上午 vp 了 CERC 2023，我开场把 E 和 B 两个 shaber 题秒了。</p><p>E 是个简单模拟，处理字符串。B 是细节题，指关注题面不起眼细节。凸多边形所以直接连 $i\to \frac n 2+i$ 就是最优解。</p><p>然后开 D，应该是要二分并且预处理所有答案，但是不会。每次看到这种线段覆盖就很烦。</p><p>开 C，这个题一眼就有一种 dp 的美感，但是 $n\leq 500$，设多维状态和高复杂度转移感觉不太可行，想不出来。</p><p><del>开 Coach Mode 看了一眼是网络流，那没事了，我不配。</del></p><p>然后开 I，$16$ 的限制肯定是 $\log n$ 的查询次数带点奇怪的东西，但是只会查全 $1$ 得到叶子结点。然后不会了。</p><p>摆了摆了，明天 THUPC 继续加油。</p><p>下午开了 USACO Gold 组。不会 T1，看了半小时，中途有一点正解思路出来但是我读入形如的类似邻接矩阵的东西</p><pre><code class="highlight">111010</code></pre><p>使用了 int 读入。然后第一步就挂了，好似。</p><p>然后大概是摆了 1.5h，剩 2h 的时候回去继续开，因为大家公认 Gold 都是 sb 题。</p><p>跳了 T1 重读 T2，发现 T2 也是弱智题，交了一发，怎么挂了这么多点？？？</p><p>哦没开 long long，重交只 WA 了 #20，这是怎么回事呢？</p><p>切完 T1 T3 出去吃了个饭想了一下，我字典序最小盲目取答案最小只在部分情况下是有保障的。<del>吃完饭越改错的越多就不改了。</del></p><p>T3 一眼小学奥数，然后发现这不就是求那个什么的最小值？？？直接使用那个什么就行了，然后中途是可以通过那个什么记录一下就可以单次 $\log$，加在一起单次询问 $\log^2$ 做完了。</p><p>有些东西 USACO 完赛再写吧。</p><p>晚上 ABC，不会 F。半夜 CF，不会 D。</p><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>上午睡到九点多起的，起床之后吃完早饭群里就发公告了。</p><p>是 thupc_275。</p><p>然后吃完早饭就吃中午饭了，中间就半小时，好抽象啊。</p><p>顺便挂个队友的游记 <a href="https://www.luogu.com.cn/blog/JustANoob/thupc2024-chu-sai-you-ji">https://www.luogu.com.cn/blog/JustANoob/thupc2024-chu-sai-you-ji</a>。</p><p>开 M 发现好抽象，一开始以为题目描述的答案是 Genshin。然后没看到 19 个一样思考了好久，甚至观察下来是 AI 会使用形如 seven 的全拼，human 会直接写 7。</p><p>然后随机开题，<del>发现怎么都是不可做题</del>，中途 xzy 过了 M，我后来写了个 C，摆了一会儿。</p><p>根据样例直接猜 K 是看 o 的个数决定答案，但是这为啥范围只有 $5\times 5$ 啊？</p><p>但是 xzy 也说是看 o 个数，我们一致认为是一个必输两个必胜三个必输。</p><p>然后四个交了一个必胜交了一个必输的结论，都 WA 了，说明要分讨。</p><p>后来发现是判断 $1\times 4$ 和 $2\times 2$ 的矩形，但我 $2\times 2$ 的矩形判断方式是 $r_0&#x3D;r_1\land r_2&#x3D;r_3$，没有判断 $c_0&#x3D;c_2$，好似。</p><p>之后就没有贡献了，，，</p><p>xzy 和 mdw 拍了好久，过完 E 发现是过四题的倒数第五，但这时候应该是封榜了。</p><p>赛后就不是倒数第五了，有更晚过题的（）</p>]]></content>
      
      
      <categories>
          
          <category> TravelNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC329F Colored Ball</title>
      <link href="/archives/ABC329F/"/>
      <url>/archives/ABC329F/</url>
      
        <content type="html"><![CDATA[<h1 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h1><p>来点不同的大炮打蚊子的非 STL 的做法。</p><h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>你有 $n$ 个盒子，每个盒子一开始装了一个颜色为 $c_i$ 的球。</p><p>有 $q$ 次询问（操作），每次询问给出一对 $(a,b)$，要把盒子 $a$ 的<strong>所有球</strong>转到盒子 $b$ 里，问此时 $b$ 里有多少<strong>颜色不同</strong>的球。</p><p>$1\leq n,q\leq 2\times 10^5,1\leq a,b,c_i\leq n$。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>考虑使用根号分治。</p><p>显然的阈值为 $B&#x3D;\sqrt n\approx 450$。</p><p>对于目前球个数 $\geq B$ 的盒子，我们记录一个桶 $bkt_{i,j}$ 表示<strong>序号（不是编号）为 $i$</strong> 的盒子是否装了 $j$。</p><p>因为这样的盒子数只有 $\leq B$ 个，所以我们需要记录一个序号，设编号为 $i$ 的盒子的序号为 $id_i$。</p><p>然后对于装球个数 $\lt B$ 的盒子，我们记录 $arr_{i,j}$ 表示<strong>编号为 $i$</strong> 的盒子的第 $j$ 个装的是什么。</p><p>大和大在一起，我们可以直接 $O(n)$ 转移。可以证明这样子转移的次数不会超过 $B$ 次。</p><p>小并到大的，直接扫一遍小的往大的里塞。</p><p>大并到小的，和上面同理。但我们无需新开一个 $id$，直接 $id_b\gets id_a$ 继承一下就可以。</p><p>小的和小的在一起，我们需要讨论一下。如果新出来的集合大小是 $\geq B$ 的，我们需要新开一个 $id$。否则直接合并。</p><p>代码和上面一样的。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p><a href="https://atcoder.jp/contests/abc329/submissions/47747560">AT submission 47747560</a></p><p>代码里前半段注释是本题正常的 STL 做法，感兴趣的也可以学习一下。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[游记] NOIP 2023 游记</title>
      <link href="/archives/NOIP2023/"/>
      <url>/archives/NOIP2023/</url>
      
        <content type="html"><![CDATA[<h1 id="Day-7"><a href="#Day-7" class="headerlink" title="Day -7"></a>Day -7</h1><p>JS-0187</p><p>不敢相信自己省排原来这么前。本来以为 200 开外就算好的了。</p><p>晚上打了把 ABC。D 没仔细算直接暴力结果复杂度假的 TLE 一发。然后火速 E 过掉 perf 1 Dan 了。</p><p>开 F。发现 F 就是个沙比并查集啊，一个集合内都是可以构造的，不同集合合并的时候启发式一下就行，至多合并 $n\log n$ 次。觉得很对。但是路径压缩写错了。</p><p>结果吃了 6 发，20:50 能过的拖到了 21:20，还掉分了，豁达。</p><p>豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达豁达</p><h1 id="Day-6"><a href="#Day-6" class="headerlink" title="Day -6"></a>Day -6</h1><p>发生了啥事啊，我不知道啊。</p><h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day -5"></a>Day -5</h1><p>生了一周病，请了一周假。第一天上学。</p><h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day -4"></a>Day -4</h1><p>要考试了&#x2F;ng</p><h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day -3"></a>Day -3</h1><p>期中考试。</p><p>语文选择题有一题很有争议，D 苏轼被贬家人很愉快？？？答案还不是选这个错误？？？</p><p>物理还行，8A 都简单，而且是期中，但是横波纵波算反了&#x2F;ng</p><p>政治提前 5min 写完了。</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h1><p>上午数学。好好好选择第八题有错，算了半天，浪费我时间打乱我节奏是吧。差点没写完&#x2F;fn&#x2F;fn&#x2F;fn</p><p>下午英语，六选四同学们在我停课期间做过，班级同学人均 AK，我错了一个，很难过。</p><p>历史感觉最正常了，但是史料类型七上第一节课讲的实在记不得了，感觉史料要丢几分。选择题出的很好。有一题书上怎么我没找到，我那节课也没上，这下寄了。</p><p>更搞笑的是怎么考完有人给我送整活准考证的？</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/svmlw58x.png"></p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>大家都去秋游了，我去不了，好难过。</p><p>如果秋游和今年秋游一样在 nj 的话我就可以去玩一天然后正好打车去酒店，<del>还剩一趟车票钱。</del></p><p>原来我起床的时候同学们都上车了啊，就我还在被窝里看平板。</p><p>早上打打游戏 duel 几道 800 1000 的简单题，duel 的时候想起来没有用 CCHv2，试图给 NOI Linux 2.0 装 CCHv2。</p><p>然后我配置了一天。</p><p>死因是 nwjs v0.9.0 按字典序看是最大最新的，但其实这是很古老的版本，最新的是 v0.82.0！</p><p>哈哈，好似。</p><p>下午两三点走的，常州北站，G146。<del>我刚和 @<a href="https://www.luogu.com.cn/user/320423">ACaCaca_</a> 说坐火车杀去 bj 就发现我坐的车终点站确实是北京。</del></p><p>上车了，旁边坐的是个漂亮小姐姐。</p><p>下车了，在车站坐出租去宜必思。在北门堵车了，好像出车祸了。</p><p>酒店房间号 8220，宜必思好绕啊，绕了一圈发现就在房间电梯口。</p><p>把东西放了一下就去面 @<a href="https://www.luogu.com.cn/user/580036">Phantom2009</a> 了。好帅诶。</p><p>一起出去跑了一大圈找东西吃，上了一个小吃街，找了一家火锅+米线的神奇组合吃了一顿。顺便买了点奶茶。</p><p>吃饭的时候一直在聊 cz 和 sz 的 OI。还聊了 nj 的大神们。</p><blockquote><p>我：感觉不如 nj 成为 ah 省会然后不占 js 别的地方名额。</p><p>妈：你当心点，这里都是 nj 人。</p></blockquote><p>吃完了就出去买了点早饭，顺便去旁边超市买点面包和饼干明天带着吃。</p><p>回酒店发现酒店提供付费早餐，这很难评。</p><p>回了酒店 @<a href="https://www.luogu.com.cn/user/419487">irris</a> 也到了，去 8263 找了一趟 irris 然后尬聊几分钟转到 Phantom2009 的房间继续尬聊。</p><p>聊到九点左右我就和 irris 一起润了。</p><p>线上三个魔怔哥，线下聊一个多小时天移动距离不超过一米的。</p><p>现实里唯唯诺诺，网络上重拳出击！</p><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>六点半起的。</p><p>酒店里吃了点早饭就润去南航了，七点就到了。</p><p>门口保安让我刷身份证，然后顺着指示牌走。我看指示牌指了一条小路，跑去转了一圈，没人。又转一圈，还是没人。教练说 7：30 到，我以为 8:00 开考，我 7:15 还没看见大队伍很慌啊。然后过了一会儿发现是工作人员没来，看了眼准考证 8:30 开考，乐。</p><p>面基天波老师，天波老师好色&#x2F;se</p><p>考场机子打不开 README，生气。考场晚发了 5min 密码，生气。</p><p>T1 一眼过，现在 CCF 流行签到题放送分题是吧。</p><p>T2 一眼 40 是很好写的，考场上试图冲了 60 和 80 的分，$abs(ans-output)\leq 1$，就很乐。</p><p>然后先开的 T4，做了一下 性质 B 和 前两个点，在想 性质 C 的 dp，就没继续写第三个点往后的非特殊性质数据，现在发现输麻了。</p><p>T3 看了好久读懂了，好奇怪，写了 10 润了。</p><p>所以分数是 $100+[40,60]+10+16$。</p><p>考完发现同学人均 200+，天波老师也是 200，自闭了。</p><p>EasonTao 好像寄了，一直都不高兴。</p><p>中午随便吃了点。</p><p>测了一下云斗 T4 还挂了 8 分，因为 性质 B 如果出现 $[1,2],[3,4]$ 的区间且 $k&#x3D;3$ 很多人都是会一起选择两个区间的。</p><p>唉。</p>]]></content>
      
      
      <categories>
          
          <category> TravelNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CSP-J 2023</title>
      <link href="/archives/CSPJ2023/"/>
      <url>/archives/CSPJ2023/</url>
      
        <content type="html"><![CDATA[<h1 id="A-小苹果-apple"><a href="#A-小苹果-apple" class="headerlink" title="A 小苹果 apple"></a>A 小苹果 apple</h1><p>简单题。</p><p>先做询问 2 好像简单，我考场就是这么干的。</p><p>询问 2 就是问你删几次才能使剩下的数个数 $\bmod 3&#x3D;1$。</p><p>你会发现每次是删掉 $\left\lceil\dfrac{1}{3} n\right\rceil$ 个数，$n$ 每次改变。</p><p>然后发现这个复杂度正确，直接莽。</p><p>询问 1 同理，看删几轮删完即可。</p><p><del>代码注释夹带了点考场私货。</del></p><pre><code class="highlight cpp"><span class="comment">/*</span><span class="comment">这段就当考场游记吧</span><span class="comment">8点20把对拍程序和自定义编译命令都调好了，写了个A+B对拍，wa on test 209</span><span class="comment">快读，不打了，听天由命</span><span class="comment"></span><span class="comment">十点半，大样例全过。</span><span class="comment">T4 这么水？我应该没写错吧。欸T1很简单吗，T4一眼秒了T1我一眼不会啊/jk</span><span class="comment">10:45检查完毕开始睡觉</span><span class="comment">11:00发现咖啡效果来了睡不着，那就摆</span><span class="comment">*/</span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;ll n;ll m;ll ans1, ans2 = <span class="number">1</span>;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">freopen</span>(<span class="string">&quot;apple.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);    <span class="built_in">freopen</span>(<span class="string">&quot;apple.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);    cin &gt;&gt; n;    m = n;    <span class="keyword">while</span> (m % <span class="number">3</span> != <span class="number">1</span>)    &#123;        ans2++;        m -= (m + <span class="number">2</span>) / <span class="number">3</span>;    &#125;    <span class="keyword">while</span> (n)    &#123;        ans1++;        n -= (n + <span class="number">2</span>) / <span class="number">3</span>;    &#125;    cout &lt;&lt; ans1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans2 &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="B-公路-road"><a href="#B-公路-road" class="headerlink" title="B 公路 road"></a>B 公路 road</h1><p>简单题。</p><p>考虑贪心。因为油箱无限大，所以你可以有一个虚拟的类似返回加油的过程。</p><p>什么意思呢，就是你现在加油比之前贵就不加了，改成之前的价格加。</p><p>所以就很简单了。</p><p>这个前缀和可能不用，我是怕出现加油有一些剩的可以多跑一点的情况。但也没啥事。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;ll n, d;ll dis[<span class="number">100020</span>];ll a[<span class="number">100020</span>];ll val;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">freopen</span>(<span class="string">&quot;road.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);    <span class="built_in">freopen</span>(<span class="string">&quot;road.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);    cin &gt;&gt; n &gt;&gt; d;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)        cin &gt;&gt; dis[i], dis[i] += dis[i - <span class="number">1</span>];    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        cin &gt;&gt; a[i];        <span class="keyword">if</span> (i &gt; <span class="number">1</span>)            a[i] = <span class="built_in">min</span>(a[i], a[i - <span class="number">1</span>]);    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        dis[i] = (dis[i] + d - <span class="number">1</span>) / d;    <span class="comment">// for (int i = 2; i &lt;= n; i++)</span>    <span class="comment">//     cout &lt;&lt; dis[i] &lt;&lt; &quot; &quot;;</span>    <span class="comment">// cout &lt;&lt; endl;</span>    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)        val += a[i - <span class="number">1</span>] * (dis[i] - dis[i - <span class="number">1</span>]);    cout &lt;&lt; val &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="C-一元二次方程-uqe"><a href="#C-一元二次方程-uqe" class="headerlink" title="C 一元二次方程 uqe"></a>C 一元二次方程 uqe</h1><p>模拟题。</p><p>难点在于分数和平方根的化简。</p><p>做这类模拟题可以分步写，写完一类直接测相对应的数据，效果是很好的。</p><p>我为了防止 long long 使用平方根有奇怪错误还手写了一个，但复杂度是正确的。</p><p><del>这题不会有人超时吧？</del></p><p>先记一个 $dlt&#x3D;b^2-4ac$，直接判断是否 $\lt 0$。</p><p>然后 $sq&#x3D;\left\lfloor\sqrt dlt\right\rfloor$。如果 $sq^2&#x3D;dlt$ 即 $dlt$ 为完全平方数那么就存在有理数解。有理数解还要根据 $2a$ 的正负性分讨一下。</p><p>如果不是完全平方数即存在两个无理数解，先写成 $\frac{p_1}{q_1}+\frac{p_2}{q_2}\sqrt dlt$ 的形式，然后化简。</p><p>平方根化简直接找有没有完全平方因子，有的话提给 $p_2$ 即可。</p><p>码量不算太大。但这题是考场上耗时最久的。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;ll m;ll a, b, c;ll dlt;ll sq;ll p, q;ll p1, q1, p2, q2;<span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(ll &amp;p, ll &amp;q)</span></span><span class="function"></span>&#123;    ll g = __gcd(p, q);    p /= g;    q /= g;&#125;<span class="function"><span class="type">void</span> <span class="title">fprt</span><span class="params">(ll &amp;p, ll &amp;q)</span></span><span class="function"></span>&#123;    <span class="comment">// cout &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; q &lt;&lt; endl;</span>    <span class="keyword">if</span> (p * q &lt; <span class="number">0</span>)        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);    <span class="keyword">if</span> (p &lt; <span class="number">0</span>)        p = -p;    <span class="keyword">if</span> (q &lt; <span class="number">0</span>)        q = -q;    <span class="built_in">F</span>(p, q);&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    sq = <span class="number">0</span>;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;    dlt = b * b - <span class="number">4</span> * a * c;    <span class="keyword">if</span> (dlt &lt; <span class="number">0</span>)        <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>), <span class="built_in">void</span>();    <span class="keyword">while</span> ((sq + <span class="number">1</span>) * (sq + <span class="number">1</span>) &lt;= dlt)        sq++;    <span class="keyword">if</span> (sq * sq == dlt)    &#123;        p = -b + sq;        q = <span class="number">2</span> * a;        <span class="keyword">if</span> (<span class="number">2</span> * a &lt; <span class="number">0</span>)            p = <span class="built_in">min</span>(-b + sq, -b - sq);        <span class="keyword">else</span>            p = <span class="built_in">max</span>(-b + sq, -b - sq);        <span class="built_in">fprt</span>(p, q);        <span class="keyword">if</span> (q == <span class="number">1</span>)            <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, p);        <span class="keyword">else</span>            <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld&quot;</span>, p, q);        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);        <span class="keyword">return</span>;    &#125;    p1 = -b;    q1 = <span class="number">2</span> * a;    p2 = <span class="number">1</span>;    <span class="comment">// cout &lt;&lt; &quot;Debug:&quot; &lt;&lt; sq &lt;&lt; &quot;/&quot; &lt;&lt; dlt &lt;&lt; endl;</span>    <span class="keyword">for</span> (ll d = <span class="number">2</span>; d &lt;= sq; d++)    &#123;        <span class="comment">// cout &lt;&lt; dlt &lt;&lt; &quot; &quot; &lt;&lt; d * d &lt;&lt; &quot; &quot; &lt;&lt; (dlt % (d * d) == 0) &lt;&lt; endl;</span>        <span class="keyword">while</span> (dlt % (d * d) == <span class="number">0</span>)        &#123;            dlt /= d * d;            p2 *= d;        &#125;    &#125;    q2 = <span class="number">2</span> * a;    <span class="built_in">fprt</span>(p1, q1);    <span class="comment">// cout &lt;&lt; &quot;debug:&quot; &lt;&lt; p1 &lt;&lt; &quot;/&quot; &lt;&lt; q1 &lt;&lt; endl;</span>    <span class="keyword">if</span> (q1 == <span class="number">1</span>)    &#123;        <span class="keyword">if</span> (p1 != <span class="number">0</span>)        &#123;            <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, p1);            <span class="built_in">printf</span>(<span class="string">&quot;+&quot;</span>);        &#125;    &#125;    <span class="keyword">else</span>    &#123;        <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld&quot;</span>, p1, q1);        <span class="built_in">printf</span>(<span class="string">&quot;+&quot;</span>);    &#125;    <span class="keyword">if</span> (p2 &lt; <span class="number">0</span>)        p2 = -p2;    <span class="keyword">if</span> (q2 &lt; <span class="number">0</span>)        q2 = -q2;    <span class="built_in">F</span>(p2, q2);    <span class="keyword">if</span> (p2 != <span class="number">1</span>)        <span class="built_in">printf</span>(<span class="string">&quot;%lld*&quot;</span>, p2);    <span class="built_in">printf</span>(<span class="string">&quot;sqrt(%lld)&quot;</span>, dlt);    <span class="keyword">if</span> (q2 != <span class="number">1</span>)        <span class="built_in">printf</span>(<span class="string">&quot;/%lld&quot;</span>, q2);    <span class="comment">// printf(&quot;YES\n&quot;);</span>    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">freopen</span>(<span class="string">&quot;uqe.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);    <span class="built_in">freopen</span>(<span class="string">&quot;uqe.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);    <span class="type">int</span> t;    cin &gt;&gt; t &gt;&gt; m;    <span class="keyword">while</span> (t--)        <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="D-旅游巴士-bus"><a href="#D-旅游巴士-bus" class="headerlink" title="D 旅游巴士 bus"></a>D 旅游巴士 bus</h1><p>T1 和 T2 一眼不会 T4 看完题秒了还有救吗？</p><p>首先，这是可以二分答案的，这个看完题就能想出来。</p><p>为什么可以二分？二分什么？如何二分？</p><p>为什么可以二分？因为开始时间任意，如果你在 $t$ 时刻能过，你拖到 $t+k$ 更能过。因为限制随着时间推移只能更少。</p><p>二分什么？我们会发现从 1 号点开始二分开始时间得到的到达时间不一定是单调上升的。那么我们二分结束时间，建反图即可，这样子就只需要判断答案可行性。</p><p>如何二分？设结束时间为 $pk$，二分 $p$ 即可。</p><p>如何 check 也是个困难点。</p><p>你会发现因为边权是 $1$，所以直接大力 bfs 即可。这时候你就通过了小样例，大样例直接炸掉。</p><p><del>所以我不算一看完题就想出正解。</del></p><p>炸掉怎么办？你考虑进行拆点。这个 $k$ 很小肯定不是出题人少写了几个 $0$，你把每个点 $x$ 拆成 $(x,y)$，表示在 $t\equiv y\pmod{k}$ 时刻你到达了 $x$ 点。</p><p>拆点之后大力 bfs 即可通过。</p><p>因为每次 bfs 新的时间只会更短，所以走过的点不需要重复经过，复杂度有保障。</p><p>时间复杂度 $\mathcal O(nk\log V)$，其中 $V&#x3D;\max{a_i}+m\leq 10^7$。大样例场上跑了 0.8s。</p><p>注意无解输出 $-1$，我是不会说有个小丑玩了一个多小时闲的没事干的时候，题面放的很大，一个字一个字研究题面才发现的。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">typedef</span> pair&lt;ll, <span class="type">int</span>&gt; pli;<span class="type">int</span> n, m;ll k;vector&lt;pli&gt; a[<span class="number">100020</span>];<span class="type">bool</span> vis[<span class="number">100020</span>][<span class="number">120</span>];<span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll et)</span></span><span class="function"></span>&#123;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)            vis[i][j] = <span class="number">0</span>;    queue&lt;pli&gt; q;    q.<span class="built_in">push</span>(&#123;et, n&#125;);    vis[n][et % k] = <span class="number">1</span>;    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())    &#123;        <span class="type">int</span> u = q.<span class="built_in">front</span>().second;        ll t = q.<span class="built_in">front</span>().first;        q.<span class="built_in">pop</span>();        <span class="keyword">if</span> (vis[<span class="number">1</span>][<span class="number">0</span>])            <span class="keyword">return</span> <span class="number">1</span>;        <span class="keyword">for</span> (pli p : a[u])        &#123;            <span class="type">int</span> v = p.second;            ll w = p.first;            <span class="keyword">if</span> (t &gt; w &amp;&amp; !vis[v][(t - <span class="number">1</span>) % k])            &#123;                vis[v][(t - <span class="number">1</span>) % k] = <span class="number">1</span>;                q.<span class="built_in">push</span>(&#123;t - <span class="number">1</span>, v&#125;);            &#125;        &#125;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">freopen</span>(<span class="string">&quot;bus.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);    <span class="built_in">freopen</span>(<span class="string">&quot;bus.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;n, &amp;m, &amp;k);    <span class="keyword">while</span> (m--)    &#123;        <span class="type">int</span> u, v;        ll w;        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;u, &amp;v, &amp;w);        a[v].<span class="built_in">push_back</span>(&#123;w, u&#125;);    &#125;    <span class="comment">//bs end time</span>    ll L = <span class="number">0</span>, R = <span class="number">1e7</span>, mid, ans = <span class="number">-1</span>;    <span class="keyword">while</span> (L &lt;= R)    &#123;        mid = L + R &gt;&gt; <span class="number">1</span>;        <span class="keyword">if</span> (<span class="built_in">check</span>(mid * k))            R = (ans = mid) - <span class="number">1</span>;        <span class="keyword">else</span>            L = mid + <span class="number">1</span>;    &#125;    <span class="keyword">if</span> (ans == <span class="number">-1</span>)        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);    <span class="keyword">else</span>        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans * k);    <span class="comment">// cerr &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; (double)clock() / CLOCKS_PER_SEC &lt;&lt; endl;</span>    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ATTENKA12017C 4/N</title>
      <link href="/archives/TENKA12017C/"/>
      <url>/archives/TENKA12017C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><p>输入一个正整数 $a(2\leq a\leq 3500)$，输出三个数 $h,w,r$，满足 $\dfrac1h+\dfrac1w+\dfrac1r&#x3D;\dfrac4a$，输出任意一种符合的答案。</p><p>保证存在一组 $h,w,r\leq 3500$ 的合法解，但是你不需要一定输出类似的方案，输出中含有 $\geq 3500$ 的方案也是合法的。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>大家都会数学，就我不会，那就来一个不太寻常的大炮打蚊子的做法。</p><p>$\mathcal O(V^3)$ 的做法显然不能接受，我们可以枚举两维，$h$ 和 $w$，然后硬算出 $r$。</p><p>如何算出 $r$？</p><p><a href="https://www.luogu.com.cn/blog/EntropyIncreaser/jian-jie-di-qu-mu-huan-yuan-fen-shuo-fang-fa">前置知识：简洁的取模还原分数方法</a></p><p>我们把 $\dfrac4a,\dfrac1h,\dfrac1w$ 全都取模变成一个整数，如何转换参考 <a href="https://www.luogu.com.cn/problem/P2613">P2613 【模板】有理数取余</a>。</p><p>设得到的三个整数为 $n,P,Q$，得到 $\dfrac1r$ 应该是 $m&#x3D;n-P-Q$。然后我们将 $m$ 还原成分数，判断是否为埃及分数以及最后是否满足 $\dfrac1h+\dfrac1w+\dfrac1r&#x3D;\dfrac4a$ 即可。</p><h1 id="丑陋代码"><a href="#丑陋代码" class="headerlink" title="丑陋代码"></a>丑陋代码</h1><p><a href="https://atcoder.jp/contests/tenka1-2017/submissions/46467770">AT submission 46467770</a></p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20231007 | CSP2023 考前模拟赛 做题笔记</title>
      <link href="/archives/20231007_mock/"/>
      <url>/archives/20231007_mock/</url>
      
        <content type="html"><![CDATA[<h1 id="书"><a href="#书" class="headerlink" title="书"></a>书</h1><p>简单题，但是有个小丑挂掉了。</p><p>对于每个 $[10^x,10^{x+1}-1]$ 的区间，计算 $n$ 覆盖了多大范围。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">freopen</span>(<span class="string">&quot;book.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);    <span class="built_in">freopen</span>(<span class="string">&quot;book.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);    ll n, ans = <span class="number">0</span>;    cin &gt;&gt; n;    ll pw = <span class="number">1</span>, cnt = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)    &#123;        <span class="keyword">if</span> (pw * <span class="number">10</span> - <span class="number">1</span> &lt;= n)            ans += cnt * <span class="number">9</span> * pw;        <span class="keyword">else</span>        &#123;            ans += cnt * (n - pw + <span class="number">1</span>);            <span class="keyword">break</span>;        &#125;        pw *= <span class="number">10</span>;        cnt++;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">[1,9]</span><span class="comment">[10,99]</span><span class="comment">[100,999]</span><span class="comment">...</span><span class="comment">[10**x,10**(x+1)-1]</span><span class="comment">*/</span></code></pre><h1 id="数"><a href="#数" class="headerlink" title="数"></a>数</h1><p>我没记错的话我在 cses.fi 上做过这题。但这题本来就很典，估计很多 OJ 都有。</p><p>设 $f_i$ 表示凑到 $i$ 的最小步数。</p><p>转移 $f_i\gets\min{f_{i-1},f_{i\times 2},f_{i\times 3}}+1$。</p><p>但是有一个小丑以为 CF 打多了误以为多测只要每个 $\mathcal O(n)$ 就能过，喜提 TLE。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> f[<span class="number">1000020</span>];<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n = <span class="number">1000000</span>;    f[f[f[<span class="number">2</span>] = f[<span class="number">3</span>] = <span class="number">1</span>] = <span class="number">0</span>] = <span class="number">1000</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt;= n; i++)    &#123;        <span class="type">int</span> x, y, z;        x = y = z = INT_MAX;        x = f[i - <span class="number">1</span>];        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)            y = f[i / <span class="number">2</span>];        <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)            z = f[i / <span class="number">3</span>];        f[i] = <span class="built_in">min</span>(&#123;x, y, z&#125;) + <span class="number">1</span>;    &#125;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n;    cin &gt;&gt; n;    cout &lt;&lt; f[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">freopen</span>(<span class="string">&quot;number.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);    <span class="built_in">freopen</span>(<span class="string">&quot;number.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);    <span class="built_in">init</span>();    <span class="type">int</span> t;    cin &gt;&gt; t;    <span class="keyword">while</span> (t--)        <span class="built_in">solve</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="盒"><a href="#盒" class="headerlink" title="盒"></a>盒</h1><p>一眼 dp，状态很容易设出 $f_{i,0&#x2F;1&#x2F;2}$ 表示第 $i$ 个位置往左不动往右的答案。</p><p>转移需要分讨。</p><ul><li><p>当前有盖子</p><ul><li><p>左边有盖子</p><p>$f_{i,0}\gets f_{i-1,0}+a_{i-1}$</p><p>$f_{i,1}\gets \max{f_{i-1,0},f_{i-1,1}}+a_{i}$</p><p>$f_{i,2}\gets\max{f_{i-1,0},f_{i-1,1},f_{i-1,2}}+a_{i+1}$</p></li><li><p>反之</p><p>$f_{i,0}\gets f_{i-1,0}+a_{i-1}$</p><p>$f_{i,1}\gets f_{i-1,1}+a_{i}$</p><p>$f_{i,2}\gets f_{i-1,1}+a_{i+1}$</p></li></ul></li><li><p>反之</p><p>$f_{i,0}\gets\max{f_{i-1,0},f_{i-1,1}}$</p><p>$f_{i,1}\gets\max{f_{i-1,0},f_{i-1,1},f_{i-1,2}}$</p><p>这里不需要转移 $f_{i,2}$，它本来就没有盖子，无需转移。转移 $f_{i,0}$ 是为了让之后的 $f_{i+1,0}$ 能够转移。</p></li></ul><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;ll f[<span class="number">200020</span>][<span class="number">3</span>];<span class="type">int</span> n;ll a[<span class="number">200020</span>];<span class="type">int</span> b[<span class="number">200020</span>];<span class="comment">//f[i][0/1/2] left,mid,right</span><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">freopen</span>(<span class="string">&quot;box.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);    <span class="built_in">freopen</span>(<span class="string">&quot;box.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);    cin &gt;&gt; n;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, a + i);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b + i);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)    &#123;        <span class="keyword">if</span> (b[i]) <span class="comment">//有盖子</span>        &#123;            f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + a[i - <span class="number">1</span>];            <span class="keyword">if</span> (b[i - <span class="number">1</span>]) <span class="comment">//左边也有盖子</span>            &#123;                f[i][<span class="number">1</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">1</span>]) + a[i];                f[i][<span class="number">2</span>] = <span class="built_in">max</span>(&#123;f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>]&#125;) + a[i + <span class="number">1</span>];            &#125;            <span class="keyword">else</span>            &#123;                f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">1</span>] + a[i];                f[i][<span class="number">2</span>] = f[i - <span class="number">1</span>][<span class="number">1</span>] + a[i + <span class="number">1</span>];            &#125;        &#125;        <span class="keyword">else</span>        &#123;            f[i][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">1</span>]);            f[i][<span class="number">1</span>] = <span class="built_in">max</span>(&#123;f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>]&#125;);        &#125;    &#125;    cout &lt;&lt; <span class="built_in">max</span>(f[n][<span class="number">0</span>], f[n][<span class="number">1</span>]) &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="和"><a href="#和" class="headerlink" title="和"></a>和</h1><p>很厉害的一道题！</p><p>首先考虑暴力怎么写。我说的不是 $3^n$ 级别的，如果你只想到这一层建议先想出多项式复杂度的代码再看。</p><p>我们的暴力应该是 $\mathcal O(Vn^3)$。</p><p>暴力的写法，应该是 $\mathcal O(n)$ 枚举更改哪个位置，$\mathcal O(V)$ 枚举更改成什么结果，$\mathcal O(n^2)$ 枚举子序列计算。</p><p>考虑优化哪一个。$O(n^2)$ ，枚举子序列大抵是可以优化的，但我不会。</p><p>考虑优化 $O(V)$ 枚举更改值。</p><p>显然的，由于只有 $300$ 个更改方案，<strong>所以能构成的完全平方数不会过多，大约是根号级别的。</strong></p><p>那么就很好优化了，$\mathcal O(n)$ 枚举修改哪个位置，先算出它没有干扰到哪些子序列，这些子序列会产生多少贡献，这个是很好算的。</p><p>然后，我们算出更改这个位置之后的某个子序列上界和下界，这里记作 $L$ 和 $R$。</p><p>$[L,R]$ 之间的完全平方数 $p^2$ 不会过多，我们枚举可行的 $p$。$p$ 的范围应为 $[\left\lceil\sqrt L\right\rceil,\left\lfloor\sqrt R\right\rfloor]$。找完全平方数选择枚举它的因子降低复杂度是一个很典的 trick。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">gmx</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">max</span>(x, y); &#125;<span class="type">int</span> n;<span class="type">int</span> a[<span class="number">320</span>];<span class="type">int</span> s[<span class="number">320</span>];<span class="type">bool</span> sq[<span class="number">100020</span>];ll f[<span class="number">320</span>];ll ans;<span class="function"><span class="type">int</span> <span class="title">S</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> s[r] - s[l - <span class="number">1</span>]; &#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="built_in">freopen</span>(<span class="string">&quot;sum.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);    <span class="built_in">freopen</span>(<span class="string">&quot;sum.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);    cin &gt;&gt; n;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)        cin &gt;&gt; a[i], s[i] = s[i - <span class="number">1</span>] + a[i];    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">300</span>; i++)        sq[i * i] = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//修改第i个位置</span>    &#123;        <span class="type">int</span> tmp = <span class="number">0</span>;        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)            <span class="keyword">for</span> (<span class="type">int</span> r = l; r &lt;= n; r++)                <span class="keyword">if</span> (i &lt; l || r &lt; i)                    <span class="keyword">if</span> (sq[<span class="built_in">S</span>(l, r)])                        tmp++;        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)        &#123;            <span class="keyword">for</span> (<span class="type">int</span> r = l; r &lt;= n; r++)            &#123;                <span class="keyword">if</span> (i &lt; l || r &lt; i)                    <span class="keyword">continue</span>;                <span class="type">int</span> L = <span class="number">1</span>, R = <span class="number">300</span>;                <span class="type">int</span> sum = <span class="built_in">S</span>(l, r) - a[i];                L += sum;                R += sum;                <span class="comment">// cout &lt;&lt; L &lt;&lt; &quot; &quot; &lt;&lt; R &lt;&lt; endl;</span>                <span class="type">int</span> mayL = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(L)), mayR = <span class="built_in">sqrt</span>(R);                <span class="comment">// cout &lt;&lt; mayL &lt;&lt; &quot; &quot; &lt;&lt; mayR &lt;&lt; endl;</span>                <span class="comment">// cout &lt;&lt; endl;</span>                <span class="keyword">for</span> (<span class="type">int</span> k = mayL; k &lt;= mayR; k++)                    <span class="keyword">if</span> (k * k - sum &lt;= <span class="number">300</span>)                        f[k * k - sum]++;            &#125;        &#125;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">300</span>; i++)            <span class="built_in">gmx</span>(ans, f[i] + tmp);    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[游记] CSP 2023 游记</title>
      <link href="/archives/CSP2023/"/>
      <url>/archives/CSP2023/</url>
      
        <content type="html"><![CDATA[<p>希望今年能靠自己的分数打进 NOIP 吧，去年是靠的常州考点的名额。</p><p>好，noip 应该是进了。</p><h1 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h1><h2 id="Day"><a href="#Day" class="headerlink" title="Day -???"></a>Day -???</h2><p>去机房不能开电脑，难受。</p><p>练初赛，全靠左顾右盼法看@<a href="https://www.luogu.com.cn/user/526163">JwJ_2010</a> 的。退役半年的都比我强，紫砂了。</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p>文化课布置了作文，难受。初赛，没看。</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>上午坐地铁去，好像在常外站看到了个高个子的穿校服的女生，但事实上好像不是去考初赛的。</p><p>地铁上死命看初赛知识点，主定理是在车上看会的。</p><p>到了，在博爱路站下车，看到了@<a href="https://www.luogu.com.cn/user/268980">xiayuhao__2009</a>。走过去竟然要走 800m，啥破地方啊&#x2F;fn</p><p>然后到了考场，这啥初中都没听过啊，门口一条竖着的马路全是人，怎么今年小朋友这么多。</p><p>看到了同校的，怎么都不穿校服？怎么都不穿校服？怎么都不穿校服？传统忘了？传统忘了？传统忘了？</p><p>大家都问我车上看见的学姐去哪了，要检查我的手机相册。</p><p>？</p><p>然后就是正常的互相膜拜。今年不在省常中没有天宁寺拜。</p><p>看到了帅气的@<a href="https://www.luogu.com.cn/user/400269">Shiota_Kaede</a>，好色。</p><p>进考场了。门口破马路真堵。还是学校里面操场宽敞。</p><p>@<a href="https://www.luogu.com.cn/user/400269">Shiota_Kaede</a> 和我姓一样，第二个首字母他是 J 我是 Y 我就润去二考场了？？？人这么多的？？？</p><p>考场里一堆小朋友，<del>好可爱</del>。</p><p>怎么教室墙上有钟离，玩原玩的。</p><p>为什么发卷是一个人一个人发的？</p><p>开考了。</p><p>考试没啥记得的，就记得上厕所说一声就可以直接去，我看着一分钟之内两个人走过我们这里上厕所。这不随便作弊？</p><p>发现 J 很简单啊，但是一对答案就萎了。</p><p>中午和@<a href="https://www.luogu.com.cn/user/268980">xiayuhao__2009</a> 在学校对面吃了顿饭。我一直在看手机看大家讨论答案。</p><p>然后润去买奶茶，发现之前买的一家店不知道是搬了还是我们走错了，寄。</p><p>去买了 coco，坐在那里还是看手机。</p><p>coco 一杯果茶，我点的正常冰放了半杯冰，大家以后记得避坑。</p><p>中午就在 QQ 聊天。</p><p>下午开考前不记得多久了润回了那个偏远初中。</p><p>依旧是看到了@<a href="https://www.luogu.com.cn/user/400269">Shiota_Kaede</a>，还见到了@<a href="https://www.luogu.com.cn/user/233576">ChenLingHan</a>。进去后还看到了@<a href="https://www.luogu.com.cn/user/200429">chufuzhe</a> 和 @<a href="https://www.luogu.com.cn/user/209848">ByGones</a>。还见到了鲲队，但不敢打招呼。</p><p>不同考场规矩还不同的，奇葩。</p><p>S 依旧很简单，但仍然是对完答案就萎了。</p><p>稍微看了下大概错了多少，比预想差一点。估计 60 上下，没仔细算。</p><p>然后一直摆到开学。</p><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><p>学校信息课。教练教了怎么用 NOI Linux。</p><p>妈的我预估 J 最低 75 怎么有人和教练说我 J 只有 70 的，教练还特地问我。</p><h2 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h2><p>怎么还要用 NOI Linux 练习去年做的卷子。哦这套啊想起来了考得很差的。怎么今年一小时阿克不了，难过。</p><h2 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h2><p>出分数线了，听说是特派员周末要下班了，所以周五得发，发完跑路了。</p><p>分数线挺低的。看来机位超多。</p><h1 id="复赛"><a href="#复赛" class="headerlink" title="复赛"></a>复赛</h1><h2 id="Day-15-21"><a href="#Day-15-21" class="headerlink" title="Day [-15,-21]"></a>Day [-15,-21]</h2><p>在 hba 训练。被模拟赛创死。</p><p>但是拍到了很多人的丑照（</p><p>原来大家管互相拍照叫对拍！</p><h2 id="Day-14"><a href="#Day-14" class="headerlink" title="Day -14"></a>Day -14</h2><p>停课力。</p><p>但是国庆作业有一项没看要求，我还要重做&#x2F;ng</p><p>在机房补了前两天学校里的入门组模拟赛，380，死因不看数据范围下意识以为多测保障了 $\sum n\leq 10^6$。</p><h2 id="Day-9"><a href="#Day-9" class="headerlink" title="Day -9"></a>Day -9</h2><p>最近几天都是在机房度过的。但是下周有模考，逃过一劫！</p><h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day -1"></a>Day -1</h2><p>板子大赛。</p><p>写完自己会的发现是 rk.3，晚上看掉 rk.11 了。所以手速在实力的差距面前只是摆设。</p><h2 id="Day-0-1"><a href="#Day-0-1" class="headerlink" title="Day 0"></a>Day 0</h2><p>【省流】J 赢麻了，S 输麻了！</p><h3 id="Morning"><a href="#Morning" class="headerlink" title="Morning"></a>Morning</h3><p>提供一个 J 自己写的题解。</p><p><a href="https://www.luogu.com.cn/blog/cayaxi09/csp-j-2023-ti-xie">https://www.luogu.com.cn/blog/cayaxi09/csp-j-2023-ti-xie</a></p><p>好像去晚了，到的时候已经有考场的人进去了。</p><p>点名批评 @<a href="https://www.luogu.com.cn/user/732869">OrangePayne</a>，2 考场进去的时候带着我进去，<del>还好我走到一半被叫回去了</del>。</p><p>诶为啥密码发的这么晚，又是面对样例和名字猜题意。</p><p>发密码了，但是是 8:30 才发，去年是提前发的啊&#x2F;oh</p><p>开题！</p><p>好好好，T1 不会啊。</p><p>想先打一个拍子，因为往年 T1 都挂了，想了个 $\mathcal O(n {\log_3}^2 n)$ 的做法。</p><p>诶不对可以少一个 $n$ 啊，好好好正解出来了。拍子是什么，不打了。</p><p>开 T2！</p><p>诶 T2 做过强化版原题，是洛谷秋令营例题还是作业来着。</p><p>哦哦原来 T2 是沙比题！会了！还是直接贪！</p><p>开 T3。T3 怎么又是模拟。调调调，过了！</p><p>开 T4！啊怎么这么简单，看错了吗？</p><p>好好好一遍过小样例。大样例炸了！哦会优化了，过了！</p><p>0.8s，有点不太稳，卡个常卡到了 0.7s，应该可以了。CCF 能卡掉这个我和他爆了！</p><p>十点半准时 AK，开始野餐！</p><p>吃了个巧克力，饼干开不动袋子。野餐进行了一分钟后结束了。</p><p>无聊啊，睡觉吧。睡不着，监考还以为我生病了还来问我。我：我全写完了。监考 &amp; 周围同学：？没见过这么拽的。</p><p>哦哦咖啡还是能抵抗睡觉的，好想此时此刻听数学老师的课，就能分分钟入睡了！</p><p>次你 @<a href="https://www.luogu.com.cn/user/744687">Coffee_zzz</a>。</p><p>摆了摆了。去上个厕所吧。</p><p>为什么大家都知道游戏在哪里，我不知道啊&#x2F;ll</p><p>然后就稀里糊涂过了一个小时。最后半小时闲的没事干，题面开的非常大重新读。</p><p>草，读完了发现 T4 忘记判无解了。</p><p>最后 10 分钟火速改掉。</p><p>结束啦。</p><p>怎么收个卷收这么久。fk。</p><h3 id="Noon"><a href="#Noon" class="headerlink" title="Noon"></a>Noon</h3><p>去老地方吃了个饭，吃完火速回 scz 面基。</p><p>@<a href="https://www.luogu.com.cn/user/400269">Shiota_Kaede</a> 还是那么漂亮，JY 小姐姐嘿嘿。</p><p>@<a href="https://www.luogu.com.cn/user/419487">irris</a> 看到 irris 力。</p><p>和 JY 小姐姐还有 irris 合了一张影&#x2F;tiao</p><p>和 @<a href="https://www.luogu.com.cn/user/183722">EasonTao</a> @<a href="https://www.luogu.com.cn/user/398789">Anny1225</a> 也合照了，拜谢未来江苏省队和未来江苏女队。</p><p>在等进考场还看见了好多无锡 OIer。拜谢。</p><h2 id="Afternoon"><a href="#Afternoon" class="headerlink" title="Afternoon"></a>Afternoon</h2><p>进考场！</p><p>还是打了对拍程序，虽然上午下午都没用上。草。</p><p>T1 水啊。</p><p>T2 看了一会儿线性做法会了，但似乎写起来很复杂，算了打了暴力跳了。</p><p>T3 模拟啊，写一写。一写从三点多写到六点。</p><p>。。。</p><p>关键是只过两个小样例，样例 3 RE 了，但没时间查了。</p><p>听天由命吧，希望 CCF 数据不会太强。</p><p>。。。</p><p>T4 没看部分分，输输输。</p><p>预估 $100+50+[0,100]+0$，输麻了。</p><p>EasonTao 出来大喊说是最简单的一届。</p><p>人均 AK，我太菜了。</p><p>说实话去年的我打这个卷子可能都能拿这么多分，一年白训了&#x2F;ll</p><p>别问 S 组怎么写这么少，因为 T3 写了一坤时还挂了根本没有好说的。</p><p>菜死了。还好 J 在小图灵和洛谷测都 AK 了，应该没问题。还好 J AK 了，S 寄得太惨也有个安慰。</p><p>妈的，今年不会蹭不上蓝勾吧。</p><h2 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h2><p>上午发现别的地方出成绩了，急急急，江苏别的地方也发了，急急急。</p><p>负责人在干啥啊？？？建议下次负责人写我，我 24h 在线。</p><p>找教练，教练说没发下来，看来负责人真的在睡觉。</p><p>看到南京也出了，更急了，直接疯狂骚扰教练，要到分数了。</p><p>J 400</p><p>S 155</p><p>都是意料之中。</p><p>怎么人均 300+ 啊，紫砂了。</p><p>@<a href="https://www.luogu.com.cn/user/500200">panrui_CFS</a> 好强，235，我校最高。没记错的话好像从省选打完到现在退役半年了吧，强。</p><p>中午找梦熊要了 AK-Star 奖金。100 CNY，赢！</p><blockquote><p>和 @<a href="https://www.luogu.com.cn/user/183722">EasonTao</a> @<a href="https://www.luogu.com.cn/user/398789">Anny1225</a> 也合照了，拜谢未来江苏省队和未来江苏女队。</p></blockquote><p>前后呼应了属于是，EasonTao 是前年 CSP-J AKer，Anny1225 是去年 CSP-J AKer，我是今年 CSP-J AKer。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ei5whc8g.png"></p>]]></content>
      
      
      <categories>
          
          <category> TravelNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20230818 | CSP2023 考前模拟赛 做题笔记</title>
      <link href="/archives/20230818_mock/"/>
      <url>/archives/20230818_mock/</url>
      
        <content type="html"><![CDATA[<h1 id="赌徒"><a href="#赌徒" class="headerlink" title="赌徒"></a>赌徒</h1><p>数学题，分类讨论。不多说。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">gmx</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">max</span>(x, y); &#125;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">gmn</span><span class="params">(T &amp;x, T y)</span> </span>&#123; x = <span class="built_in">min</span>(x, y); &#125;<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;ll a, b, c;cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<span class="keyword">if</span> (!c)<span class="keyword">return</span> <span class="built_in">puts</span>(!b ? <span class="string">&quot;Ivor&quot;</span> : <span class="string">&quot;Harper&quot;</span>), <span class="built_in">void</span>();<span class="built_in">puts</span>(a + b &lt;= c &amp;&amp; b ^ c &amp;&amp; b || (b % c &amp; <span class="number">1</span>) &amp;&amp; !(c &amp; <span class="number">1</span>) ? <span class="string">&quot;Harper&quot;</span> : <span class="string">&quot;Ivor&quot;</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;gambler.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);<span class="built_in">freopen</span>(<span class="string">&quot;gambler.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);<span class="type">int</span> x;cin &gt;&gt; x;<span class="type">int</span> t;cin &gt;&gt; t;<span class="keyword">while</span> (t--)<span class="built_in">solve</span>();<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h1 id="残片"><a href="#残片" class="headerlink" title="残片"></a>残片</h1><p>没改好。</p><pre><code class="highlight cpp"></code></pre><h1 id="护手"><a href="#护手" class="headerlink" title="护手"></a>护手</h1><p>没有强制在线，我只用莫队！！1</p><p>首先你会发现这道题长了一脸莫队的样子，区间询问又是可以离线的。</p><p>然后你直接拍一个莫队上去，会发现 $T&#x3D;0$ 奇数分是很好拿的。因为我们知道 $x \oplus x&#x3D;0,x\oplus 0&#x3D;x$，那么奇数次出现就是区间所有的异或起来。只拿这个分甚至可以维护前缀直接异或直接 $\mathcal O(1)$ 回答问题。</p><p><del>但事实上我考场是凑了半天发现不用判断是第几次出现直接异或就可以的。</del></p><p>然后你考虑偶数的怎么搞，你想，区间里非重复元素的集合减去出现奇数次元素集合不就是出现偶数次元素集合吗！</p><p>所以你维护某个区间去重之后的元素的异或，把偶数当成奇数做，最后和上树的去重元素异或异或一下就好。</p><p>去重元素异或维护很容易，统计每个数出现次数，删去之后全都没了和加上之后是第一次都异或起来。得分 $83\ \text{pts}$。</p><p>怎么回事呢？</p><p>考虑进行卡常。</p><p>我们会发现我们 <strong>不在意每个数具体出现多少次，只在意他前面和后面出现的位置。</strong> 因为我们只需要判断是否在区间内出现过。</p><p>考虑维护 $pre_i$ 表示第 $i$ 个位置上一个与其相等元素位置，$nxt_i$ 表示第 $i$ 个位置下一个与其相等元素位置。</p><p>然后莫队区间移动只需要判断 $pre,nxt,l,r$ 的大小关系了。本地测试最长点耗时 $1.7\ \text{s}$。</p><hr><p>再插一嘴，你要是 $nxt,pre$ 或者是 $83\ \text{pts}$ 做法维护的数字出现次数的数组，用 <code>map/unordered_map</code> 是真的要死。<code>map</code> 稳定 $\log$，<code>unordered_map</code> 均摊常数实则会被卡到线性。</p><p>你复杂度再乘上一个 $\log$ 你卡的过去？？？</p><p>离散化，离散化，离散化！</p><pre><code class="highlight inform7">#include &lt;bits/stdc++.h&gt;using namespace std;#define getchar() p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++char buf<span class="comment">[1000000]</span>, *p1 = buf, *p2 = buf;inline int read()&#123;register char c = getchar();register int x = 0;while (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;)c = getchar();while (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48), c = getchar();return x;&#125;int n, Q;int a<span class="comment">[800020]</span>;struct node&#123;int l, r, t, id;&#125; query<span class="comment">[700020]</span>;int ans<span class="comment">[700020]</span>;int b<span class="comment">[800020]</span>;int p<span class="comment">[800020]</span>;int mp<span class="comment">[800020]</span>;int pos<span class="comment">[800020]</span>;int fa<span class="comment">[800020]</span>;int pre<span class="comment">[800020]</span>;int nxt<span class="comment">[800020]</span>;int len;int ANS, X;inline bool cmp(node a, node b) &#123; return pos<span class="comment">[a.l]</span> ^ pos<span class="comment">[b.l]</span> ? pos<span class="comment">[a.l]</span> &lt; pos<span class="comment">[b.l]</span> : pos<span class="comment">[a.l]</span> &amp; 1 ? a.r &gt; b.r  : a.r &lt; b.r; &#125;int main()&#123;freopen(<span class="string">&quot;gauntlet.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);freopen(<span class="string">&quot;gauntlet.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);register int subtask;subtask = read();n = read();Q = read();len = sqrt(n);for (register int i = 1; i &lt;= n; i++)a<span class="comment">[i]</span> = b<span class="comment">[i]</span> = read();sort(b + 1, b + n + 1);register int m = unique(b + 1, b + n + 1) - b;for (register int i = 1; i &lt;= n; i++)&#123;register int j = lower_bound(b + 1, b + m + 1, a<span class="comment">[i]</span>) - b;p<span class="comment">[j]</span> = a<span class="comment">[i]</span>;a<span class="comment">[i]</span> = j;pos<span class="comment">[i]</span> = (i + len - 1) / len;&#125;for (register int i = 1; i &lt;= n; i++)&#123;nxt<span class="comment">[i]</span> = n + 1;pre<span class="comment">[i]</span> = fa<span class="comment">[a<span class="comment">[i]</span>]</span>;nxt<span class="comment">[pre<span class="comment">[i]</span>]</span> = i;fa<span class="comment">[a<span class="comment">[i]</span>]</span> = i;&#125;for (register int i = 1; i &lt;= Q; i++)&#123;int l, r, t;l = read();r = read();t = read();query<span class="comment">[i]</span> = &#123;l, r, t, i&#125;;&#125;sort(query + 1, query + Q + 1, cmp);register int l = 1, r = 0;for (register int i = 1; i &lt;= Q; i++)&#123;while (l &lt; query<span class="comment">[i]</span>.l)&#123;ANS ^= p<span class="comment">[a<span class="comment">[l]</span>]</span>;// del(l++);if (nxt<span class="comment">[l]</span> &gt; r)X ^= p<span class="comment">[a<span class="comment">[l]</span>]</span>;l++;&#125;while (r &gt; query<span class="comment">[i]</span>.r)&#123;ANS ^= p<span class="comment">[a<span class="comment">[r]</span>]</span>;if (pre<span class="comment">[r]</span> &lt; l)X ^= p<span class="comment">[a<span class="comment">[r]</span>]</span>;r--;&#125;while (l &gt; query<span class="comment">[i]</span>.l)&#123;l--;ANS ^= p<span class="comment">[a<span class="comment">[l]</span>]</span>;if (nxt<span class="comment">[l]</span> &gt; r)X ^= p<span class="comment">[a<span class="comment">[l]</span>]</span>;&#125;while (r &lt; query<span class="comment">[i]</span>.r)&#123;r++;ANS ^= p<span class="comment">[a<span class="comment">[r]</span>]</span>;if (pre<span class="comment">[r]</span> &lt; l)X ^= p<span class="comment">[a<span class="comment">[r]</span>]</span>;&#125;if (!query<span class="comment">[i]</span>.t)ans<span class="comment">[query<span class="comment">[i]</span>.id]</span> = ANS;elseans<span class="comment">[query<span class="comment">[i]</span>.id]</span> = ANS ^ X;&#125;for (register int i = 1; i &lt;= Q; i++)printf(<span class="string">&quot;%d\n&quot;</span>, ans<span class="comment">[i]</span>);return 0;&#125;/*inline void add(int i)&#123;mp<span class="comment">[a<span class="comment">[i]</span>]</span>++;ANS ^= p<span class="comment">[a<span class="comment">[i]</span>]</span>;if (mp<span class="comment">[a<span class="comment">[i]</span>]</span> == 1)X ^= p<span class="comment">[a<span class="comment">[i]</span>]</span>;&#125;inline void del(int i)&#123;mp<span class="comment">[a<span class="comment">[i]</span>]</span>--;ANS ^= p<span class="comment">[a<span class="comment">[i]</span>]</span>;if (mp<span class="comment">[a<span class="comment">[i]</span>]</span> == 0)X ^= p<span class="comment">[a<span class="comment">[i]</span>]</span>;&#125;*/</code></pre><h1 id="无量"><a href="#无量" class="headerlink" title="无量"></a>无量</h1><pre><code class="highlight cpp"></code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 常州市程序设计小能手 2023 做题笔记 | CZOI 2023 做题笔记</title>
      <link href="/archives/CZOI2023/"/>
      <url>/archives/CZOI2023/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>初中了没法打小学生比赛了。膜拜小学但是吊打我的巨佬。但是虽然初中仍然能写炸 T1 并且只能口胡到 T2。</p><h1 id="T1-矩形纸片"><a href="#T1-矩形纸片" class="headerlink" title="T1 矩形纸片"></a>T1 矩形纸片</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://czoj.com.cn/p/P1672">http://czoj.com.cn/p/P1672</a></p><p>来源 <a href="http://czoj.com.cn/">CZOJ</a>。</p><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>题面中的 $10^9$ 完全吓唬人用的。</p><p>考虑到 $1\leq a,b,c,d,x,y\leq 1000$，最暴力的方法开个 $2000\times 2000$ 大小的数组存每个位置是否覆盖。</p><p>时间复杂度 $\mathcal O(a\times b+c\times d+2000^2)$。</p><p>或者考虑容斥，用第一个的覆盖面积加上第二个的覆盖面积减去重合面积。特判如果 $(x,y)$ 与第一个纸片没有重合就没有重合面积。</p><hr><p>Solution by @<a href="http://czoj.com.cn/user/6">cyx2009</a></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> a,b,c,d,x,y;    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;x&gt;&gt;y;    cout&lt;&lt;(a*b)+(c*d)-(x&gt;a||y&gt;b?<span class="number">0</span>:<span class="built_in">min</span>(a-x<span class="number">+1</span>,c)*<span class="built_in">min</span>(b-y<span class="number">+1</span>,d))&lt;&lt;endl;       <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><hr><p>Code by @<a href="http://czoj.com.cn/user/6">cyx2009</a></p><h1 id="T2-奶牛农场"><a href="#T2-奶牛农场" class="headerlink" title="T2 奶牛农场"></a>T2 奶牛农场</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://czoj.com.cn/p/P1673">http://czoj.com.cn/p/P1673</a></p><p>来源 <a href="http://czoj.com.cn/">CZOJ</a>。</p><h2 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h2><p>考虑贪心，对于每个为 $0$ 的位置只设置比前面高 $1$，尽可能的让后面的位置选的高度数量更多。</p><hr><p>Solution by @<a href="http://czoj.com.cn/user/6">cyx2009</a></p><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n;<span class="type">int</span> ans[<span class="number">100020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin&gt;&gt;n;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        cin&gt;&gt;ans[i];        <span class="keyword">if</span>(ans[i]==<span class="number">0</span>)ans[i]=ans[i<span class="number">-1</span>]<span class="number">+1</span>;    &#125;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        <span class="keyword">if</span>(ans[i]&lt;=ans[i<span class="number">-1</span>]||ans[i]&gt;<span class="number">1000000000</span>||ans[i]&lt;=<span class="number">0</span>)        &#123;            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);            <span class="keyword">return</span> <span class="number">0</span>;        &#125;    &#125;    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;    &#125;    cout&lt;&lt;endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><hr><p>Code by @<a href="http://czoj.com.cn/user/6">cyx2009</a></p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1817A Almost Increasing Subsequence</title>
      <link href="/archives/CF1817A/"/>
      <url>/archives/CF1817A/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><blockquote><p>我们定义“几乎递增”序列表示这个序列没有 $3$ 个连续的元素 $x,y,z$ 使得 $x\ge y\ge z$。</p><p>现在有一个长度为 $n$ 的序列，有 $q$ 次询问，每次问一个区间 $[l,r]$，你回答 $[l,r]$ 中最长的“几乎递增”子序列长度。</p><p>一行 $2$ 个正整数 $n,q$ 表示长度和查询个数。</p><p>$q$ 行每行 $1$ 个整数，表示最长的“几乎递增”子序列长度。</p><p>$1\leq n,q\leq 2\times 10^5,a_i\leq 10^9$。</p></blockquote><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>这里讲一下莫队算法。</p><p>因为莫队算法是基于分块的，也就是说每个询问，莫队算法的时间复杂度为 $\mathcal O(\sqrt n)$，总时间复杂度 $\mathcal O(q\sqrt n)$，可以接受。</p><p>很显然，这题在进行莫队的时候，我们只需对于新进的数字判断一下三个数关系即可实现莫队精华部分。</p><p>接着我们按照莫队常规操作记录编号输出即可。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span>usingnamespacestd;<span class="meta">#<span class="keyword">define</span> getchar() p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++</span><span class="type">char</span> buf[<span class="number">1000000</span>],*p1=buf,*p2=buf;<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span><span class="function"></span>&#123;    registerchar c=<span class="built_in">getchar</span>();registerint x=<span class="number">0</span>;    <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)c=<span class="built_in">getchar</span>();<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=<span class="built_in">getchar</span>();    <span class="keyword">return</span> x;&#125;<span class="type">int</span> len,n,q;<span class="type">int</span> a[<span class="number">200020</span>];<span class="type">int</span> ans[<span class="number">200020</span>];<span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> l,r,id;&#125;b[<span class="number">2000020</span>];<span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span><span class="function"></span>&#123;    <span class="type">int</span> fx=(x.l<span class="number">-1</span>)/len,fy=(y.l<span class="number">-1</span>)/len;    <span class="keyword">if</span>(fx^fy)<span class="keyword">return</span> fx&lt;fy;    <span class="keyword">if</span>(fx&amp;<span class="number">1</span>)<span class="keyword">return</span> x.r&gt;y.r;    <span class="keyword">return</span> x.r&lt;y.r;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    n=<span class="built_in">read</span>();q=<span class="built_in">read</span>();    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        a[i]=<span class="built_in">read</span>();    &#125;    len=<span class="built_in">sqrt</span>(n);    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)    &#123;        <span class="type">int</span> l,r;        l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();        b[i]=&#123;l,r,i&#125;;    &#125;    <span class="built_in">sort</span>(b<span class="number">+1</span>,b+q<span class="number">+1</span>,cmp);    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>,ANS=<span class="number">0</span>;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;<span class="keyword">while</span>(r&lt;b[i].r)&#123;r++;ANS++;<span class="keyword">if</span>(r-l<span class="number">+1</span>&lt;<span class="number">3</span>)<span class="keyword">continue</span>;<span class="keyword">if</span>(a[r<span class="number">-2</span>]&gt;=a[r<span class="number">-1</span>]&amp;&amp;a[r<span class="number">-1</span>]&gt;=a[r])ANS--;&#125;<span class="keyword">while</span>(r&gt;b[i].r)&#123;<span class="keyword">if</span>(r-l<span class="number">+1</span>&lt;<span class="number">3</span>)&#123;r--;ANS--;<span class="keyword">continue</span>;&#125;<span class="keyword">if</span>(a[r<span class="number">-2</span>]&lt;a[r<span class="number">-1</span>]||a[r<span class="number">-1</span>]&lt;a[r])ANS--;r--;&#125;<span class="keyword">while</span>(l&lt;b[i].l)&#123;<span class="keyword">if</span>(r-l<span class="number">+1</span>&lt;<span class="number">3</span>)&#123;l++;ANS--;<span class="keyword">continue</span>;&#125;<span class="keyword">if</span>(a[l]&lt;a[l<span class="number">+1</span>]||a[l<span class="number">+1</span>]&lt;a[l<span class="number">+2</span>])ANS--;l++;&#125;<span class="keyword">while</span>(l&gt;b[i].l)&#123;l--;ANS++;<span class="keyword">if</span>(r-l<span class="number">+1</span>&lt;<span class="number">3</span>)<span class="keyword">continue</span>;<span class="keyword">if</span>(a[l]&gt;=a[l<span class="number">+1</span>]&amp;&amp;a[l<span class="number">+1</span>]&gt;=a[l<span class="number">+2</span>])ANS--;&#125;ans[b[i].id]=ANS;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)    &#123;        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);    &#125;    return0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC171E Red Scarf</title>
      <link href="/archives/ABC171E/"/>
      <url>/archives/ABC171E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><blockquote><p>给出有 $n$ 个数的序列 $b$，还原序列 $a$，使 $a_i$ 为除 $b_i$ 以外所有数的异或和。<br>$2\leq n\leq 2\times 10^6,0\leq a_i\leq 10^9$。<br>$n\equiv0\pmod{2}$。</p></blockquote><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>前置知识：异或的归零律、恒等律与自反 $a\oplus a&#x3D;0,a\oplus 0&#x3D;a,a\oplus b\oplus a&#x3D;b$。</p><p>观察题意可得我们求出的 $a_i$ 即为 $b_1\oplus b_2\oplus \dots \oplus b_n$ 再去除一个 $b_i$。</p><p>设 $b_1\oplus b_2\oplus \dots \oplus b_n&#x3D;k$。</p><p>我们根据异或的自反可得：</p><p>$$<br>\begin{aligned}k\oplus b_i&amp;&#x3D;b_1\oplus b_2\oplus \dots \oplus b_n\oplus b_i\&amp;&#x3D;b_1\oplus b_2\oplus\dots\oplus b_{i-1}\oplus b_{i+1}\oplus b_{i+2}\oplus \dots \oplus b_n\end{aligned}<br>$$</p><p>于是我们得到了想求的 $a$ 数组。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n,k;<span class="type">int</span> a[<span class="number">200020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin&gt;&gt;n;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        cin&gt;&gt;a[i];        k^=a[i];    &#125;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        cout&lt;&lt;(k^a[i])&lt;&lt;<span class="string">&quot; \n&quot;</span>[i==n];    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] UVA291 The House Of Santa Claus</title>
      <link href="/archives/UVA291/"/>
      <url>/archives/UVA291/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><blockquote><p>一张无向图。<img src="data:image/png;base64,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">，由 $5$ 个点 $8$ 条边组成。请问如何才能从点 $1$ 出发<strong>不遗漏不重复</strong>走完所有边。</p></blockquote><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>简单的一笔画问题。通过一笔画我们不难想到七桥问题，作为尝试，我们都知道一张图内拥有 $0$ 或 $2$ 个奇点时才可被一笔画。</p><p>显然这张图上，奇点是 $1$ 和 $2$。因为题目说了从 $1$ 开始，所以起点为 $1$。</p><p>我们考虑对这张图进行搜索，枚举之后每一步走哪一条边，打上边是否走过的标记即可。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>这题没有输入，可直接打表。具体的答案在程序最后的注释。</p><p>[collapse status&#x3D;”false” title&#x3D;”代码”]</p><pre><code class="highlight prolog">#include&lt;bits/stdc++.h&gt;using namespace std;bool vis[<span class="number">10</span>][<span class="number">10</span>];int fa[<span class="number">10</span>][<span class="number">10</span>];int ans[<span class="number">10</span>];void dfs(int u,int dep)&#123;    if(dep&gt;<span class="number">8</span>)    &#123;        for(int i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)        &#123;            cout&lt;&lt;ans[i];        &#125;        cout&lt;&lt;endl;        return;    &#125;    for(int i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)    &#123;        if(fa[u][i]&amp;&amp;!vis[u][i])        &#123;            ans[dep+<span class="number">1</span>]=i;            vis[u][i]=vis[i][u]=<span class="number">1</span>;            dfs(i,dep+<span class="number">1</span>);            vis[u][i]=vis[i][u]=<span class="number">0</span>;        &#125;    &#125;&#125;int main()&#123;    fa[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;fa[<span class="number">1</span>][<span class="number">3</span>]=<span class="number">2</span>;fa[<span class="number">1</span>][<span class="number">5</span>]=<span class="number">3</span>;    fa[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">4</span>;fa[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">5</span>;fa[<span class="number">2</span>][<span class="number">5</span>]=<span class="number">6</span>;    fa[<span class="number">3</span>][<span class="number">1</span>]=<span class="number">7</span>;fa[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">8</span>;fa[<span class="number">3</span>][<span class="number">4</span>]=<span class="number">9</span>;fa[<span class="number">3</span>][<span class="number">5</span>]=<span class="number">10</span>;    fa[<span class="number">4</span>][<span class="number">3</span>]=<span class="number">11</span>;fa[<span class="number">4</span>][<span class="number">5</span>]=<span class="number">12</span>;    fa[<span class="number">5</span>][<span class="number">1</span>]=<span class="number">13</span>;fa[<span class="number">5</span>][<span class="number">2</span>]=<span class="number">14</span>;fa[<span class="number">5</span>][<span class="number">3</span>]=<span class="number">15</span>;fa[<span class="number">5</span>][<span class="number">4</span>]=<span class="number">16</span>;    ans[<span class="number">1</span>]=<span class="number">1</span>;    dfs(<span class="number">1</span>,<span class="number">1</span>);    return <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">123153452</span><span class="comment">123154352</span><span class="comment">123451352</span><span class="comment">123453152</span><span class="comment">123513452</span><span class="comment">123543152</span><span class="comment">125134532</span><span class="comment">125135432</span><span class="comment">125315432</span><span class="comment">125345132</span><span class="comment">125431532</span><span class="comment">125435132</span><span class="comment">132153452</span><span class="comment">132154352</span><span class="comment">132534512</span><span class="comment">132543512</span><span class="comment">134512352</span><span class="comment">134512532</span><span class="comment">134521532</span><span class="comment">134523512</span><span class="comment">134532152</span><span class="comment">134532512</span><span class="comment">135123452</span><span class="comment">135125432</span><span class="comment">135215432</span><span class="comment">135234512</span><span class="comment">135432152</span><span class="comment">135432512</span><span class="comment">152134532</span><span class="comment">152135432</span><span class="comment">152345312</span><span class="comment">152354312</span><span class="comment">153123452</span><span class="comment">153125432</span><span class="comment">153213452</span><span class="comment">153254312</span><span class="comment">153452132</span><span class="comment">153452312</span><span class="comment">154312352</span><span class="comment">154312532</span><span class="comment">154321352</span><span class="comment">154325312</span><span class="comment">154352132</span><span class="comment">154352312</span><span class="comment">*/</span></code></pre><p>[&#x2F;collapse]</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF616D Longest k-Good Segment</title>
      <link href="/archives/CF616D/"/>
      <url>/archives/CF616D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h1><blockquote><p>有一个长度为 $n$ 的序列 $a$，找出最长的 $[l,r]$ 使得 $a_l,a_{l+1},a_{l+2},\dots a_{r-1},a_r$ 不重复的数字个数 $\leq k$。<br>$1\leq k \leq n\leq 5\times 10^5,a_i\leq 10^6$</p></blockquote><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>分析一下复杂度，$n$ 的级别显然告诉我们要做到 $n^2$ 以下。</p><p>观察到固定左端点 $l$，随着 $r$ 往右推，不重复数字的个数也是单调不降的。考虑双指针。</p><p>我们先让 $r$ 往右挪动，每一步检查一下当前的不重复数字个数，如果不满足题意那么挪动左端点 $l$ 把不重复的数字个数控制在 $k$ 以内。</p><p>时间复杂度 $\mathcal O(n)$。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n,k;<span class="type">int</span> a[<span class="number">500020</span>];<span class="type">int</span> cnt[<span class="number">1000020</span>],sum;<span class="type">int</span> ansl=<span class="number">1</span>,ansr;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin&gt;&gt;n&gt;&gt;k;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        cin&gt;&gt;a[i];    &#125;    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;    <span class="keyword">while</span>(r&lt;n)    &#123;        sum+=((++cnt[a[++r]])==<span class="number">1</span>);        <span class="keyword">while</span>(sum&gt;k)sum-=(!(--cnt[a[l++]]));        <span class="keyword">if</span>(r-l<span class="number">+1</span>&gt;ansr-ansl<span class="number">+1</span>)ansr=r,ansl=l;    &#125;    cout&lt;&lt;ansl&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ansr&lt;&lt;endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20230427 | VP 往年区赛</title>
      <link href="/archives/20230427_mock/"/>
      <url>/archives/20230427_mock/</url>
      
        <content type="html"><![CDATA[<p><img src="data:image/png;base64,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"></p><p>考场 $225\ \tt{pts}$，</p><p>考完改了 $10$ 个字节 $335\ \tt{pts}$，</p><p>回家改了 $2$ 个字节 $400\ \tt{pts}$。</p><p>水平没长进挂分的水平进步不小。</p><h1 id="D-三角形个数-count"><a href="#D-三角形个数-count" class="headerlink" title="D.三角形个数 count"></a>D.三角形个数 count</h1><p>很显然 $\mathcal O(n^2)$ 枚举两个角度会超时。</p><p>考虑到题目隐藏数据范围 $a_i\leq 180$，我们实际只要开桶记录每个度数出现次数，然后枚举三角形角度得到每个度数出现次数，相乘即可。</p><p>考场的 $j$ 和 $k$ 变量忘记 $+1$，$-80\ \tt{pts}$。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n;<span class="type">long</span> <span class="type">long</span> h[<span class="number">200</span>];<span class="type">long</span> <span class="type">long</span> cnt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> x;cin&gt;&gt;x;h[x]++;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">180</span>;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;<span class="number">180</span>;j++)&#123;<span class="keyword">for</span>(<span class="type">int</span> k=j<span class="number">+1</span>;k&lt;<span class="number">180</span>;k++)&#123;<span class="keyword">if</span>(i+j+k!=<span class="number">180</span>)<span class="keyword">continue</span>;cnt+=h[i]*h[j]*h[k];&#125;&#125;&#125;cout&lt;&lt;cnt&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">5</span><span class="comment">20 20 30 130 14</span><span class="comment">*/</span></code></pre><h1 id="E-牛队-cow"><a href="#E-牛队-cow" class="headerlink" title="E.牛队 cow"></a>E.牛队 cow</h1><p>考虑到这头牛能网友看到的牛的高度具单调递减，具有单调性。</p><p>直接单调栈维护，一旦即将进入的高度比栈顶高就连续排出元素最后插入进栈。</p><p>看到的牛高度是<strong>严格小于</strong>当前牛的高度。</p><p>考场没有发现是严格小于，写的小于等于，$-65\ \tt{pts}$。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;stack&lt;<span class="type">int</span>&gt;s;<span class="type">int</span> n;<span class="type">int</span> a[<span class="number">1000020</span>];<span class="type">long</span> <span class="type">long</span> ans;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(s.<span class="built_in">empty</span>()||s.<span class="built_in">top</span>()&gt;a[i])&#123;<span class="comment">//cout&lt;&lt;&quot;insert:&quot;&lt;&lt;a[i]&lt;&lt;endl;</span>s.<span class="built_in">push</span>(a[i]);&#125;<span class="keyword">else</span>&#123;<span class="comment">//ans+=1LL*s.size()*(s.size()-1)/2;</span><span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;s.<span class="built_in">top</span>()&lt;=a[i])&#123;ans+=s.<span class="built_in">size</span>()<span class="number">-1</span>;s.<span class="built_in">pop</span>();&#125;<span class="comment">//cout&lt;&lt;&quot;insert:&quot;&lt;&lt;a[i]&lt;&lt;endl;</span>s.<span class="built_in">push</span>(a[i]);&#125;&#125;ans+=<span class="number">1LL</span>*s.<span class="built_in">size</span>()*(s.<span class="built_in">size</span>()<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">// for(int i=1;i&lt;=n;i++)</span><span class="comment">// &#123;</span><span class="comment">// for(int j=i+1;j&lt;=n;j++)</span><span class="comment">// &#123;</span><span class="comment">// if(a[j]&gt;=a[i])break;</span><span class="comment">// ans++;</span><span class="comment">// &#125;</span><span class="comment">// &#125;</span><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">5</span><span class="comment">3 2 4 1 5</span><span class="comment"></span><span class="comment">5</span><span class="comment">1 4 2 3 5</span><span class="comment"></span><span class="comment">10</span><span class="comment">6 7 10 3 4 8 1 2 5 9</span><span class="comment"></span><span class="comment">*/</span></code></pre><h1 id="F-机房分组-team"><a href="#F-机房分组-team" class="headerlink" title="F.机房分组 team"></a>F.机房分组 team</h1><p>求最值，考虑穷举贪心二分答案。</p><p>这题显然有贪心性质，每次插到最小但是能容纳下这个同学的列去。</p><p>建议的证明就是，其他列的可能可以给比你大的人坐，为了每一列坐得多你不能抢别人位置。</p><p>不知道为啥这个代码稀里糊涂的跑过去了，应该是可以二分得到最小位置继续优化的。</p><p>考场的 $top$ 变量第一次调用没有 <code>++top</code>，$- 20\ \tt{pts}$。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> top,n;<span class="type">int</span> a[<span class="number">200020</span>];vector&lt;<span class="type">int</span>&gt;b[<span class="number">200020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;<span class="comment">//for(int i=1;i&lt;=n;i++)</span><span class="comment">//&#123;</span><span class="comment">//if(!top||a[i]&gt;f[top])</span><span class="comment">//&#123;</span><span class="comment">//f[++top]=a[i];</span><span class="comment">//&#125;</span><span class="comment">//else</span><span class="comment">//&#123;</span><span class="comment">//int p=lower_bound(f+1,f+top+1,a[i])-f;</span><span class="comment">//f[p]=a[i];</span><span class="comment">//&#125;</span><span class="comment">//&#125;</span>b[++top].<span class="built_in">push_back</span>(a[<span class="number">1</span>]);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;<span class="type">int</span> minn=INT_MAX,p=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=top;j++)&#123;<span class="keyword">if</span>(a[i]&lt;=b[j][<span class="built_in">int</span>(b[j].<span class="built_in">size</span>())<span class="number">-1</span>]&amp;&amp;b[j][<span class="built_in">int</span>(b[j].<span class="built_in">size</span>())<span class="number">-1</span>]&lt;minn)&#123;minn=b[j][<span class="built_in">int</span>(b[j].<span class="built_in">size</span>())<span class="number">-1</span>];p=j;&#125;&#125;<span class="keyword">if</span>(!p)&#123;b[++top].<span class="built_in">push_back</span>(a[i]);&#125;<span class="keyword">else</span>&#123;b[p].<span class="built_in">push_back</span>(a[i]);&#125;&#125;cout&lt;&lt;top&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">7</span><span class="comment">6 3 6 1 2 4 5</span><span class="comment"></span><span class="comment"></span><span class="comment">8</span><span class="comment">389 207 155 300 299 170 158 65</span><span class="comment">*/</span></code></pre><h1 id="G-买铅笔-pencil"><a href="#G-买铅笔-pencil" class="headerlink" title="G.买铅笔 pencil"></a>G.买铅笔 pencil</h1><p>完全背包板子。</p><p>但是，完全背包是求能装下的最大价值，这里是求超过的最小价值。</p><p>那么显然，除了最大最小需要改变，观察到 $a_i,b_i\leq 100$，我们只需上限调到 $n+100$ 即可，然后在 $[n,n+100]$ 的范围内找最小花费，保险一点右端点可以写成 $n+200$。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">long</span> <span class="type">long</span> f[<span class="number">4000500</span>];<span class="type">int</span> n;<span class="type">int</span> x,y;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));cin&gt;&gt;n;f[<span class="number">0</span>]=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;cin&gt;&gt;x&gt;&gt;y;<span class="keyword">for</span>(<span class="type">int</span> j=x;j&lt;=n<span class="number">+200</span>;j++)&#123;f[j]=<span class="built_in">min</span>(f[j],f[j-x]+y);&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> j=n;j&lt;=n<span class="number">+200</span>;j++)&#123;f[n]=<span class="built_in">min</span>(f[n],f[j]);&#125;cout&lt;&lt;f[n]&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">/*</span><span class="comment">57</span><span class="comment">2 2</span><span class="comment">50 30</span><span class="comment">30 27</span><span class="comment">*/</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF776C Molly&#39;s Chemicals</title>
      <link href="/archives/CF776C/"/>
      <url>/archives/CF776C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>给定长度为 $n$ 的序列 $a$，求有多少组 $(l,r)$ 满足 $\sum\limits_{i&#x3D;l}^ra_i&#x3D;k^i$。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>首先考虑，枚举 $l$ 和 $r$，判断 $\sum\limits_{i&#x3D;l}^r$ 是否为 $k$ 的倍数。但是显然这种做法复杂度为 $n^2$ 无法通过。</p><p>设 $s$ 为 $a$ 的前缀和数组，我们注意到，我们查找 $s_r-s_{l-1}&#x3D;k^i$，其实等价于找 $s$ 中是否有 $s_r-k^i$ 这个元素，那么我们只需枚举一个端点以及一个 $k$ 的次幂。</p><p>显然在这个题中，除去 $k&#x3D;\pm1$，上述的 $i$ 最多只需枚举至 $\log_2 (10^9\times 10^5)\approx 60$ 次。</p><p>因此，总的时间复杂度为 $\mathcal O(n\log V)$。其中 $V&#x3D;10^9\times 10^5$。对于 C++ 选手，如果你用 map 来判断 $s_r-k^i$ 是否存在还需乘上一个 $\log_2 n$。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> n;ll st[<span class="number">100</span>];<span class="type">int</span> top;ll pw=<span class="number">1</span>;ll k,ans;ll a[<span class="number">100020</span>];ll s[<span class="number">100020</span>];map&lt;ll,<span class="type">int</span>&gt;mp;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    cin&gt;&gt;n&gt;&gt;k;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        cin&gt;&gt;a[i];        s[i]=a[i]+s[i<span class="number">-1</span>];    &#125;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;i++)    &#123;        <span class="keyword">if</span>(<span class="built_in">abs</span>(pw)&gt;<span class="number">1e14</span>)<span class="keyword">break</span>;        st[++top]=pw;        pw*=k;    &#125;    mp[<span class="number">0</span>]=<span class="number">1</span>;    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    &#123;        <span class="keyword">if</span>(k==<span class="number">1</span>)ans+=mp[s[i]<span class="number">-1</span>];        <span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">-1</span>)ans+=mp[s[i]<span class="number">-1</span>]+mp[s[i]<span class="number">+1</span>];        <span class="keyword">else</span>         &#123;            <span class="keyword">for</span>(<span class="type">int</span> _=<span class="number">1</span>;_&lt;=top;_++)            &#123;                ans+=mp[s[i]-st[_]];            &#125;        &#125;        mp[s[i]]++;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC159E Dividing Chocolate</title>
      <link href="/archives/ABC159E/"/>
      <url>/archives/ABC159E/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>有一个 $H\times W$ 的矩阵，切若干次，使得每一块中 $1$ 个数 $\leq k$，只能一切到底，问最少用几刀。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>直接暴力枚举每一行每一列绝对不行，复杂度 $\mathcal O(2^{H+W})$。</p><p>我们发现 $H$ 很小，我们可以枚举 $H$ 在哪里切割，复杂度 $\mathcal O(2^H)$。其实最多只有 $H-1$ 刀，为了方便描述，统一用 $H$。</p><p>接着，我们对于 $W$ 考虑贪心，每一块有尽量多的 $1$，最后肯定花费最小，也是可以证明的。</p><p>综上所述，我们枚举 $2^H$ 种方案，接着扫一遍 $W$ 确定切割次数。</p><p>时间复杂度 $\mathcal O(2^H\times W\times H)$，可以通过此题。</p><p>但是还不完美，如果 $H\leq 15,W\leq 10^6$，明显是会炸掉的。</p><p>我们扫 $W$ 时，这里 $1$ 个数肯定是单调不增的，可以考虑进行二分或者倍增来找。这一段的时间复杂度一下子变成了 $\mathcal O(\log W)$，总时间复杂度 $\mathcal O(2^H\times \log W\times H)$。</p><p>但上述做法在面对全是 $1$ 时，每次只能前进一步，实际上会退化成 $\mathcal O(W)$。其余数据效果比最初做法时间上较佳。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>代码很长，不贴了，发个链接。</p><p><a href="https://atcoder.jp/contests/abc159/submissions/38882298">Code 1</a></p><p><a href="https://atcoder.jp/contests/abc159/submissions/38882293">Code 2</a></p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC251D At Most 3 (Contestant ver.)</title>
      <link href="/archives/ABC251D/"/>
      <url>/archives/ABC251D/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>给出 $w$，问造一个数组，满足选三个正好是等于所有 $\leqslant w$ 的。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>这个 $w$ 最多 $7$ 位，但 $&lt;w$ 只有 $6$ 位。</p><p>我们把这个数设为 $\overline{abcdef}$，然后分成 $\overline{ab}$、$\overline{cd}$、$\overline{ef}$。</p><p>每个都有 $99$ 种可能，加上 $10^6$，一共 $298$ 个。</p><h3 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;cout&lt;&lt;<span class="number">298</span>&lt;&lt;endl;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">99</span>;i++)&#123;cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">99</span>;i++)&#123;cout&lt;&lt;i*<span class="number">100</span>&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">99</span>;i++)&#123;cout&lt;&lt;i*<span class="number">100</span>*<span class="number">100</span>&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;cout&lt;&lt;<span class="number">1000000</span>&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC257E Addition and Multiplication 2</title>
      <link href="/archives/ABC257E/"/>
      <url>/archives/ABC257E/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>有 $9$ 种数字，$1,2,\dots9$。</p><p>数字 $i$ 可以花 $c_i$ 的价格购买，你有 $n$ 元。</p><p>最后输出你购买的数字拼成的最大值。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>我们考虑，先让位数最大。</p><p>然后，再最大化最高位、次高位、次次高位，一直往下。</p><p>最大位数，即为用 $n$ 除以最便宜的价钱。</p><p>然后，你可能会有剩余的钱。</p><p>剩余的，我们开始置换。</p><p>从 $9$ 开始枚举，能换就换，并输出你置换的数字。</p><p>这样最大化了较高位，还保证位数没有变少。</p><p>具体可以品味下代码。</p><h3 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h3><pre><code class="highlight cpp"><span class="type">int</span> c[<span class="number">20</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="type">int</span> n, mnc = INT_MAX, maxn;    cin &gt;&gt; n;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)    &#123;        cin &gt;&gt; c[i];        <span class="keyword">if</span> (c[i] &lt;= mnc)        &#123;            mnc = c[i];            maxn = i;        &#125;    &#125;    <span class="type">int</span> cnt = n / mnc;    <span class="type">int</span> x = <span class="number">0</span>, cnt2 = <span class="number">0</span>;    <span class="type">int</span> s = n - cnt * mnc;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">1</span>; i--)    &#123;        <span class="keyword">if</span> (i &gt; maxn)        &#123;            <span class="keyword">if</span> (c[i] - mnc &lt;= s)            &#123;                cnt2 = s / (c[i] - mnc);                cnt -= cnt2;                s%=c[i] - mnc;                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt2; j++)                &#123;                    cout &lt;&lt; i;                &#125;            &#125;        &#125;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)    &#123;        cout &lt;&lt; maxn;    &#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC247E Max Min</title>
      <link href="/archives/ABC247E/"/>
      <url>/archives/ABC247E/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>输入一个长度为 $n$ 个数字，还有 $X$ 和 $Y$。<br>问数组中有几个区间最大值是 $X$ 且最小值是 $Y$。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>所有数字分为 $a_i&gt;Y$，$a_i&#x3D;Y$，$a_i&lt;X$，$a_i&#x3D;X$，$X&lt;a_i&lt;Y$ 五种情况。<br>$&gt;Y$ 和 $&lt;X$ 的位置一定不能选。<br>选一个区间，包含至少一个 $&#x3D;Y$，包含至少一个 $&#x3D;X$，问有多少种方案。<br>问以每个位置作为结尾，有多少个方案。<br>对于每个位置，找自己之前的最近的 $X$ 是多少，最近的 $Y$ 是多少，至多选多少个数字没有 $&gt;Y$ 和 $&lt;X$ 的情况。</p><h3 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,x,y,maxxid=<span class="number">0</span>,minnid=<span class="number">0</span>,la=<span class="number">1</span>;<span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> z;cin&gt;&gt;z;<span class="keyword">if</span>(z==x)&#123;maxxid=i;&#125;<span class="keyword">if</span>(z==y)&#123;minnid=i;&#125;<span class="keyword">if</span>(z&gt;x||z&lt;y)&#123;maxxid=<span class="number">0</span>;minnid=<span class="number">0</span>;la=i<span class="number">+1</span>;&#125;<span class="keyword">if</span>(maxxid!=<span class="number">0</span>&amp;&amp;minnid!=<span class="number">0</span>)&#123;ans+=<span class="built_in">min</span>(maxxid,minnid)-la<span class="number">+1</span>;&#125;&#125;cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC260D Draw Your Cards</title>
      <link href="/archives/ABC260D/"/>
      <url>/archives/ABC260D/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>依次摸 $n$ 张卡片，第 $i$ 个卡片上写的 $p_i$，$p_i$ 是 $1$ 到 $n$ 的一个排列。</p><p>维护一些牌堆，如果 $p_i$ 大于所有堆顶的牌，那么新开一堆只有 $p_i$。</p><p>否则在所有堆顶的牌，找到大于 $p_i$ 最小的一张，把 $p_i$ 放到这个堆的堆顶。</p><p>如果这一堆有恰好 $K$ 张牌，把这 $K$ 个牌的数字都标记上当前的时间 $i$，并把这堆删掉。</p><p>最后输出每个数字被标记的时间，如果没有被标记过就是 $-1$。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>如果我们真的模拟题意去开栈，肯定会 boom 的。</p><p>观察题意可得，所有操作只考虑牌堆顶，且卡片只要进入牌堆就不会变动。</p><p>因此我们只需维护牌堆顶即可。但这样时间复杂度仍然很高，我们可以把牌堆顶存入一个 set，每次查询即为 $\mathcal O(\log n)$ 了。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">200005</span>];<span class="type">int</span> fa[<span class="number">200005</span>],id,c[<span class="number">200005</span>],d[<span class="number">200005</span>];<span class="type">bool</span> f[<span class="number">200005</span>];<span class="type">int</span> ans[<span class="number">200005</span>];set&lt;<span class="type">int</span>&gt;s;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];<span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>||a[i]&gt;*s.<span class="built_in">rbegin</span>())&#123;s.<span class="built_in">insert</span>(a[i]);id++;fa[a[i]]=id;c[id]=a[i];d[id]++;<span class="keyword">if</span>(d[id]==k)&#123;f[id]=<span class="number">1</span>;ans[id]=i;s.<span class="built_in">erase</span>(a[i]);&#125;&#125;<span class="keyword">else</span>&#123;<span class="keyword">auto</span> it=s.<span class="built_in">upper_bound</span>(a[i]);<span class="type">int</span> x=fa[*it];<span class="keyword">if</span>(f[x]==<span class="number">1</span>)&#123;<span class="keyword">continue</span>;&#125;c[x]=a[i];d[x]++;fa[a[i]]=x;s.<span class="built_in">erase</span>(it);s.<span class="built_in">insert</span>(a[i]);<span class="keyword">if</span>(d[x]==k)&#123;f[x]=<span class="number">1</span>;ans[x]=i;s.<span class="built_in">erase</span>(a[i]);&#125;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cout&lt;&lt;(ans[fa[i]]==<span class="number">0</span>?<span class="number">-1</span>:ans[fa[i]])&lt;&lt;endl;&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC232E Rook Path</title>
      <link href="/archives/ABC232E/"/>
      <url>/archives/ABC232E/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>有一个 $H\times W$ 的国际象棋棋盘，求一个<strong>车</strong>从 $(x_1,y_1)$ 走到 $(x_2,y_2)$ 正好用 $K$ 步的方案数。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>首先看到题，很显然是动态规划。$f_{k,i,j}$ 表示走到 $(i,j)$ 正好 $k$ 步的方案。但时间复杂度过高，考虑进行优化。</p><p>我们可以不记录具体走到哪个点位，我们只需知道当前在不在起点即可。于是就有 $f_{k,0&#x2F;1&#x2F;2&#x2F;3}$ 表示第 $k$ 步时，当前位置为 $(x_1,y_1),(x_1,非y_1),(非x_1,y_1),(非x_1,非y_1)$。</p><p>我们在运用一些排列组合的基本知识，便能得到以下转移方程：</p><p>$$<br>f_{k,0} &#x3D; f_{k-1,1} \times (W-1) + f_{k,2} \times (H-1)<br>$$</p><p>$$<br>f_{k,1} &#x3D; f_{k-1,1} \times (W-2) + f_{k,0} + f_{k,3} \times (H-1)<br>$$</p><p>$$<br>f_{k,2} &#x3D; f_{k-1,2} \times (H-2) + f_{k,0} + f_{k,3} \times (W-1)<br>$$</p><p>$$<br>f_{k,3} &#x3D; f_{k-1,3} \times (H+W-4) + f_{k,2} + f_{k,1}<br>$$</p><p>接着，我们再循环过程中是可以压掉第一维 $k$ 的，那么我们只需记录 $4$ 个变量即可。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>远古时期代码，码风有点不好请见谅。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="meta">#<span class="keyword">define</span> ll long long</span><span class="meta">#<span class="keyword">define</span> p 998244353</span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">long</span> <span class="type">long</span> a,b,c,d;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;ll h,w,k,xx1,xx2,yy1,yy2;cin&gt;&gt;h&gt;&gt;w&gt;&gt;k&gt;&gt;xx1&gt;&gt;yy1&gt;&gt;xx2&gt;&gt;yy2;a=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;ll a1,b1,c1,d1;a1=b*(w<span class="number">-1</span>)+c*(h<span class="number">-1</span>);b1=b*(w<span class="number">-2</span>)+a+d*(h<span class="number">-1</span>);c1=c*(h<span class="number">-2</span>)+a+d*(w<span class="number">-1</span>);d1=d*(h+w<span class="number">-4</span>)+b+c;a1%=p;b1%=p;c1%=p;d1%=p;a=a1;b=b1;c=c1;d=d1;&#125;<span class="keyword">if</span>(xx2==xx1&amp;&amp;yy2==yy1)cout&lt;&lt;a%p;<span class="keyword">else</span> <span class="keyword">if</span>(xx2==xx1)cout&lt;&lt;b%p;<span class="keyword">else</span> <span class="keyword">if</span>(yy2==yy1)cout&lt;&lt;c%p;<span class="keyword">else</span> cout&lt;&lt;d%p;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC252F Bread</title>
      <link href="/archives/ABC252F/"/>
      <url>/archives/ABC252F/</url>
      
        <content type="html"><![CDATA[<h3 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h3><p>原题 <a href="https://www.luogu.com.cn/problem/P1334">P1334 瑞瑞的木板</a>。刚好不久前做过，赛时直接贺了自己的代码过掉的。</p><h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>为方便和瑞瑞的木板联系起来，下文翻译不采用原题中的“面包”而是使用“木板”。</p><p>有一根长度为 $L$ 的木板，切成 $n$ 根小木板。第 $i$ 根小木板的长度为 $l_i$，每次切下长度为 $x$ 的小木板需要耗费 $x$ 的体力。允许有剩余，也就是说不保证 $L&#x3D;\sum_{i&#x3D;1}^n l_i$。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>本题与瑞瑞的木板唯一区别，即不保证 $L&#x3D;\sum_{i&#x3D;1}^n l_i$。为了方便我们贺代码，我们可以自己加一块长度为 $L-\sum_{i&#x3D;1}^n l_i$ 的木板。这时耗费体力肯定不变。</p><p>那么这题就完美的变成了瑞瑞的木板。接下来，我们按照合并果子的贪心思想，每次切最小的即可。详细的贪心证明可以去看 <a href="https://www.luogu.com.cn/problem/P1090">P1090 合并果子</a> 的题解。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;multiset&lt;<span class="type">long</span> <span class="type">long</span>&gt;s;<span class="type">long</span> <span class="type">long</span> n,l,ss=<span class="number">0</span>;cin&gt;&gt;n&gt;&gt;l;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">long</span> <span class="type">long</span> x;cin&gt;&gt;x;s.<span class="built_in">insert</span>(x);ss+=x;&#125;<span class="keyword">if</span>(l-ss!=<span class="number">0</span>)s.<span class="built_in">insert</span>(l-ss);<span class="comment">//插入新的小木板</span><span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;<span class="keyword">while</span>(s.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;<span class="type">long</span> <span class="type">long</span> x=*s.<span class="built_in">begin</span>();s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());<span class="type">long</span> <span class="type">long</span> y=*s.<span class="built_in">begin</span>();s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());s.<span class="built_in">insert</span>(x+y);sum+=x+y;&#125;cout&lt;&lt;sum&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20221203 | SCZ-QZS 模拟赛 T5</title>
      <link href="/archives/20221203_SCZ_QZS_T5/"/>
      <url>/archives/20221203_SCZ_QZS_T5/</url>
      
        <content type="html"><![CDATA[<p>题意很明确了，大意就是一棵树，染色，距离 $\le 2$ 不得染同色，问染色方案。</p><p>首先我们要明确，距离 $\le 2$，具体是什么情况呢？</p><p>显然，分两个大类：</p><ul><li><p>一条链往下</p><ul><li>某节点和它的儿子</li><li>某节点和它的孙子</li></ul></li><li><p>非一条链往下</p><ul><li>某节点和它的兄弟</li></ul></li></ul><p>那么我们就梳理出了 $3$ 中不能涂同一种颜色的情况。</p><p>读到这里，我想应该正解慢慢出来了。</p><p>其次我们要知道，总染色方案就是每个点染色方案之积。</p><p>那么每个点最初有 $k$ 种选择，我们看一下它是否存在爷爷，若存在最多只有 $k-2$ 种，因为有爷爷必然有爸爸。</p><p><strong>一条链往下</strong>的方案已经考虑完了，接下来考虑兄弟。</p><p>兄弟就很简单了，记一个变量，自己的父亲每往下搜索一次加一，既能得到兄弟的个数。</p><p>详情见代码。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> p=<span class="number">1000000007</span>;<span class="type">int</span> n,k,u,v;<span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;<span class="comment">//十年OI一场空，不开long long见祖宗</span><span class="type">bool</span> vis[<span class="number">100020</span>];vector&lt;<span class="type">int</span>&gt;a[<span class="number">100020</span>];<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tmp)</span><span class="comment">//u表示目前节点 tmp表示当前节点涂色数量</span></span><span class="function"></span>&#123;ans*=tmp;<span class="comment">//乘上方案数</span>ans%=p;<span class="comment">//十年OI一场空，忘记取模见祖宗</span>vis[u]=<span class="number">1</span>;<span class="comment">//遍历基本操作，也可以记录father</span><span class="type">int</span> cnt=<span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">auto</span> v:a[u])&#123;<span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;<span class="type">int</span> w=(u==<span class="number">1</span>?k<span class="number">-1</span>:k<span class="number">-2</span>);<span class="comment">//如果是自己根，自己的儿子没有爷爷，反之肯定有爷爷</span>    <span class="comment">//上一条语句也可以写成dfs多带个dep参数，记录深度</span>w-=cnt;<span class="comment">//去除自己的兄弟所要染色的情况</span><span class="built_in">dfs</span>(v,w);<span class="comment">//继续搜索</span>cnt++;<span class="comment">//兄弟+1</span>&#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);a[u].<span class="built_in">push_back</span>(v);a[v].<span class="built_in">push_back</span>(u);        <span class="comment">//建边基本操作，也可以单向</span>&#125;<span class="built_in">dfs</span>(<span class="number">1</span>,k);<span class="comment">//开始搜索</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(<span class="type">int</span>)ans);<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[游记] CSP 2022 &amp; NOIP 2022 游记</title>
      <link href="/archives/CSP2022/"/>
      <url>/archives/CSP2022/</url>
      
        <content type="html"><![CDATA[<h2 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h2><h3 id="Day-4"><a href="#Day-4" class="headerlink" title="Day -4"></a>Day -4</h3><p>好耶，逃了信息课去基房四练初赛！</p><p>看了一遍 <a href="https://www.luogu.com.cn/blog/334586/csp-pre-knowledge">159号程序员</a> 的日报，认真刷了一点数学题，感觉差不多了。</p><h3 id="Day-3"><a href="#Day-3" class="headerlink" title="Day -3"></a>Day -3</h3><p>晚自习做了套 tg 组卷子，$69$，感觉过初赛还算稳……？</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h3><p>考前一天还要 whk，呜呜呜想哭。</p><p>下午去学校的基房<del>搞基</del>做了套 pj 组的初赛卷子。$79.5$，最高 $80.5$ 还可以吧……？</p><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>$$Morning$$</p><p>早上睡了个懒觉（？</p><p><del>七点多起不算太晚</del></p><p>然后就到考场 main 基去了。</p><p>重点得看考卷（</p><p>我【】你【】的 €€£，【】有向联通是强连通还是弱联通啊，这都不说的吗？？？</p><p>我【】你【】的 €€£，【】你不给子串定义还好，说了连续<strong>字母</strong>我【】反而没算空串！！！</p><p>pj 貌似只有选择有槽点。</p><p>感觉 pj 要寄了。</p><p>$$afternoon$$</p><p>tg 终于和 byx、cfz、cjy、byx 等巨佬在一起了！</p><p>重点得看考卷（</p><p>我【】你【】的 €€£，【】宇宙射线是个什么鬼？？？出题人脑子被宇宙射线射傻了吧？？？宇宙射线什么时候带出题人的马走啊？？？</p><p>预估明年题目：</p><pre><code class="highlight">射线拦截射线的冰雪小屋射线杀射线棋射线在干什么？有没有空？可以来拯救吗？五彩斑斓的射线找啊找啊找射线射线+线射 Problem射线的修炼合并射线</code></pre><p>我【】你【】的 €€£，【】期末作业是个什么鬼？？？【】的两人做作业六个摆烂？？？</p><p>我【】你【】的 €€£，【】<code>for(int j=0;j&lt;n;j*=2)</code> 是个什么鬼？？？【】的死循环求复杂度是吧，$\Theta(\infty)$？？？</p><p>我【】你【】的 €€£，【】$O()$ 是个什么鬼？？？【】的我都知道复杂度的记号不能这么写！！！</p><p>tg 槽点真【】多。</p><p>感觉 tg 要寄了。</p><p>$$evening$$</p><p>写游记去了。</p><p>总结：这场是练习找茬能力的。</p><h2 id="复赛"><a href="#复赛" class="headerlink" title="复赛"></a>复赛</h2><h3 id="Day-3-1"><a href="#Day-3-1" class="headerlink" title="Day -3"></a>Day -3</h3><p>CCF 取消了 JS 的 CSP！！！</p><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h3><p>CCF 恢复了 JS 的 CSP！！！</p><p>上个课间还在讨论 CCF 的父母身体健康，下个课间整个教学楼的 OIer 都沸腾了。</p><p>因为是做完核酸通知的，还要做核酸。</p><p>不过，我们班参加第二轮有五个，四个正好轮到今天核酸。</p><p>可怜的 GPD 巨佬被老师单独拉走<del>去小黑屋反省</del>出学校去做核酸。</p><h3 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day -1"></a>Day -1</h3><p>模考终于考完了。</p><p>模考废了。</p><p>CSP 别废。</p><h3 id="Day-0-1"><a href="#Day-0-1" class="headerlink" title="Day 0"></a>Day 0</h3><p>CSP 啦！</p><p>在地铁上偶遇 WJC 巨佬<del>但教练说膜拜巨佬 rp 会被巨佬吸去所以不敢膜拜。</del></p><p>提前进了 scz 又遇到一堆巨佬。</p><p><del>如何评价 wjl 在 scz 门口大喊 sxy 我爱你。</del></p><p>进 pj 考场了。</p><p>坐了好久<del>没发现 scz 电脑的扫雷。</del></p><p>但为啥八点半考八点二十五发题？</p><p>算了不管了。</p><p>还眼瞎没找到 README，但我记得去年在 NJ 好像直接在桌面，结果这次在 JSOI 系统上。</p><p>看题第一眼：</p><p>T1 快速幂。</p><p>T2 一元二次方程。</p><p>T3 大模拟。</p><p>T4 不知道。</p><p>第二眼：</p><p>T1 特判。</p><p>T2 一元二次石锤，<del>但我不会怎么办</del>。</p><p>T3 大模拟。</p><p>T4 不知道。</p><p>T1一开始写了个奇奇怪怪的，大概是 $10^9$ 的时候数据过大，拆成 $10^2\times 10^7$，先算 $a^{b\div 100}$，再乘 $100$ 次。</p><p>在最后几分钟玩机房的 Python 才发现特判就能过。</p><p>T2 在切完 T1 3min 后想出正解一元二次方程。但我不会解，写了个奇奇怪怪的二分一直挂，换上了暴力。</p><p>寄。</p><p>T3 数据分治了一下特殊情况，不知道为什么自测分数很低。</p><p>T4 不会，针对 $k&#x3D;0$ 写了个类似并查集的东西，把每个点的贡献集体加到这一组的某个点上，但也挂了。</p><p>考完出来被小五 IOIAKer XYC 吊打了一番，和巨佬一起去天语雅阁吃了个饭。</p><p>下午 tg，小学生参赛有，但 XYC 应该是最小的。</p><p><del>如何评价 XYC 巨佬忽悠高中生不要写 freopen。</del></p><p>提高也提前五分钟发了卷子。</p><p>拿到手，一眼丁真三道图论一道 DS。</p><p>T1 一眼最短路，数据范围表明 $n^2$ 复杂度，我写了个 $\mathcal O(n^2)$ 对每个点 bfs 一下到其他点换几次，然后跑 $\mathcal O(n^4)$ 算答案。</p><p>期望得分 $20\ \tt{pts}$，但自测上了 $70$。</p><p>应该是优化的功劳</p><p>T2 一眼 DS，考完听说正解是 ST 表，赛时没想到，写了个数据分治，$\leq 1000$ 跑暴力，$&gt; 1000$ 写了个不知道对不对的线段树。</p><p>期望得分 $[0,75]\ \tt{pts}$，自测只有 $20$ 挺离谱。</p><p>T3 针对小数据写了暴力，期望得分 $[15,40]\ \tt{pts}$，自测也差不多 $40$。</p><p>但考完听说是诈骗不是图论，很迷。</p><p>T4 摆了。</p><p>感觉这把 tg 打得还行吧，自测 $130$ 左右，实际可能往上一点。听说蓝勾 $150$ 左右，感觉很悬没机会了。但还是祈祷 CCF 数据多给点分吧。</p><h2 id="NOIp"><a href="#NOIp" class="headerlink" title="NOIp"></a>NOIp</h2><h3 id="Day-9"><a href="#Day-9" class="headerlink" title="Day -9"></a>Day -9</h3><p>CSP 出分了&#x2F;hsh</p><p>两组都是因为赛场脑残挂分，痛失双国一，痛失 J 和 S 的前 $20%$……</p><p>也因为挂分，S 没达到 NOIp 参赛线。</p><p>呜呜呜就差一个 T2 的 <code>LLONG_MAX</code> 写成了 <code>INT_MAX</code>！</p><p> 但晚自习的时候，教练讲，因为今年 NOIp 在 CZ 有考场，我们学校所有提高非 $0$ 分都能去！</p><p>耶~</p><h3 id="Day-8"><a href="#Day-8" class="headerlink" title="Day -8"></a>Day -8</h3><p>很不理解为什么班歌大赛班主任让我在台上跳舞。</p><p>同时为什么公开处刑我 S 组省内 rk.300+ 这个糗事啊！我连目标两组都前 $20%$ 都没达到诶！</p><h3 id="Day-1-2"><a href="#Day-1-2" class="headerlink" title="Day -1"></a>Day -1</h3><p>班歌大赛去世了。</p><p>带了墨镜，怎么还全认出我了啊啊啊！！！</p><h3 id="Day-0-2"><a href="#Day-0-2" class="headerlink" title="Day 0"></a>Day 0</h3><p>早起。困。</p><p>到了门口还要做核酸诶。</p><p>去的时候已经有两位巨佬在了，我们交换了食物。<del>巧克力换巧克力等于没换啊喂</del></p><p>等了一会儿，凑齐了我们常外这届初一的 $7$ 位巨佬和我一个蒟蒻。</p><p>带队的老师带我们去机房，但我感觉好像和 CSP 去的路线不太一样……？</p><p>果然，那个楼道被锁了。几十个人被困在了楼道困了 $15\ \tt{min}$。</p><p>真的服了啊！</p><p>然后几位高中生找到了去机房的路，说要带我们去，正要<del>省常中 OIer 起义</del>时，带队老师来了，带我们走了出去。</p><p>NOIp 游记 $\to$ 省常中楼道游寄。</p><p>终于到了机房，不容易啊。</p><p>敲了个缺省源，写了个对拍器，但八点半都过了为什么不发题？？？</p><p><del>哦，原来是特派员去问官方，官方数据人跳出来说“不可以，特派员”。</del></p><p>拿到手，全都不会。</p><p>T1 写了一个多小时，$\mathcal O(n^2m)$ 的写法，后来想到了一点优化，但我很快就想出一种卡死优化的方法，没写。</p><p>预估 $70+\ \tt{pts}$，结果特判数据 $1$ 时，输出完 <code>0 0</code> 没有退出，又跑了后面的，寄。</p><hr><p>出考场的我：</p><p>“这次 T1 谁第一个测试点不 AC 我笑话谁一百年。”</p><hr><p>T2 没写。</p><p>T3 写了个一条链的部分分，对着小数据推的公式，但大数据好像过不了，寄。</p><p>T3 我还为了 $n\leq3,m\leq8$ 的点写了 $200$ 行代码，没调完，我到死都不知道没建边是怎么搜索搜到那里的。</p><p>T4 写了暴力，预估 $8\ \tt{pts}$，这个还是有信心拿到的。</p><p>现在估分可能一共只有 $[77,80]\ \tt{pts}$。</p><hr><p><img src="https://s1.ax1x.com/2022/11/27/zU8eAS.png"></p>]]></content>
      
      
      <categories>
          
          <category> TravelNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] 20220810 | CSP2021-J</title>
      <link href="/archives/20220810_CSPJ2021/"/>
      <url>/archives/20220810_CSPJ2021/</url>
      
        <content type="html"><![CDATA[<h4 id="分糖果"><a href="#分糖果" class="headerlink" title="分糖果"></a>分糖果</h4><p>分类讨论。</p><p>讨论一下三种情况。</p><p>不细说了，很简单，送分。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;candy.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;candy.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);<span class="type">int</span> n,l,r;cin&gt;&gt;n&gt;&gt;l&gt;&gt;r;<span class="keyword">if</span>(l%n&lt;=r%n)&#123;<span class="keyword">if</span>(r-l&lt;n)&#123;cout&lt;&lt;r%n&lt;&lt;endl;&#125;<span class="keyword">else</span>&#123;cout&lt;&lt;n<span class="number">-1</span>&lt;&lt;endl;&#125;&#125;<span class="keyword">else</span> &#123;cout&lt;&lt;n<span class="number">-1</span>&lt;&lt;endl;&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>暴力想法（大约 $70\ pts$）</p><p>对于每次操作，去找一遍大小关系 $\mathcal O(n)$ 得到位置。</p><p>满分想法（$100\ pts$）</p><p>考虑到 $1$ 操作很少，只有 $5000$，那么对每个一操作，$\mathcal  O(n)$ 修改数字的位置。数字位置只要看和当前要更改的数字比一下，加一减一即可。</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">int</span> a[<span class="number">8020</span>];<span class="type">int</span> b[<span class="number">8020</span>];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;sort.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;sort.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);<span class="type">int</span> n,q;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;b[i]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;<span class="keyword">if</span>(a[j]&lt;=a[i])b[i]++;&#125;<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;j++)&#123;<span class="keyword">if</span>(a[j]&lt;a[i])b[i]++;&#125;&#125; <span class="keyword">while</span>(q--)&#123;<span class="type">int</span> op;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;<span class="type">int</span> x,v;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;v);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;x;i++)&#123;<span class="keyword">if</span>(a[i]&lt;=a[x]&amp;&amp;v&lt;a[i])&#123;b[i]++;b[x]--;&#125;<span class="keyword">if</span>(a[i]&gt;a[x]&amp;&amp;v&gt;=a[i])&#123;b[i]--;b[x]++;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=x<span class="number">+1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(a[i]&lt;a[x]&amp;&amp;v&lt;=a[i])&#123;b[i]++;b[x]--;&#125;<span class="keyword">if</span>(a[i]&gt;=a[x]&amp;&amp;v&gt;a[i])&#123;b[i]--;b[x]++;&#125;&#125;a[x]=v;&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;<span class="type">int</span> x,ans=<span class="number">1</span>;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b[x]);&#125;&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h4><p>模拟题。</p><p>按题意先处理字符串即可。</p><p>处理之后判断是否合法。</p><p>合法再分两种情况：</p><ul><li><p>服务机</p><ul><li><p>有同 ip 的服务机了</p><p><code>FAIL</code></p></li><li><p>没有<br><code>OK</code>，并且自己占位置。</p></li></ul></li><li><p>客户机</p><ul><li><p>没有同 ip 的服务机</p><p><code>FAIL</code></p></li><li><p>有<br>输出服务机编号。</p></li></ul></li></ul><p>之后，我们只需要考虑怎么把字符串类型映射到一个数字（服务机编号）上。</p><p>诶，map 的翻译就叫映射。</p><p>你，懂了吗？</p><p><del>不懂评论或百度，谢谢</del></p><p>再说几个细节：</p><ol><li>特判前导零</li><li>单独的零不算前导零</li><li>可能 ip 地址分割数字的字符不一定是按 <code>. . . . :</code> 排。</li></ol><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">s_to_i</span><span class="params">(string s)</span></span><span class="function"></span>&#123;<span class="type">int</span> ret=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;ret=ret*<span class="number">10</span>+(s[i]-<span class="string">&#x27;0&#x27;</span>);&#125;<span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">bool</span> <span class="title">all_digit</span><span class="params">(string s)</span></span><span class="function"></span>&#123;<span class="type">bool</span> ret=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;<span class="keyword">if</span>(!<span class="built_in">isdigit</span>(s[i]))ret=<span class="number">0</span>;&#125;<span class="keyword">return</span> ret;&#125;<span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string s)</span></span><span class="function"></span>&#123;<span class="type">int</span> i=<span class="number">0</span>;string a,b,c,d,e;a=b=c=d=e=<span class="string">&quot;&quot;</span>;<span class="keyword">for</span>(;i&lt;s.<span class="built_in">size</span>();i++)&#123;<span class="keyword">if</span>(s[i]==<span class="string">&#x27;.&#x27;</span>)&#123;i++;<span class="keyword">break</span>;&#125;a+=s[i];&#125;<span class="keyword">for</span>(;i&lt;s.<span class="built_in">size</span>();i++)&#123;<span class="keyword">if</span>(s[i]==<span class="string">&#x27;.&#x27;</span>)&#123;i++;<span class="keyword">break</span>;&#125;b+=s[i];&#125;<span class="keyword">for</span>(;i&lt;s.<span class="built_in">size</span>();i++)&#123;<span class="keyword">if</span>(s[i]==<span class="string">&#x27;.&#x27;</span>)&#123;i++;<span class="keyword">break</span>;&#125;c+=s[i];&#125;<span class="keyword">for</span>(;i&lt;s.<span class="built_in">size</span>();i++)&#123;<span class="keyword">if</span>(s[i]==<span class="string">&#x27;:&#x27;</span>)&#123;i++;<span class="keyword">break</span>;&#125;d+=s[i];&#125;<span class="keyword">for</span>(;i&lt;s.<span class="built_in">size</span>();i++)&#123;e+=s[i];&#125;<span class="keyword">if</span>(a!=<span class="string">&quot;&quot;</span>&amp;&amp;b!=<span class="string">&quot;&quot;</span>&amp;&amp;c!=<span class="string">&quot;&quot;</span>&amp;&amp;d!=<span class="string">&quot;&quot;</span>&amp;&amp;e!=<span class="string">&quot;&quot;</span>)&#123;<span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;a!=<span class="string">&quot;0&quot;</span>||b[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;b!=<span class="string">&quot;0&quot;</span>||c[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;c!=<span class="string">&quot;0&quot;</span>||d[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;d!=<span class="string">&quot;0&quot;</span>||e[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;e!=<span class="string">&quot;0&quot;</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="keyword">if</span>(<span class="built_in">all_digit</span>(a)&amp;&amp;<span class="built_in">all_digit</span>(b)&amp;&amp;<span class="built_in">all_digit</span>(c)&amp;&amp;<span class="built_in">all_digit</span>(d)&amp;&amp;<span class="built_in">all_digit</span>(e))&#123;<span class="keyword">if</span>(a.<span class="built_in">size</span>()&lt;=<span class="number">3</span>&amp;&amp;b.<span class="built_in">size</span>()&lt;=<span class="number">3</span>&amp;&amp;c.<span class="built_in">size</span>()&lt;=<span class="number">3</span>&amp;&amp;d.<span class="built_in">size</span>()&lt;=<span class="number">3</span>&amp;&amp;e.<span class="built_in">size</span>()&lt;=<span class="number">5</span>)&#123;<span class="type">int</span> aa=<span class="built_in">s_to_i</span>(a),bb=<span class="built_in">s_to_i</span>(b),cc=<span class="built_in">s_to_i</span>(c),dd=<span class="built_in">s_to_i</span>(d),ee=<span class="built_in">s_to_i</span>(e);<span class="keyword">if</span>(<span class="number">0</span>&lt;=aa&amp;&amp;aa&lt;=<span class="number">255</span> &amp;&amp; <span class="number">0</span>&lt;=bb&amp;&amp;bb&lt;=<span class="number">255</span> &amp;&amp; <span class="number">0</span>&lt;=cc&amp;&amp;cc&lt;=<span class="number">255</span> &amp;&amp; <span class="number">0</span>&lt;=dd&amp;&amp;dd&lt;=<span class="number">255</span> &amp;&amp; <span class="number">0</span>&lt;=ee&amp;&amp;ee&lt;=<span class="number">65535</span>)&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;map&lt;string,<span class="type">int</span>&gt;m;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="built_in">freopen</span>(<span class="string">&quot;network.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="built_in">freopen</span>(<span class="string">&quot;network.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);<span class="type">int</span> n;cin&gt;&gt;n;string s,t;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;s&gt;&gt;t;<span class="keyword">if</span>(!<span class="built_in">check</span>(t))&#123;<span class="built_in">puts</span>(<span class="string">&quot;ERR&quot;</span>);<span class="keyword">continue</span>; &#125;<span class="keyword">if</span>(s==<span class="string">&quot;Server&quot;</span>)&#123;<span class="keyword">if</span>(m[t]!=<span class="number">0</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;FAIL&quot;</span>);&#125;<span class="keyword">else</span>&#123;m[t]=i;<span class="built_in">puts</span>(<span class="string">&quot;OK&quot;</span>);&#125;&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">&quot;Client&quot;</span>)&#123;<span class="keyword">if</span>(m[t]==<span class="number">0</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;FAIL&quot;</span>);&#125;<span class="keyword">else</span>&#123;cout&lt;&lt;m[t]&lt;&lt;endl;&#125;&#125;&#125; <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="小熊的果篮"><a href="#小熊的果篮" class="headerlink" title="小熊的果篮"></a>小熊的果篮</h4><p>先咕着</p><pre><code class="highlight cpp">害嗨嗨</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[游记] JSOI 2022 游记</title>
      <link href="/archives/JSOI2022/"/>
      <url>/archives/JSOI2022/</url>
      
        <content type="html"><![CDATA[<p>JSOI&#x3D;信息与未来，非 JS 省选。</p><h3 id="2022-7-15"><a href="#2022-7-15" class="headerlink" title="2022.7.15"></a>2022.7.15</h3><p>群里早就约好了面基时间地点，还有一天就面基啦！</p><h3 id="2022-7-16"><a href="#2022-7-16" class="headerlink" title="2022.7.16"></a>2022.7.16</h3><p>九点半出了地铁。</p><p>九点四十就开始排队了，大家太积极了。</p><p>等了半个多小时，捕捉了一只野生 cyc。</p><p>PS：可惜了，几年前的手机拍照延迟过高，大头照没拍到几张清楚的。</p><p>又过了一会儿，同班同学也来了。</p><p>可惜我们<a href="https://www.luogu.com.cn/user/400269">珂爱的佳雨小姐姐</a>上午在家内卷写作业呢，下午才来。</p><p><a href="https://www.luogu.com.cn/user/556205">IOIAKer Public</a>也有课，中午才能main&#x2F;kk。</p><p>中午去吃了个饭，<del>顺便玩了一会儿 pie.ai。</del></p><p>吃完饭就进去了呢。</p><p>一起坐在休息室，也就是 scz 的阶梯教室。</p><p>又 main 到了 IOIAKer Public 和 佳雨小姐姐还有 <a href="https://www.luogu.com.cn/user/426624">神犇lzx</a> 以及 <a href="https://www.luogu.com.cn/user/525255">CZOI rk.1 柏巨佬</a>。</p><p>还有好多好多初次 main 到的。</p><p>main 完就比赛了 QwQ。</p><p>P1：一眼丁真，鉴定为数位 dp。（但其实数据规模不大，只是个暴力。</p><p>P2：一眼丁真，鉴定为搜索基础题。（就我 dfs 出错改 bfs，别人咋又暴力过了。</p><p>P3：一眼丁真，鉴定为双指针。（虽然我想到了一种能卡掉我想法的数据。</p><p>P4：一眼丁真，鉴定为我不会的东西。（但我瞎写写出了 12pts&#x2F;jk。</p><p>P5：一眼丁真，鉴定为我不会的东西。（交互+mathler，WC2022T3 复现了属于是。</p><p>P6：一眼丁真，鉴定为我不会的东西。（输出俄罗斯方块摆放位置以通关，真毒瘤！<del>最后两分钟交代码，没编译就交了结果少打一个分号 CE&#x2F;kk</del>。</p><p>最终得分：15pts+15pts+12pts+12pts+2pts+0pts，合计 56pts。</p><p>还好别人赛前问我和第一能差多少分，我说肯定不超过 50pts，<del>但 tm 谁知道 zxx 还能 ak 啊</del>，差了 44pts，差点真差了 50pts。</p><h3 id="2022-7-17"><a href="#2022-7-17" class="headerlink" title="2022.7.17"></a>2022.7.17</h3><p>中午出成绩了。</p><p>全市第四，但按 NJ 的水准，排二十多个去了。</p><p>我就是个废物。</p>]]></content>
      
      
      <categories>
          
          <category> TravelNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC061C Big Array</title>
      <link href="/archives/ABC061C/"/>
      <url>/archives/ABC061C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>$n$ 次操作，每次两个数 $a_i,b_i$，在一个初始为空的序列里插入 $b_i$ 个 $a_i$，操作结束后问第 $k$ 小是什么。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>类似于 <a href="https://atcoder.jp/contests/abc247/tasks/abc247_d">ABC247D</a> 的写法，还是个弱化版。</p><p>我们不用真的插入 $b_i$ 个 $a_i$，只需记录 $b_i$ 有多少即可，因为很多的数都用不到。</p><p>这是很多个一添，同理，我们可以很多个一删。</p><p>所以我们用一个 <code>pair</code> 记录两个量，<strong>数字</strong>和<strong>次数</strong>。</p><p>然后按数字的大小排序，最后遍历数组，每次用 $k$ 减掉出现次数，如果此时 $k\leqslant0$，那么就输出当前数字。</p><p>注意，$k$ 最大可以为 $100000^2$，那么开好 <code>long long</code>。</p><p>我因为这个错了一次……</p><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">using</span> <span class="keyword">namespace</span> std;vector&lt;pair&lt;ll,ll&gt;&gt;v;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;ll n,k;cin&gt;&gt;n&gt;&gt;k;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;v.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(a,b));<span class="comment">//插入数字和次数</span>&#125;<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());<span class="comment">//pair的排序默认先看first，也就是此题中的数字的大小</span><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="type">int</span>)v.<span class="built_in">size</span>();i++)&#123;k-=v[i].second;<span class="comment">//减掉出现次数</span><span class="keyword">if</span>(k&lt;=<span class="number">0</span>)&#123;cout&lt;&lt;v[i].first&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//&lt;=0时，输出当前数字。</span>&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF727C Guess the Array</title>
      <link href="/archives/CF727C/"/>
      <url>/archives/CF727C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>一个长度为 $n$ 的数组，最多 $n$ 次询问，输出数组元素。</p><p>询问：每次输出 <code>? x y</code>，返回 $x+y$ 的值。</p><p>输出：输出 <code> !</code> 之后空一格，正常输出数组元素。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>小学数学知识。</p><p>我们先询问 $x+y$ 的值，在询问 $x+z$ 的值，最后询问 $y+z$ 的值。</p><p>恰好每个数出现两次，把总和除以二，得到 $x+y+z$。</p><p>知道三数总和，知道两两之和，相减求 $3$ 个数的值。</p><p>接着处理余下的数。</p><p>整除 $3$，输出。</p><p>余 $2$，查询两个数的和，在随机找一个数搭配算出来。</p><p>余 $1$，随便找数搭配算。</p><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="type">int</span> a[n<span class="number">+1</span>];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-n%<span class="number">3</span>;i+=<span class="number">3</span>)<span class="comment">//先3个一组解决</span>&#123;<span class="type">int</span> x,y,z;cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i<span class="number">+2</span>&lt;&lt;endl;<span class="built_in">fflush</span>(stdout);cin&gt;&gt;x;cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i<span class="number">+1</span>&lt;&lt;endl;<span class="built_in">fflush</span>(stdout);cin&gt;&gt;y;cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;i<span class="number">+1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i<span class="number">+2</span>&lt;&lt;endl;<span class="built_in">fflush</span>(stdout);cin&gt;&gt;z;<span class="type">int</span> sum=x+y+z;sum/=<span class="number">2</span>;a[i<span class="number">+1</span>]=sum-x;a[i<span class="number">+2</span>]=sum-y;a[i]=sum-z;&#125;    <span class="comment">//解决剩下的</span><span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">2</span>)&#123;cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;n&lt;&lt;endl;<span class="built_in">fflush</span>(stdout);<span class="type">int</span> x,y;cin&gt;&gt;x;cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;n&lt;&lt;endl;<span class="built_in">fflush</span>(stdout);cin&gt;&gt;y;a[n]=y-a[<span class="number">1</span>];a[n<span class="number">-1</span>]=x-a[n];&#125;<span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">1</span>)&#123;cout&lt;&lt;<span class="string">&quot;? 1 &quot;</span>&lt;&lt;n&lt;&lt;endl;<span class="built_in">fflush</span>(stdout);<span class="type">int</span> x;cin&gt;&gt;x;a[n]=x-a[<span class="number">1</span>];&#125;cout&lt;&lt;<span class="string">&quot;! &quot;</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;&#125;</code></pre><p>不知道交互题怎么解决，看<a href="https://www.luogu.com.cn/problem/P1947">P1947</a>和<a href="https://www.luogu.com.cn/problem/P1733">P1733</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1656B Subtract Operation</title>
      <link href="/archives/CF1656B/"/>
      <url>/archives/CF1656B/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>有 $n$ 个数，每次选一个删掉，其他数都减去删掉的数，问最后一个数会不会等于 $k$。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这题一看就是结论题。我们先把 $a$ 数组假设为删除数字顺序定下来的数组，看最后结果。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xhqaiz6i.png"></p><p>上述过程每步已经化简。</p><p>那么，很容易看出，最后答案是两个数的差。</p><p>这题便成为了：$n$ 个数里，是否有两个数字差为 $k$。</p><p>那么我想到是用 <code>map</code> 和 <code>set</code> 做。</p><p><code>map</code> 没访问的位置便不存在，不担心 RE，<code>set</code> 自带 <code>count</code> 找出现次数。</p><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;set&lt;ll&gt;s;s.<span class="built_in">clear</span>();ll n,k;cin&gt;&gt;n&gt;&gt;k;<span class="type">bool</span> f=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;ll x;cin&gt;&gt;x;s.<span class="built_in">insert</span>(x);<span class="keyword">if</span>(s.<span class="built_in">count</span>(x-k)||s.<span class="built_in">count</span>(x+k))<span class="comment">//差值为k，可能x是较大数，也可能是较小数。</span>&#123;f=<span class="number">1</span>;&#125;&#125;<span class="built_in">puts</span>(f==<span class="number">1</span>?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> t;cin&gt;&gt;t;<span class="keyword">while</span>(t--)&#123;<span class="built_in">solve</span>();&#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;<span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;map&lt;ll,<span class="type">bool</span>&gt;mp;mp.<span class="built_in">clear</span>();ll n,k;cin&gt;&gt;n&gt;&gt;k;<span class="type">bool</span> f=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;ll x;cin&gt;&gt;x;mp[x]=<span class="number">1</span>;<span class="keyword">if</span>(mp[x-k]||mp[x+k])&#123;f=<span class="number">1</span>;&#125;&#125;<span class="built_in">puts</span>(f==<span class="number">1</span>?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> t;cin&gt;&gt;t;<span class="keyword">while</span>(t--)&#123;<span class="built_in">solve</span>();&#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] P8197 [传智杯 #4 决赛] 排排队</title>
      <link href="/archives/P8197/"/>
      <url>/archives/P8197/</url>
      
        <content type="html"><![CDATA[<h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>从交换相邻这里，我们可以明显看出来，这有些类似冒泡排序。</p><p>但是，我们要来思考一下怎样情况输出 <code>NO</code>。</p><p>我们就用冒泡排序的代码来分析一下。为了方便分析，就用 <code>for</code> 循环版的。</p><pre><code class="highlight cpp"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n-i;j++)&#123;<span class="keyword">if</span>(a[j]&lt;a[j<span class="number">+1</span>])&#123;<span class="built_in">swap</span>(a[j],a[j<span class="number">+1</span>]);&#125;&#125;&#125;</code></pre><p>我们能很快的反应出来，$(n-1)\times (n-i)$ 肯定是比 $n^2$ 要小的。</p><p>所以，$n^2$ 的操作绰绰有余。</p><p>因此，我们只要判断数组元素是否相同就可以了，不用考虑能否在 $n^2$ 次操作内完成。</p><p>我们先写出判断一样的代码。</p><pre><code class="highlight cpp"><span class="type">int</span> n=<span class="built_in">read</span>();<span class="type">int</span> a[n<span class="number">+1</span>],b[n<span class="number">+1</span>],c[n<span class="number">+1</span>],d[n<span class="number">+1</span>];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];c[i]=a[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;b[i];d[i]=b[i];&#125;<span class="built_in">sort</span>(c<span class="number">+1</span>,c+n<span class="number">+1</span>);<span class="built_in">sort</span>(d<span class="number">+1</span>,d+n<span class="number">+1</span>);<span class="comment">//因为不能打乱ab数组，就用别的数组代替。如果排序后一模一样，里面元素也一样。</span><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(c[i]!=d[i])&#123;<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);<span class="keyword">return</span>;&#125;<span class="comment">//判断ab数组元素是否相同</span>&#125;</code></pre><p>接着，如果可以构造出来，我们就可以每次确定一个数的位置，最后就能创造出来。</p><pre><code class="highlight cpp"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//循环b的元素</span>&#123;<span class="type">int</span> x;<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;<span class="keyword">if</span>(a[j]==b[i])&#123;x=j;<span class="comment">//找位置</span><span class="keyword">break</span>;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> j=x;j&gt;i;j--)<span class="comment">//交换</span>&#123;<span class="built_in">swap</span>(a[j],a[j<span class="number">-1</span>]);cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;j<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;&#125;&#125;cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</code></pre><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);ch=<span class="built_in">getchar</span>();&#125;<span class="keyword">return</span> x*f;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n=<span class="built_in">read</span>();<span class="type">int</span> a[n<span class="number">+1</span>],b[n<span class="number">+1</span>],c[n<span class="number">+1</span>],d[n<span class="number">+1</span>];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];c[i]=a[i];&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;b[i];d[i]=b[i];&#125;<span class="built_in">sort</span>(c<span class="number">+1</span>,c+n<span class="number">+1</span>);<span class="built_in">sort</span>(d<span class="number">+1</span>,d+n<span class="number">+1</span>);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">if</span>(c[i]!=d[i])&#123;<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);<span class="keyword">return</span>;&#125;&#125;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> x;<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)<span class="comment">//这里赛时写错过了，事后被同学 hack 了 QwQ</span>&#123;<span class="keyword">if</span>(a[j]==b[i])&#123;x=j;<span class="keyword">break</span>;&#125;&#125;<span class="keyword">for</span>(<span class="type">int</span> j=x;j&gt;i;j--)&#123;<span class="built_in">swap</span>(a[j],a[j<span class="number">-1</span>]);cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;j<span class="number">-1</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;&#125;&#125;cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> t=<span class="built_in">read</span>();<span class="keyword">while</span>(t--)&#123;<span class="built_in">solve</span>();&#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1648A Weird Sum</title>
      <link href="/archives/CF1648A/"/>
      <url>/archives/CF1648A/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>一个 $n\times m$ 的网格，每个格子里有 $1$ 个数，问对于所有相同的数，曼哈顿距离总和是多少？</p><p>曼哈顿距离：$a_{i_1,j_1}$ 与 $a_{i_2,j_2}$ 距离为 $\left|i_1-i_2\right|+\left|j_1-j_2\right|$。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>暴力搜一遍，肯定挂掉，$n\times m$ 有 $100000$。</p><p>所以，我们对每种数进行分类，每一类再分成 $x$ 轴的总距离求和加上 $y$ 轴的总距离求和。</p><p>这是蒟蒻我能想到的最优解了。</p><h3 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h3><p>那么总距离求和该怎么做呢，例如上文的 $x$ 轴的总距离求和。</p><p>我们考虑把它们排序，放在一根数轴上。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4x536hgp.png"></p><p>我们以端点为 $i_2$ 和 $i_3$ 的线段做例子：</p><p>本身长度 $2$。</p><p>往右边走，有 $i_3,i_4,i_5$，产生 $3$ 次贡献。</p><p>左边每个点都可以与上面 $3$ 个点产生连接，左边有 $2$ 个点，$i_1$ 和 $i_2$。</p><p>注意，线段的两个端点也算进去。</p><p>那么这个线段产生<strong>左边端点个数 $\times$ 线段长度 $\times$ 右边端点个数</strong>这么多贡献。</p><p>同理，每个线段也产生上述贡献。</p><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="meta">#<span class="keyword">define</span> ll long long</span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> x,y;<span class="comment">//记录x轴和y轴</span>&#125;;vector&lt;node&gt;a[<span class="number">100020</span>];<span class="comment">//对数字分类</span><span class="function">ll <span class="title">s</span><span class="params">(vector&lt;<span class="type">int</span>&gt;a)</span><span class="comment">//求和</span></span><span class="function"></span>&#123;ll sum=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;sum+=i*(a[i]-a[i<span class="number">-1</span>])*(a.<span class="built_in">size</span>()-i);&#125;<span class="keyword">return</span> sum;&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,m,maxx=INT_MIN;cin&gt;&gt;n&gt;&gt;m;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;<span class="type">int</span> z;cin&gt;&gt;z;node zz;zz.x=i;zz.y=j;a[z].<span class="built_in">push_back</span>(zz);<span class="comment">//插入这个点信息</span>maxx=<span class="built_in">max</span>(z,maxx);<span class="comment">//找出最大值</span>&#125;&#125;ll sum=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxx;i++)&#123;vector&lt;<span class="type">int</span>&gt;xx;<span class="comment">//记录x轴</span>vector&lt;<span class="type">int</span>&gt;yy;<span class="comment">//记录y轴</span><span class="keyword">for</span>(<span class="keyword">auto</span> j:a[i])<span class="comment">//插入点的信息</span>&#123;xx.<span class="built_in">push_back</span>(j.x);yy.<span class="built_in">push_back</span>(j.y);&#125;        <span class="comment">//排序</span><span class="built_in">sort</span>(xx.<span class="built_in">begin</span>(),xx.<span class="built_in">end</span>());<span class="built_in">sort</span>(yy.<span class="built_in">begin</span>(),yy.<span class="built_in">end</span>());ll sx=<span class="built_in">s</span>(xx);ll sy=<span class="built_in">s</span>(yy);sum+=sx+sy;<span class="comment">//求和</span>&#125;cout&lt;&lt;sum&lt;&lt;endl;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> t=<span class="number">1</span>;<span class="keyword">while</span>(t--)&#123;<span class="built_in">solve</span>();&#125;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1646B Quality vs Quantity</title>
      <link href="/archives/CF1646B/"/>
      <url>/archives/CF1646B/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>我们对于 $n$ 个数 $a_1,a_2,…,a_n$，每个数可以选择标记为 <code>Red</code> 或 <code>Blue</code>。</p><p>对于颜色 $c$，<code>Count(c)</code> 表示颜色 $c$ 出现几次。</p><p>对于颜色 $c$，<code>Sum(c)</code> 表示标记为颜色 $c$ 的数字总和。</p><p>问是否存在 <code>Sum(Red)</code> $&gt;$ <code>Sum(Blue)</code> 且  <code>Count(Red)</code> $&lt;$  <code>Count(Blue)</code></p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>个人认为像贪心。</p><p>我们尽量让多的个数和少的个数差距缩小，最好为 $1$，再让多的个数全选小的，少的个数全选大的，最大程度缩小差距。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;ll a[n<span class="number">+5</span>];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];&#125;<span class="built_in">sort</span>(a<span class="number">+1</span>,a+n<span class="number">+1</span>);<span class="comment">//排序，更好区分大小</span>ll l=<span class="number">2</span>,r=n,sl=a[<span class="number">1</span>]+a[<span class="number">2</span>],sr=a[n];<span class="comment">//默认多的有两个，少的有一个，小的和默认为两个最小的，大的和默认一个最大的</span><span class="type">bool</span> f=<span class="number">0</span>;<span class="comment">//记录是否实现</span><span class="keyword">if</span>(sr&gt;sl)<span class="comment">//默认状态就实现，去输出</span>&#123;f=<span class="number">1</span>;<span class="keyword">goto</span> check;&#125;<span class="keyword">while</span>(l<span class="number">+2</span>&lt;r)<span class="comment">//每次左右都移一次，所以这里是+2</span>&#123;l++;r--;sl+=a[l];sr+=a[r];<span class="keyword">if</span>(sr&gt;sl)<span class="comment">//判断</span>&#123;f=<span class="number">1</span>;<span class="keyword">break</span>;&#125;&#125;check:;<span class="keyword">if</span>(f==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC105C Base -2 Number</title>
      <link href="/archives/ABC105C/"/>
      <url>/archives/ABC105C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>给定一个 $10$ 进制数，将其转变成 $-2$ 进制。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>和二进制一样短除法。</p><p>注意事项：</p><ul><li>特判数据 $n&#x3D;0$ ，不特判的话，它本身进入不了短除法代码，答案就没有记录</li><li>任何位置上不可能出现 $-1$，要转成 $1$ 输出。</li><li>短除法倒着输出。</li></ul><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span><span class="comment">//没加上快读快写、long long定义ll，防抄袭</span></span><span class="function"></span>&#123;<span class="type">int</span> a[<span class="number">105</span>];<span class="comment">//存储答案</span>ll n=<span class="built_in">read</span>();<span class="type">int</span> x=<span class="number">-1</span>;<span class="comment">//存储答案位数</span><span class="keyword">if</span>(n==<span class="number">0</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);<span class="keyword">return</span>;&#125;<span class="comment">//特判</span><span class="keyword">while</span>(n!=<span class="number">0</span>)<span class="comment">//短除法</span>&#123;a[++x]=n%(<span class="number">-2</span>);n/=(<span class="number">-2</span>);<span class="keyword">if</span>(a[x]==(<span class="number">-1</span>))<span class="comment">//注意事项栏</span>&#123;n++;a[x]=<span class="number">1</span>; &#125;&#125;<span class="built_in">reverse</span>(a,a+x<span class="number">+1</span>);<span class="comment">//倒着输出，翻转区间</span><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=x;<span class="built_in">write</span>(a[i++]));&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1644B Anti-Fibonacci Permutation</title>
      <link href="/archives/CF1644B/"/>
      <url>/archives/CF1644B/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>我们定义对于所有 $i$ ($3 \leq i \leq n$)， $p_{i-2}+p_{i-1} \ne p_i$  这样的数列称之为 <strong>反斐波那契数列</strong> ，给定一个 $n$ ，请输出 $n$ 个长度为 $n$ 的不同的反斐波那契数列。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>只要 $p_{i-2}$ 和 $p_{i-1}$ 中任意一个数大于 $p_i$ ，那么肯定为反斐波那契数列。</p><p>所以构造一个<strong>降序</strong>的数列，然后每次把最后一个数往前挪，肯定能构成一个反斐波那契数列。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="type">int</span> f=n;<span class="comment">//记录最小位置</span><span class="type">int</span> a[n<span class="number">+1</span>];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=n-i<span class="number">+1</span>;<span class="comment">//创造降序数组</span><span class="keyword">for</span>(<span class="type">int</span> nn=<span class="number">0</span>;nn&lt;n;nn++)<span class="comment">//n个数列</span>&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;cout&lt;&lt;endl;<span class="built_in">swap</span>(a[f],a[f<span class="number">-1</span>]);<span class="comment">//每次把最小往前</span>f--;<span class="comment">//更新最小位置</span>&#125;&#125;</code></pre><p>多组数据，代码未全。请勿copy，当心踩坑。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF17FINALA AKIBA</title>
      <link href="/archives/CF17FINALA/"/>
      <url>/archives/CF17FINALA/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>输入一个字符串，可不可以在任意一位插入 $\tt A$，使这个字符串变为 <code>AKIHABARA</code>。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p><code>AKIHABARA</code> 中只出现了 $4$ 次 $\tt A$ ，所以，我们枚举所有可能，每个位置都可以有 <em>选</em> 或 <em>不选</em> 两种可能，所以一共只有 $2^4$ 种可能，十分少。</p><p>我们只要分别枚举 没有 $\tt A$、一个 $\tt A$、两个 $\tt A$、三个 $\tt A$、四个 $\tt A$ 的情况即可。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><pre><code class="highlight cpp"><span class="comment">//没有 A</span><span class="keyword">if</span>(s==<span class="string">&quot;KIHBR&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//一个 A</span><span class="keyword">if</span>(s==<span class="string">&quot;AKIHBR&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;KIHABR&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;KIHBAR&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;KIHBRA&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//两个 A</span><span class="keyword">if</span>(s==<span class="string">&quot;AKIHABR&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;AKIHBAR&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;AKIHBRA&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;KIHABAR&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;KIHABRA&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;KIHBARA&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//三个 A</span><span class="keyword">if</span>(s==<span class="string">&quot;AKIHABAR&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;AKIHABRA&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;AKIHBARA&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">if</span>(s==<span class="string">&quot;KIHABARA&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//四个 A</span><span class="keyword">if</span>(s==<span class="string">&quot;AKIHABARA&quot;</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//都不满足</span><span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] ABC142D Disjoint Set of Common Divisors</title>
      <link href="/archives/ABC142D/"/>
      <url>/archives/ABC142D/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>给定两个数 $a$ 和 $b$ ，求能同时整除 $a$ 和 $b$ 的数的个数，且这些数需要两两互质。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>两两互质，也就说明有以下几种情况：</p><ol><li>均为不同的质数。</li><li>相邻 。</li><li>一个是质数，另一个不是他的倍数。</li><li>所有数和 $1$。</li><li>相邻奇数</li><li>较大数是质数。<br>……</li></ol><p>这是常见的情况，其实还有很多。那么我们肯定不能全写到程序里。我们只选择第 $1$ 个性质：均为不同的质数。</p><p>确保了找的答案是质数，然后确保它是这两个数的因数（因为能整除），那么我们只要找到两个数<strong>共同的质因数</strong>。</p><p>共同的质因数，一定是两个数最大公因数的质因数。</p><p>所以找出最大公因数，再找出所有最大公因数的质因数（还要算上特殊的”1”），即为答案。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="meta">#<span class="keyword">define</span> ll long long<span class="comment">//数据很大，要long long</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;ll a,b,s=<span class="number">1</span>;<span class="comment">//1一定是两个数的公因数</span><span class="function">ll <span class="title">gcd</span><span class="params">(ll x,ll y)</span></span><span class="function"></span>&#123;<span class="keyword">return</span> y?<span class="built_in">gcd</span>(y,x%y):x;<span class="comment">//辗转相除法求最大公因数</span>&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;cin&gt;&gt;a&gt;&gt;b;ll g=<span class="built_in">gcd</span>(a,b);<span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(g);i++)<span class="comment">//枚举最大公因数的质因数</span>&#123;<span class="keyword">if</span>(g%i==<span class="number">0</span>)<span class="comment">//如果是的（后续补充说明）</span>&#123;s++;<span class="comment">//找到了一个</span><span class="keyword">while</span>(g%i==<span class="number">0</span>)g/=i;<span class="comment">//把这个质因数除完</span>&#125;&#125;cout&lt;&lt;(g!=<span class="number">1</span>?++s:s);<span class="comment">//如果有剩余的质因数，再加上1</span>&#125;</code></pre><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>第 $15$ 行 <code>if(g%i==0)</code> 解释</p><p>找到了$g$ 最小能整除的数 $i$，那么 $i$ <strong>肯定是个质数</strong>，不用加以判断。</p><p>举个不成功的反例验证一下结论。</p><p>如果 $i$ 不是质数，说明 $i$ 还有其他因数，那么 $i$ 的因数也就是 $g$ 的因数了，$i$ 肯定不是最小能被整除的数了。</p><p>所以得出结论，$i$ 肯定是个质数，不用加上质数判断。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1633C Kill the Monster</title>
      <link href="/archives/CF1633C/"/>
      <url>/archives/CF1633C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>一个 01 串，找到一个它的子串，1 的个数多删所有 0，0 的个数多删所有 1。问最多删几个数。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>首先统计 01 个数是必须的。</p><p>之后，分类讨论 3 种情况。</p><h4 id="情况1：0-的个数比-1-多。"><a href="#情况1：0-的个数比-1-多。" class="headerlink" title="情况1：0 的个数比 1 多。"></a>情况1：0 的个数比 1 多。</h4><p>输出 1 的个数。</p><h4 id="情况2：1-的个数比-0-多。"><a href="#情况2：1-的个数比-0-多。" class="headerlink" title="情况2：1 的个数比 0 多。"></a>情况2：1 的个数比 0 多。</h4><p>输出 0 的个数。</p><h4 id="情况-3：1-的个数和-0-的个数相等。"><a href="#情况-3：1-的个数和-0-的个数相等。" class="headerlink" title="情况 3：1 的个数和 0 的个数相等。"></a>情况 3：1 的个数和 0 的个数相等。</h4><p>这里有个小问题。</p><p>有人可能问，一样不是输出 $0$ 吗？</p><p>但是，重新审题。<strong>找到一个它的子串</strong>，这里划重点。</p><p>也就是说，不用看整个字符串。</p><p>那么我们少拿一个 0 或少拿一个 1，答案就更多了。</p><p>所以，输出 0 的个数 -1。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;string s;cin&gt;&gt;s;<span class="type">int</span> cnt0=<span class="number">0</span>,cnt1=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)<span class="comment">//记录01个数</span>&#123;<span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)cnt1++;<span class="keyword">else</span> cnt0++;&#125;<span class="keyword">if</span>(cnt0==cnt1)cout&lt;&lt;cnt0<span class="number">-1</span>&lt;&lt;endl;<span class="comment">//分类讨论</span><span class="keyword">else</span> cout&lt;&lt;<span class="built_in">min</span>(cnt0,cnt1)&lt;&lt;endl;&#125;</code></pre><p>多组数据，代码未全。请勿copy，当心踩坑！</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1633B Minority</title>
      <link href="/archives/CF1633B/"/>
      <url>/archives/CF1633B/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>一个 01 串，找到一个它的子串，1 的个数多删所有 0，0 的个数多删所有 1。问最多删几个数。</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>首先统计 01 个数是必须的。</p><p>之后，分类讨论 3 种情况。</p><h4 id="情况1：0-的个数比-1-多。"><a href="#情况1：0-的个数比-1-多。" class="headerlink" title="情况1：0 的个数比 1 多。"></a>情况1：0 的个数比 1 多。</h4><p>输出 1 的个数。</p><h4 id="情况2：1-的个数比-0-多。"><a href="#情况2：1-的个数比-0-多。" class="headerlink" title="情况2：1 的个数比 0 多。"></a>情况2：1 的个数比 0 多。</h4><p>输出 0 的个数。</p><h4 id="情况-3：1-的个数和-0-的个数相等。"><a href="#情况-3：1-的个数和-0-的个数相等。" class="headerlink" title="情况 3：1 的个数和 0 的个数相等。"></a>情况 3：1 的个数和 0 的个数相等。</h4><p>这里有个小问题。</p><p>有人可能问，一样不是输出 $0$ 吗？</p><p>但是，重新审题。<strong>找到一个它的子串</strong>，这里划重点。</p><p>也就是说，不用看整个字符串。</p><p>那么我们少拿一个 0 或少拿一个 1，答案就更多了。</p><p>所以，输出 0 的个数 -1。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;string s;cin&gt;&gt;s;<span class="type">int</span> cnt0=<span class="number">0</span>,cnt1=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)<span class="comment">//记录01个数</span>&#123;<span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)cnt1++;<span class="keyword">else</span> cnt0++;&#125;<span class="keyword">if</span>(cnt0==cnt1)cout&lt;&lt;cnt0<span class="number">-1</span>&lt;&lt;endl;<span class="comment">//分类讨论</span><span class="keyword">else</span> cout&lt;&lt;<span class="built_in">min</span>(cnt0,cnt1)&lt;&lt;endl;&#125;</code></pre><p>多组数据，代码未全。请勿copy，当心踩坑！</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1627B Not Sitting</title>
      <link href="/archives/CF1627B/"/>
      <url>/archives/CF1627B/</url>
      
        <content type="html"><![CDATA[<h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>A 和 B 两个人，在 $n \times m$ 的教室找位置。A 想和 B 坐得近，B 想和 A 坐得远，由 A 先选位置，请问对于所有情况，A 与 B 之间的距离各是多少？</p><p>补充：距离的定义为：$a_{i_1,j_1}$ 与 $a_{i_2,j_2}$ 距离为 $\left|i_1-i_2\right|+\left|j_1-j_2\right|$</p><h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>A 会选什么位置，我们不用考虑，因为题目求所有情况，不是最优或最坏，所以只需考虑 B 坐的位置。由于想离得远，那么不管 A 坐哪，B 一定选择四个角上离得最远的位置。</p><p>根据上述分析，我们只需穷举 A 坐的位置，并且每次判断 A 的位置与四个角的距离，就可以得出所有结果。</p><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><pre><code class="highlight cpp"><span class="function"><span class="type">int</span> <span class="title">juli</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2)</span><span class="comment">//求距离函数</span></span><span class="function"></span>&#123;<span class="keyword">return</span> <span class="built_in">abs</span>(x1-x2)+<span class="built_in">abs</span>(y1-y2);&#125;<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;multiset&lt;<span class="type">int</span>&gt;s;<span class="comment">//答案要求排序，set自动排序+去重，mutiset自动排序+不去重</span><span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)<span class="comment">//双重循环穷举答案</span>&#123;s.<span class="built_in">insert</span>(<span class="built_in">max</span>(&#123;<span class="built_in">juli</span>(i,j,<span class="number">1</span>,<span class="number">1</span>),<span class="built_in">juli</span>(i,j,<span class="number">1</span>,m),<span class="built_in">juli</span>(i,j,n,<span class="number">1</span>),<span class="built_in">juli</span>(i,j,n,m)&#125;));<span class="comment">//判断四个角的最大距离</span>&#125;&#125;<span class="keyword">for</span>(<span class="keyword">auto</span> i:s)cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//输出答案</span>cout&lt;&lt;endl;&#125;</code></pre><p>多组数据，代码未全。请勿copy，当心踩坑！</p><p><a href="https://codeforces.com/contest/1627/submission/142843751">完整代码在这</a></p><h3 id="科普一个热知识："><a href="#科普一个热知识：" class="headerlink" title="科普一个热知识："></a>科普一个热知识：</h3><p>可能有些同学对于 <code>s.insert(max(&#123;juli(i,j,1,1),juli(i,j,1,m),juli(i,j,n,1),juli(i,j,n,m)&#125;)); </code> 这一行有疑惑，本机运行可能报错。其实这是新语法，之前求多个最大值要写很多 <code>max()</code>，现在只需 <code>max(&#123;&#125;)</code>，在大括号里写上多个值，如这样：</p><p>求 $a,b,c,d$ 的最大值</p><p>正常代码 <code>cout&lt;&lt;max(max(a,b),max(c,d))&lt;&lt;endl;</code> 要写 $3$ 个 <code>max()</code>，现在只需 <code>cout&lt;&lt;max(&#123;a,b,c,d&#125;)&lt;&lt;endl;</code> 即可。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1621A Stable Arrangement of Rooks</title>
      <link href="/archives/CF1621A/"/>
      <url>/archives/CF1621A/</url>
      
        <content type="html"><![CDATA[<h4 id="题目翻译："><a href="#题目翻译：" class="headerlink" title="题目翻译："></a>题目翻译：</h4><p>有 $n \times n$ 大小的棋盘，一共放 $k$ 辆车，使得这个棋盘稳定。</p><p>稳定的概念是：所有的车移动至相邻四格（上下左右）不会出现一行一列有 $\ge 2$ 辆车。</p><h4 id="做题思路"><a href="#做题思路" class="headerlink" title="做题思路:"></a>做题思路:</h4><p>我们可以考虑，移动之后没有同一行一列有多辆车，那么就让它移动之后还是只有它一辆车，换句话说，每辆车之间至少空一行和一列，也就是在对角线上放是最优想法。如果对角线放不下 $k$ 辆车了，无解输出 <code>-1</code> 。</p><h4 id="深入思考（此分析大佬跳过）"><a href="#深入思考（此分析大佬跳过）" class="headerlink" title="深入思考（此分析大佬跳过）"></a>深入思考（此分析大佬跳过）</h4><p>在怎样的情况下 $n \times n$ 的棋盘放不下 $k$ 辆车呢？</p><p>很显然，每两行两列放一辆车，那么最多可以放 $\left\lfloor\dfrac{n+1}{2}\right\rfloor$ 辆车（大多数语言整数除法自动下取整），所以只要判断 $\dfrac{n+1}{2}$ 与 $k$ 的大小关系。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;<span class="keyword">if</span>((n<span class="number">+1</span>)/<span class="number">2</span>&lt;k)<span class="comment">//判断是否放得下</span>&#123;cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;<span class="keyword">return</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="keyword">if</span>(i==j&amp;&amp;i%<span class="number">2</span>!=<span class="number">0</span>&amp;&amp;k&gt;<span class="number">0</span>)<span class="comment">//判断分别为：对角线、隔一行一列、还可以放车</span>&#123;cout&lt;&lt;<span class="string">&#x27;R&#x27;</span>;k--;<span class="comment">//放完一辆</span>&#125;<span class="keyword">else</span>&#123;cout&lt;&lt;<span class="string">&#x27;.&#x27;</span>;&#125;&#125;cout&lt;&lt;endl;&#125;&#125;</code></pre><p>多组数据，代码未全。请勿copy，当心踩坑！</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1615A Closing The Gap</title>
      <link href="/archives/CF1615A/"/>
      <url>/archives/CF1615A/</url>
      
        <content type="html"><![CDATA[<h4 id="题目翻译："><a href="#题目翻译：" class="headerlink" title="题目翻译："></a>题目翻译：</h4><p>有 $n$ 个数，每个数为 $a_i$  ，你可以每次选 $2$ 个数 $a$ 和 $b$ ，把 $a$ 高度 $-1$ ，把 $b$ 高度 $+1$。在经历无限次操作后，求 $max(a)-min(a)$ 的值。</p><h4 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h4><p>其实就是求平均数，如果求出的和是 $n$ 的倍数，那么意味数组 $a$ 中的每个值<strong>相等</strong>且均为<strong>正整数</strong>，那么相差<strong>都为 $0$</strong>。反之不是 $n$ 的倍数，那么总会有数多出 $1$ ，那么最大与最小的差<strong>就为 $1$</strong> 。这个想法非常好证明，取模之后的数比 $n$ 要小，那么每个数添上 $1$ 总会有没添上的，那么差就是为 $1$。</p><h4 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h4><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,sum=<span class="number">0</span>; cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> x;cin&gt;&gt;x;<span class="comment">//输入 </span>sum+=x;<span class="comment">//求和 </span>&#125;cout&lt;&lt;(sum%n==<span class="number">0</span>?<span class="number">0</span>:<span class="number">1</span>)&lt;&lt;endl;<span class="comment">//判断 输出 </span>&#125;</code></pre><p>或者不会三步运算符可用 $if … else…$ 代替</p><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n,sum=<span class="number">0</span>; cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="type">int</span> x;cin&gt;&gt;x;<span class="comment">//输入 </span>sum+=x;<span class="comment">//求和 </span>&#125;<span class="keyword">if</span>(sum%n==<span class="number">0</span>)<span class="comment">//如果是第一种情况 </span>&#123;cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;&#125; <span class="keyword">else</span><span class="comment">//如果是第二种情况</span>&#123;cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;&#125;&#125;</code></pre><p>多组数据，代码未全。请勿copy，当心踩坑。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1613B Absent Remainder</title>
      <link href="/archives/CF1613B/"/>
      <url>/archives/CF1613B/</url>
      
        <content type="html"><![CDATA[<p>题目说了，每组数不同，并且 $x\bmod y$ 也不出现在数组 $a$ 中，那么我们可以对数组进行<strong>排序</strong>，因为 $a\bmod b$ 得出的结果是<strong>一定比 $b$ 小的</strong>。那么拿数组的其他数分别去取模最小的数，那么得出的结果一定比数组最小的数还小，则一定<strong>不可能出现</strong>在数组 $a$ 之内。</p><p>简单解释一下这个数据：</p><pre><code class="highlight basic"><span class="number">6</span><span class="symbol">2 </span><span class="number">7</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">8</span></code></pre><p>按我的思路，则会排序成以下数组：</p><p>$[2,3,4,5,7,8]$。</p><p>$3\bmod2$ 不在数组 $a$ 中，</p><p>$4\bmod2$ 不在数组 $a$ 中，</p><p>$5\bmod2$ 不在数组 $a$ 中，</p><p>$7\bmod2$ 不在数组 $a$ 中，</p><p>$8\bmod2$ 不在数组 $a$ 中。</p><p>贴代码：</p><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span><span class="function"></span>&#123;<span class="type">int</span> n;cin&gt;&gt;n;<span class="type">int</span> a[n];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;cin&gt;&gt;a[i];&#125;<span class="built_in">sort</span>(a,a+n);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)<span class="comment">//n/2组数据即可 </span>&#123;cout&lt;&lt;a[n-i<span class="number">-1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[<span class="number">0</span>]&lt;&lt;endl;<span class="comment">//分别输出x与y,注意顺序，必须x在前y在后 </span>&#125;&#125;</code></pre><p>多组数据，代码未全，当心踩坑。</p>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[题解] CF1555A PizzaForces</title>
      <link href="/archives/CF1555A/"/>
      <url>/archives/CF1555A/</url>
      
        <content type="html"><![CDATA[<h3 id="题目传送："><a href="#题目传送：" class="headerlink" title="题目传送："></a>题目传送：</h3><ul><li><a href="https://www.luogu.com.cn/problem/CF1555A">洛谷</a>；</li><li><a href="https://codeforces.com/problemset/problem/1555/A">CodeForces</a>。</li></ul><h3 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h3><p>这题有 $3$ 大要点：</p><ul><li>平均价一样 $2.5$ 分钟，只需满足尽量披萨数与人数差尽量小。</li><li>$6,8,10$ 可以凑出所有大于等于 $6$ 的偶数。<br>转化一下：$3,4,5$ 可以凑出所有大于等于 $3$ 的整数，因为 $3,4$ 凑不出的最大数为 $5$，具体见<a href="https://www.luogu.com.cn/problem/P3951">洛谷 P3951</a>。</li><li>语言特性：大部分编程语言做除法都是向下取整，所以数学上四舍五入 $a$ 除以 $b$ 等于编程语言中的 <code>(a+b-1)/b</code>。</li></ul><h3 id="做题思路："><a href="#做题思路：" class="headerlink" title="做题思路："></a>做题思路：</h3><p>先特判：<br>$n &lt; 6$ 是 $15$ 分钟；<br>$n \geq 6$ 时，输出 <code>(n+1)/2*5</code>,（因为 $n$ 可能是奇数，所以要加 $1$），前面提到，这个 $\frac{n + 1}{2}$ 一定会被 $3,4,5$ 凑出来，然后把乘 $2.5$ 转化为除以 $2$ 乘 $5$（否则万一 $n+1$ 是奇数就玩完）。</p><h3 id="AC-代码："><a href="#AC-代码：" class="headerlink" title="AC 代码："></a>AC 代码：</h3><h4 id="C-版："><a href="#C-版：" class="headerlink" title="C++ 版："></a>C++ 版：</h4><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="meta">#<span class="keyword">define</span> ll long long</span><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span><span class="function"></span>&#123;ll t;cin&gt;&gt;t;<span class="keyword">while</span>(t--)&#123;ll n;cin&gt;&gt;n;<span class="keyword">if</span>(n&lt;<span class="number">6</span>)n=<span class="number">6</span>;cout&lt;&lt;(n<span class="number">+1</span>)/<span class="number">2</span>*<span class="number">5</span>&lt;&lt;endl;&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h4 id="Python-版："><a href="#Python-版：" class="headerlink" title="Python 版："></a>Python 版：</h4><pre><code class="highlight python">t=<span class="built_in">int</span>(<span class="built_in">input</span>())<span class="keyword">for</span> tt <span class="keyword">in</span> <span class="built_in">range</span>(t):    n=<span class="built_in">int</span>(<span class="built_in">input</span>())    <span class="keyword">if</span> n&lt;<span class="number">6</span>:        <span class="built_in">print</span>(<span class="number">15</span>)    <span class="keyword">else</span>:        <span class="built_in">print</span>((n+<span class="number">1</span>)//<span class="number">2</span>*<span class="number">5</span>)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Solution </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
